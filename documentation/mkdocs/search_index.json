{
    "docs": [
        {
            "location": "/", 
            "text": "OpenBaton\n\n\nOpenBaton is an open source project providing a comprehensive implementation of the ETSI Management and Orchestration (MANO) specification. \n\n\nWhat is NFV\n\n\nETSI NFV represents a concerted telco operator initiative fostering the development of virtual network infrastructures by porting and further adapting network functions to the specific cloud environment. \nETSI NFV has defined a large set of virtualisation use cases, spanning from the cloudification of the main core network functions such as IMS, Evolved Packet Core, and Radio Access Networks, as well as providing on demand and complete virtualised infrastructures as IaaS or PaaS to third partie, such as enterprises and professional radio. \nThat enables providing elastic deployments of cost efficient network infrastructures.\nOne of the main concerns of ETSI NFV is to prove the feasibility of the cloud deployments of the typical network functions through proof of concept trials and prototypes as well as providing indications for further standardization in the areas of underlying infrastructures, software architectures, networking and management, and orchestration to improve performance and grant security of the overall infrastructure.\nETSI NFV limits itself to this level of indications, considering that other standardization bodies and de-facto open source standards such as 3GPP and OpenStack should finalize the specific implementation work. \n\n\nIts main components\n\n\nOpenBaton provides the following components: \n\n A Network Function Virtualisation Orchestrator (NFVO) completely designed and implemented following the ETSI MANO specification\n\n A generic Virtual Network Function Manager (VNFM) able to manage the lifecycle of VNFs based on their descriptors\n* A set of libraries which could be used for building your own VNFM\n\n\nCan I plug in my Network Functions?\n\n\nYes, this is possible using two different approaches:\n\n integrating your own VNFM. In this case you can use either the REST interface, or the JMS one for interoperating with the NFVO\n\n implementing a set of scripts which can be executed as part of the lifecycle event of your Virtual Network Function Descriptor. We provide a generic VNFM and EMS which can be used for executing them\n\n\nCan I use OpenBaton to build my own Network Service?\n\n\nYes! OpenBaton provides a NFVO which can interoperate with VNFMs implemented by third parties. In this project we provide also a set of tools (like the vnfm-sdk) which supports developers in building their own VNFM. \n\n\nGet started\n\n\nIn order to get started you can follow the \ninstallation guide\n\n\nGet in contact\n\n\nwww.open-baton.org", 
            "title": "Get Started"
        }, 
        {
            "location": "/#openbaton", 
            "text": "OpenBaton is an open source project providing a comprehensive implementation of the ETSI Management and Orchestration (MANO) specification.", 
            "title": "OpenBaton"
        }, 
        {
            "location": "/#what-is-nfv", 
            "text": "ETSI NFV represents a concerted telco operator initiative fostering the development of virtual network infrastructures by porting and further adapting network functions to the specific cloud environment. \nETSI NFV has defined a large set of virtualisation use cases, spanning from the cloudification of the main core network functions such as IMS, Evolved Packet Core, and Radio Access Networks, as well as providing on demand and complete virtualised infrastructures as IaaS or PaaS to third partie, such as enterprises and professional radio. \nThat enables providing elastic deployments of cost efficient network infrastructures.\nOne of the main concerns of ETSI NFV is to prove the feasibility of the cloud deployments of the typical network functions through proof of concept trials and prototypes as well as providing indications for further standardization in the areas of underlying infrastructures, software architectures, networking and management, and orchestration to improve performance and grant security of the overall infrastructure.\nETSI NFV limits itself to this level of indications, considering that other standardization bodies and de-facto open source standards such as 3GPP and OpenStack should finalize the specific implementation work.", 
            "title": "What is NFV"
        }, 
        {
            "location": "/#its-main-components", 
            "text": "OpenBaton provides the following components:   A Network Function Virtualisation Orchestrator (NFVO) completely designed and implemented following the ETSI MANO specification  A generic Virtual Network Function Manager (VNFM) able to manage the lifecycle of VNFs based on their descriptors\n* A set of libraries which could be used for building your own VNFM", 
            "title": "Its main components"
        }, 
        {
            "location": "/#can-i-plug-in-my-network-functions", 
            "text": "Yes, this is possible using two different approaches:  integrating your own VNFM. In this case you can use either the REST interface, or the JMS one for interoperating with the NFVO  implementing a set of scripts which can be executed as part of the lifecycle event of your Virtual Network Function Descriptor. We provide a generic VNFM and EMS which can be used for executing them", 
            "title": "Can I plug in my Network Functions?"
        }, 
        {
            "location": "/#can-i-use-openbaton-to-build-my-own-network-service", 
            "text": "Yes! OpenBaton provides a NFVO which can interoperate with VNFMs implemented by third parties. In this project we provide also a set of tools (like the vnfm-sdk) which supports developers in building their own VNFM.", 
            "title": "Can I use OpenBaton to build my own Network Service?"
        }, 
        {
            "location": "/#get-started", 
            "text": "In order to get started you can follow the  installation guide", 
            "title": "Get started"
        }, 
        {
            "location": "/#get-in-contact", 
            "text": "www.open-baton.org", 
            "title": "Get in contact"
        }, 
        {
            "location": "/install/", 
            "text": "Install OpenBaton\n\n\nThis how to will walk you through getting started with OpenBaton. In particular it will show you how you can setup and configure its main components. It will also show you how to write your Network Service Descriptor and create your own Virtual Network Function Package and deploy it on your PoPs. \n\n\nOpenBaton comprises different components:\n\n the Network Function Virtualisation Orchestrator (NFVO), always required for creating a composition of differnet Virtual Network Function Descriptors\n\n generic-VNFM, needed only when the VNFP approach is used. Using the generic-VNFM implies also the usage of the EMS which is automatically installed on the VDUs where such VNF has to be installed. \n\n\n\n\nBefore you start\n\n\nFirst of all it is important to clarify the different deployment options. Depending on your requirements OpenBaton, using a plugin mechanism, supports different VIM implementations. In particular, in this relesae, two different vim plugins are available: \n\n test-plugin: it is a mockup of the VIM interface which is quite useful for development. It basically does not create any real virtual resources and it can be used for developing new features on the NFVO without having to always deploy new services.\n\n openstack-plugin: it provides an implementation of the VIM interface for requesting resources to OpenStack. \n\n\nDepending on which one is your target provider, you will need to configure runtime different Point of Presence (PoP). This is something which will be explained later on in this user guide. \n\n\nLet's move on\n\n\nNext step is to install the NFVO component", 
            "title": "Overview"
        }, 
        {
            "location": "/install/#install-openbaton", 
            "text": "This how to will walk you through getting started with OpenBaton. In particular it will show you how you can setup and configure its main components. It will also show you how to write your Network Service Descriptor and create your own Virtual Network Function Package and deploy it on your PoPs.   OpenBaton comprises different components:  the Network Function Virtualisation Orchestrator (NFVO), always required for creating a composition of differnet Virtual Network Function Descriptors  generic-VNFM, needed only when the VNFP approach is used. Using the generic-VNFM implies also the usage of the EMS which is automatically installed on the VDUs where such VNF has to be installed.", 
            "title": "Install OpenBaton"
        }, 
        {
            "location": "/install/#before-you-start", 
            "text": "First of all it is important to clarify the different deployment options. Depending on your requirements OpenBaton, using a plugin mechanism, supports different VIM implementations. In particular, in this relesae, two different vim plugins are available:   test-plugin: it is a mockup of the VIM interface which is quite useful for development. It basically does not create any real virtual resources and it can be used for developing new features on the NFVO without having to always deploy new services.  openstack-plugin: it provides an implementation of the VIM interface for requesting resources to OpenStack.   Depending on which one is your target provider, you will need to configure runtime different Point of Presence (PoP). This is something which will be explained later on in this user guide.", 
            "title": "Before you start"
        }, 
        {
            "location": "/install/#lets-move-on", 
            "text": "Next step is to install the NFVO component", 
            "title": "Let's move on"
        }, 
        {
            "location": "/nfvo-installation/", 
            "text": "Install NFVO\n\n\nThe NFVO is implemented in java using the \nspring.io\n framework. For more details about the NFVO architecture, you can refer to the extend it section.\n\n\ninstall the latest NFVO version from the source code\n\n\nThe NFVO can be installed using different mechanisms. In this how to we will show you how to instantiate it using directly from the git repo. \n\n\nThe NFVO uses the Java Messaging System for communicating with the VNFMs. Therefore it is a prerequisites to have ActiveMQ up and running. To facilitate the installation procedures we provide an installation script which can be used for installing the NFVO and the prerequired libraries. Considering that this script needs to install some system libraries, it is required to execute it as super user. \n\n\nsudo su -\ncurl -fsSkL https://raw.githubusercontent.com/openbaton/bootstrap/master/openbaton.sh |bash\n\n\n\n\nAt the end of the installation procedure, if there are no errors, the dashboard should be reachable at: \nlocalhost:8080\n. At the end of the installation, you should have the following structure: \n\n\n/opt/openbaton/\n\u251c\u2500\u2500 apache-activemq-5.11.1\n\u251c\u2500\u2500 generic-vnfm\n\u2514\u2500\u2500 nfvo\n\n\n\n\nwhere:\n\n \napache-activemq-5.11.1\n contains the activeMQ software (it is basically downloaded, extracted and executed)\n\n \ngeneric-vnfm\ncontains the source code and scripts required for dealing with the generic-vnfm\n* \nnfvo\n contains the source code and scripts of the NFVO \n\n\nThe NFVO is configured with default configuration parameters at the beginning. The configuration file is located on \n\n\n/etc/openbaton/openbaton.properties\n\n\n\n\nThis file can be modified for specific parameters. For instance, you can decide to change logging levels and mechanisms:\n\n\nlogging.level.org.springframework=INFO\nlogging.level.org.hibernate=INFO\nlogging.level.org.jclouds=WARN\nlogging.level.org.springframework.security=WARN\n# Level for loggers on classes inside the root package \norg.project.openbaton\n (and its\n# sub-packages)\nlogging.level.org.openbaton.nfvo=INFO\n# Direct log to a log file\nlogging.file=/var/log/openbaton.log\n\n\n\n\nOr parameters related with persistency (hibernate):\n\n\n# DB properties\nspring.datasource.username=admin\nspring.datasource.password=changeme\n# hsql jdbc\nspring.datasource.url=jdbc:hsqldb:file:/tmp/openbaton/openbaton.hsdb\nspring.datasource.driver-class-name=org.hsqldb.jdbc.JDBCDriver\nspring.jpa.database-platform=org.hibernate.dialect.HSQLDialect\n# mysql jdbc\n#spring.datasource.url=jdbc:mysql://localhost:3306/openbaton\n#spring.datasource.driver-class-name=com.mysql.jdbc.Driver\n#spring.jpa.database-platform=org.hibernate.dialect.MySQLDialect\n# hibernate properties\nspring.jpa.show-sql=false\nspring.jpa.hibernate.ddl-auto=create-drop\n\n\n\n\nBy deafault ActiveMQ is installed on the same host of the NFVO. Be aware of the fact that if you want your VNFM to be executed on a different host, you will need that ActiveMQ is reachable also from the extern.\nWhen using the generic-VNFM (by default also instantiated on the same host of the NFVO) you will need to configure the activemq endpoint with an IP which can be reached also from the VMs where your VNF (EMS) will be installed.\n\n\n# activeMQ\nspring.activemq.broker-url=tcp://localhost:61616\nspring.activemq.user=admin\nspring.activemq.password=admin\n\n\n\n\nThis parameter is file size of the VNF Package which can be uploaded to the NFVO\n\n\n# filesUpload\nmultipart.maxFileSize=2046MB\nmultipart.maxRequestSize=2046MB\n\n\n\n\nThe following properties are related with teh plugin mechanism used for loading VIM and Monitoring instances. Basically whenever a new VIM interface will be available, it will be enough to place it under the \nvim-plugin-installation-dir\n to be loaded runtime by the NFVO.\n\n\n# plugin install\n# directory for the vim driver plugins\nvim-plugin-installation-dir = ./plugins/vim-drivers\n# classes contained in the jar files to be loaded\nvim-classes=org.project.openbaton.clients.interfaces.client.test.TestClient;org.project.openbaton.clients.interfaces.client.openstack.OpenstackClient\n# directory for the monitoring plugin\nmonitoring-plugin-installation-dir = ./plugins/monitoring\n# classes contained in the jar files to be loaded\nmonitoring-classes=org.project.openbaton.monitoring.agent.SmartDummyMonitoringAgent\n# nfvo behaviour\ndelete-on-all-status = false\n\n\n\n\nThose properties are needed in case you want to tune a bit the performances of the NFVO\n\n\n# Thread pool executor configuration\n# for info see http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/scheduling/concurrent/ThreadPoolTaskExecutor.html\nvmanager-executor-core-pool-size = 20\nvmanager-executor-max-pool-size = 25\nvmanager-executor-queue-capacity = 500\nvmanager-keep-alive = 30\n\n\n\n\nWhenever some of those parameters are changed, you will need to restart the orchestrator. This can be done with the following command: \n\n\ncd /opt/openbaton/nfvo\n./openbaton.sh restart\n\n\n\n\nAt this point the NFVO is ready to be used. Please refer to the NFVO user guide for how to start using it. \n\n\nLet's move to the next step\n\n\nDependening on the approach used for deploying your VNF, you'll have either to install the generic-VNFM or install and register your own VNFM", 
            "title": "Install NFVO"
        }, 
        {
            "location": "/nfvo-installation/#install-nfvo", 
            "text": "The NFVO is implemented in java using the  spring.io  framework. For more details about the NFVO architecture, you can refer to the extend it section.", 
            "title": "Install NFVO"
        }, 
        {
            "location": "/nfvo-installation/#install-the-latest-nfvo-version-from-the-source-code", 
            "text": "The NFVO can be installed using different mechanisms. In this how to we will show you how to instantiate it using directly from the git repo.   The NFVO uses the Java Messaging System for communicating with the VNFMs. Therefore it is a prerequisites to have ActiveMQ up and running. To facilitate the installation procedures we provide an installation script which can be used for installing the NFVO and the prerequired libraries. Considering that this script needs to install some system libraries, it is required to execute it as super user.   sudo su -\ncurl -fsSkL https://raw.githubusercontent.com/openbaton/bootstrap/master/openbaton.sh |bash  At the end of the installation procedure, if there are no errors, the dashboard should be reachable at:  localhost:8080 . At the end of the installation, you should have the following structure:   /opt/openbaton/\n\u251c\u2500\u2500 apache-activemq-5.11.1\n\u251c\u2500\u2500 generic-vnfm\n\u2514\u2500\u2500 nfvo  where:   apache-activemq-5.11.1  contains the activeMQ software (it is basically downloaded, extracted and executed)   generic-vnfm contains the source code and scripts required for dealing with the generic-vnfm\n*  nfvo  contains the source code and scripts of the NFVO   The NFVO is configured with default configuration parameters at the beginning. The configuration file is located on   /etc/openbaton/openbaton.properties  This file can be modified for specific parameters. For instance, you can decide to change logging levels and mechanisms:  logging.level.org.springframework=INFO\nlogging.level.org.hibernate=INFO\nlogging.level.org.jclouds=WARN\nlogging.level.org.springframework.security=WARN\n# Level for loggers on classes inside the root package  org.project.openbaton  (and its\n# sub-packages)\nlogging.level.org.openbaton.nfvo=INFO\n# Direct log to a log file\nlogging.file=/var/log/openbaton.log  Or parameters related with persistency (hibernate):  # DB properties\nspring.datasource.username=admin\nspring.datasource.password=changeme\n# hsql jdbc\nspring.datasource.url=jdbc:hsqldb:file:/tmp/openbaton/openbaton.hsdb\nspring.datasource.driver-class-name=org.hsqldb.jdbc.JDBCDriver\nspring.jpa.database-platform=org.hibernate.dialect.HSQLDialect\n# mysql jdbc\n#spring.datasource.url=jdbc:mysql://localhost:3306/openbaton\n#spring.datasource.driver-class-name=com.mysql.jdbc.Driver\n#spring.jpa.database-platform=org.hibernate.dialect.MySQLDialect\n# hibernate properties\nspring.jpa.show-sql=false\nspring.jpa.hibernate.ddl-auto=create-drop  By deafault ActiveMQ is installed on the same host of the NFVO. Be aware of the fact that if you want your VNFM to be executed on a different host, you will need that ActiveMQ is reachable also from the extern.\nWhen using the generic-VNFM (by default also instantiated on the same host of the NFVO) you will need to configure the activemq endpoint with an IP which can be reached also from the VMs where your VNF (EMS) will be installed.  # activeMQ\nspring.activemq.broker-url=tcp://localhost:61616\nspring.activemq.user=admin\nspring.activemq.password=admin  This parameter is file size of the VNF Package which can be uploaded to the NFVO  # filesUpload\nmultipart.maxFileSize=2046MB\nmultipart.maxRequestSize=2046MB  The following properties are related with teh plugin mechanism used for loading VIM and Monitoring instances. Basically whenever a new VIM interface will be available, it will be enough to place it under the  vim-plugin-installation-dir  to be loaded runtime by the NFVO.  # plugin install\n# directory for the vim driver plugins\nvim-plugin-installation-dir = ./plugins/vim-drivers\n# classes contained in the jar files to be loaded\nvim-classes=org.project.openbaton.clients.interfaces.client.test.TestClient;org.project.openbaton.clients.interfaces.client.openstack.OpenstackClient\n# directory for the monitoring plugin\nmonitoring-plugin-installation-dir = ./plugins/monitoring\n# classes contained in the jar files to be loaded\nmonitoring-classes=org.project.openbaton.monitoring.agent.SmartDummyMonitoringAgent\n# nfvo behaviour\ndelete-on-all-status = false  Those properties are needed in case you want to tune a bit the performances of the NFVO  # Thread pool executor configuration\n# for info see http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/scheduling/concurrent/ThreadPoolTaskExecutor.html\nvmanager-executor-core-pool-size = 20\nvmanager-executor-max-pool-size = 25\nvmanager-executor-queue-capacity = 500\nvmanager-keep-alive = 30  Whenever some of those parameters are changed, you will need to restart the orchestrator. This can be done with the following command:   cd /opt/openbaton/nfvo\n./openbaton.sh restart  At this point the NFVO is ready to be used. Please refer to the NFVO user guide for how to start using it.", 
            "title": "install the latest NFVO version from the source code"
        }, 
        {
            "location": "/nfvo-installation/#lets-move-to-the-next-step", 
            "text": "Dependening on the approach used for deploying your VNF, you'll have either to install the generic-VNFM or install and register your own VNFM", 
            "title": "Let's move to the next step"
        }, 
        {
            "location": "/use/", 
            "text": "How to use OpenBaton\n\n\nIn order to use OpenBaton for launching your first Network Service, you will need to prepare your Network Service Descriptor (NSD). In order to orchestrate your Network Service, the NFVO expects a clear definition of the NSD. Please refer to the are defined as set of VNF descriptors, therefore it is important to have in place the descriptors of the VNF you would like to manage.", 
            "title": "Introduction"
        }, 
        {
            "location": "/use/#how-to-use-openbaton", 
            "text": "In order to use OpenBaton for launching your first Network Service, you will need to prepare your Network Service Descriptor (NSD). In order to orchestrate your Network Service, the NFVO expects a clear definition of the NSD. Please refer to the are defined as set of VNF descriptors, therefore it is important to have in place the descriptors of the VNF you would like to manage.", 
            "title": "How to use OpenBaton"
        }, 
        {
            "location": "/vnfpackage/", 
            "text": "VNFPackage\n\n\nNote\n: This is the initial version of the VNFPackage and might change most probably in the next releases to improve and simplify the creation, usability and power.\n\n\nThis doc describes essential components of a VNFPackage, how to create them and how to use them after onboarding.\nTherefore, you can find a practical tutorial at the end with all the steps starting from the creation over onboarding and finally referencing it by a NSD.\n\n\nA VNFPackage is a tar-archive that contains all the information required for creating a VNF for the openbaton NFVO.\nAfter onboarding the VNFPackage on the NFVO you can use the VNF directly in the NSD by referencing the VNFD by its id.\nA VNFPackage includes the VNFD, the image, scripts and a Metadata file structured as shown in the next part.\n\n\nPackage structure\n\n\nThe VNFPackage consists of the following files/folder:\n\n\n\n\nMetadata.yaml\n\n\nvnfd.json\n\n\nscripts/\n\n\n1_script.sh\n\n\n2_script.sh\n\n\n\n\n\n\nimage.img\n\n\n\n\nMetadata.yaml\n\n\nThe Metadata.yaml defines essential properties for the VNF. This file bases on the YAML syntax where information are stored in simple \\\nkey> : \\\nvalue> associations.\n\n\nThe example of a Metadata.yaml file below shows a basic definition of a VNFPackage.\n\n\nname: vnfPackage_name\nscripts-link: scripts_link\nimage-link: image_link\nimage:\n    name: image_name\n    diskFormat: disk_format\n    containerFormat: container_format\n    minCPU: min_cpu\n    minDisk: min_disk\n    minRam: min_ram\n    isPublic: is_public\n\n\n\n\nEach property is explained more in detail now. Please consider also the notes since some properties are optional (or even not implemented) and if they are defined, they may have more priority than other and overrides them therefore.\n\n\n\n\nname\n: The name defines the name of the VNFPackage itself used to store it on the database.\n\n\nscripts-link\n: This link points to a public git repository where scripts are stored that are needed to be executed for managing the lifecycle of the exposed VNF.\n\n\nNote\n Either you can define the scripts-link or put the scripts into the folder scripts/.\n    The scripts-link has a higher priority than the scripts located in the folder scripts/.\n    So if you set the scripts-link, the scripts in folder scripts/ are ignored completely.\n\n\nNote\n The scripts-link is processed by the Element Management System (EMS) in the meaning of fetching the files from that link.\n    So you need to take care about ensuring that the URL defined is available.\n\n\nNote\n Scripts are executed when a specific Event is fired and this Event references to specific scripts.\n\n\n\n\n\n\nimage-link\n: This link points to an image available over this URL used to upload the image to the cloud environment.\n\n\nNote\n Either you have to define the image-link or put the image directly into the VNFPackage.\n    Otherwise an NotFoundException will be thrown and the VNFPackage will not onboard.\n    The image-link has a higher priority than the image stored in the VNFPackage directly.\n\n\nNote\n The image-link is a future feature and not implemented in the current version.\n    Therefore, you need to put the image into the VNFPackage directly and remove this line or let the value empty.\n\n\n\n\n\n\nimage\n: All the properties explained below are required to upload the image to the cloud environment properly.\n    This image will be uploaded to each cloud environment automatically while onboarding the VNFPackage.\n\n\nname\n: This defines the name for the image to upload either located directly in the VNFPackage or available via the URL defined in image-link.\n\n\ndiskFormat\n: The diskFormat defines the format in which disk type the image is stored.\n\n\ncontainerFormat\n: The containerFormat defines the format in which container type the image is stored .\n\n\nminCPU\n: The minCPU defines the minimum amount of CPU cores for using this image properly.\n\n\nminDisk\n: The minDisk defines the minimum amount of disk space for using this image properly.\n\n\nminRam\n: The minRam defines the minimum amount of RAM for using this image properly.\n\n\nisPublic\n: The isPublic defines whether the image is available public or not.\n\n\n\n\n\n\n\n\n\\\nVNFD>.json\n\n\nThe \\\nvnfd>.json contains the VirtualNetworkFunctionDescriptor (VNFD) onboarded on the Orchestrator.\nThis VNFD can later be referenced in a NSD by its id to make use of it.\nA more detailed explanation of the VNFD can be found here [].\n\n\nNote\n The name of the file is not important but the suffix .json since the VNFPackageManagement is looking for this kind file format.\n\n\nscripts\n\n\nThe scripts folder contains all the scripts required for starting, configuring or whatever you want to do on the running instance.\n[EXECUTION ORDER]\n\n\nNote\n These scripts in the folder \nscripts\n are fetched only if the \nscripts-link\n is not defined in the \nMetadata.yaml\n.\n    This means that the scripts in that folder have less priority than the scripts located under \nscripts-link\n.\n\n\nNote\n Scripts are executed when a specific Event is fired and this Event references to specific scripts.\n\n\n\\\nimage>.img\n\n\nThis image is used to upload it to all the cloud environments which are addressed inside the VNFD with that image.\nIt doesn't matter whether an image already exists on the considered cloud environment or not.\n\n\nNote\n This image has lower priority than the \nimage-links\n defined in \nMetadata.yaml\n.\n    This mean that the image will be ignored if the \nimage-links\n is defined.\n\n\nNote\n The name of the image doesn't matter but the suffix .img since the VNFPackageManagement is looking for a file with this suffix.\n    However, the name and all the properties for stroing it on the cloud environment are defined in \nMetadata.yaml\n under the key \nimage\n.\n\n\nTutorial\n\n\nThis section explains how to create, upload and make use of VNFPackages.\nThe chosen scenario is a NetworkService for testing the network connectivity by using iperf.\nTherefore, we need a server and a client installing the iperf server/client and configuring them for communication between.\n\n\nCreation of VNFPackages\n\n\nFor doing so, we need to create two VNFPackages and reference them in the NSD.\nSo we need one VNFPackage for the iperf server (called iperf-server) and one for the iperf client (called iperf-client).\nFirst we will start with the creation of the iperf-server VNFPackage and then we will create the iperf-client VNFPackage.\n\n\nFirst of all we should create a directory for each VNFPackage where we put all the files related to the VNFPackage because in the end we need to pack them into an tar archive for onboarding it on the NFVO.\n\n\nVNFPackage [iperf-server]\n\n\nThis iperf-server VNFPackage have to install the iperf server and needs to provide its ip to the iperf client.\n\n\nMetadata [iperf-server]\n\n\nIn the Metadata we define the name of the VNFPackage, the scripts location and also the properties for the image to upload.\nSince the image-link is not implemented in the current release we will put the image directly into the VNFPackage.\nFinally, it looks as shown below.\n\n\nname: iperf-server\nscripts-link: https://gitlab.fokus.fraunhofer.de/openbaton/scripts-test-public.git\nimage-link:\nimage:\n    name: iperf_server_image\n    diskFormat: QCOW2\n    containerFormat: bare\n    minCPU: 2\n    minDisk: 5\n    minRam: 2048\n    isPublic: false\n\n\n\n\nVNFD [iperf-server]\n\n\nThis is how the VNFD looks like for the iperf-server VNFPackage.\nImportant to notice here is the vm_image that points to the image we have defined in the Metadata.yaml\n\n\n{\n    \nvendor\n:\nfokus\n,\n    \nversion\n:\n0.2\n,\n    \nname\n:\niperf-server\n,\n    \ntype\n:\nserver\n,\n    \nendpoint\n:\ngeneric\n,\n    \nvdu\n:[\n        {\n            \nvm_image\n:[\n                \niperf_server_image\n\n            ],\n            \nvimInstanceName\n:\nvim-instance\n,\n            \nscale_in_out\n:2,\n            \nvnfc\n:[\n                {\n                    \nexposed\n:true,\n                    \nconnection_point\n:[\n                        {\n                            \nvirtual_link_reference\n:\nprivate\n\n                        }\n                    ]\n                }\n            ]\n        }\n    ],\n    \nvirtual_link\n:[\n        {\n            \nname\n:\nprivate\n\n        }\n    ],\n    \nlifecycle_event\n:[\n        {\n            \nevent\n:\nINSTANTIATE\n,\n            \nlifecycle_events\n:[\n                \ninstall.sh\n,\n                \ninstall-srv.sh\n\n            ]\n        }\n    ],\n    \ndeployment_flavour\n:[\n        {\n            \ndf_constraint\n:[\n                \nconstraint1\n,\n                \nconstraint2\n\n            ],\n            \ncostituent_vdu\n:[\n            ],\n            \nflavour_key\n:\nm1.small\n\n        }\n    ]\n}\n\n\n\n\nImage\n\n\nThe image we have to choose must be a debian 64bit image (e.g. ubuntu amd64) for satisfying the EMS and scripts which are designed for that kind of image.\nWe have chosen this one \nubuntu-14.04.3-server-amd64.iso\n.\n\n\nVNFPackage [iperf-client]\n\n\nThis iperf-server VNFPackage have to install the iperf client and needs to configure it to set the iperf servers' IP.\n\n\nMetadata [iperf-client]\n\n\nIn the Metadata we define the name of the VNFPackage, the scripts location and also the properties for the image to upload.\nSince the image-link is not implemented in the current release we will put the image directly into the VNFPackage.\nFinally, it looks as shown below.\n\n\nname: iperf-client\nscripts-link: https://gitlab.fokus.fraunhofer.de/openbaton/scripts-test-public.git\nimage-link:\nimage:\n    name: iperf_client_image\n    diskFormat: QCOW2\n    containerFormat: bare\n    minCPU: 2\n    minDisk: 5\n    minRam: 2048\n    isPublic: false\n\n\n\n\nVNFD [iperf-client]\n\n\nThis is how the VNFD looks like for the iperf-client VNFPackage.\nImportant to notice here is the vm_image that points to the image we have defined in the Metadata.yaml\n\n\n{\n    \nvendor\n:\nfokus\n,\n    \nversion\n:\n0.1\n,\n    \nname\n:\niperf-client\n,\n    \ntype\n:\nclient\n,\n    \nendpoint\n:\ngeneric\n,\n    \nvdu\n:[\n        {\n            \nvm_image\n:[\n                \niperf_client_image\n\n            ],\n            \nvirtual_memory_resource_element\n:\n1024\n,\n            \nvirtual_network_bandwidth_resource\n:\n1000000\n,\n            \nvimInstanceName\n:\nvim-instance\n,\n            \nvdu_constraint\n:\n,\n            \nhigh_availability\n:\nACTIVE_PASSIVE\n,\n            \nscale_in_out\n:2,\n            \nvnfc\n:[\n                {\n                    \nconnection_point\n:[\n                        {\n                            \nvirtual_link_reference\n:\nprivate\n\n                        }\n                    ]\n                }\n            ]\n        }\n    ],\n    \nvirtual_link\n:[\n        {\n            \nname\n:\nprivate\n\n        }\n    ],\n    \nlifecycle_event\n:[\n        {\n            \nevent\n:\nINSTANTIATE\n,\n            \nlifecycle_events\n:[\n                \ninstall.sh\n\n            ]\n        },\n        {\n            \nevent\n:\nCONFIGURE\n,\n            \nlifecycle_events\n:[\n                \nserver_configure.sh\n\n            ]\n        }\n    ],\n    \ndeployment_flavour\n:[\n        {\n            \ndf_constraint\n:[\n                \nconstraint1\n,\n                \nconstraint2\n\n            ],\n            \ncostituent_vdu\n:[\n            ],\n            \nflavour_key\n:\nm1.small\n\n        }\n    ]\n}\n\n\n\n\nImage\n\n\nThe image we have to choose must be a debian 64bit image (e.g. ubuntu amd64) for satisfying the EMS and scripts which are designed for that kind of architecture.\nWe have chosen this one \nubuntu-14.04.3-server-amd64.iso\n.\n\n\nOnboarding VNFPackages\n\n\nOnce we have finalized the creation of VNFPackages and packed them into a tar we can onboard them on the NFVO as shown in the following:\n\n\n$ curl -X POST -v -F file=@vnf-package.tar \nhttp://localhost:8080/api/v1/vnf-packages\n\n\n\n\n\nThis must be done for both VNFPackages expecting that the NFVO is running locally and the tar archive is called vnf-package.tar.\nOtherwise you need to adapt the path to the package and also the URL where the NFVO is located.\nNow where we onboarded the VNFPackages they are available on the NFVO and we can make use of it by referencing them in the NSD by their ids'.\n\n\nTo get the ids of the newly created VNFDs you need to fetch the VNFDs by invoking the following command:\n\n\n$ curl -X \nGET http://localhost:8080/api/v1/vnf-descriptors\n\n\n\n\n\nThis request will return a list of already existing VNFDs.\nJust looking for the VNFDs we created before and use the id to reference them in the NSD.\nThe following list of VNFDs is an example of this request.\nTo make it better readable it is shown only the interesting parts.\n\n\n[\n  {\n    \nid\n: \n29d918b9-6245-4dc4-abc6-b7dd6e84f2c1\n,\n    \nname\n: \niperf-server\n,\n    .\n    .\n    .\n  },\n  {\n    \nid\n: \n87820607-4048-4fad-b02b-dbcab8bb5c1c\n,\n    \nname\n: \niperf-client\n,\n    .\n    .\n    .\n  }\n]\n\n\n\n\nNSD [iperf]\n\n\nIn this section we will create s NSD and referencing the previously created VNFPackages by their ids'.\nFor doing that we just need to define the \nid\n for each VNFPackges' VNFD in the list of VNFDs.\nTo provide also the iperf-servers' IP to the iperf-client we need to define dependencies you can found under the key \nvnf_dependency\n setting the source to \niperf-server\n and the target to \niperf-client\n by providing the parameter \nip1\n.\n\n\nNote\n When creating the NSD the VNFD is fetched by the id defined. Other properties we would set in the VNFD in this NSD will be ignored.\n\n\n{\n    \nname\n:\niperf\n,\n    \nvendor\n:\nfokus\n,\n    \nversion\n:\n0.1-ALPHA\n,\n    \nvnfd\n:[\n        {\n            \nid\n:\n29d918b9-6245-4dc4-abc6-b7dd6e84f2c1\n\n        },\n        {\n            \nid\n:\n87820607-4048-4fad-b02b-dbcab8bb5c1c\n\n        }\n    ],\n    \nvld\n:[\n        {\n            \nname\n:\nprivate\n\n        }\n    ],\n    \nvnf_dependency\n:[\n        {\n            \nsource\n : {\n                \nname\n: \niperf-server\n\n            },\n            \ntarget\n:{\n                \nname\n: \niperf-client\n\n            },\n            \nparameters\n:[\n                \nprivate1\n\n            ]\n        }\n    ]\n}\n\n\n\n\nFinally you can onboard this NSD and create a NSR that bases on both VNFPackages created before.\n\n\nOnboard NSD\n\n\nThe following command will onboard the NSD on the NFVO:\n\n\n$ curl -X POST -v -F file=@vnf-package.tar \nhttp://localhost:8080/api/v1/ns-descriptors\n\n\n\n\n\nThis will return the NSD with the id we need to create NSR.\nAfterwards, we can deploy the NSD.\n\n\nCreate NSR (Deployment)\n\n\nTo deploy the NSD we create a NSR with the following command:\n\n\n$ curl -X POST -v -F file=@vnf-package.tar \nhttp://localhost:8080/api/v1/ns-records/\nNSD_ID\n\n\n\n\n\nInstallation and configuration is done automatically and provides you with a configured iperf server/client infrastructure.", 
            "title": "Create your own VNF Package"
        }, 
        {
            "location": "/vnfpackage/#vnfpackage", 
            "text": "Note : This is the initial version of the VNFPackage and might change most probably in the next releases to improve and simplify the creation, usability and power.  This doc describes essential components of a VNFPackage, how to create them and how to use them after onboarding.\nTherefore, you can find a practical tutorial at the end with all the steps starting from the creation over onboarding and finally referencing it by a NSD.  A VNFPackage is a tar-archive that contains all the information required for creating a VNF for the openbaton NFVO.\nAfter onboarding the VNFPackage on the NFVO you can use the VNF directly in the NSD by referencing the VNFD by its id.\nA VNFPackage includes the VNFD, the image, scripts and a Metadata file structured as shown in the next part.", 
            "title": "VNFPackage"
        }, 
        {
            "location": "/vnfpackage/#package-structure", 
            "text": "The VNFPackage consists of the following files/folder:   Metadata.yaml  vnfd.json  scripts/  1_script.sh  2_script.sh    image.img", 
            "title": "Package structure"
        }, 
        {
            "location": "/vnfpackage/#metadatayaml", 
            "text": "The Metadata.yaml defines essential properties for the VNF. This file bases on the YAML syntax where information are stored in simple \\ key> : \\ value> associations.  The example of a Metadata.yaml file below shows a basic definition of a VNFPackage.  name: vnfPackage_name\nscripts-link: scripts_link\nimage-link: image_link\nimage:\n    name: image_name\n    diskFormat: disk_format\n    containerFormat: container_format\n    minCPU: min_cpu\n    minDisk: min_disk\n    minRam: min_ram\n    isPublic: is_public  Each property is explained more in detail now. Please consider also the notes since some properties are optional (or even not implemented) and if they are defined, they may have more priority than other and overrides them therefore.   name : The name defines the name of the VNFPackage itself used to store it on the database.  scripts-link : This link points to a public git repository where scripts are stored that are needed to be executed for managing the lifecycle of the exposed VNF.  Note  Either you can define the scripts-link or put the scripts into the folder scripts/.\n    The scripts-link has a higher priority than the scripts located in the folder scripts/.\n    So if you set the scripts-link, the scripts in folder scripts/ are ignored completely.  Note  The scripts-link is processed by the Element Management System (EMS) in the meaning of fetching the files from that link.\n    So you need to take care about ensuring that the URL defined is available.  Note  Scripts are executed when a specific Event is fired and this Event references to specific scripts.    image-link : This link points to an image available over this URL used to upload the image to the cloud environment.  Note  Either you have to define the image-link or put the image directly into the VNFPackage.\n    Otherwise an NotFoundException will be thrown and the VNFPackage will not onboard.\n    The image-link has a higher priority than the image stored in the VNFPackage directly.  Note  The image-link is a future feature and not implemented in the current version.\n    Therefore, you need to put the image into the VNFPackage directly and remove this line or let the value empty.    image : All the properties explained below are required to upload the image to the cloud environment properly.\n    This image will be uploaded to each cloud environment automatically while onboarding the VNFPackage.  name : This defines the name for the image to upload either located directly in the VNFPackage or available via the URL defined in image-link.  diskFormat : The diskFormat defines the format in which disk type the image is stored.  containerFormat : The containerFormat defines the format in which container type the image is stored .  minCPU : The minCPU defines the minimum amount of CPU cores for using this image properly.  minDisk : The minDisk defines the minimum amount of disk space for using this image properly.  minRam : The minRam defines the minimum amount of RAM for using this image properly.  isPublic : The isPublic defines whether the image is available public or not.", 
            "title": "Metadata.yaml"
        }, 
        {
            "location": "/vnfpackage/#vnfd62json", 
            "text": "The \\ vnfd>.json contains the VirtualNetworkFunctionDescriptor (VNFD) onboarded on the Orchestrator.\nThis VNFD can later be referenced in a NSD by its id to make use of it.\nA more detailed explanation of the VNFD can be found here [].  Note  The name of the file is not important but the suffix .json since the VNFPackageManagement is looking for this kind file format.", 
            "title": "\\&lt;VNFD>.json"
        }, 
        {
            "location": "/vnfpackage/#scripts", 
            "text": "The scripts folder contains all the scripts required for starting, configuring or whatever you want to do on the running instance.\n[EXECUTION ORDER]  Note  These scripts in the folder  scripts  are fetched only if the  scripts-link  is not defined in the  Metadata.yaml .\n    This means that the scripts in that folder have less priority than the scripts located under  scripts-link .  Note  Scripts are executed when a specific Event is fired and this Event references to specific scripts.", 
            "title": "scripts"
        }, 
        {
            "location": "/vnfpackage/#image62img", 
            "text": "This image is used to upload it to all the cloud environments which are addressed inside the VNFD with that image.\nIt doesn't matter whether an image already exists on the considered cloud environment or not.  Note  This image has lower priority than the  image-links  defined in  Metadata.yaml .\n    This mean that the image will be ignored if the  image-links  is defined.  Note  The name of the image doesn't matter but the suffix .img since the VNFPackageManagement is looking for a file with this suffix.\n    However, the name and all the properties for stroing it on the cloud environment are defined in  Metadata.yaml  under the key  image .", 
            "title": "\\&lt;image>.img"
        }, 
        {
            "location": "/vnfpackage/#tutorial", 
            "text": "This section explains how to create, upload and make use of VNFPackages.\nThe chosen scenario is a NetworkService for testing the network connectivity by using iperf.\nTherefore, we need a server and a client installing the iperf server/client and configuring them for communication between.", 
            "title": "Tutorial"
        }, 
        {
            "location": "/vnfpackage/#creation-of-vnfpackages", 
            "text": "For doing so, we need to create two VNFPackages and reference them in the NSD.\nSo we need one VNFPackage for the iperf server (called iperf-server) and one for the iperf client (called iperf-client).\nFirst we will start with the creation of the iperf-server VNFPackage and then we will create the iperf-client VNFPackage.  First of all we should create a directory for each VNFPackage where we put all the files related to the VNFPackage because in the end we need to pack them into an tar archive for onboarding it on the NFVO.  VNFPackage [iperf-server]  This iperf-server VNFPackage have to install the iperf server and needs to provide its ip to the iperf client.  Metadata [iperf-server]  In the Metadata we define the name of the VNFPackage, the scripts location and also the properties for the image to upload.\nSince the image-link is not implemented in the current release we will put the image directly into the VNFPackage.\nFinally, it looks as shown below.  name: iperf-server\nscripts-link: https://gitlab.fokus.fraunhofer.de/openbaton/scripts-test-public.git\nimage-link:\nimage:\n    name: iperf_server_image\n    diskFormat: QCOW2\n    containerFormat: bare\n    minCPU: 2\n    minDisk: 5\n    minRam: 2048\n    isPublic: false  VNFD [iperf-server]  This is how the VNFD looks like for the iperf-server VNFPackage.\nImportant to notice here is the vm_image that points to the image we have defined in the Metadata.yaml  {\n     vendor : fokus ,\n     version : 0.2 ,\n     name : iperf-server ,\n     type : server ,\n     endpoint : generic ,\n     vdu :[\n        {\n             vm_image :[\n                 iperf_server_image \n            ],\n             vimInstanceName : vim-instance ,\n             scale_in_out :2,\n             vnfc :[\n                {\n                     exposed :true,\n                     connection_point :[\n                        {\n                             virtual_link_reference : private \n                        }\n                    ]\n                }\n            ]\n        }\n    ],\n     virtual_link :[\n        {\n             name : private \n        }\n    ],\n     lifecycle_event :[\n        {\n             event : INSTANTIATE ,\n             lifecycle_events :[\n                 install.sh ,\n                 install-srv.sh \n            ]\n        }\n    ],\n     deployment_flavour :[\n        {\n             df_constraint :[\n                 constraint1 ,\n                 constraint2 \n            ],\n             costituent_vdu :[\n            ],\n             flavour_key : m1.small \n        }\n    ]\n}  Image  The image we have to choose must be a debian 64bit image (e.g. ubuntu amd64) for satisfying the EMS and scripts which are designed for that kind of image.\nWe have chosen this one  ubuntu-14.04.3-server-amd64.iso .  VNFPackage [iperf-client]  This iperf-server VNFPackage have to install the iperf client and needs to configure it to set the iperf servers' IP.  Metadata [iperf-client]  In the Metadata we define the name of the VNFPackage, the scripts location and also the properties for the image to upload.\nSince the image-link is not implemented in the current release we will put the image directly into the VNFPackage.\nFinally, it looks as shown below.  name: iperf-client\nscripts-link: https://gitlab.fokus.fraunhofer.de/openbaton/scripts-test-public.git\nimage-link:\nimage:\n    name: iperf_client_image\n    diskFormat: QCOW2\n    containerFormat: bare\n    minCPU: 2\n    minDisk: 5\n    minRam: 2048\n    isPublic: false  VNFD [iperf-client]  This is how the VNFD looks like for the iperf-client VNFPackage.\nImportant to notice here is the vm_image that points to the image we have defined in the Metadata.yaml  {\n     vendor : fokus ,\n     version : 0.1 ,\n     name : iperf-client ,\n     type : client ,\n     endpoint : generic ,\n     vdu :[\n        {\n             vm_image :[\n                 iperf_client_image \n            ],\n             virtual_memory_resource_element : 1024 ,\n             virtual_network_bandwidth_resource : 1000000 ,\n             vimInstanceName : vim-instance ,\n             vdu_constraint : ,\n             high_availability : ACTIVE_PASSIVE ,\n             scale_in_out :2,\n             vnfc :[\n                {\n                     connection_point :[\n                        {\n                             virtual_link_reference : private \n                        }\n                    ]\n                }\n            ]\n        }\n    ],\n     virtual_link :[\n        {\n             name : private \n        }\n    ],\n     lifecycle_event :[\n        {\n             event : INSTANTIATE ,\n             lifecycle_events :[\n                 install.sh \n            ]\n        },\n        {\n             event : CONFIGURE ,\n             lifecycle_events :[\n                 server_configure.sh \n            ]\n        }\n    ],\n     deployment_flavour :[\n        {\n             df_constraint :[\n                 constraint1 ,\n                 constraint2 \n            ],\n             costituent_vdu :[\n            ],\n             flavour_key : m1.small \n        }\n    ]\n}  Image  The image we have to choose must be a debian 64bit image (e.g. ubuntu amd64) for satisfying the EMS and scripts which are designed for that kind of architecture.\nWe have chosen this one  ubuntu-14.04.3-server-amd64.iso .", 
            "title": "Creation of VNFPackages"
        }, 
        {
            "location": "/vnfpackage/#onboarding-vnfpackages", 
            "text": "Once we have finalized the creation of VNFPackages and packed them into a tar we can onboard them on the NFVO as shown in the following:  $ curl -X POST -v -F file=@vnf-package.tar  http://localhost:8080/api/v1/vnf-packages   This must be done for both VNFPackages expecting that the NFVO is running locally and the tar archive is called vnf-package.tar.\nOtherwise you need to adapt the path to the package and also the URL where the NFVO is located.\nNow where we onboarded the VNFPackages they are available on the NFVO and we can make use of it by referencing them in the NSD by their ids'.  To get the ids of the newly created VNFDs you need to fetch the VNFDs by invoking the following command:  $ curl -X  GET http://localhost:8080/api/v1/vnf-descriptors   This request will return a list of already existing VNFDs.\nJust looking for the VNFDs we created before and use the id to reference them in the NSD.\nThe following list of VNFDs is an example of this request.\nTo make it better readable it is shown only the interesting parts.  [\n  {\n     id :  29d918b9-6245-4dc4-abc6-b7dd6e84f2c1 ,\n     name :  iperf-server ,\n    .\n    .\n    .\n  },\n  {\n     id :  87820607-4048-4fad-b02b-dbcab8bb5c1c ,\n     name :  iperf-client ,\n    .\n    .\n    .\n  }\n]", 
            "title": "Onboarding VNFPackages"
        }, 
        {
            "location": "/vnfpackage/#nsd-iperf", 
            "text": "In this section we will create s NSD and referencing the previously created VNFPackages by their ids'.\nFor doing that we just need to define the  id  for each VNFPackges' VNFD in the list of VNFDs.\nTo provide also the iperf-servers' IP to the iperf-client we need to define dependencies you can found under the key  vnf_dependency  setting the source to  iperf-server  and the target to  iperf-client  by providing the parameter  ip1 .  Note  When creating the NSD the VNFD is fetched by the id defined. Other properties we would set in the VNFD in this NSD will be ignored.  {\n     name : iperf ,\n     vendor : fokus ,\n     version : 0.1-ALPHA ,\n     vnfd :[\n        {\n             id : 29d918b9-6245-4dc4-abc6-b7dd6e84f2c1 \n        },\n        {\n             id : 87820607-4048-4fad-b02b-dbcab8bb5c1c \n        }\n    ],\n     vld :[\n        {\n             name : private \n        }\n    ],\n     vnf_dependency :[\n        {\n             source  : {\n                 name :  iperf-server \n            },\n             target :{\n                 name :  iperf-client \n            },\n             parameters :[\n                 private1 \n            ]\n        }\n    ]\n}  Finally you can onboard this NSD and create a NSR that bases on both VNFPackages created before.  Onboard NSD  The following command will onboard the NSD on the NFVO:  $ curl -X POST -v -F file=@vnf-package.tar  http://localhost:8080/api/v1/ns-descriptors   This will return the NSD with the id we need to create NSR.\nAfterwards, we can deploy the NSD.  Create NSR (Deployment)  To deploy the NSD we create a NSR with the following command:  $ curl -X POST -v -F file=@vnf-package.tar  http://localhost:8080/api/v1/ns-records/ NSD_ID   Installation and configuration is done automatically and provides you with a configured iperf server/client infrastructure.", 
            "title": "NSD [iperf]"
        }, 
        {
            "location": "/nfvo-how-to-use-gui/", 
            "text": "OpenBaton Dashboard\n\n\nThe Dashboard of OpenBaton helps you for the the management of lifecycle of different objects like \nVimInstaces, Network Service Descriptors/Records and Virtual Network Function Descriptos/Records in the OpenBaton environment.\n\n\nOverview\n\n\nThe index page is an overview of the state of NFVO \n\n\n\n\nNumber of Network Service Records\n\n\nNumber of Virtual Network Functions\n\n\nNumber of Virtual Deployment Units\n\n\nNumber of Network Service Descriptors\n\n\n\n\n\n\nManage PoPs\n\n\nIn this page you can see the list of Vim Instances registered\n\n\n\n\nFor registering a new Vim Instance you should click the button on the top-right side \nRegister Vim\n of this page and choose your json to register a Vim Instance\n\n\n\n\nIf you want to delete one Vim Instance you can click the button \nAction\n and than \nDelete\n in the menu\n\n\nNetwork Service Descriptors\n\n\nIn the menu on the left side under the voice Catalogue you can find \nNS Decriptors\n\nIn this page you can see the list of NS Descriptors stored into OpenBaton\n\n\n\n\nFor storing a NS Descriptor you have 2 options:\n\n\n\n\nCreate NSD Form\n\n\nCreate NSD File\n\n\n\n\nCreate a NSD using a File\n\n\n\n\nCreate a NSD using Form\n\n\n\n\nNetwork Service Descriptor Information\n\n\nIn the list of Network Service Descriptors if you click on the id in the table you can see the information\n into Network Service Descriptor selected by id and will be shown this page\n\n\n\n\nIn this page you can see the JSON file of the NSD just clicking on the link \nShow JSON\n\n\n\n\nIn the page \nNetwork Service Descriptor Information\n you can see the \nGraphical view\n of Network Service Descriptor \njust clicking the link \nShow Graph\n\n\n\n\nIn the list of VNFD if you click the \nAction\n button you can delete the VNFD from NSD\nand the information about the \nDependencies\n into Network Service Descriptor\n\n\n\n\nIn the list of VNFDependencies if you click the \nAction\n button you can delete the VNFDependency from NSD\n\n\nVirtual Network Function Descriptor Information\n\n\nIn the list of Virtual Network Function Descriptor into NSD if you click on the id of Virtual Network Function Descriptor will be shown this page\n\n\n\n\nIn the bottom side of the page you can see the Virtual Deployment Unit (VDU) tab and if you click the \nid\n of the \nVDU you can see the details of VDU like in this page\n\n\n\n\nNetwork Service Records\n\n\nIn the menu of the left side if you click on the \nOrchestrator NS\n and than \nNS Records\n you will see the list of \nNetwork Service Records\n\n  Like in this screenshot \n\n\n\n\nIn this page you can see the details of a Network Service Record just click the id and will be show this page\n\n\n\n\nIn this page you can see the JSON file of the NSR just clicking on the link \nShow JSON\n and also the \nGraphical view\n \nof Network Service Record just clicking the link \nShow Graph\n\nIn the table of VNF Records you can delete one VNFR just clicking \nDelete\n in the menu \nAction\n\nFor seeing the details of VNFR just click on the \nid\n of a VNFR and will be shown this page", 
            "title": "Use via the Dashboard"
        }, 
        {
            "location": "/nfvo-how-to-use-gui/#openbaton-dashboard", 
            "text": "The Dashboard of OpenBaton helps you for the the management of lifecycle of different objects like \nVimInstaces, Network Service Descriptors/Records and Virtual Network Function Descriptos/Records in the OpenBaton environment.", 
            "title": "OpenBaton Dashboard"
        }, 
        {
            "location": "/nfvo-how-to-use-gui/#overview", 
            "text": "The index page is an overview of the state of NFVO    Number of Network Service Records  Number of Virtual Network Functions  Number of Virtual Deployment Units  Number of Network Service Descriptors", 
            "title": "Overview"
        }, 
        {
            "location": "/nfvo-how-to-use-gui/#manage-pops", 
            "text": "In this page you can see the list of Vim Instances registered   For registering a new Vim Instance you should click the button on the top-right side  Register Vim  of this page and choose your json to register a Vim Instance   If you want to delete one Vim Instance you can click the button  Action  and than  Delete  in the menu", 
            "title": "Manage PoPs"
        }, 
        {
            "location": "/nfvo-how-to-use-gui/#network-service-descriptors", 
            "text": "In the menu on the left side under the voice Catalogue you can find  NS Decriptors \nIn this page you can see the list of NS Descriptors stored into OpenBaton   For storing a NS Descriptor you have 2 options:   Create NSD Form  Create NSD File   Create a NSD using a File   Create a NSD using Form   Network Service Descriptor Information  In the list of Network Service Descriptors if you click on the id in the table you can see the information\n into Network Service Descriptor selected by id and will be shown this page   In this page you can see the JSON file of the NSD just clicking on the link  Show JSON   In the page  Network Service Descriptor Information  you can see the  Graphical view  of Network Service Descriptor \njust clicking the link  Show Graph   In the list of VNFD if you click the  Action  button you can delete the VNFD from NSD\nand the information about the  Dependencies  into Network Service Descriptor   In the list of VNFDependencies if you click the  Action  button you can delete the VNFDependency from NSD  Virtual Network Function Descriptor Information  In the list of Virtual Network Function Descriptor into NSD if you click on the id of Virtual Network Function Descriptor will be shown this page   In the bottom side of the page you can see the Virtual Deployment Unit (VDU) tab and if you click the  id  of the \nVDU you can see the details of VDU like in this page", 
            "title": "Network Service Descriptors"
        }, 
        {
            "location": "/nfvo-how-to-use-gui/#network-service-records", 
            "text": "In the menu of the left side if you click on the  Orchestrator NS  and than  NS Records  you will see the list of  Network Service Records \n  Like in this screenshot    In this page you can see the details of a Network Service Record just click the id and will be show this page   In this page you can see the JSON file of the NSR just clicking on the link  Show JSON  and also the  Graphical view  \nof Network Service Record just clicking the link  Show Graph \nIn the table of VNF Records you can delete one VNFR just clicking  Delete  in the menu  Action \nFor seeing the details of VNFR just click on the  id  of a VNFR and will be shown this page", 
            "title": "Network Service Records"
        }, 
        {
            "location": "/extend/", 
            "text": "Extend OpenBaton\n\n\nBeing an open source implementation, OpenBaton can be easily extended for supporting additional features or capabilities.\n\n\nExtend the NFVO\n\n\nThe NFVO has been implemented as a java modular application using the Spring.io framework. It is pretty easy to add a new module for extending the supported features. Please refer to the [nfvo-documentation] for learning a bit more about the NFVO architecture.\n\n\nImplement a new plugin of the VIM interface\n\n\nFirst of all you need to install the plugin sdk to your local repository. The second step is to install the gradle plugin [plugin-sdk-gradle-plugin]. \nCreate a new project with build.gradle starting with:\n\n\n   project.ext {\n        mainClassName = '\npath_to_Starter\n'\n    }\n    buildscript {\n        repositories{\n            mavenCentral()\n            maven {\n                url uri('../repository-local')\n            }\n        }\n        dependencies {\n            classpath 'org.project.openbaton:plugin-sdk-gradle-plugin:0.1'\n            classpath 'org.springframework.boot:spring-boot-gradle-plugin:1.2.5.RELEASE'\n        }\n    }\n    apply plugin: 'spring-boot'\n    apply plugin: 'plugin-sdk'\n\n\n\n\nCreate a starter that contains a psvm calling PluginStarter.run() like this:\n\n\npublic static void main(String[] args) {\n    PluginStarter.run(\nplugin_class\n, \nplugin_register_name\n, \nnfvo_ip\n, \nnfvo_rmi_port(default: 1099)\n);\n}\n\n\n\n\nCreate a plugin class extending ClientInterfaces for vim-driver.\n\n\nBuild your own VNFM using the provided vnfm-sdk\n\n\nIn order to facilitate the implementation of a VNFM specific for your VNFs, we provide a Java SDK that could provide all the basic functionalities required, among them the implementation of the vnfm-or interface. \n\n\nnfvo-documentation\n\n\nplugin-sdk-gradle-plugin", 
            "title": "Overview"
        }, 
        {
            "location": "/extend/#extend-openbaton", 
            "text": "Being an open source implementation, OpenBaton can be easily extended for supporting additional features or capabilities.", 
            "title": "Extend OpenBaton"
        }, 
        {
            "location": "/extend/#extend-the-nfvo", 
            "text": "The NFVO has been implemented as a java modular application using the Spring.io framework. It is pretty easy to add a new module for extending the supported features. Please refer to the [nfvo-documentation] for learning a bit more about the NFVO architecture.", 
            "title": "Extend the NFVO"
        }, 
        {
            "location": "/extend/#implement-a-new-plugin-of-the-vim-interface", 
            "text": "First of all you need to install the plugin sdk to your local repository. The second step is to install the gradle plugin [plugin-sdk-gradle-plugin]. \nCreate a new project with build.gradle starting with:     project.ext {\n        mainClassName = ' path_to_Starter '\n    }\n    buildscript {\n        repositories{\n            mavenCentral()\n            maven {\n                url uri('../repository-local')\n            }\n        }\n        dependencies {\n            classpath 'org.project.openbaton:plugin-sdk-gradle-plugin:0.1'\n            classpath 'org.springframework.boot:spring-boot-gradle-plugin:1.2.5.RELEASE'\n        }\n    }\n    apply plugin: 'spring-boot'\n    apply plugin: 'plugin-sdk'  Create a starter that contains a psvm calling PluginStarter.run() like this:  public static void main(String[] args) {\n    PluginStarter.run( plugin_class ,  plugin_register_name ,  nfvo_ip ,  nfvo_rmi_port(default: 1099) );\n}  Create a plugin class extending ClientInterfaces for vim-driver.", 
            "title": "Implement a new plugin of the VIM interface"
        }, 
        {
            "location": "/extend/#build-your-own-vnfm-using-the-provided-vnfm-sdk", 
            "text": "In order to facilitate the implementation of a VNFM specific for your VNFs, we provide a Java SDK that could provide all the basic functionalities required, among them the implementation of the vnfm-or interface.   nfvo-documentation  plugin-sdk-gradle-plugin", 
            "title": "Build your own VNFM using the provided vnfm-sdk"
        }, 
        {
            "location": "/nfvo-architecture/", 
            "text": "NFVO Architecture\n\n\nNFVO\n is a modular software composed by the modules illustrated in the following picture:\n\n\n\n\nAPI\n\n\nThis module contains the necessary classes exposing APIs as ReST server. The most importat ones are the classes managing VimInstances, NetworkServiceDescriptors and NetworkServiceRecords. For more details please see \nthe api documentation\n\n\nMAIN\n\n\nThis module contains the classes charged of the startup of the whole system, gathering configuratons for instance.\n\n\nCOMMON\n\n\nThis module contains the classes that are common to the NFVO\n\n\nCLI\n\n\nThis module contains the NFVO console.\n\n\nDASHBOARD\n\n\nThis module contains the web dashboard available at localhost:8080\n\n\nCORE-INT\n\n\nThis module contains the interfaces of the core functionalities regarding only the internal NFVO interfaces. Most of them are definend in \nETSI MANO specification\n in NFV-MANO interfaces section.\n\n\nCORE-IMPL\n\n\nThis module contains the beans implementing the core-int interfaces.\n\n\nVNFM-INT\n\n\nThis module contains the interfaces of the core functionalities regarding only the NFVO interfaces to the VnfManagers. Most of them are definend in \nETSI MANO specification\n in NFV-MANO interfaces section.\n\n\nVNFM-IMPL\n\n\nThis module contains the beans implementing the vnfm-int interfaces.\n\n\nREPOSITORY\n\n\nThis module contains specific repositories interfacing the database, in a generic way.\n\n\nCATALOGUE\n\n\nThis module contains the complete model of NFVO that is sharde in the openbaton libraries.\n\n\nVIM-INT\n\n\nThis module contains the interfaces of the core functionalities regarding only the NFVO interfaces to the VIM. Most of them are definend in \nETSI MANO specification\n in NFV-MANO interfaces section.\n\n\nVIM-IMPL\n\n\nThis module contains the beans implementing the vim-int interfaces.\n\n\nPLUGIN\n\n\nThis module contains the utility classes used to interface to the openbaton plugins.\n\n\nVIM-DRIVERS\n\n\nThis module contains the interface for the VIM openbaton plugins.\n\n\nEXCEPTION\n\n\nThis module contains all the exception classes common to every project containing openbaton libraries.\n\n\nMONITORING\n\n\nThis module contains the interface for the Monitoring openbaton plugins.\n\n\nNFVO - VNFM ReST interface\n\n\nNfvo exposes a ReST interface for the communication with the VnfManagers. The sequence diagram regarding the instantiation of a NetworkServiceRecord is shown in the following picture.\n\n\n\n\nAs shown in the picture, NFVO calls some ReST methods on the vnfm in a particular order. Than it expects some kind of back call. The list of these call exchange is described in the following sections. The ALLOCATE_RESOURCES call is not needed if the vnfm will take care of creating VMs. The communication with the EMS is particular to each VnfManagers. In order to be able to be found, the Vnfm needs to register to the NFVO. This can be done through a particular call.\n\n\n\n\n\n\n\n\nParams\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\nOrEndpoint\n\n\nthe endpoint of the NFVO (i.e. http://127.0.0.1:8080)\n\n\n\n\n\n\nVnfmEnpoint\n\n\nthe endpoint of the Vnfm. this is given while registering\n\n\n\n\n\n\n\n\nRegistration (Vnfm-Or):\n\n\npath:\n\n\nOrEndpoint\n /admin/v1/vnfm-register\n\n\nbody:\n\n\n{\n    \ntype\n:\ndummy\n,\n    \nendpointType\n:\nREST\n,\n    \nendpoint\n:\nVnfmEndpoint\n\n}\n\n\n\n\nwhere:\n\n \ntype\n is the vnfm type you are going to handle (specified in VirtualNetowrkFunctionDescriptor -\n endpoint). \n \nendpointType\n is the vnfm type you are going to implement (REST or JMS). \n* \nendpoint\n is the vnfm endpoint you have chosen (basically http://\n:\n). \n\n\nInstantiate (Or-Vnfm)\n\n\npath\n\n\nVnfmEnpoint\n \n\n\nbody\n\n\n{  \n    \nscriptsLink\n:\nlinktogit\n, // a link to the reposritory where the links are located\n    \nscripts\n:\nscriptsfiles\n, // the scripts files coming from the vnfPackage, in case no scriptsLink is provided\n    \nvnfd\n:{  ...  }, // the VirtualNetowrkFunctionDescriptor from which a VirtualNetowrkFunctionRecord is created\n    \nvnfdf\n:{  ...  }, // the deployment flavours to be used\n    \nvlrs\n:[  ...  ], // the list of VirtualLinkRecords of the NetworkServiceRecord.\n    \nextention\n:{  \nnsr-id\n:\n...\n  }, // some info like the NetworkServiceRecord id\n    \naction\n:\nINSTANTIATE\n // the action to be executed\n}\n\n\n\n\nIn this action either the \nscriptsLink\n or the \nscripts\n fields are set. The vnfm-sdk will take care of them.    \n\n\nInstantiate (Vnfm-Or)\n\n\npath\n\n\nOrEndpoint\n /admin/v1/vnfm-core-actions\n\n\nbody\n\n\n{  \n    \nvirtualNetworkFunctionRecord\n:{  ...  }, // the created VirtualNetowrkFunctionRecord\n    \naction\n:\nINSTANTIATE\n\n}\n\n\n\n\nModify (aka AddRelations) (Or-Vnfm)\n\n\npath\n\n\nVnfmEnpoint\n \n\n\nbody\n\n\n{  \n    \nvnfr\n:{  }, // the VirtualNetowrkFunctionRecord target of the depedendecy\n    \nvnfrd\n:{  }, // the VNFDependency containing all the source parameters needed by the scripts\n    \naction\n:\nMODIFY\n\n}\n\n\n\n\nModify (aka AddRelations) (Vnfm-Or)\n\n\npath\n\n\nVnfmEnpoint\n \n\n\nbody\n\n\n{  \n    \nvirtualNetworkFunctionRecord\n:{  },\n    \naction\n:\nMODIFY\n\n}\n\n\n\n\nStart (Or-Vnfm)\n\n\npath\n\n\nVnfmEnpoint\n \n\n\nbody\n\n\n{  \n    \nvnfr\n:{  ...  },\n    \naction\n:\nSTART\n\n}\n\n\n\n\nStart (Vnfm-Or)\n\n\npath\n\n\nOrEndpoint\n /admin/v1/vnfm-core-actions\n\n\nbody\n\n\n{  \n    \nvirtualNetworkFunctionRecord\n:{  ...  },\n    \naction\n:\nSTART\n\n}", 
            "title": "NFVO Architecture"
        }, 
        {
            "location": "/nfvo-architecture/#nfvo-architecture", 
            "text": "NFVO  is a modular software composed by the modules illustrated in the following picture:   API  This module contains the necessary classes exposing APIs as ReST server. The most importat ones are the classes managing VimInstances, NetworkServiceDescriptors and NetworkServiceRecords. For more details please see  the api documentation  MAIN  This module contains the classes charged of the startup of the whole system, gathering configuratons for instance.  COMMON  This module contains the classes that are common to the NFVO  CLI  This module contains the NFVO console.  DASHBOARD  This module contains the web dashboard available at localhost:8080  CORE-INT  This module contains the interfaces of the core functionalities regarding only the internal NFVO interfaces. Most of them are definend in  ETSI MANO specification  in NFV-MANO interfaces section.  CORE-IMPL  This module contains the beans implementing the core-int interfaces.  VNFM-INT  This module contains the interfaces of the core functionalities regarding only the NFVO interfaces to the VnfManagers. Most of them are definend in  ETSI MANO specification  in NFV-MANO interfaces section.  VNFM-IMPL  This module contains the beans implementing the vnfm-int interfaces.  REPOSITORY  This module contains specific repositories interfacing the database, in a generic way.  CATALOGUE  This module contains the complete model of NFVO that is sharde in the openbaton libraries.  VIM-INT  This module contains the interfaces of the core functionalities regarding only the NFVO interfaces to the VIM. Most of them are definend in  ETSI MANO specification  in NFV-MANO interfaces section.  VIM-IMPL  This module contains the beans implementing the vim-int interfaces.  PLUGIN  This module contains the utility classes used to interface to the openbaton plugins.  VIM-DRIVERS  This module contains the interface for the VIM openbaton plugins.  EXCEPTION  This module contains all the exception classes common to every project containing openbaton libraries.  MONITORING  This module contains the interface for the Monitoring openbaton plugins.", 
            "title": "NFVO Architecture"
        }, 
        {
            "location": "/nfvo-architecture/#nfvo-vnfm-rest-interface", 
            "text": "Nfvo exposes a ReST interface for the communication with the VnfManagers. The sequence diagram regarding the instantiation of a NetworkServiceRecord is shown in the following picture.   As shown in the picture, NFVO calls some ReST methods on the vnfm in a particular order. Than it expects some kind of back call. The list of these call exchange is described in the following sections. The ALLOCATE_RESOURCES call is not needed if the vnfm will take care of creating VMs. The communication with the EMS is particular to each VnfManagers. In order to be able to be found, the Vnfm needs to register to the NFVO. This can be done through a particular call.     Params  Meaning      OrEndpoint  the endpoint of the NFVO (i.e. http://127.0.0.1:8080)    VnfmEnpoint  the endpoint of the Vnfm. this is given while registering     Registration (Vnfm-Or):  path:  OrEndpoint  /admin/v1/vnfm-register  body:  {\n     type : dummy ,\n     endpointType : REST ,\n     endpoint : VnfmEndpoint \n}  where:   type  is the vnfm type you are going to handle (specified in VirtualNetowrkFunctionDescriptor -  endpoint).    endpointType  is the vnfm type you are going to implement (REST or JMS). \n*  endpoint  is the vnfm endpoint you have chosen (basically http:// : ).   Instantiate (Or-Vnfm)  path  VnfmEnpoint    body  {  \n     scriptsLink : linktogit , // a link to the reposritory where the links are located\n     scripts : scriptsfiles , // the scripts files coming from the vnfPackage, in case no scriptsLink is provided\n     vnfd :{  ...  }, // the VirtualNetowrkFunctionDescriptor from which a VirtualNetowrkFunctionRecord is created\n     vnfdf :{  ...  }, // the deployment flavours to be used\n     vlrs :[  ...  ], // the list of VirtualLinkRecords of the NetworkServiceRecord.\n     extention :{   nsr-id : ...   }, // some info like the NetworkServiceRecord id\n     action : INSTANTIATE  // the action to be executed\n}  In this action either the  scriptsLink  or the  scripts  fields are set. The vnfm-sdk will take care of them.      Instantiate (Vnfm-Or)  path  OrEndpoint  /admin/v1/vnfm-core-actions  body  {  \n     virtualNetworkFunctionRecord :{  ...  }, // the created VirtualNetowrkFunctionRecord\n     action : INSTANTIATE \n}  Modify (aka AddRelations) (Or-Vnfm)  path  VnfmEnpoint    body  {  \n     vnfr :{  }, // the VirtualNetowrkFunctionRecord target of the depedendecy\n     vnfrd :{  }, // the VNFDependency containing all the source parameters needed by the scripts\n     action : MODIFY \n}  Modify (aka AddRelations) (Vnfm-Or)  path  VnfmEnpoint    body  {  \n     virtualNetworkFunctionRecord :{  },\n     action : MODIFY \n}  Start (Or-Vnfm)  path  VnfmEnpoint    body  {  \n     vnfr :{  ...  },\n     action : START \n}  Start (Vnfm-Or)  path  OrEndpoint  /admin/v1/vnfm-core-actions  body  {  \n     virtualNetworkFunctionRecord :{  ...  },\n     action : START \n}", 
            "title": "NFVO - VNFM ReST interface"
        }, 
        {
            "location": "/vnfm-generic/", 
            "text": "VNFManager Generic\n\n\nThe Generic VNFManager is an implementation following the \nETSI MANO\n specifications. For that reason is highly tied to the EMS.\n\n\nThe Generic VNFManager handles communication with the NFVO and with EMS. The communication between NFVO and the EMS is done through Stomp protocol, in particural JMS. The sequece diagram following explains the communication messages.\n\n\n![Sequence Diagram NFVO - VNFM - EMS][or-vnfm-sequence]\n\n\nThe Generic VNFManager is supposed to be used for any type of VNF that follows some convetions regarding:\n\n\n\n\nVMs deployment\n\n\nscript execution order\n\n\nVMs termination\n\n\n\n\nVMs deployment\n\n\nAs seen in the previous picture, the allocation of resources (VMs) are requested by the VNFManager to the NFVO. Before that all the VNFManagers need to request whenever the resources are available on the selected PoP. This is done by the GRANT_OPERATION message and it is executed by all the VNFManagers. The Generic VNFM sends the ALLOCATE_RESOURCES message as well. If the GRANT_OPERATION message is returned, than it means that there are enough resources, if not an ERROR message will be sent. After the GRANT_OPERATION message it is possible to send the ALLOCATE_RESOURCE message. This message will create all the resources and than, if no errors occured, return the ALLOCATE_RESOURCE message to the VNFManager. after that point the VMs are created and the VNFRecord is filled with values, such as ips, that can be found directly in the VirtalNetworkFunctionRecord-\nVirtualDeploymentUnit-\nVNFCInstance object. \n\n\nScript Execution Costraints\n\n\nDuring the INSTANTIATE and the MODIFY operations, scripts are executed in the VMs. The ordering of this scripts is defined in the NetworkServiceDescriptor from which the NetworkServiceRecord was created, in particural into the VirtalNetworkFunctionRecord-\nLifecycleEvents (see VNFD). The available parameters are defined into the VirtalNetworkFunctionDescriptor fields:\n\n\n\n\nprovides\n\n\nconfigurations\n\n\n\n\nIn the INSTANTIATE scripts, the parameters defined into these two fields are then available as environment variables into the script exactly as defined.\n\n\nIn the MODIFY scripts, the INSTANTIATE parameters are still available but plus there are environment variables that come from a VNFDependency. These kind of parameters are defined into the \nrequires\n and the VNFDependency-\nparameters fields, and are then available as $\ntype_of_vnf_source\n.\nname_of_parameter\n\n\nVMs termination\n\n\nAs for VMs deployment, VMs termination is done by the NFVO. Specific scripts can be run before termination by putting them under the RELEASE_REOSURCES lifecycel event.", 
            "title": "Generic VNFM"
        }, 
        {
            "location": "/vnfm-generic/#vnfmanager-generic", 
            "text": "The Generic VNFManager is an implementation following the  ETSI MANO  specifications. For that reason is highly tied to the EMS.  The Generic VNFManager handles communication with the NFVO and with EMS. The communication between NFVO and the EMS is done through Stomp protocol, in particural JMS. The sequece diagram following explains the communication messages.  ![Sequence Diagram NFVO - VNFM - EMS][or-vnfm-sequence]  The Generic VNFManager is supposed to be used for any type of VNF that follows some convetions regarding:   VMs deployment  script execution order  VMs termination   VMs deployment  As seen in the previous picture, the allocation of resources (VMs) are requested by the VNFManager to the NFVO. Before that all the VNFManagers need to request whenever the resources are available on the selected PoP. This is done by the GRANT_OPERATION message and it is executed by all the VNFManagers. The Generic VNFM sends the ALLOCATE_RESOURCES message as well. If the GRANT_OPERATION message is returned, than it means that there are enough resources, if not an ERROR message will be sent. After the GRANT_OPERATION message it is possible to send the ALLOCATE_RESOURCE message. This message will create all the resources and than, if no errors occured, return the ALLOCATE_RESOURCE message to the VNFManager. after that point the VMs are created and the VNFRecord is filled with values, such as ips, that can be found directly in the VirtalNetworkFunctionRecord- VirtualDeploymentUnit- VNFCInstance object.   Script Execution Costraints  During the INSTANTIATE and the MODIFY operations, scripts are executed in the VMs. The ordering of this scripts is defined in the NetworkServiceDescriptor from which the NetworkServiceRecord was created, in particural into the VirtalNetworkFunctionRecord- LifecycleEvents (see VNFD). The available parameters are defined into the VirtalNetworkFunctionDescriptor fields:   provides  configurations   In the INSTANTIATE scripts, the parameters defined into these two fields are then available as environment variables into the script exactly as defined.  In the MODIFY scripts, the INSTANTIATE parameters are still available but plus there are environment variables that come from a VNFDependency. These kind of parameters are defined into the  requires  and the VNFDependency- parameters fields, and are then available as $ type_of_vnf_source . name_of_parameter  VMs termination  As for VMs deployment, VMs termination is done by the NFVO. Specific scripts can be run before termination by putting them under the RELEASE_REOSURCES lifecycel event.", 
            "title": "VNFManager Generic"
        }, 
        {
            "location": "/vnfm-how-to-write/", 
            "text": "How to write a VNFManager\n\n\nHow to write a Vnfm for OpenBaton:\n\n\nrequirements:\n\n JDK 7\n\n vnfm-sdk lib\n\n\nIt is suggested to use the vnfm-sdk-jms (in case of a jms Vnfm or vnfm-sdk-rest in case of a ReST VNFManager) because it is a sdk providing already the utilities classes in charge of the communication to the NFVO and other tools. This implementation make use of \nSpringBoot\n. If you don't want this dependency than use the simple vnfm-sdk artifact, but all the communication with the NFVO needs to be implemented.\n\n\nFor gathering the vnfm-sdk-jms library you need that to your build.gradle:\n\n\nbuildscript {\n    dependencies {\n        classpath(\norg.springframework.boot:spring-boot-gradle-plugin:1.2.6.RELEASE\n)\n    }\n}\napply plugin: 'spring-boot'\nbootRepackage {\n    mainClass = 'path.to.the.vnfm.class.VNFManager'\n}\napply plugin: 'java'\napply plugin: 'maven'\nrepositories {\n    mavenCentral()\n    maven {\n        url \nhttp://193.175.132.176:8081/nexus/content/groups/public\n\n    }\n}\ndependencies {\n    compile 'org.openbaton:vnfm-sdk-jms:0.5-SNAPSHOT' \n}\n\n\n\n\nIn this way you will have access to all the model classes and the vnfm-sdk classes needed to implement a VNFManager. The main class of your Vnfm will be the only class needed to be implemented and this class needs to extend \nAbstractVnfmSpringJMS\n. This class will provide all the methods that will be called in all the instantiation process (instantiate, modify etc.).\n\n\nIt needs to implement as well a main methods as follows:\n\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.openbaton.common.vnfm_sdk.jms.AbstractVnfmSpringJMS;\npublic class VNFManager extends AbstractVnfmSpringJMS{\n    @Autowired\n    private VnfmHelper vnfmHelper;\n    /**\n    *   implement all the methods...\n    */\n    public static void main(String[] args){\n        SpringApplication.run(VNFManager.class);\n    }\n}\n\n\n\n\nThen just compile \n run. \n\n\n$ ./gradlew clean build\n$ java -jar build/libs/vnfm-manager.jar\n\n\n\n\nThere is the possibility to use the VnfmHelper. The vnfmHelper helps with some methods out of the box:\n\n\npackage org.openbaton.common.vnfm_sdk;\nimport org.openbaton.catalogue.nfvo.messages.Interfaces.NFVMessage;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\npublic abstract class VnfmHelper {\n    protected Logger log = LoggerFactory.getLogger(this.getClass());\n    public abstract void sendToNfvo(NFVMessage nfvMessage);\n    public abstract NFVMessage sendAndReceive(NFVMessage nfvMessage) throws Exception;\n}\n\n\n\n\nthat send messages to the NFVO and wait for the answer.\nThis class need to be implemented in case you want to use only the vnfm-sdk and must be provided to the AbstarctVnfm.\n\n\nIn any case a configuration file is needed to be in the classpath called conf.properties\n\n\ntype=generic\nallocate = true\nconcurrency = 15\ntransacted = false\n\n\n\n\nWhere the parameters means:\n\n\n\n\n\n\n\n\nParams\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\ntype\n\n\nThe type of VNF you are going to handle\n\n\n\n\n\n\nallocate\n\n\ntrue if the NFVO will ALLOCATE_RESOURCES, false if the VNFManager will do\n\n\n\n\n\n\nconcurrency\n\n\nThe number of concurrent Receiver (only for vnfm-sdk-jms)\n\n\n\n\n\n\ntransacted\n\n\nWhenever the JMS receiver method shoud be transacted, this allows the message to be resent in case of exception VNFManager side (only for vnfm-sdk-jms)\n\n\n\n\n\n\n\n\nPlease do not forget: if you use vnfm-sdk-jms or vnfm-sdk-rest \nthe VNFManager main class needs to be stateless\n since can (will) run each method potentially in parallel. For what concerns vnfm-sdk-jms, even setting concurrency to 1, will not assure to have always the same instance of the class.", 
            "title": "Write your own VNFM"
        }, 
        {
            "location": "/vnfm-how-to-write/#how-to-write-a-vnfmanager", 
            "text": "How to write a Vnfm for OpenBaton:  requirements:  JDK 7  vnfm-sdk lib  It is suggested to use the vnfm-sdk-jms (in case of a jms Vnfm or vnfm-sdk-rest in case of a ReST VNFManager) because it is a sdk providing already the utilities classes in charge of the communication to the NFVO and other tools. This implementation make use of  SpringBoot . If you don't want this dependency than use the simple vnfm-sdk artifact, but all the communication with the NFVO needs to be implemented.  For gathering the vnfm-sdk-jms library you need that to your build.gradle:  buildscript {\n    dependencies {\n        classpath( org.springframework.boot:spring-boot-gradle-plugin:1.2.6.RELEASE )\n    }\n}\napply plugin: 'spring-boot'\nbootRepackage {\n    mainClass = 'path.to.the.vnfm.class.VNFManager'\n}\napply plugin: 'java'\napply plugin: 'maven'\nrepositories {\n    mavenCentral()\n    maven {\n        url  http://193.175.132.176:8081/nexus/content/groups/public \n    }\n}\ndependencies {\n    compile 'org.openbaton:vnfm-sdk-jms:0.5-SNAPSHOT' \n}  In this way you will have access to all the model classes and the vnfm-sdk classes needed to implement a VNFManager. The main class of your Vnfm will be the only class needed to be implemented and this class needs to extend  AbstractVnfmSpringJMS . This class will provide all the methods that will be called in all the instantiation process (instantiate, modify etc.).  It needs to implement as well a main methods as follows:  import org.springframework.beans.factory.annotation.Autowired;\nimport org.openbaton.common.vnfm_sdk.jms.AbstractVnfmSpringJMS;\npublic class VNFManager extends AbstractVnfmSpringJMS{\n    @Autowired\n    private VnfmHelper vnfmHelper;\n    /**\n    *   implement all the methods...\n    */\n    public static void main(String[] args){\n        SpringApplication.run(VNFManager.class);\n    }\n}  Then just compile   run.   $ ./gradlew clean build\n$ java -jar build/libs/vnfm-manager.jar  There is the possibility to use the VnfmHelper. The vnfmHelper helps with some methods out of the box:  package org.openbaton.common.vnfm_sdk;\nimport org.openbaton.catalogue.nfvo.messages.Interfaces.NFVMessage;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\npublic abstract class VnfmHelper {\n    protected Logger log = LoggerFactory.getLogger(this.getClass());\n    public abstract void sendToNfvo(NFVMessage nfvMessage);\n    public abstract NFVMessage sendAndReceive(NFVMessage nfvMessage) throws Exception;\n}  that send messages to the NFVO and wait for the answer.\nThis class need to be implemented in case you want to use only the vnfm-sdk and must be provided to the AbstarctVnfm.  In any case a configuration file is needed to be in the classpath called conf.properties  type=generic\nallocate = true\nconcurrency = 15\ntransacted = false  Where the parameters means:     Params  Meaning      type  The type of VNF you are going to handle    allocate  true if the NFVO will ALLOCATE_RESOURCES, false if the VNFManager will do    concurrency  The number of concurrent Receiver (only for vnfm-sdk-jms)    transacted  Whenever the JMS receiver method shoud be transacted, this allows the message to be resent in case of exception VNFManager side (only for vnfm-sdk-jms)     Please do not forget: if you use vnfm-sdk-jms or vnfm-sdk-rest  the VNFManager main class needs to be stateless  since can (will) run each method potentially in parallel. For what concerns vnfm-sdk-jms, even setting concurrency to 1, will not assure to have always the same instance of the class.", 
            "title": "How to write a VNFManager"
        }, 
        {
            "location": "/FAQ/", 
            "text": "Frequently Asked Questions (FAQ)\n\n\nQ1 ActiveMQ:connection refused\n\n\nI'm getting this error message: \n\n\n2015-10-01 11:40:49.475 ERROR 26648 --- [enerContainer-1] o.s.j.l.DefaultMessageListenerContainer  : Could not refresh JMS Connection for destination 'event-register' - retrying using FixedBackOff{interval=5000, currentAttempts=1, maxAttempts=unlimited}. Cause: Could not connect to broker URL: tcp://localhost:61616. Reason: java.net.ConnectException: Connection refused\n\n\n\n\nAnswer: double check that ActiveMQ is up and running: \n\n\napache-activemq-5.11.1/bin/activemq status\n\n\n\n\nif not running, you need to start it. \n\n\nQ2 What type of database is the NFVO using?\n\n\nThe NFVO uses Hibernate for managing transactions with a relational database. By default the NFVO is configured with an in memory database (HSQL). \nOther types of databases are supported, for instance MySQL. This can be changed directly from the configuration file, outcommenting the : \n\n\n# mysql jdbc\nspring.datasource.url=jdbc:mysql://localhost:3306/openbaton\nspring.datasource.driver-class-name=com.mysql.jdbc.Driver\nspring.jpa.database-platform=org.hibernate.dialect.MySQLDialect", 
            "title": "FAQ"
        }, 
        {
            "location": "/FAQ/#frequently-asked-questions-faq", 
            "text": "Q1 ActiveMQ:connection refused  I'm getting this error message:   2015-10-01 11:40:49.475 ERROR 26648 --- [enerContainer-1] o.s.j.l.DefaultMessageListenerContainer  : Could not refresh JMS Connection for destination 'event-register' - retrying using FixedBackOff{interval=5000, currentAttempts=1, maxAttempts=unlimited}. Cause: Could not connect to broker URL: tcp://localhost:61616. Reason: java.net.ConnectException: Connection refused  Answer: double check that ActiveMQ is up and running:   apache-activemq-5.11.1/bin/activemq status  if not running, you need to start it.   Q2 What type of database is the NFVO using?  The NFVO uses Hibernate for managing transactions with a relational database. By default the NFVO is configured with an in memory database (HSQL). \nOther types of databases are supported, for instance MySQL. This can be changed directly from the configuration file, outcommenting the :   # mysql jdbc\nspring.datasource.url=jdbc:mysql://localhost:3306/openbaton\nspring.datasource.driver-class-name=com.mysql.jdbc.Driver\nspring.jpa.database-platform=org.hibernate.dialect.MySQLDialect", 
            "title": "Frequently Asked Questions (FAQ)"
        }
    ]
}