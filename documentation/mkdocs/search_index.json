{
    "docs": [
        {
            "location": "/", 
            "text": "OpenBaton\n\n\nOpenBaton is an open source project providing a comprehensive implementation of the ETSI Management and Orchestration (MANO) specification. \n\n\nWhat is NFV\n\n\nETSI NFV represents a concerted telco operator initiative fostering the development of virtual network infrastructures by porting and further adapting network functions to the specific cloud environment. \nETSI NFV has defined a large set of virtualisation use cases, spanning from the cloudification of the main core network functions such as IMS, Evolved Packet Core, and Radio Access Networks, as well as providing on demand and complete virtualised infrastructures as IaaS or PaaS to third parties, such as enterprises and professional radio. \nThat enables providing elastic deployments of cost efficient network infrastructures.\nOne of the main concerns of ETSI NFV is to prove the feasibility of the cloud deployments of the typical network functions through proof of concept trials and prototypes as well as providing indications for further standardization in the areas of underlying infrastructures, software architectures, networking and management, and orchestration to improve performance and grant security of the overall infrastructure.\nETSI NFV limits itself to this level of indications, considering that other standardization bodies and de-facto open source standards such as 3GPP and OpenStack should finalize the specific implementation work. \n\n\nIts main components\n\n\nOpenBaton rel.2 provides the many different features and components. \n\n\n\n\nA Network Function Virtualisation Orchestrator (NFVO) completely designed and implemented following the ETSI MANO specification. Read more \nhere\n\n\nA generic Virtual Network Function Manager (VNFM) able to manage the lifecycle of VNFs based on their descriptors. Read more \nhere\n\n\nA plugin mechanism for adding and removing different type of VIMs without having to re-write anything in your orchestration logic. Read more \nhere\n\n\nA powerful event engine useful based on a pub/sub mechanism for the dispatching of lifecycle events execution\n\n\nAn autoscaling engine which can be used for automatic runtime management of the scaling operation operations of your VNFs. Read more \nhere\n\n\nA fault management system which can be used for automatic runtime management of faults which may occur at any level. Read more \nhere\n\n\nIt integrates with the Zabbix monitoring system. Read more \nhere\n\n\nA set of libraries (the openbaton-libs) which could be used for building your own VNFM. Read more \nhere\n\n\n\n\n\n\nCan I plug in my Network Functions?\n\n\nYes, this is possible using two different approaches:\n\n\n\n\nintegrating your own VNFM. In this case you can use either the REST interface, or the AMQP one for interoperating with the NFVO\n\n\nimplementing a set of scripts which can be executed as part of the lifecycle event of your Virtual Network Function Descriptor. We provide a generic VNFM and EMS which can be used for executing them\n\n\n\n\nCan I use OpenBaton to build my own Network Service?\n\n\nYes! OpenBaton provides a NFVO which can interoperate with VNFMs implemented by third parties. In this project we provide also a set of tools (like the vnfm-sdk) which supports developers in building their own VNFM. \n\n\nGet started\n\n\nIn order to get started you can follow the \ninstallation guide\n\n\nGet in contact\n\n\n\n\nVia twitter: \ntwitter\n\n\nSubscribing to our mailing list: \nusers-at-openbaton-dot-org\n\n\nSending us an email to: \ninfo-at-openbaton-dot-org\n\n\n\n\nSupported by\n\n\nOpen Baton is a project developed by Fraunhofer FOKUS and TU Berlin. It is supported by different European publicly funded projects: \nNUBOMEDIA\n, \nMobile Cloud Networking\n, \nCogNet\n\n\n\n\n\n\n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Get Started"
        }, 
        {
            "location": "/#openbaton", 
            "text": "OpenBaton is an open source project providing a comprehensive implementation of the ETSI Management and Orchestration (MANO) specification.", 
            "title": "OpenBaton"
        }, 
        {
            "location": "/#what-is-nfv", 
            "text": "ETSI NFV represents a concerted telco operator initiative fostering the development of virtual network infrastructures by porting and further adapting network functions to the specific cloud environment. \nETSI NFV has defined a large set of virtualisation use cases, spanning from the cloudification of the main core network functions such as IMS, Evolved Packet Core, and Radio Access Networks, as well as providing on demand and complete virtualised infrastructures as IaaS or PaaS to third parties, such as enterprises and professional radio. \nThat enables providing elastic deployments of cost efficient network infrastructures.\nOne of the main concerns of ETSI NFV is to prove the feasibility of the cloud deployments of the typical network functions through proof of concept trials and prototypes as well as providing indications for further standardization in the areas of underlying infrastructures, software architectures, networking and management, and orchestration to improve performance and grant security of the overall infrastructure.\nETSI NFV limits itself to this level of indications, considering that other standardization bodies and de-facto open source standards such as 3GPP and OpenStack should finalize the specific implementation work.", 
            "title": "What is NFV"
        }, 
        {
            "location": "/#its-main-components", 
            "text": "OpenBaton rel.2 provides the many different features and components.    A Network Function Virtualisation Orchestrator (NFVO) completely designed and implemented following the ETSI MANO specification. Read more  here  A generic Virtual Network Function Manager (VNFM) able to manage the lifecycle of VNFs based on their descriptors. Read more  here  A plugin mechanism for adding and removing different type of VIMs without having to re-write anything in your orchestration logic. Read more  here  A powerful event engine useful based on a pub/sub mechanism for the dispatching of lifecycle events execution  An autoscaling engine which can be used for automatic runtime management of the scaling operation operations of your VNFs. Read more  here  A fault management system which can be used for automatic runtime management of faults which may occur at any level. Read more  here  It integrates with the Zabbix monitoring system. Read more  here  A set of libraries (the openbaton-libs) which could be used for building your own VNFM. Read more  here", 
            "title": "Its main components"
        }, 
        {
            "location": "/#can-i-plug-in-my-network-functions", 
            "text": "Yes, this is possible using two different approaches:   integrating your own VNFM. In this case you can use either the REST interface, or the AMQP one for interoperating with the NFVO  implementing a set of scripts which can be executed as part of the lifecycle event of your Virtual Network Function Descriptor. We provide a generic VNFM and EMS which can be used for executing them", 
            "title": "Can I plug in my Network Functions?"
        }, 
        {
            "location": "/#can-i-use-openbaton-to-build-my-own-network-service", 
            "text": "Yes! OpenBaton provides a NFVO which can interoperate with VNFMs implemented by third parties. In this project we provide also a set of tools (like the vnfm-sdk) which supports developers in building their own VNFM.", 
            "title": "Can I use OpenBaton to build my own Network Service?"
        }, 
        {
            "location": "/#get-started", 
            "text": "In order to get started you can follow the  installation guide", 
            "title": "Get started"
        }, 
        {
            "location": "/#get-in-contact", 
            "text": "Via twitter:  twitter  Subscribing to our mailing list:  users-at-openbaton-dot-org  Sending us an email to:  info-at-openbaton-dot-org", 
            "title": "Get in contact"
        }, 
        {
            "location": "/#supported-by", 
            "text": "Open Baton is a project developed by Fraunhofer FOKUS and TU Berlin. It is supported by different European publicly funded projects:  NUBOMEDIA ,  Mobile Cloud Networking ,  CogNet   \n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Supported by"
        }, 
        {
            "location": "/nfvo-installation-deb/", 
            "text": "Install Open Baton\n\n\nThis tutorial will guide towards the installation of a minimal Open Baton environment composed by the following components: \n\n\n\n\nThe NFVO implemented in java using the \nspring.io\n framework. For more details about the NFVO architecture, you can refer to the next sections\n\n\nRabbitMQ as messaging system \nRabbitMQ\n.\n\n\nTest plugin for being able to execute the \ndummy NSR\n tutorial without needing an OpenStack instance. \n\n\n\n\nAnd a set of optional components: \n\n\n\n\nGeneric VNFM\n\n\nOpenStack plugin: in case you want to use OpenStack as VIM\n\n\n\n\nInstall a stable binary version of Open Baton on a debian (Jessy) or ubuntu (14.04) based Operating System\n\n\nThis installation guide will provide you details on how to install the minimal set of Open Baton components using the boostrap scripts.\n\n\nNOTE:\n Please refer to \nthis tutorial\n if you are willing to install a development environment where you can easily modify, compile and commit changes to the code base directly.\n\n\nTo facilitate the installation procedures we provide a bootstrap script which will install the desired components and configure them for running a hello world VNF out of the box. To execute the bootstrap procedure you need to have curl installed (see http://curl.haxx.se/). This command should work on any linux system: \n\n\napt-get install curl\n\n\n\n\nTo start the bootstrap procedure of the Open Baton environment you can type the following command:\n\n\nsh \n(curl -s http://get.openbaton.org/bootstraps/bootstrap) release\n\n\n\n\njust in case you are interested in the latest nigthly versions of the binaries please run:\n\n\nsh \n(curl -s http://get.openbaton.org/bootstraps/bootstrap) nightly\n\n\n\n\nNOTE - By default RabbitMQ is installed on the host of the NFVO. Be aware of the fact that during the installation you will be prompted for entering the RabbitMQ IP and Port. Please make sure that this IP can be\n  reached by external components (VMs, or host where will run other VNFMs) otherwise you will have runtime issues. If you are installing Open Baton on a VM running in OpenStack, the best is that you put here\n  the floating IP. \n\n\nDuring the bootstrap procedure you will be prompted for inputs. For instance you can choose to install or not the Generic VNFM, or enable or not SSL. \nAt the end of the bootstrap procedure, if there are no errors, the dashboard shuold be reachable at: \nlocalhost:8080\n and you should have the following structure:\n\n\n/usr/lib/openbaton\n\u251c\u2500\u2500 openbaton-*.jar\n\u251c\u2500\u2500 gvnfm\n\u2514\u2500\u2500 plugins\n\n\n\n\nWhere:\n\n\n\n\nopenbaton-*jar\n is the jar file related to the version of Open Baton NFVO which has been installed\n\n\ngvnfm\n (present only if during the installation procedure you also installed the Generic VNFM) contains the jar file related to the Open Baton Generic VNFM\n\n\nplugins\n contains the plugins for Open Baton. So far, if you downloaded the VIM-Driver Plugins during the installation procedure, it will contain only the jar files related to the plugins downloaded\n\n\n\n\nAdditionally you should also have the following structure:\n\n\n/usr/bin\n\u251c\u2500\u2500 openbaton-nfvo\n\u2514\u2500\u2500 openbaton-gvnfm\n\n\n\n\nWhere:\n\n\n\n\nopenbaton-nfvo\n is the Open Baton NFVO executable\n\n\nopenbaton-gvnfm\n (present only if you also installed the Generic VNFM) is the Open Baton Generic GVNFM executable\n\n\n\n\nAt this point Open Baton is ready to be used. Please refer to the \nIntroduction\n on how to start using it.\n\n\nStarting and stopping NFVO (and the Generic VNFM)\n\n\nAfter the installation procedure the NFVO is running.\n\nIf you want to stop it, enter one of the following commands depending on your OS.\n* With Ubuntu 14.04:\n\n\nsudo service openbaton-nfvo stop\nsudo stop openbaton-nfvo\nsudo openbaton-nfvo stop\n\n\n\n\n\n\nWith Debian Jessie:\n\n\n\n\nsudo systemctl stop openbaton-nfvo.service\n\n\n\n\nTo start the NFVO, instead, enter one of the following commands depending on your OS.\n\n\n\n\nWith Ubuntu 14.04:\n\n\n\n\nsudo service openbaton-nfvo start\nsudo start openbaton-nfvo\nsudo openbaton-nfvo start\n\n\n\n\n\n\nWith Debian Jessie:\n\n\n\n\nsudo systemctl start openbaton-nfvo.service\n\n\n\n\nNote (in case you also installed the Generic VNFM):\n If you also installed the Generic VNFM it is also already running at the end of the installation procedure. You can stop it with one of the following commands depending on your OS.\n\n\n\n\nWith Ubuntu 14.04:\n\n\n\n\nsudo service openbaton-gvnfm stop\nsudo stop openbaton-gvnfm\nsudo openbaton-gvnfm stop\n\n\n\n\n\n\nWith Debian Jessie:\n\n\n\n\nsudo systemctl stop openbaton-gvnfm.service\n\n\n\n\nNote (in case you also installed the Generic VNFM):\n You can start the Generic VNFM with one of the following commands depending on your OS.\n\n\n\n\nWith Ubuntu 14.04:\n\n\n\n\nsudo service openbaton-gvnfm start\nsudo start openbaton-gvnfm\nsudo openbaton-gvnfm start\n\n\n\n\n\n\nWith Debian Jessie:\n\n\n\n\nsudo systemctl start openbaton-gvnfm.service\n\n\n\n\nNFVO properties overview\n\n\nAfter the bootstrap procedure, the NFVO the configuration file is located at: \n\n\n/etc/openbaton/openbaton.properties\n\n\n\n\nFeel free to modify that file for adding or removing specific functionalities. For instance, you can decide to change logging levels (TRACE, DEBUG, INFO, WARN, and ERROR) and mechanisms:\n\n\nlogging.level.org.springframework=INFO\nlogging.level.org.hibernate=INFO\nlogging.level.org.apache=INFO\nlogging.level.org.jclouds=WARN\n# logging.level.org.springframework.security=WARN\nlogging.level.org.springframework.web = WARN\n\n# Level for loggers on classes inside the root package \norg.project.openbaton\n (and its\n# sub-packages)\nlogging.level.org.openbaton=INFO\n\n# Direct log to a log file\nlogging.file=/var/log/openbaton.log\n\n\n\n\nOr parameters related with persistency (hibernate):\n\n\n# DB properties\nspring.datasource.username=admin\nspring.datasource.password=changeme\n# hsql jdbc\nspring.datasource.url=jdbc:hsqldb:file:/tmp/openbaton/openbaton.hsdb\nspring.datasource.driver-class-name=org.hsqldb.jdbc.JDBCDriver\nspring.jpa.database-platform=org.hibernate.dialect.HSQLDialect\n# mysql jdbc\n#spring.datasource.url=jdbc:mysql://localhost:3306/openbaton\n#spring.datasource.driver-class-name=com.mysql.jdbc.Driver\n#spring.jpa.database-platform=org.hibernate.dialect.MySQLDialect\n# hibernate properties\nspring.jpa.show-sql=false\nspring.jpa.hibernate.ddl-auto=create-drop\n\n\n\n\nIMPORTANT NOTES:\n\n\n(Keep in mind that whenever some of the parameters below referred are changed, you will need to restart the NFVO)\n\n\n1) By default RabbitMQ is installed on the host of the NFVO. Be aware of the fact that if you want your VNFM to be executed on a different host, you will need RabbitMQ to be reachable also from the outside.\n\nSo when you want to deploy a VNF (EMS) in a VM which runs on a different host in respect to the NFVO, you will need to configure the rabbitmq endpoint (\nnfvo.rabbit.brokerIp\n) with the real IP of the NFVO host (instead of localhost).\n\n\nThis can be done changing the following properties of the \n/etc/openbaton/openbaton.properties\n file:\n\n\nnfvo.rabbit.brokerIp = localhost \n\n\n\n\nto:\n\n\nnfvo.rabbit.brokerIp = the rabbitmq broker ip\n\n\n\n\n2) At the end of the installation the NFVO is working with a in-memory database. In order to start using persistency through mysql database, you need to make the properties changes shown below:\n\n\n# DB properties\nspring.datasource.username=admin\nspring.datasource.password=changeme\n# hsql jdbc\n# spring.datasource.url=jdbc:hsqldb:file:/tmp/openbaton/openbaton.hsdb\n# spring.datasource.driver-class-name=org.hsqldb.jdbc.JDBCDriver\n# spring.jpa.database-platform=org.hibernate.dialect.HSQLDialect\n\n# mysql jdbc\nspring.datasource.url=jdbc:mysql://localhost:3306/openbaton\nspring.datasource.driver-class-name=com.mysql.jdbc.Driver\nspring.jpa.database-platform=org.hibernate.dialect.MySQLDialect\n\n# hibernate properties\nspring.jpa.show-sql=false\n# spring.jpa.hibernate.ddl-auto=create-drop\nspring.jpa.hibernate.ddl-auto=update\n\n\n\n\nWhere:\n\n \nspring.datasource.username\n and \nspring.datasource.password\n need to be adapted to the mysql username and password.\n \nspring.jpa.hibernate.ddl-auto\n has to be set to \nupdate\n if you want the NFVO not to drop all the tables after being shut down and to make it reuse the same tables after restarting.\n\n\nFor more details please see the \nSpring Documentation\n regarding the configuration parameters.\n\n\nThese are other parameters about the configuration of Rabbit MQ:\n\n\n#########################################\n############## RabbitMQ #################\n#########################################\n\n# Comma-separated list of addresses to which the client should connect to.\n# spring.rabbitmq.addresses=${nfvo.rabbit.brokerIp}\n# Create an AmqpAdmin bean.\nspring.rabbitmq.dynamic=true\n# RabbitMQ host.\nspring.rabbitmq.host= ${nfvo.rabbit.brokerIp}\n# spring.rabbitmq.host= localhost\n# Acknowledge mode of container.\n# spring.rabbitmq.listener.acknowledge-mode=\n# Start the container automatically on startup.\n# spring.rabbitmq.listener.auto-startup=true\n# Minimum number of consumers.\nspring.rabbitmq.listener.concurrency= 5\n# Maximum number of consumers.\nspring.rabbitmq.listener.max-concurrency= 30\n# Number of messages to be handled in a single request. It should be greater than or equal to the transaction size (if used).\n# spring.rabbitmq.listener.prefetch=\n# Number of messages to be processed in a transaction. For best results it should be less than or equal to the prefetch count.\n# spring.rabbitmq.listener.transaction-size=\n# Login user to authenticate to the broker.\nspring.rabbitmq.username= admin\n# Login to authenticate against the broker.\nspring.rabbitmq.password= openbaton\n# RabbitMQ port.\nspring.rabbitmq.port=5672\n# Requested heartbeat timeout, in seconds; zero for none.\n# spring.rabbitmq.requested-heartbeat=\n# Enable SSL support.\n# spring.rabbitmq.ssl.enabled=false\n# Path to the key store that holds the SSL certificate.\n# spring.rabbitmq.ssl.key-store=\n# Password used to access the key store.\n# spring.rabbitmq.ssl.key-store-password=\n# Trust store that holds SSL certificates.\n# spring.rabbitmq.ssl.trust-store=\n# Password used to access the trust store.\n# spring.rabbitmq.ssl.trust-store-password=\n# Virtual host to use when connecting to the broker.\n# spring.rabbitmq.virtual-host=\n\n\n\n\n\nThese parameters represent the maximum file size of the VNF Package which can be uploaded to the NFVO and the total maximum request size\n\n\n# filesUpload\nmultipart.maxFileSize=2046MB\nmultipart.maxRequestSize=2046MB\n\n\n\n\nThe following properties are related to the plugin mechanism used for loading VIM and Monitoring instances. The \nvim-plugin-installation-dir\n is the directory where all the jar files are, which implement the VIM interface (see the \nvim plugin documentation\n). The NFVO will load them at runtime.  \n\n\n########## plugin install ###############\n# directory for the vim driver plugins\nplugin-installation-dir = /usr/local/lib/openbaton/plugins\n# this is path to which the plugins(for example openstack-plugin) will write the output log through NFVO\nnfvo.plugin.log.path = \n\n\n\n\nThis property allows the user to delete the Network Service Records no matter in which status are they. Pleas note that in any case it is possible to remove a Network Service Record in \nNULL\n state.\n\n\n# nfvo behaviour\nnfvo.delete.all-status= true\n\n\n\n\nMONITORING:\n Openbaton allows the monitoring of the VNFs via Zabbix. If you want to use this feature, install and configure Zabbix server following the guide at this page \nZabbix server configuration\n.\nOnce the Zabbix server is correctly configured and running, you need only to add following property. \nEvery time a new Network Service is instantiated, each VNFC (VM) is automatically registered to Zabbix server.\n\n\nnfvo.monitoring.ip = the Zabbix server ip\n\n\n\n\nThese are other parameters about the configuration of the nfvo behaviour:\n\n\n# True to enable security (username and password to access), default to false\nnfvo.security.enabled = true\n# Wait for the NSR to be deleted\nnfvo.delete.wait = false \n# The broker ip that needs to be reachable from all the components\nnfvo.rabbit.brokerIp = the broker ip here \n# Set the queues to be autodeleted after the shut down\nnfvo.rabbit.autodelete = true \n# Setting the number of plugin active consumers\nnfvo.plugin.active.consumers = 5 \n# Setting the number of minimum concurrency of the nfvo receivers\nnfvo.rabbit.minConcurrency = 5 \n# Setting the number of maximum concurrency of the nfvo receivers\nnfvo.rabbit.maxConcurrency = 15\n# Setting the management port number of rabbitmq\nnfvo.rabbit.management.port = 15672 \n\n# Setting the heartbeat between ems and the broker\nnfvo.ems.queue.heartbeat = 60\n# Set the ems queues to be autodeleted after the shut down\nnfvo.ems.queue.autodelete = true\n# Set the ems version to be installed\nnfvo.ems.version = 0.15\n\n# Allow infinite quotas during the GRANT_OPERATION\nnfvo.vim.drivers.allowInfiniteQuota = false\n# Execute the start event sequentially and in order based on the VNFDependencies. This implies the NSD not to have cycling dependencies\nnfvo.start.ordered = false\n# Avoid doing the GRANT_OPERATION\nnfvo.quota.check = true\n# if true, deleting the nsd will remove also its vnfd\nnfvo.vnfd.cascade.delete = false\n# if true, deleting the vnfd will remove also its vnfpackage\nvnfd.vnfp.cascade.delete = false\n# if true, after deleting a NSR, the nfvo will wait for \nnfvo.delete.vnfr.wait.timeout\n after that timeout the VMs and VNFR will be deleted anyway from the NFVO\nnfvo.delete.vnfr.wait = false\n# this timeout is useful only if \nnfvo.delete.vnfr.wait\n is set to true\nnfvo.delete.vnfr.wait.timeout = 60\n\n\n\n\nThose properties are needed in case you want to tune a bit the performances of the NFVO. When the VNFMs send a message to the NFVO, there is a pool of threads able to process these messages in parallel. These parameters allows you to change the pool configuration, for more details please check the \nspring documentation regarding thread pool executor\n \n\n\n# Thread pool executor configuration\n# for info see http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/scheduling/concurrent/ThreadPoolTaskExecutor.html\nnfvo.vmanager.executor.corepoolsize = 20\nnfvo.vmanager.executor.maxpoolsize = 30\nnfvo.vmanager.executor.queuecapacity = 500\nnfvo.vmanager.executor.keepalive = 30\n\n\n\n\nLet's move to the next step\n\n\nDependening on the approach used for deploying your VNF, you'll have either to install the generic-VNFM or install and register your own VNFM\n\n\n\n\n\n\n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Install Open Baton"
        }, 
        {
            "location": "/nfvo-installation-deb/#install-open-baton", 
            "text": "This tutorial will guide towards the installation of a minimal Open Baton environment composed by the following components:    The NFVO implemented in java using the  spring.io  framework. For more details about the NFVO architecture, you can refer to the next sections  RabbitMQ as messaging system  RabbitMQ .  Test plugin for being able to execute the  dummy NSR  tutorial without needing an OpenStack instance.    And a set of optional components:    Generic VNFM  OpenStack plugin: in case you want to use OpenStack as VIM   Install a stable binary version of Open Baton on a debian (Jessy) or ubuntu (14.04) based Operating System  This installation guide will provide you details on how to install the minimal set of Open Baton components using the boostrap scripts.  NOTE:  Please refer to  this tutorial  if you are willing to install a development environment where you can easily modify, compile and commit changes to the code base directly.  To facilitate the installation procedures we provide a bootstrap script which will install the desired components and configure them for running a hello world VNF out of the box. To execute the bootstrap procedure you need to have curl installed (see http://curl.haxx.se/). This command should work on any linux system:   apt-get install curl  To start the bootstrap procedure of the Open Baton environment you can type the following command:  sh  (curl -s http://get.openbaton.org/bootstraps/bootstrap) release  just in case you are interested in the latest nigthly versions of the binaries please run:  sh  (curl -s http://get.openbaton.org/bootstraps/bootstrap) nightly  NOTE - By default RabbitMQ is installed on the host of the NFVO. Be aware of the fact that during the installation you will be prompted for entering the RabbitMQ IP and Port. Please make sure that this IP can be\n  reached by external components (VMs, or host where will run other VNFMs) otherwise you will have runtime issues. If you are installing Open Baton on a VM running in OpenStack, the best is that you put here\n  the floating IP.   During the bootstrap procedure you will be prompted for inputs. For instance you can choose to install or not the Generic VNFM, or enable or not SSL. \nAt the end of the bootstrap procedure, if there are no errors, the dashboard shuold be reachable at:  localhost:8080  and you should have the following structure:  /usr/lib/openbaton\n\u251c\u2500\u2500 openbaton-*.jar\n\u251c\u2500\u2500 gvnfm\n\u2514\u2500\u2500 plugins  Where:   openbaton-*jar  is the jar file related to the version of Open Baton NFVO which has been installed  gvnfm  (present only if during the installation procedure you also installed the Generic VNFM) contains the jar file related to the Open Baton Generic VNFM  plugins  contains the plugins for Open Baton. So far, if you downloaded the VIM-Driver Plugins during the installation procedure, it will contain only the jar files related to the plugins downloaded   Additionally you should also have the following structure:  /usr/bin\n\u251c\u2500\u2500 openbaton-nfvo\n\u2514\u2500\u2500 openbaton-gvnfm  Where:   openbaton-nfvo  is the Open Baton NFVO executable  openbaton-gvnfm  (present only if you also installed the Generic VNFM) is the Open Baton Generic GVNFM executable   At this point Open Baton is ready to be used. Please refer to the  Introduction  on how to start using it.  Starting and stopping NFVO (and the Generic VNFM)  After the installation procedure the NFVO is running. \nIf you want to stop it, enter one of the following commands depending on your OS.\n* With Ubuntu 14.04:  sudo service openbaton-nfvo stop\nsudo stop openbaton-nfvo\nsudo openbaton-nfvo stop   With Debian Jessie:   sudo systemctl stop openbaton-nfvo.service  To start the NFVO, instead, enter one of the following commands depending on your OS.   With Ubuntu 14.04:   sudo service openbaton-nfvo start\nsudo start openbaton-nfvo\nsudo openbaton-nfvo start   With Debian Jessie:   sudo systemctl start openbaton-nfvo.service  Note (in case you also installed the Generic VNFM):  If you also installed the Generic VNFM it is also already running at the end of the installation procedure. You can stop it with one of the following commands depending on your OS.   With Ubuntu 14.04:   sudo service openbaton-gvnfm stop\nsudo stop openbaton-gvnfm\nsudo openbaton-gvnfm stop   With Debian Jessie:   sudo systemctl stop openbaton-gvnfm.service  Note (in case you also installed the Generic VNFM):  You can start the Generic VNFM with one of the following commands depending on your OS.   With Ubuntu 14.04:   sudo service openbaton-gvnfm start\nsudo start openbaton-gvnfm\nsudo openbaton-gvnfm start   With Debian Jessie:   sudo systemctl start openbaton-gvnfm.service  NFVO properties overview  After the bootstrap procedure, the NFVO the configuration file is located at:   /etc/openbaton/openbaton.properties  Feel free to modify that file for adding or removing specific functionalities. For instance, you can decide to change logging levels (TRACE, DEBUG, INFO, WARN, and ERROR) and mechanisms:  logging.level.org.springframework=INFO\nlogging.level.org.hibernate=INFO\nlogging.level.org.apache=INFO\nlogging.level.org.jclouds=WARN\n# logging.level.org.springframework.security=WARN\nlogging.level.org.springframework.web = WARN\n\n# Level for loggers on classes inside the root package  org.project.openbaton  (and its\n# sub-packages)\nlogging.level.org.openbaton=INFO\n\n# Direct log to a log file\nlogging.file=/var/log/openbaton.log  Or parameters related with persistency (hibernate):  # DB properties\nspring.datasource.username=admin\nspring.datasource.password=changeme\n# hsql jdbc\nspring.datasource.url=jdbc:hsqldb:file:/tmp/openbaton/openbaton.hsdb\nspring.datasource.driver-class-name=org.hsqldb.jdbc.JDBCDriver\nspring.jpa.database-platform=org.hibernate.dialect.HSQLDialect\n# mysql jdbc\n#spring.datasource.url=jdbc:mysql://localhost:3306/openbaton\n#spring.datasource.driver-class-name=com.mysql.jdbc.Driver\n#spring.jpa.database-platform=org.hibernate.dialect.MySQLDialect\n# hibernate properties\nspring.jpa.show-sql=false\nspring.jpa.hibernate.ddl-auto=create-drop  IMPORTANT NOTES:  (Keep in mind that whenever some of the parameters below referred are changed, you will need to restart the NFVO)  1) By default RabbitMQ is installed on the host of the NFVO. Be aware of the fact that if you want your VNFM to be executed on a different host, you will need RabbitMQ to be reachable also from the outside. \nSo when you want to deploy a VNF (EMS) in a VM which runs on a different host in respect to the NFVO, you will need to configure the rabbitmq endpoint ( nfvo.rabbit.brokerIp ) with the real IP of the NFVO host (instead of localhost).  This can be done changing the following properties of the  /etc/openbaton/openbaton.properties  file:  nfvo.rabbit.brokerIp = localhost   to:  nfvo.rabbit.brokerIp = the rabbitmq broker ip  2) At the end of the installation the NFVO is working with a in-memory database. In order to start using persistency through mysql database, you need to make the properties changes shown below:  # DB properties\nspring.datasource.username=admin\nspring.datasource.password=changeme\n# hsql jdbc\n# spring.datasource.url=jdbc:hsqldb:file:/tmp/openbaton/openbaton.hsdb\n# spring.datasource.driver-class-name=org.hsqldb.jdbc.JDBCDriver\n# spring.jpa.database-platform=org.hibernate.dialect.HSQLDialect\n\n# mysql jdbc\nspring.datasource.url=jdbc:mysql://localhost:3306/openbaton\nspring.datasource.driver-class-name=com.mysql.jdbc.Driver\nspring.jpa.database-platform=org.hibernate.dialect.MySQLDialect\n\n# hibernate properties\nspring.jpa.show-sql=false\n# spring.jpa.hibernate.ddl-auto=create-drop\nspring.jpa.hibernate.ddl-auto=update  Where:   spring.datasource.username  and  spring.datasource.password  need to be adapted to the mysql username and password.   spring.jpa.hibernate.ddl-auto  has to be set to  update  if you want the NFVO not to drop all the tables after being shut down and to make it reuse the same tables after restarting.  For more details please see the  Spring Documentation  regarding the configuration parameters.  These are other parameters about the configuration of Rabbit MQ:  #########################################\n############## RabbitMQ #################\n#########################################\n\n# Comma-separated list of addresses to which the client should connect to.\n# spring.rabbitmq.addresses=${nfvo.rabbit.brokerIp}\n# Create an AmqpAdmin bean.\nspring.rabbitmq.dynamic=true\n# RabbitMQ host.\nspring.rabbitmq.host= ${nfvo.rabbit.brokerIp}\n# spring.rabbitmq.host= localhost\n# Acknowledge mode of container.\n# spring.rabbitmq.listener.acknowledge-mode=\n# Start the container automatically on startup.\n# spring.rabbitmq.listener.auto-startup=true\n# Minimum number of consumers.\nspring.rabbitmq.listener.concurrency= 5\n# Maximum number of consumers.\nspring.rabbitmq.listener.max-concurrency= 30\n# Number of messages to be handled in a single request. It should be greater than or equal to the transaction size (if used).\n# spring.rabbitmq.listener.prefetch=\n# Number of messages to be processed in a transaction. For best results it should be less than or equal to the prefetch count.\n# spring.rabbitmq.listener.transaction-size=\n# Login user to authenticate to the broker.\nspring.rabbitmq.username= admin\n# Login to authenticate against the broker.\nspring.rabbitmq.password= openbaton\n# RabbitMQ port.\nspring.rabbitmq.port=5672\n# Requested heartbeat timeout, in seconds; zero for none.\n# spring.rabbitmq.requested-heartbeat=\n# Enable SSL support.\n# spring.rabbitmq.ssl.enabled=false\n# Path to the key store that holds the SSL certificate.\n# spring.rabbitmq.ssl.key-store=\n# Password used to access the key store.\n# spring.rabbitmq.ssl.key-store-password=\n# Trust store that holds SSL certificates.\n# spring.rabbitmq.ssl.trust-store=\n# Password used to access the trust store.\n# spring.rabbitmq.ssl.trust-store-password=\n# Virtual host to use when connecting to the broker.\n# spring.rabbitmq.virtual-host=  These parameters represent the maximum file size of the VNF Package which can be uploaded to the NFVO and the total maximum request size  # filesUpload\nmultipart.maxFileSize=2046MB\nmultipart.maxRequestSize=2046MB  The following properties are related to the plugin mechanism used for loading VIM and Monitoring instances. The  vim-plugin-installation-dir  is the directory where all the jar files are, which implement the VIM interface (see the  vim plugin documentation ). The NFVO will load them at runtime.    ########## plugin install ###############\n# directory for the vim driver plugins\nplugin-installation-dir = /usr/local/lib/openbaton/plugins\n# this is path to which the plugins(for example openstack-plugin) will write the output log through NFVO\nnfvo.plugin.log.path =   This property allows the user to delete the Network Service Records no matter in which status are they. Pleas note that in any case it is possible to remove a Network Service Record in  NULL  state.  # nfvo behaviour\nnfvo.delete.all-status= true  MONITORING:  Openbaton allows the monitoring of the VNFs via Zabbix. If you want to use this feature, install and configure Zabbix server following the guide at this page  Zabbix server configuration .\nOnce the Zabbix server is correctly configured and running, you need only to add following property. \nEvery time a new Network Service is instantiated, each VNFC (VM) is automatically registered to Zabbix server.  nfvo.monitoring.ip = the Zabbix server ip  These are other parameters about the configuration of the nfvo behaviour:  # True to enable security (username and password to access), default to false\nnfvo.security.enabled = true\n# Wait for the NSR to be deleted\nnfvo.delete.wait = false \n# The broker ip that needs to be reachable from all the components\nnfvo.rabbit.brokerIp = the broker ip here \n# Set the queues to be autodeleted after the shut down\nnfvo.rabbit.autodelete = true \n# Setting the number of plugin active consumers\nnfvo.plugin.active.consumers = 5 \n# Setting the number of minimum concurrency of the nfvo receivers\nnfvo.rabbit.minConcurrency = 5 \n# Setting the number of maximum concurrency of the nfvo receivers\nnfvo.rabbit.maxConcurrency = 15\n# Setting the management port number of rabbitmq\nnfvo.rabbit.management.port = 15672 \n\n# Setting the heartbeat between ems and the broker\nnfvo.ems.queue.heartbeat = 60\n# Set the ems queues to be autodeleted after the shut down\nnfvo.ems.queue.autodelete = true\n# Set the ems version to be installed\nnfvo.ems.version = 0.15\n\n# Allow infinite quotas during the GRANT_OPERATION\nnfvo.vim.drivers.allowInfiniteQuota = false\n# Execute the start event sequentially and in order based on the VNFDependencies. This implies the NSD not to have cycling dependencies\nnfvo.start.ordered = false\n# Avoid doing the GRANT_OPERATION\nnfvo.quota.check = true\n# if true, deleting the nsd will remove also its vnfd\nnfvo.vnfd.cascade.delete = false\n# if true, deleting the vnfd will remove also its vnfpackage\nvnfd.vnfp.cascade.delete = false\n# if true, after deleting a NSR, the nfvo will wait for  nfvo.delete.vnfr.wait.timeout  after that timeout the VMs and VNFR will be deleted anyway from the NFVO\nnfvo.delete.vnfr.wait = false\n# this timeout is useful only if  nfvo.delete.vnfr.wait  is set to true\nnfvo.delete.vnfr.wait.timeout = 60  Those properties are needed in case you want to tune a bit the performances of the NFVO. When the VNFMs send a message to the NFVO, there is a pool of threads able to process these messages in parallel. These parameters allows you to change the pool configuration, for more details please check the  spring documentation regarding thread pool executor    # Thread pool executor configuration\n# for info see http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/scheduling/concurrent/ThreadPoolTaskExecutor.html\nnfvo.vmanager.executor.corepoolsize = 20\nnfvo.vmanager.executor.maxpoolsize = 30\nnfvo.vmanager.executor.queuecapacity = 500\nnfvo.vmanager.executor.keepalive = 30  Let's move to the next step  Dependening on the approach used for deploying your VNF, you'll have either to install the generic-VNFM or install and register your own VNFM   \n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Install Open Baton"
        }, 
        {
            "location": "/use/", 
            "text": "How to use OpenBaton\n\n\nIn order to use OpenBaton for launching your first Network Service, you will need to follow these steps:\n\n\n\n\nRegister one or more Point of Presences (PoPs). \nLearn more here\n\n\nBuild your VNF Package\n\n\nDecide which VNFM to use.\n\n\nCreate the VNF Package(s).\n\n\nPrepare the Network Service Descriptor (NSD).\n\n\n\n\n\n\n\n\nOnce these steps are completed you will be able to orchestrate your Network Service from the dashboard or via the \nREST APIs\n. \n\n\nVirtual Network Function Manager Approaches\n\n\nIn order to manage the Virtual Network Function(s), the NFV-MANO architectural framework expects a Virtual Network Function Manager (VNFM).\nTo facilitate ease of use and extensibility, the Openbaton project provides three different approaches to using a VNFM:\n\n\n\n\nUse the Generic VNFM\n\n\nBuild a VNFM using the SDK\n\n\nUse your own VNFM\n\n\n\n\nMain purposes of the approaches\n\n\n1. Use the Generic VNFM\n\n\nUsing the generic VNFM you don't need to create a VNFM to use Openbaton.\nIt is called \"Generic\" because it may be assigned the management of a single VNF instance, or the management of VNF multiple instances of the same type or of different types.\nIt is already included in Openbaton as default.\n\n\nPlease refer to the following doc for more details: \nUse the generic VNFM\n\n\n2. Build a VNFM using the SDK\n\n\nOpenbaton provides a Java SDK called vnfm-sdk which helps you to simply create a VNFM for your VNF.\nRegarding the type of the communication between the NFVO and the VNFM (Or-Vnfm), you can use the vnfm-sdk-amqp or vnfm-sdk-rest, depending if you prefer to communicate with AMQP or REST.\n\n\nPlease refer to the following doc for more details: \nBuild your own VNFM\n\n\n3. Use your own VNFM\n\n\nThis approach allows you to integrate your VNFM and VNF within Openbaton. In this case, the Or-Vnfm communication will be via REST interfaces.\n\n\nThe three pages following describe in details these three different approaches.\n\n\nPlease refer to the following doc for more details: \nBring your own VNFM\n\n\n\n\n\n\n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Introduction"
        }, 
        {
            "location": "/use/#how-to-use-openbaton", 
            "text": "In order to use OpenBaton for launching your first Network Service, you will need to follow these steps:   Register one or more Point of Presences (PoPs).  Learn more here  Build your VNF Package  Decide which VNFM to use.  Create the VNF Package(s).  Prepare the Network Service Descriptor (NSD).     Once these steps are completed you will be able to orchestrate your Network Service from the dashboard or via the  REST APIs .", 
            "title": "How to use OpenBaton"
        }, 
        {
            "location": "/use/#virtual-network-function-manager-approaches", 
            "text": "In order to manage the Virtual Network Function(s), the NFV-MANO architectural framework expects a Virtual Network Function Manager (VNFM).\nTo facilitate ease of use and extensibility, the Openbaton project provides three different approaches to using a VNFM:   Use the Generic VNFM  Build a VNFM using the SDK  Use your own VNFM", 
            "title": "Virtual Network Function Manager Approaches"
        }, 
        {
            "location": "/use/#main-purposes-of-the-approaches", 
            "text": "1. Use the Generic VNFM  Using the generic VNFM you don't need to create a VNFM to use Openbaton.\nIt is called \"Generic\" because it may be assigned the management of a single VNF instance, or the management of VNF multiple instances of the same type or of different types.\nIt is already included in Openbaton as default.  Please refer to the following doc for more details:  Use the generic VNFM  2. Build a VNFM using the SDK  Openbaton provides a Java SDK called vnfm-sdk which helps you to simply create a VNFM for your VNF.\nRegarding the type of the communication between the NFVO and the VNFM (Or-Vnfm), you can use the vnfm-sdk-amqp or vnfm-sdk-rest, depending if you prefer to communicate with AMQP or REST.  Please refer to the following doc for more details:  Build your own VNFM  3. Use your own VNFM  This approach allows you to integrate your VNFM and VNF within Openbaton. In this case, the Or-Vnfm communication will be via REST interfaces.  The three pages following describe in details these three different approaches.  Please refer to the following doc for more details:  Bring your own VNFM   \n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Main purposes of the approaches"
        }, 
        {
            "location": "/security/", 
            "text": "First access to the Open Baton platform\n\n\nWhen accessing the dashboard, you will be prompted for a username and password. The first access can only be done with the super user created during the installation. Then it is possible to create other users and projects. For the configuration of the first access please follow this guide.\n\n\nRoles and projects\n\n\nOpenbaton's security model consists of different user roles and projects.\n\n\nThis security feature is always enabled, so the propery\n\n\nnfvo.security.enabled = true\n\n\n\n\nin the \n/etc/openbaton/openbaton.properties\n file is \ndeprecated\n. \n\n\nA project is a separate realm in which permitted users can work. Users can be assigned to projects and adopt different roles. Changes made in a project's environment are not visible from another project. When the NFVO starts a default project is created. Every project has a \nunique\n name and a project-id.  \n\n\nA user can have the role \nADMIN\n or \nGUEST\n in a project. There is only one super user with role \nOB_ADMIN\n and he has control over the whole system. He may add and delete users and projects, assign roles and has access to all the projects. When starting the NFVO there will be already the super user (with the role of an \nOB_ADMIN\n) defined by default with the user name \nadmin\n and the default password \nopenbaton\n.\n\n\nThe default password can be changed by setting \n\n\nnfvo.security.admin.password = \n\n\n\n\nin \nopenbaton.properties\n.  \n\n\nThe next available role is \nADMIN\n. If a user is the \nADMIN\n of a project he can create, delete and update PoPs, NSD, VNFD, VNFPackages, NSR and VNFR in his projects. He cannot access or see other projects or users.\n\n\nThe last role is the \nGUEST\n. He can just see the components (PoPs, NSD, NSR etc.) of the project he is assigned to but he cannot create update or delete them. Furthermore he does not see other projects and users.\n\n\nSSL\n\n\nThe NFVO can use SSL to encrypt communication. To enable this feature set \n\n\nserver.ssl.enabled = true\nserver.port: 8443\nserver.ssl.key-store = /etc/openbaton/keystore.p12\nserver.ssl.key-store-password = password\nserver.ssl.keyStoreType = PKCS12\nserver.ssl.keyAlias = tomcat\n\n\n\n\nin the \nopenbaton.properties\n file.\n\nStart the NFVO and it will use SSL from now on and run on port 8443 instead of 8080, but port 8080 is redirected to 8443. To access the dashboard the use of https is required.\n\n\n\n\n\n\n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "First access"
        }, 
        {
            "location": "/security/#first-access-to-the-open-baton-platform", 
            "text": "When accessing the dashboard, you will be prompted for a username and password. The first access can only be done with the super user created during the installation. Then it is possible to create other users and projects. For the configuration of the first access please follow this guide.", 
            "title": "First access to the Open Baton platform"
        }, 
        {
            "location": "/security/#roles-and-projects", 
            "text": "Openbaton's security model consists of different user roles and projects.  This security feature is always enabled, so the propery  nfvo.security.enabled = true  in the  /etc/openbaton/openbaton.properties  file is  deprecated .   A project is a separate realm in which permitted users can work. Users can be assigned to projects and adopt different roles. Changes made in a project's environment are not visible from another project. When the NFVO starts a default project is created. Every project has a  unique  name and a project-id.    A user can have the role  ADMIN  or  GUEST  in a project. There is only one super user with role  OB_ADMIN  and he has control over the whole system. He may add and delete users and projects, assign roles and has access to all the projects. When starting the NFVO there will be already the super user (with the role of an  OB_ADMIN ) defined by default with the user name  admin  and the default password  openbaton .  The default password can be changed by setting   nfvo.security.admin.password =   in  openbaton.properties .    The next available role is  ADMIN . If a user is the  ADMIN  of a project he can create, delete and update PoPs, NSD, VNFD, VNFPackages, NSR and VNFR in his projects. He cannot access or see other projects or users.  The last role is the  GUEST . He can just see the components (PoPs, NSD, NSR etc.) of the project he is assigned to but he cannot create update or delete them. Furthermore he does not see other projects and users.", 
            "title": "Roles and projects"
        }, 
        {
            "location": "/security/#ssl", 
            "text": "The NFVO can use SSL to encrypt communication. To enable this feature set   server.ssl.enabled = true\nserver.port: 8443\nserver.ssl.key-store = /etc/openbaton/keystore.p12\nserver.ssl.key-store-password = password\nserver.ssl.keyStoreType = PKCS12\nserver.ssl.keyAlias = tomcat  in the  openbaton.properties  file. \nStart the NFVO and it will use SSL from now on and run on port 8443 instead of 8080, but port 8080 is redirected to 8443. To access the dashboard the use of https is required.   \n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "SSL"
        }, 
        {
            "location": "/vim-instance/", 
            "text": "Register a new Point of Presence (PoP)\n\n\nThe \nVirtualised Infrastructure Manager\n (Vim) is the functional block, responsible for controlling and managing the\n NFVI compute, storage and network resources within a Point of Presence (PoP).\n\n\nIn order to interoperate with a PoP it is required to register the VIM instance responsible for it on the NFVO. For doing that you can write a JSon file containing the details of a Vim Instance like the one described below: \n\n\n{  \n   \nname\n:\nvim-instance-name\n,\n   \nauthUrl\n:\nhttp://192.168.0.5:5000/v2.0\n,\n   \ntenant\n:\ntenantName\n,\n   \nusername\n:\nuserName\n,\n   \npassword\n:\npassword\n,\n   \nkeyPair\n:\nkeyName\n,\n   \nsecurityGroups\n:[  \n      \nsecurityName\n\n   ],\n   \ntype\n:\nopenstack\n,\n   \nlocation\n:{  \n      \nname\n:\nBerlin\n,\n      \nlatitude\n:\n52.525876\n,\n      \nlongitude\n:\n13.314400\n\n   }\n}\n\n\n\n\n\n\n\n\n\n\n\nParams\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\nname\n\n\nThe name of the VimInstance\n\n\n\n\n\n\nauthUrl\n\n\nThe endpoint to request the authentication\n\n\n\n\n\n\ntenant\n\n\nThe tenant is a string to refer to a group of users\n\n\n\n\n\n\nusername\n\n\nThe name of the user recognized in OpenStack in the keystone service\n\n\n\n\n\n\npassword\n\n\nThe password of the user recognized in the OpenStack in the keystone service\n\n\n\n\n\n\nkeyPair\n\n\nThe keyPair name stored into OpenStack to get the access to the VMs\n\n\n\n\n\n\nsecurityGroups\n\n\nRecognise a Security group into OpenStack where gives a sets of IP filter rules that are applied to an instance's networking.\n\n\n\n\n\n\ntype\n\n\nThe type of the Vim Instance that will start the corresponding plugin. Possible values are: \nopenstack\n or \ntest\n\n\n\n\n\n\nlocation\n\n\nThe location of the data Center. Name: String of the place where is the Data Center located. Latitude/Longitude geolocation point\n\n\n\n\n\n\n\n\nBy default we use only one tenant on your PoP. We are currently working on supporting the instantiation of different NSDs in different tenants. \n\n\nRegister the PoP using the GUI\n\n\nIn order to make use of your VIM described within your JSON descriptor, you need to request the NFVO to register it. \nYou can use the dashboard available at \nlocalhost:8080\n for this purpose. \nUnder the menu \nManage PoPs\n you can see the \nPoP instances\n. Click on the Register VIM button and upload your VIM descriptor. Following picture shows the dashboard: \n\n\n\n\nOnce the VIM instance is registered, it will appear on the list of available PoPs. At this point the VIM/PoP can be included in your Network Service Descriptors. \n\nPlease note that the name chosen must be unique and will be used to refer the VimInstance\n.\n\n\nFor more information about the dashboard see: \nOpenBaton Dashboard\n\n\nWhat are the supported VIM types?\n\n\nBy default the NFVO supports two different VIM types: \n\n\n\n\nopenstack: for interoperating with an OpenStack instance\n\n\ntest: for testing purposes implementing a VIM mockup\n\n\n\n\nFor each of those types there is a different implementation of the VIM API. The NFVO uses a plugin mechanism for interacting with VIMs. In the folders \nplugins\n under nfvo folder should be a jar file that implements the interface to the your VIM ( i.e. \nOpenstack\n )\n(you can change the folder where OpenBaton searches for the plugins by changing the variable \nplugin-installation-dir\n in the \nopenbaton.properties\n file under /etc/openbaton)\nThis jar is the implementation of the interface that communicates with your VIM.\n\n\nNote\n: You can implement your own interface just follow the documentation \nVim plugin\n.\n\n\nWhere do I find the open source plugins?\n\n\nOpenBaton platform provides an openstack and a test plugin. They are automatically download by the bootstrap. Anyway you can find them \nhere\n\n\n\n\n\n\n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Register a PoP"
        }, 
        {
            "location": "/vim-instance/#register-a-new-point-of-presence-pop", 
            "text": "The  Virtualised Infrastructure Manager  (Vim) is the functional block, responsible for controlling and managing the\n NFVI compute, storage and network resources within a Point of Presence (PoP).  In order to interoperate with a PoP it is required to register the VIM instance responsible for it on the NFVO. For doing that you can write a JSon file containing the details of a Vim Instance like the one described below:   {  \n    name : vim-instance-name ,\n    authUrl : http://192.168.0.5:5000/v2.0 ,\n    tenant : tenantName ,\n    username : userName ,\n    password : password ,\n    keyPair : keyName ,\n    securityGroups :[  \n       securityName \n   ],\n    type : openstack ,\n    location :{  \n       name : Berlin ,\n       latitude : 52.525876 ,\n       longitude : 13.314400 \n   }\n}     Params  Meaning      name  The name of the VimInstance    authUrl  The endpoint to request the authentication    tenant  The tenant is a string to refer to a group of users    username  The name of the user recognized in OpenStack in the keystone service    password  The password of the user recognized in the OpenStack in the keystone service    keyPair  The keyPair name stored into OpenStack to get the access to the VMs    securityGroups  Recognise a Security group into OpenStack where gives a sets of IP filter rules that are applied to an instance's networking.    type  The type of the Vim Instance that will start the corresponding plugin. Possible values are:  openstack  or  test    location  The location of the data Center. Name: String of the place where is the Data Center located. Latitude/Longitude geolocation point     By default we use only one tenant on your PoP. We are currently working on supporting the instantiation of different NSDs in different tenants.", 
            "title": "Register a new Point of Presence (PoP)"
        }, 
        {
            "location": "/vim-instance/#register-the-pop-using-the-gui", 
            "text": "In order to make use of your VIM described within your JSON descriptor, you need to request the NFVO to register it. \nYou can use the dashboard available at  localhost:8080  for this purpose. \nUnder the menu  Manage PoPs  you can see the  PoP instances . Click on the Register VIM button and upload your VIM descriptor. Following picture shows the dashboard:    Once the VIM instance is registered, it will appear on the list of available PoPs. At this point the VIM/PoP can be included in your Network Service Descriptors.  Please note that the name chosen must be unique and will be used to refer the VimInstance .  For more information about the dashboard see:  OpenBaton Dashboard", 
            "title": "Register the PoP using the GUI"
        }, 
        {
            "location": "/vim-instance/#what-are-the-supported-vim-types", 
            "text": "By default the NFVO supports two different VIM types:    openstack: for interoperating with an OpenStack instance  test: for testing purposes implementing a VIM mockup   For each of those types there is a different implementation of the VIM API. The NFVO uses a plugin mechanism for interacting with VIMs. In the folders  plugins  under nfvo folder should be a jar file that implements the interface to the your VIM ( i.e.  Openstack  )\n(you can change the folder where OpenBaton searches for the plugins by changing the variable  plugin-installation-dir  in the  openbaton.properties  file under /etc/openbaton)\nThis jar is the implementation of the interface that communicates with your VIM.  Note : You can implement your own interface just follow the documentation  Vim plugin .", 
            "title": "What are the supported VIM types?"
        }, 
        {
            "location": "/vim-instance/#where-do-i-find-the-open-source-plugins", 
            "text": "OpenBaton platform provides an openstack and a test plugin. They are automatically download by the bootstrap. Anyway you can find them  here   \n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Where do I find the open source plugins?"
        }, 
        {
            "location": "/vnfpackage/", 
            "text": "VNF Package\n\n\nNote\n: This is the initial version of the VNF Package and might change most probably in the next releases to improve and simplify the creation, usability and power.\n\n\nThis doc describes essential components of a VNF Package, how to create them and how to use them after onboarding.\nTherefore, you can find a practical tutorial at the end with all the steps starting from the creation over onboarding and finally referencing it by an NSD.\n\n\nA VNF Package is a tar-archive that contains all the information required for creating a VNF for the Open Baton's NFVO.\nAfter onboarding the VNF Package to the NFVO you can use the VNF directly in the NSD by referencing the VNFD by its ID.\nA VNF Package includes the VNFD, the image, scripts and a Metadata file structured as shown in the next part.\n\n\nPackage structure\n\n\nThe VNF Package has the following structure:\n\n\n- Metadata.yaml\n- vnfd.json\n- scripts/\n    - 1_script.sh\n    - 2_script.sh\n- image.img (not supported at the moment, use image-link!)\n\n\n\n\nMetadata.yaml\n\n\nThe Metadata.yaml defines essential properties for the VNF. This file is based on the YAML syntax where information are stored in simple \nkey> : \nvalue> associations.\n\n\nThe example of the Metadata file below shows a basic definition of a VNF Package.\n\n\nname: VNF Package_name\nscripts-link: scripts_link\nimage:\n    upload: option\n    ids: list_of_ids\n    names: list_of_names\n    link: image_link\nimage-config:\n    name: image_name\n    diskFormat: disk_format\n    containerFormat: container_format\n    minCPU: min_cpu\n    minDisk: min_disk\n    minRam: min_ram\n    isPublic: is_public\n\n\n\n\nIn the following each property is explained in more detail. Please consider also the notes since some properties are optional (or even not implemented) and if they are defined, they may have more priority than other and override them therefore.\n\n\n\n\nname\n: The name defines the name of the VNF Package itself used to store it in the database.\n\n\nscripts-link\n: This link points to a public git repository where scripts are stored that are needed to be executed for managing the lifecycle of the exposed VNF.\n\n\nNote\n Either you can define the scripts-link or put the scripts into the folder scripts/.\n    The scripts-link has a higher priority than the scripts located in the folder scripts/.\n    So if you set the scripts-link, the scripts in folder scripts/ are ignored completely.\n\n\nNote\n The scripts-link is processed by the Element Management System (EMS) in the meaning of fetching the files from that link.\n    So you need to take care about ensuring that the URL defined is available.\n\n\nNote\n Scripts are executed during different lifecycle-events.\n\n\n\n\n\n\nimage\n:\n\n\nupload\n: Here you can choose between different options (true, false, check).\n\n\ntrue: choosing this option means to upload the defined image on all the VimInstances. It does not matter if an image with the defined name exists or not.\n\n\nfalse: choosing this option means that you assume that the image (defined in the ids or names) is already present.\nIf the image does not exist, the VNF Package onboarding will throw an exception.\nIn this case the image (if defined) will be ignored.\n\n\ncheck: this option means that the VNF PackageManagement checks first if the image is available (defined in ids or names).\nIf the image does not exist, a new one with the image defined in the VNF Package will be created.\n\n\nNote\n Please use quotation marks for this option since the values are handled as strings internally.\nOtherwise true and false will be handled as a boolean that would lead to a faulty behavior when onboarding a new VNF Package.\n\n\n\n\n\n\nids\n: The list of image IDs is used to fetch the image from the corresponding VimInstance.\n    To do it, the manager iterates over all IDs and checks if an image with that ID exists on the VimInstance.\n    The defined IDs have a higher priority than the list of names.\n    We distinguish between the following cases:\n\n\nIf it finds no image with these IDs, it continues with the list of image names.\n\n\nIf it finds one image with these IDs, this image will be used.\n\n\nIf it finds multiple images with the same ID (should never happen) or multiple IDs matching to multiple images, an exception will be thrown because it is not clear which image to use.\n\n\n\n\n\n\nnames\n: The list of image names is used to fetch the image from the corresponding VimInstance.\n    To do it, manager iterates over all names and checks if an image with that name exists on the VimInstance.\n    The list of names have a lower priority than the list of IDs.\n    We distinguish between the following cases:\n\n\nIf it finds no image with that name, an exception will be thrown except you defined the upload option check.\nThen it will create a new image defined in the VNF Package.\n\n\nIf it finds one image, this image will be used.\n\n\nIf it finds multiple images with the same name or multiple names matching to multiple images, an exception will be thrown because it is not clear which image to use.\n\n\n\n\n\n\nlink\n: This link points to an image available at this URL used to upload the image to the cloud environment.\n\n\nNote\n Either you have to define the image link or put the image directly into the VNF Package if you want to upload a new Image to the VIM by using image upload option \ntrue\n or \ncheck\n.\n    Otherwise a NotFoundException will be thrown and the VNF Package will not be onboarded.\n    The image-link has a higher priority than the image stored in the VNF Package directly.\n\n\n*Note\n* At the moment it is only supported to upload an image by using the \nlink\n. Image uploading from an image inside the package is disabled.\n\n\n\n\n\n\n\n\n\n\nimage-config\n: All the properties explained below are required to upload the image to the cloud environment properly.\n    In case of creating a new image this configuration will be used and is obviously mandatory.\n\n\nname\n: This defines the name for the image to upload either located directly in the VNF Package or available via the URL defined in image-link.\n\n\ndiskFormat\n: The diskFormat defines the format in which disk type the image is stored.\n\n\ncontainerFormat\n: The containerFormat defines the format in which container type the image is stored .\n\n\nminCPU\n: The minCPU defines the minimum amount of CPU cores for using this image properly.\n\n\nminDisk\n: The minDisk defines the minimum amount of disk space for using this image properly.\n\n\nminRam\n: The minRam defines the minimum amount of RAM for using this image properly.\n\n\nisPublic\n: The isPublic defines whether the image is available public or not.\n\n\n\n\n\n\n\n\nVNFD>.json\n\n\nThe \nvnfd>.json contains the VirtualNetworkFunctionDescriptor (VNFD) onboarded to the Orchestrator.\nThis VNFD can later be referenced in a NSD by its ID to make use of it.\nA more detailed explanation of the VNFD can be found \nhere\n.\n\n\nNote\n The name of the file is not is up to you but the file extension .json is must be present since the VNFPackageManagement is looking for this kind of file.\n\n\nscripts\n\n\nThe scripts folder contains all the scripts required for starting, configuring or whatever you want to do on the running instance during specific lifecycles.\nThe execution order is defined by the lifecycle_events inside the VNFD.\nThis lifecycle_events are triggered by the NFVO in the meaning of: if the event \"INSTANTIATE\" contains a script in the lifecycle_events, this script is executed when the NFVO calls the instantiate method for the specific VNFR.\n\n\nNote\n The scripts in the folder \nscripts\n are fetched only if the \nscripts-link\n is not defined in the \nMetadata.yaml\n.\n    This means that the scripts in that folder have less priority than the scripts located under \nscripts-link\n.\n\n\nNote\n Scripts are executed when a specific Event is fired and this Event references to specific scripts.\n\n\nimage>.img\n\n\nNote\n At the moment it is only supported to upload an image by using the \nlink\n defined in \nMetadata.yaml\n. Image uploading from an image inside the package is disabled.\n\n\nThis image is used for uploading it to all the cloud environments which are addressed inside the VNFD with that image.\nIt doesn't matter whether an image already exists on the considered cloud environment or not.\n\n\nNote\n This image has lower priority than the \nimage-links\n defined in \nMetadata.yaml\n.\n    This means that the image will be ignored if the \nimage-links\n is defined.\n\n\nNote\n The name of the image doesn't matter but the suffix .img since the VNFPackageManagement is looking for a file with this suffix.\n    However, the name and all the properties for storing it on the cloud environment are defined in \nMetadata.yaml\n under the key \nimage\n.\n\n\nTutorial\n\n\nThis section explains how to create, upload and make use of VNF Packages.\nThe chosen scenario is a Network Service for testing the network connectivity by using \niPerf\n.\niPerf is a tool for active measurements of the maximum achievable bandwidth on IP networks.\nTherefore, we need a server and a client installing the iPerf server/client and configuring them for communication between.\n\n\nCreation of VNF Packages\n\n\nFor doing so, we need to create two VNF Packages and reference them in the NSD.\nSo we need a VNF Package for the iperf server (called iperf-server) and for the iperf client (called iperf-client).\nFirst we will start with the creation of the iperf-server VNF Package and then we will create the iperf-client VNF Package.\n\n\nFirst of all we should create a directory for each VNF Package where we put all the files related to the VNF Package because in the end we need to pack them into a tar archive for onboarding it on the NFVO.\n\n\nVNF Package [iperf-server]\n\n\nThis iperf-server VNF Package has to install the iperf server and needs to provide its ip to the iperf client.\n\n\nMetadata [iperf-server]\n\n\nIn the Metadata.yaml we define the name of the VNF Package, the scripts location and also the properties for the image to use or upload.\nSince passing an image is not supported in the current release we will use the image link inside the \nMetadata.yaml\n.\nFinally, it looks as shown below.\n\n\nname: iperf-server\nscripts-link: https://script-link-to-git.git\nimage:\n    upload: \ncheck\n\n    names:\n        - iperf_server_image\n    link: \nhttp://releases.ubuntu.com/14.04/ubuntu-14.04.3-server-amd64.iso\n\nimage-config:\n    name: iperf_server_image\n    diskFormat: QCOW2\n    containerFormat: BARE\n    minCPU: 2\n    minDisk: 5\n    minRam: 2048\n    isPublic: false\n\n\n\n\nVNFD [iperf-server]\n\n\nThis is how the \nVNFD\n looks like for the iperf-server VNF Package.\nImportant to notice here is that the vm_image defined in the Metadata.yaml is filled automatically during the onboarding process of the VNF Package.\n\n\n{\n  \nname\n:\niperf-server\n,\n  \nvendor\n:\nFOKUS\n,\n  \nversion\n:\n1.0\n,\n  \nlifecycle_event\n:[\n    {\n      \nevent\n:\nINSTANTIATE\n,\n      \nlifecycle_events\n:[\n        \ninstall.sh\n,\n        \ninstall-srv.sh\n\n      ]\n    }\n  ],\n  \nvirtual_link\n:[\n    {\n      \nname\n:\nprivate\n\n    }\n  ],\n  \nvdu\n:[\n    {\n      \nvm_image\n:[\n      ],\n      \nscale_in_out\n:1,\n      \nvnfc\n:[\n        {\n          \nconnection_point\n:[\n            {\n              \nvirtual_link_reference\n:\nprivate\n\n            }\n          ]\n        }\n      ],\n      \nvimInstanceName\n:[\nvim-instance\n]\n    }\n  ],\n  \ndeployment_flavour\n:[\n    {\n      \nflavour_key\n:\nm1.small\n\n    }\n  ],\n  \ntype\n:\nserver\n,\n  \nendpoint\n:\ngeneric\n,\n  \nvnfPackageLocation\n:\nhttps://github.com/openbaton/vnf-scripts.git\n\n}\n\n\n\n\nImage\n\n\nThe image we have to choose must be a debian 64bit image (e.g. ubuntu amd64) for satisfying the EMS and scripts which are designed for that kind of image.\nWe have chosen this one \nubuntu-14.04.3-server-amd64.iso\n.\n\n\nVNF Package [iperf-client]\n\n\nThis iperf-client VNF Package has to install the iPerf client and needs to be configured in order to know the iPerf servers' IP.\n\n\nMetadata [iperf-client]\n\n\nIn the Metadata.yaml we define the name of the VNF Package, the scripts location and also the properties for the image to upload.\nSince passing an image is not supported in the current release we will use the image link inside the \nMetadata.yaml\n.\nFinally, it looks as shown below.\n\n\nname: iperf-client\nscripts-link: https://gitlab.fokus.fraunhofer.de/openbaton/scripts-test-public.git\nimage:\n    upload: \ncheck\n\n    names:\n        - iperf_client_image\n    link: \nhttp://releases.ubuntu.com/14.04/ubuntu-14.04.3-server-amd64.iso\n\nimage-config:\n    name: iperf_client_image\n    diskFormat: QCOW2\n    containerFormat: BARE\n    minCPU: 2\n    minDisk: 5\n    minRam: 2048\n    isPublic: false\n\n\n\n\nVNFD [iperf-client]\n\n\nThis is how the \nVNFD\n looks like for the iperf-client VNF Package.\nImportant to notice here is that the vm_image defined in the Metadata.yaml is filled automatically during the onboarding process of the VNF Package.\n\n\n{\n  \nname\n:\niperf-client\n,\n  \nvendor\n:\nFOKUS\n,\n  \nversion\n:\n1.0\n,\n  \nlifecycle_event\n:[\n    {\n      \nevent\n:\nCONFIGURE\n,\n      \nlifecycle_events\n:[\n        \nserver_configure.sh\n\n      ]\n    },\n    {\n      \nevent\n:\nINSTANTIATE\n,\n      \nlifecycle_events\n:[\n        \ninstall.sh\n\n      ]\n    }\n  ],\n  \nvdu\n:[\n    {\n      \nvm_image\n:[\n        \n\n      ],\n      \nscale_in_out\n:1,\n      \nvnfc\n:[\n        {\n          \nconnection_point\n:[\n            {\n              \nvirtual_link_reference\n:\nprivate\n\n            }\n          ]\n        }\n      ],\n      \nvimInstanceName\n:[\nvim-instance\n]\n    }\n  ],\n  \nvirtual_link\n:[\n    {\n      \nname\n:\nprivate\n\n    }\n  ],\n  \ndeployment_flavour\n:[\n    {\n      \nflavour_key\n:\nm1.small\n\n    }\n  ],\n  \ntype\n:\nclient\n,\n  \nendpoint\n:\ngeneric\n,\n  \nvnfPackageLocation\n:\nhttps://github.com/openbaton/vnf-scripts.git\n\n}\n\n\n\n\nImage\n\n\nThe image we have to choose must be a debian 64bit image (e.g. ubuntu amd64) for satisfying the EMS and scripts which are designed for that kind of architecture.\nWe have chosen this one \nubuntu-14.04.3-server-amd64.iso\n.\n\n\nOnboarding VNF Packages\n\n\nOnce we have finalized the creation of VNF Packages and packed them into a tar we can onboard them to the NFVO. Make sure that you also uploaded a VimInstance before onboarding the package. Onboarding can be done as shown in the following:\n\n\n$ curl -X POST -v -F file=@vnf-package.tar \nhttp://localhost:8080/api/v1/vnf-packages\n\n\n\n\n\nThis must be done for both VNF Packages expecting that the NFVO is running locally and the tar archive is called vnf-package.tar.\nOtherwise you need to adapt the path to the package and also the URL where the NFVO is located.\nNow where we onboarded the VNF Packages they are available on the NFVO and we can make use of it by referencing them in the NSD by their IDs'.\n\n\nNote\n You could use the \nDashboard\n as well for onboarding the VNF Packages.\n\n\nTo get the IDs of the newly created VNFDs you need to fetch the VNFDs by invoking the following command:\n\n\n$ curl -X GET \nhttp://localhost:8080/api/v1/vnf-descriptors\n\n\n\n\n\nThis request will return a list of already existing VNFDs.\nJust looking for the VNFDs we created before and use their IDs to reference them in the NSD.\nThe following list of VNFDs is an output example of this request.\nTo make it more readable only the interesting parts are shown.\n\n\n[\n  [...]\n  {\n    [...]\n    \nid\n: \n29d918b9-6245-4dc4-abc6-b7dd6e84f2c1\n,\n    \nname\n: \niperf-server\n,\n    [...]\n  },\n  {\n    [...]\n    \nid\n: \n87820607-4048-4fad-b02b-dbcab8bb5c1c\n,\n    \nname\n: \niperf-client\n,\n    [...]\n  }\n  [...]\n]\n\n\n\n\nNSD [iperf]\n\n\nIn this section we will create a \nNSD\n and reference the previously created VNF Packages by their IDs.\nFor doing that we just need to define the \nid\n for each VNFPackges' VNFD in the list of VNFDs.\nTo provide also the iperf-servers' IP to the iperf-client we need to define dependencies you can find under the key \nvnf_dependency\n setting the source to \niperf-server\n and the target to \niperf-client\n by providing the parameter \nprivate\n that indicates the private IP address of the iPerf server in the network \"private\".\n\n\nNote\n When creating the NSD the VNFD is fetched by the ID defined. Other properties we would set in the VNFD in this NSD will be ignored.\n\n\n{\n    \nname\n:\niperf\n,\n    \nvendor\n:\nfokus\n,\n    \nversion\n:\n0.1-ALPHA\n,\n    \nvnfd\n:[\n        {\n            \nid\n:\n29d918b9-6245-4dc4-abc6-b7dd6e84f2c1\n\n        },\n        {\n            \nid\n:\n87820607-4048-4fad-b02b-dbcab8bb5c1c\n\n        }\n    ],\n    \nvld\n:[\n        {\n            \nname\n:\nprivate\n\n        }\n    ],\n    \nvnf_dependency\n:[\n        {\n            \nsource\n : {\n                \nname\n: \niperf-server\n\n            },\n            \ntarget\n:{\n                \nname\n: \niperf-client\n\n            },\n            \nparameters\n:[\n                \nprivate\n\n            ]\n        }\n    ]\n}\n\n\n\n\nFinally you can onboard this NSD and deploy an NSR that bases on both VNF Packages created before.\n\n\nOnboard NSD\n\n\nThe following command will onboard the NSD on the NFVO:\n\n\n$ curl -X POST -v -F file=@nsd.json \nhttp://localhost:8080/api/v1/ns-descriptors\n\n\n\n\n\nThis will return the NSD with the ID we need to create the NSR.\nAfterwards, we can deploy the NSD.\n\n\nNote\n You could use the \nDashboard\n as well for onboarding the NSD.\n\n\nCreate NSR (Deployment)\n\n\nTo deploy the NSD we create a NSR with the following command:\n\n\n$ curl -X POST -v -F file=@vnf-package.tar \nhttp://localhost:8080/api/v1/ns-records/\nNSD_ID\n\n\n\n\n\nInstallation and configuration is done automatically and provides you with a configured iperf server/client service.\n\n\nNote\n You could use the \nDashboard\n as well for creating the NSR of this NSD.\n\n\n\n\n\n\n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Create your own VNF Package"
        }, 
        {
            "location": "/vnfpackage/#vnf-package", 
            "text": "Note : This is the initial version of the VNF Package and might change most probably in the next releases to improve and simplify the creation, usability and power.  This doc describes essential components of a VNF Package, how to create them and how to use them after onboarding.\nTherefore, you can find a practical tutorial at the end with all the steps starting from the creation over onboarding and finally referencing it by an NSD.  A VNF Package is a tar-archive that contains all the information required for creating a VNF for the Open Baton's NFVO.\nAfter onboarding the VNF Package to the NFVO you can use the VNF directly in the NSD by referencing the VNFD by its ID.\nA VNF Package includes the VNFD, the image, scripts and a Metadata file structured as shown in the next part.", 
            "title": "VNF Package"
        }, 
        {
            "location": "/vnfpackage/#package-structure", 
            "text": "The VNF Package has the following structure:  - Metadata.yaml\n- vnfd.json\n- scripts/\n    - 1_script.sh\n    - 2_script.sh\n- image.img (not supported at the moment, use image-link!)", 
            "title": "Package structure"
        }, 
        {
            "location": "/vnfpackage/#metadatayaml", 
            "text": "The Metadata.yaml defines essential properties for the VNF. This file is based on the YAML syntax where information are stored in simple  key> :  value> associations.  The example of the Metadata file below shows a basic definition of a VNF Package.  name: VNF Package_name\nscripts-link: scripts_link\nimage:\n    upload: option\n    ids: list_of_ids\n    names: list_of_names\n    link: image_link\nimage-config:\n    name: image_name\n    diskFormat: disk_format\n    containerFormat: container_format\n    minCPU: min_cpu\n    minDisk: min_disk\n    minRam: min_ram\n    isPublic: is_public  In the following each property is explained in more detail. Please consider also the notes since some properties are optional (or even not implemented) and if they are defined, they may have more priority than other and override them therefore.   name : The name defines the name of the VNF Package itself used to store it in the database.  scripts-link : This link points to a public git repository where scripts are stored that are needed to be executed for managing the lifecycle of the exposed VNF.  Note  Either you can define the scripts-link or put the scripts into the folder scripts/.\n    The scripts-link has a higher priority than the scripts located in the folder scripts/.\n    So if you set the scripts-link, the scripts in folder scripts/ are ignored completely.  Note  The scripts-link is processed by the Element Management System (EMS) in the meaning of fetching the files from that link.\n    So you need to take care about ensuring that the URL defined is available.  Note  Scripts are executed during different lifecycle-events.    image :  upload : Here you can choose between different options (true, false, check).  true: choosing this option means to upload the defined image on all the VimInstances. It does not matter if an image with the defined name exists or not.  false: choosing this option means that you assume that the image (defined in the ids or names) is already present.\nIf the image does not exist, the VNF Package onboarding will throw an exception.\nIn this case the image (if defined) will be ignored.  check: this option means that the VNF PackageManagement checks first if the image is available (defined in ids or names).\nIf the image does not exist, a new one with the image defined in the VNF Package will be created.  Note  Please use quotation marks for this option since the values are handled as strings internally.\nOtherwise true and false will be handled as a boolean that would lead to a faulty behavior when onboarding a new VNF Package.    ids : The list of image IDs is used to fetch the image from the corresponding VimInstance.\n    To do it, the manager iterates over all IDs and checks if an image with that ID exists on the VimInstance.\n    The defined IDs have a higher priority than the list of names.\n    We distinguish between the following cases:  If it finds no image with these IDs, it continues with the list of image names.  If it finds one image with these IDs, this image will be used.  If it finds multiple images with the same ID (should never happen) or multiple IDs matching to multiple images, an exception will be thrown because it is not clear which image to use.    names : The list of image names is used to fetch the image from the corresponding VimInstance.\n    To do it, manager iterates over all names and checks if an image with that name exists on the VimInstance.\n    The list of names have a lower priority than the list of IDs.\n    We distinguish between the following cases:  If it finds no image with that name, an exception will be thrown except you defined the upload option check.\nThen it will create a new image defined in the VNF Package.  If it finds one image, this image will be used.  If it finds multiple images with the same name or multiple names matching to multiple images, an exception will be thrown because it is not clear which image to use.    link : This link points to an image available at this URL used to upload the image to the cloud environment.  Note  Either you have to define the image link or put the image directly into the VNF Package if you want to upload a new Image to the VIM by using image upload option  true  or  check .\n    Otherwise a NotFoundException will be thrown and the VNF Package will not be onboarded.\n    The image-link has a higher priority than the image stored in the VNF Package directly.  *Note * At the moment it is only supported to upload an image by using the  link . Image uploading from an image inside the package is disabled.      image-config : All the properties explained below are required to upload the image to the cloud environment properly.\n    In case of creating a new image this configuration will be used and is obviously mandatory.  name : This defines the name for the image to upload either located directly in the VNF Package or available via the URL defined in image-link.  diskFormat : The diskFormat defines the format in which disk type the image is stored.  containerFormat : The containerFormat defines the format in which container type the image is stored .  minCPU : The minCPU defines the minimum amount of CPU cores for using this image properly.  minDisk : The minDisk defines the minimum amount of disk space for using this image properly.  minRam : The minRam defines the minimum amount of RAM for using this image properly.  isPublic : The isPublic defines whether the image is available public or not.", 
            "title": "Metadata.yaml"
        }, 
        {
            "location": "/vnfpackage/#vnfd62json", 
            "text": "The  vnfd>.json contains the VirtualNetworkFunctionDescriptor (VNFD) onboarded to the Orchestrator.\nThis VNFD can later be referenced in a NSD by its ID to make use of it.\nA more detailed explanation of the VNFD can be found  here .  Note  The name of the file is not is up to you but the file extension .json is must be present since the VNFPackageManagement is looking for this kind of file.", 
            "title": "&lt;VNFD>.json"
        }, 
        {
            "location": "/vnfpackage/#scripts", 
            "text": "The scripts folder contains all the scripts required for starting, configuring or whatever you want to do on the running instance during specific lifecycles.\nThe execution order is defined by the lifecycle_events inside the VNFD.\nThis lifecycle_events are triggered by the NFVO in the meaning of: if the event \"INSTANTIATE\" contains a script in the lifecycle_events, this script is executed when the NFVO calls the instantiate method for the specific VNFR.  Note  The scripts in the folder  scripts  are fetched only if the  scripts-link  is not defined in the  Metadata.yaml .\n    This means that the scripts in that folder have less priority than the scripts located under  scripts-link .  Note  Scripts are executed when a specific Event is fired and this Event references to specific scripts.", 
            "title": "scripts"
        }, 
        {
            "location": "/vnfpackage/#image62img", 
            "text": "Note  At the moment it is only supported to upload an image by using the  link  defined in  Metadata.yaml . Image uploading from an image inside the package is disabled.  This image is used for uploading it to all the cloud environments which are addressed inside the VNFD with that image.\nIt doesn't matter whether an image already exists on the considered cloud environment or not.  Note  This image has lower priority than the  image-links  defined in  Metadata.yaml .\n    This means that the image will be ignored if the  image-links  is defined.  Note  The name of the image doesn't matter but the suffix .img since the VNFPackageManagement is looking for a file with this suffix.\n    However, the name and all the properties for storing it on the cloud environment are defined in  Metadata.yaml  under the key  image .", 
            "title": "&lt;image>.img"
        }, 
        {
            "location": "/vnfpackage/#tutorial", 
            "text": "This section explains how to create, upload and make use of VNF Packages.\nThe chosen scenario is a Network Service for testing the network connectivity by using  iPerf .\niPerf is a tool for active measurements of the maximum achievable bandwidth on IP networks.\nTherefore, we need a server and a client installing the iPerf server/client and configuring them for communication between.", 
            "title": "Tutorial"
        }, 
        {
            "location": "/vnfpackage/#creation-of-vnf-packages", 
            "text": "For doing so, we need to create two VNF Packages and reference them in the NSD.\nSo we need a VNF Package for the iperf server (called iperf-server) and for the iperf client (called iperf-client).\nFirst we will start with the creation of the iperf-server VNF Package and then we will create the iperf-client VNF Package.  First of all we should create a directory for each VNF Package where we put all the files related to the VNF Package because in the end we need to pack them into a tar archive for onboarding it on the NFVO.  VNF Package [iperf-server]  This iperf-server VNF Package has to install the iperf server and needs to provide its ip to the iperf client.  Metadata [iperf-server]  In the Metadata.yaml we define the name of the VNF Package, the scripts location and also the properties for the image to use or upload.\nSince passing an image is not supported in the current release we will use the image link inside the  Metadata.yaml .\nFinally, it looks as shown below.  name: iperf-server\nscripts-link: https://script-link-to-git.git\nimage:\n    upload:  check \n    names:\n        - iperf_server_image\n    link:  http://releases.ubuntu.com/14.04/ubuntu-14.04.3-server-amd64.iso \nimage-config:\n    name: iperf_server_image\n    diskFormat: QCOW2\n    containerFormat: BARE\n    minCPU: 2\n    minDisk: 5\n    minRam: 2048\n    isPublic: false  VNFD [iperf-server]  This is how the  VNFD  looks like for the iperf-server VNF Package.\nImportant to notice here is that the vm_image defined in the Metadata.yaml is filled automatically during the onboarding process of the VNF Package.  {\n   name : iperf-server ,\n   vendor : FOKUS ,\n   version : 1.0 ,\n   lifecycle_event :[\n    {\n       event : INSTANTIATE ,\n       lifecycle_events :[\n         install.sh ,\n         install-srv.sh \n      ]\n    }\n  ],\n   virtual_link :[\n    {\n       name : private \n    }\n  ],\n   vdu :[\n    {\n       vm_image :[\n      ],\n       scale_in_out :1,\n       vnfc :[\n        {\n           connection_point :[\n            {\n               virtual_link_reference : private \n            }\n          ]\n        }\n      ],\n       vimInstanceName :[ vim-instance ]\n    }\n  ],\n   deployment_flavour :[\n    {\n       flavour_key : m1.small \n    }\n  ],\n   type : server ,\n   endpoint : generic ,\n   vnfPackageLocation : https://github.com/openbaton/vnf-scripts.git \n}  Image  The image we have to choose must be a debian 64bit image (e.g. ubuntu amd64) for satisfying the EMS and scripts which are designed for that kind of image.\nWe have chosen this one  ubuntu-14.04.3-server-amd64.iso .  VNF Package [iperf-client]  This iperf-client VNF Package has to install the iPerf client and needs to be configured in order to know the iPerf servers' IP.  Metadata [iperf-client]  In the Metadata.yaml we define the name of the VNF Package, the scripts location and also the properties for the image to upload.\nSince passing an image is not supported in the current release we will use the image link inside the  Metadata.yaml .\nFinally, it looks as shown below.  name: iperf-client\nscripts-link: https://gitlab.fokus.fraunhofer.de/openbaton/scripts-test-public.git\nimage:\n    upload:  check \n    names:\n        - iperf_client_image\n    link:  http://releases.ubuntu.com/14.04/ubuntu-14.04.3-server-amd64.iso \nimage-config:\n    name: iperf_client_image\n    diskFormat: QCOW2\n    containerFormat: BARE\n    minCPU: 2\n    minDisk: 5\n    minRam: 2048\n    isPublic: false  VNFD [iperf-client]  This is how the  VNFD  looks like for the iperf-client VNF Package.\nImportant to notice here is that the vm_image defined in the Metadata.yaml is filled automatically during the onboarding process of the VNF Package.  {\n   name : iperf-client ,\n   vendor : FOKUS ,\n   version : 1.0 ,\n   lifecycle_event :[\n    {\n       event : CONFIGURE ,\n       lifecycle_events :[\n         server_configure.sh \n      ]\n    },\n    {\n       event : INSTANTIATE ,\n       lifecycle_events :[\n         install.sh \n      ]\n    }\n  ],\n   vdu :[\n    {\n       vm_image :[\n         \n      ],\n       scale_in_out :1,\n       vnfc :[\n        {\n           connection_point :[\n            {\n               virtual_link_reference : private \n            }\n          ]\n        }\n      ],\n       vimInstanceName :[ vim-instance ]\n    }\n  ],\n   virtual_link :[\n    {\n       name : private \n    }\n  ],\n   deployment_flavour :[\n    {\n       flavour_key : m1.small \n    }\n  ],\n   type : client ,\n   endpoint : generic ,\n   vnfPackageLocation : https://github.com/openbaton/vnf-scripts.git \n}  Image  The image we have to choose must be a debian 64bit image (e.g. ubuntu amd64) for satisfying the EMS and scripts which are designed for that kind of architecture.\nWe have chosen this one  ubuntu-14.04.3-server-amd64.iso .", 
            "title": "Creation of VNF Packages"
        }, 
        {
            "location": "/vnfpackage/#onboarding-vnf-packages", 
            "text": "Once we have finalized the creation of VNF Packages and packed them into a tar we can onboard them to the NFVO. Make sure that you also uploaded a VimInstance before onboarding the package. Onboarding can be done as shown in the following:  $ curl -X POST -v -F file=@vnf-package.tar  http://localhost:8080/api/v1/vnf-packages   This must be done for both VNF Packages expecting that the NFVO is running locally and the tar archive is called vnf-package.tar.\nOtherwise you need to adapt the path to the package and also the URL where the NFVO is located.\nNow where we onboarded the VNF Packages they are available on the NFVO and we can make use of it by referencing them in the NSD by their IDs'.  Note  You could use the  Dashboard  as well for onboarding the VNF Packages.  To get the IDs of the newly created VNFDs you need to fetch the VNFDs by invoking the following command:  $ curl -X GET  http://localhost:8080/api/v1/vnf-descriptors   This request will return a list of already existing VNFDs.\nJust looking for the VNFDs we created before and use their IDs to reference them in the NSD.\nThe following list of VNFDs is an output example of this request.\nTo make it more readable only the interesting parts are shown.  [\n  [...]\n  {\n    [...]\n     id :  29d918b9-6245-4dc4-abc6-b7dd6e84f2c1 ,\n     name :  iperf-server ,\n    [...]\n  },\n  {\n    [...]\n     id :  87820607-4048-4fad-b02b-dbcab8bb5c1c ,\n     name :  iperf-client ,\n    [...]\n  }\n  [...]\n]", 
            "title": "Onboarding VNF Packages"
        }, 
        {
            "location": "/vnfpackage/#nsd-iperf", 
            "text": "In this section we will create a  NSD  and reference the previously created VNF Packages by their IDs.\nFor doing that we just need to define the  id  for each VNFPackges' VNFD in the list of VNFDs.\nTo provide also the iperf-servers' IP to the iperf-client we need to define dependencies you can find under the key  vnf_dependency  setting the source to  iperf-server  and the target to  iperf-client  by providing the parameter  private  that indicates the private IP address of the iPerf server in the network \"private\".  Note  When creating the NSD the VNFD is fetched by the ID defined. Other properties we would set in the VNFD in this NSD will be ignored.  {\n     name : iperf ,\n     vendor : fokus ,\n     version : 0.1-ALPHA ,\n     vnfd :[\n        {\n             id : 29d918b9-6245-4dc4-abc6-b7dd6e84f2c1 \n        },\n        {\n             id : 87820607-4048-4fad-b02b-dbcab8bb5c1c \n        }\n    ],\n     vld :[\n        {\n             name : private \n        }\n    ],\n     vnf_dependency :[\n        {\n             source  : {\n                 name :  iperf-server \n            },\n             target :{\n                 name :  iperf-client \n            },\n             parameters :[\n                 private \n            ]\n        }\n    ]\n}  Finally you can onboard this NSD and deploy an NSR that bases on both VNF Packages created before.  Onboard NSD  The following command will onboard the NSD on the NFVO:  $ curl -X POST -v -F file=@nsd.json  http://localhost:8080/api/v1/ns-descriptors   This will return the NSD with the ID we need to create the NSR.\nAfterwards, we can deploy the NSD.  Note  You could use the  Dashboard  as well for onboarding the NSD.  Create NSR (Deployment)  To deploy the NSD we create a NSR with the following command:  $ curl -X POST -v -F file=@vnf-package.tar  http://localhost:8080/api/v1/ns-records/ NSD_ID   Installation and configuration is done automatically and provides you with a configured iperf server/client service.  Note  You could use the  Dashboard  as well for creating the NSR of this NSD.   \n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "NSD [iperf]"
        }, 
        {
            "location": "/vnfm-generic/", 
            "text": "Generic VNF Manager\n\n\nThe Generic VNF Manager is an implementation following the \nETSI MANO\n specifications. It works as intermediate component between the NFVO and the VNFs, particularly the Virtual Machines on top of which the VNF software is installed. In order to complete the lifecycle of a VNF, it interoperates with the Element Management System (EMS) acting as an agent inside the VMs and executing scripts containeed in the vnf package.\nThis VNFM may be assigned the management of a single VNF instance, or the management of multiple VNF instances of the same type or of different types.\n\n\nThe Generic VNFManager handles communication with the NFVO and with EMS. The communication NFVO \u2194 VNFM \u2194 EMS is done using the AMQP protocol over RabbitMQ.  \n\n\nThe communication between the NFVO and Generic VNFManager:\n\n\n\n\nThe communication between the Generic VNFManager and EMS:\n\n\n\n\nAs you can see, the Generic VNFM sends commands to the EMS, which is running in the VM. Then the EMS executes the commands (scripts) locally in the VNFC. \nPlease note that the EMS executes those scripts as root user\n.\nThe following sequence diagram explains the communication messages.\n\n\n\n\nThe Generic VNFManager is supposed to be used for any type of VNF that follows some conventions regarding:\n\n\n\n\nVMs deployment\n\n\nScript execution costraints\n\n\nVMs termination\n\n\n\n\nVMs deployment\n\n\nAccordingly to the \nETSI MANO B.3\n the VNF instantiation flows can be done in two ways:\n\n\n\n\nWith resource allocation done by NFVO\n\n\nWith resource allocation done by VNF Manager\n\n\n\n\nThe Generic VNFM follows the first approach. In the first approach two messages will be sent to the NFVO:\n\n\n\n\n\n\nGRANT_OPERATION message\n: check if the resources are available on the selected PoP. If the GRANT_OPERATION message is returned, then there are enough resources, otherwise an ERROR message will be sent. After the GRANT_OPERATION message it is possible to send the ALLOCATE_RESOURCE message.  \n\n\n\n\n\n\nALLOCATE_RESOURCE message\n: This message ask the NFVO to create all the resources and then, if no errors occurred, the ALLOCATE_RESOURCE message will be returned to the VNFManager. Only the VNFMs which follow the first approach need to send this message.\n\n\n\n\n\n\nAfter that point the VMs are created and \nthe VNF record is filled with values\n, such as ips, that can be found directly in the VirtualNetworkFunctionRecord\u2192VirtualDeploymentUnit\u2192VNFCInstance object.\n\n\nScript Execution Costraints\n\n\nFor each operation of the VNF Lifecycle Management interface, the VNFManager sends scripts to the EMS which executes them locally in the VMs.\n\n\nNote\n: The scripts come from the VNFPackage which you need to create (see \nVNFPackage documentation\n).\n\n\nThe ordering of this scripts is defined in the NetworkServiceDescriptor from which the NetworkServiceRecord was created, in particular into the NetworkServiceDescriptor\u2192VirtualNetworkFunctionDescriptor\u2192LifecycleEvents.\nHere an example (to make it more readable it is shown only the \nVNF lifecycle event\n part):\n\n\n{// NSD\n  ...\n  {// VNFD\n    ...\n    \nlifecycle_event\n:[\n        {\n            \nevent\n:\nINSTANTIATE\n,\n            \nlifecycle_events\n:[\n                \npre-install.sh\n,\n                \ninstall.sh\n\n            ]\n        },\n        {\n            \nevent\n:\nCONFIGURE\n,\n            \nlifecycle_events\n:[\n                \nserver_configure.sh\n\n            ]\n        },\n        {\n            \nevent\n:\nSTART\n,\n            \nlifecycle_events\n:[\n                 \nserver_start.sh\n\n            ]\n        },\n        {\n            \nevent\n:\nTERMINATE\n,\n            \nlifecycle_events\n:[\n                 \nserver_terminate.sh\n\n            ]\n        }\n    ],\n    ...\n  }\n  ...\n}\n\n\n\n\nIn the following table is described for each \nVNF lifecycle event\n when the scripts are executed.\n\n\n\n\n\n\n\n\nVNF Lifecycle event\n\n\nWhen scripts are executed\n\n\n\n\n\n\n\n\n\n\nINSTANTIATE\n\n\nDuring the instantiation of the corresponding VNF\n\n\n\n\n\n\nCONFIGURE\n\n\nAfter the instantiation. Useful if the VNF depends on other VNFs, because we can get parameters provided by them (e.g. IP). The parameters are available as environment variables (see later).\n\n\n\n\n\n\nSTART\n\n\nAfter the instantiation or configuration (It depends whether the event CONFIGURE specified).\n\n\n\n\n\n\nTERMINATE\n\n\nDuring the termination of the corresponding VNF\n\n\n\n\n\n\nSCALE_IN\n\n\nWhen the VNF is target of a scaled in vnfcInstance\n\n\n\n\n\n\n\n\nThe available parameters are defined in the VirtualNetworkFunctionDescriptor fields:\n\n\n\n\n\n\n\nconfigurations\n: it contains specific parameters which you want to use in the scripts.\n\n\nout-of-the-box\n: the following parameters are automatically available into the scripts:  \n\n\nPrivate IP\n\n\nFloating IP (if requested)\n\n\nHostname\n\nPlease check the example at the end of the page to understand this mechanism.\n\n\n\n\n\n\n\n\nIn the INSTANTIATE scripts, the parameters defined in these two fields are then available as environment variables into the script exactly as defined (i.e. you can get by $parameter_name).\n\n\nIn the MODIFY scripts, the INSTANTIATE parameters are still available but plus there are environment variables that come from other VNF sources, where they are specified in the provides field. \nThese kind of parameters are defined in the \nrequires\n fields (of the VNF target) and the VNFDependency\u2192parameters fields (of the NSD), and are then available as $\ntype_of_vnf_source\n_\nname_of_parameter\n (in the VNF target).\n\n\nNOTE\n: \nthe scripts in the CONFIGURE lifecycle event need to start with the type of the source VNF followed by _ and the name of the script (i.e. server_configure.sh)\n\n\nVMs termination\n\n\nAs for VMs deployment, VMs termination is done by the NFVO. Specific scripts can be run before termination by putting them under the TERMINATE lifecycle event.\n\n\nLaunch the Generic VNFM\n\n\nTo launch the Generic VNFM, execute the following command:\n\n\n$ cd \ngeneric directory\n\n$ ./generic-vnfm.sh start\n\n\n\n\nThe Generic VNFM can handle more than one VNF (in parallel) of the same or different type, so that you need to start only one Generic VNFM.\n\n\nEXAMPLE WITH DEPENDENCY AND SCRIPTS\n\n\nLet's see a simple example with two VNFs: vnf-server and vnf-database.\n\nThe vnf-server needs the ip of the vnf-database to be able to connect properly. The following figure shows the source (vnf-database), the target (vnf-server)\nand the dependency (IP). Such VNFs are connected in the same virtual network called \"vnet\".\n\n\n\n\nINSTANTIATE scripts\n\n\nTo start the VNFs we'll have two scripts \ninstantiate-vnf-server.sh\n and \ninstantiate-vnf-database.sh\n (more scripts are possible). Here an example of the instantiate-vnf-server.sh script:\n\n\n#!/bin/bash\n\necho \nINSTANTIATIATION of the VNF server\n\necho \nThe following parameters are available:\n\n\necho \nOut-of-the-box parameters:\n\necho \nHostname: ${hostname}\n\necho \nPrivate IP: ${vnet}\n\necho \nFloating IP (if requested otherwise it does not exist): ${vnet_floatingIp}\n\n\necho \nConfiguration parameters:\n\necho \nThe answer to everything is.. ${ANSWER_TO_EVERYTHING}\n\n\n# ... Add the code to start the vnf_server ...\n\n\n\n\nCONFIGURE script\n\n\nAfter the instantiation of the vnf-server we would configure it with the following \ndatabase_connectToDb.sh\n script:\n\n\n#!/bin/bash\n\necho \nThis is the ip of the vnf-database: ${database_vnet}\n\necho \nThis is the floating ip of the vnf-database: ${database_vnet_floatingIp}\n\necho \nThis is the hostname of the vnf-database: ${database_hostname}\n\n\n# ... Add the code to connect to the vnf-database with the ip: ${database_vnet} ...\n\n\n\n\n\nNote1\n: \ndatabase\n is the type of the vnf-database, \nvnet\n is the name of the network.\n\n\nNote2\n: All the scripts need to be in a repository or in the vnf package (see the vnf package structure \nhere\n).\n\n\nIn order to deploy the VNFs we have to create both the VNF descriptor: \nvnf-database-descriptor.json\n and \nvnf-server-descriptor.json\n. Below we'll be showed the most relevant part of them:\n\n\nvnf-database-descriptor.json\n\n\n{\n    \nname\n:\nvnf-database\n,\n    \ntype\n:\ndatabase\n,\n    \nendpoint\n:\ngeneric\n,\n    ...\n    \nlifecycle_event\n:[\n        {\n            \nevent\n:\nINSTANTIATE\n,\n            \nlifecycle_events\n:[\n                \ninstantiate-vnf-database.sh\n\n            ]\n        }\n    ],\n    ...\n}\n\n\n\n\nNote:\n to use the Generic VNFM for managing a VNF just set \"generic\" in the endpoint field.\n\n\nvnf-server-descriptor.json\n\n\n{\n    \nname\n:\nvnf-server\n,\n    \ntype\n:\nserver\n,\n    \nendpoint\n:\ngeneric\n,\n    ...\n    \nconfigurations\n:{\n            \nname\n:\nconfig_name\n,\n            \nconfigurationParameters\n:[\n            {\n                \nconfKey\n:\nANSWER_TO_EVERYTHING\n,\n                \nvalue\n:\n42\n\n            }\n            ]\n    },\n    ...\n    \nlifecycle_event\n:[\n        {\n            \nevent\n:\nINSTANTIATE\n,\n            \nlifecycle_events\n:[\n                \ninstantiate-vnf-server.sh\n\n            ]\n        },\n        {\n            \nevent\n:\nCONFIGURE\n,\n            \nlifecycle_events\n:[\n                \ndatabase_connectToDb.sh\n\n            ]\n        }\n    ],\n    ...\n}\n\n\n\n\nThe result network service descriptor shall include both the vnf descriptors above and the dependency:\n\n\n{\n    \nname\n:\nsimple-nsd\n,\n    \nvnfd\n:[\n        {\n            \nid\n:\n29d918b9-6245-4dc4-abc6-b7dd6e84f2c1\n\n        },\n        {\n            \nid\n:\n87820607-4048-4fad-b02b-dbcab8bb5c1c\n\n        }\n    ],\n    \nvld\n:[\n        {\n            \nname\n:\nvnet\n\n        }\n    ],\n    \nvnf_dependency\n:[\n        {\n            \nsource\n : {\n                \nname\n: \nvnf-database\n\n            },\n            \ntarget\n:{\n                \nname\n: \nvnf-server\n\n            },\n            \nparameters\n:[\n                \nvnet\n\n            ]\n        }\n    ]\n}\n\n\n\n\nSee the complete tutorial \u2192 \nVNFPackage tutorial\n.\n\n\n\n\n\n\n\n\n\n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Generic VNFM"
        }, 
        {
            "location": "/vnfm-generic/#generic-vnf-manager", 
            "text": "The Generic VNF Manager is an implementation following the  ETSI MANO  specifications. It works as intermediate component between the NFVO and the VNFs, particularly the Virtual Machines on top of which the VNF software is installed. In order to complete the lifecycle of a VNF, it interoperates with the Element Management System (EMS) acting as an agent inside the VMs and executing scripts containeed in the vnf package.\nThis VNFM may be assigned the management of a single VNF instance, or the management of multiple VNF instances of the same type or of different types.  The Generic VNFManager handles communication with the NFVO and with EMS. The communication NFVO \u2194 VNFM \u2194 EMS is done using the AMQP protocol over RabbitMQ.    The communication between the NFVO and Generic VNFManager:   The communication between the Generic VNFManager and EMS:   As you can see, the Generic VNFM sends commands to the EMS, which is running in the VM. Then the EMS executes the commands (scripts) locally in the VNFC.  Please note that the EMS executes those scripts as root user .\nThe following sequence diagram explains the communication messages.   The Generic VNFManager is supposed to be used for any type of VNF that follows some conventions regarding:   VMs deployment  Script execution costraints  VMs termination   VMs deployment  Accordingly to the  ETSI MANO B.3  the VNF instantiation flows can be done in two ways:   With resource allocation done by NFVO  With resource allocation done by VNF Manager   The Generic VNFM follows the first approach. In the first approach two messages will be sent to the NFVO:    GRANT_OPERATION message : check if the resources are available on the selected PoP. If the GRANT_OPERATION message is returned, then there are enough resources, otherwise an ERROR message will be sent. After the GRANT_OPERATION message it is possible to send the ALLOCATE_RESOURCE message.      ALLOCATE_RESOURCE message : This message ask the NFVO to create all the resources and then, if no errors occurred, the ALLOCATE_RESOURCE message will be returned to the VNFManager. Only the VNFMs which follow the first approach need to send this message.    After that point the VMs are created and  the VNF record is filled with values , such as ips, that can be found directly in the VirtualNetworkFunctionRecord\u2192VirtualDeploymentUnit\u2192VNFCInstance object.  Script Execution Costraints  For each operation of the VNF Lifecycle Management interface, the VNFManager sends scripts to the EMS which executes them locally in the VMs.  Note : The scripts come from the VNFPackage which you need to create (see  VNFPackage documentation ).  The ordering of this scripts is defined in the NetworkServiceDescriptor from which the NetworkServiceRecord was created, in particular into the NetworkServiceDescriptor\u2192VirtualNetworkFunctionDescriptor\u2192LifecycleEvents.\nHere an example (to make it more readable it is shown only the  VNF lifecycle event  part):  {// NSD\n  ...\n  {// VNFD\n    ...\n     lifecycle_event :[\n        {\n             event : INSTANTIATE ,\n             lifecycle_events :[\n                 pre-install.sh ,\n                 install.sh \n            ]\n        },\n        {\n             event : CONFIGURE ,\n             lifecycle_events :[\n                 server_configure.sh \n            ]\n        },\n        {\n             event : START ,\n             lifecycle_events :[\n                  server_start.sh \n            ]\n        },\n        {\n             event : TERMINATE ,\n             lifecycle_events :[\n                  server_terminate.sh \n            ]\n        }\n    ],\n    ...\n  }\n  ...\n}  In the following table is described for each  VNF lifecycle event  when the scripts are executed.     VNF Lifecycle event  When scripts are executed      INSTANTIATE  During the instantiation of the corresponding VNF    CONFIGURE  After the instantiation. Useful if the VNF depends on other VNFs, because we can get parameters provided by them (e.g. IP). The parameters are available as environment variables (see later).    START  After the instantiation or configuration (It depends whether the event CONFIGURE specified).    TERMINATE  During the termination of the corresponding VNF    SCALE_IN  When the VNF is target of a scaled in vnfcInstance     The available parameters are defined in the VirtualNetworkFunctionDescriptor fields:    configurations : it contains specific parameters which you want to use in the scripts.  out-of-the-box : the following parameters are automatically available into the scripts:    Private IP  Floating IP (if requested)  Hostname \nPlease check the example at the end of the page to understand this mechanism.     In the INSTANTIATE scripts, the parameters defined in these two fields are then available as environment variables into the script exactly as defined (i.e. you can get by $parameter_name).  In the MODIFY scripts, the INSTANTIATE parameters are still available but plus there are environment variables that come from other VNF sources, where they are specified in the provides field. \nThese kind of parameters are defined in the  requires  fields (of the VNF target) and the VNFDependency\u2192parameters fields (of the NSD), and are then available as $ type_of_vnf_source _ name_of_parameter  (in the VNF target).  NOTE :  the scripts in the CONFIGURE lifecycle event need to start with the type of the source VNF followed by _ and the name of the script (i.e. server_configure.sh)  VMs termination  As for VMs deployment, VMs termination is done by the NFVO. Specific scripts can be run before termination by putting them under the TERMINATE lifecycle event.", 
            "title": "Generic VNF Manager"
        }, 
        {
            "location": "/vnfm-generic/#launch-the-generic-vnfm", 
            "text": "To launch the Generic VNFM, execute the following command:  $ cd  generic directory \n$ ./generic-vnfm.sh start  The Generic VNFM can handle more than one VNF (in parallel) of the same or different type, so that you need to start only one Generic VNFM.", 
            "title": "Launch the Generic VNFM"
        }, 
        {
            "location": "/vnfm-generic/#example-with-dependency-and-scripts", 
            "text": "Let's see a simple example with two VNFs: vnf-server and vnf-database. \nThe vnf-server needs the ip of the vnf-database to be able to connect properly. The following figure shows the source (vnf-database), the target (vnf-server)\nand the dependency (IP). Such VNFs are connected in the same virtual network called \"vnet\".   INSTANTIATE scripts  To start the VNFs we'll have two scripts  instantiate-vnf-server.sh  and  instantiate-vnf-database.sh  (more scripts are possible). Here an example of the instantiate-vnf-server.sh script:  #!/bin/bash\n\necho  INSTANTIATIATION of the VNF server \necho  The following parameters are available: \n\necho  Out-of-the-box parameters: \necho  Hostname: ${hostname} \necho  Private IP: ${vnet} \necho  Floating IP (if requested otherwise it does not exist): ${vnet_floatingIp} \n\necho  Configuration parameters: \necho  The answer to everything is.. ${ANSWER_TO_EVERYTHING} \n\n# ... Add the code to start the vnf_server ...  CONFIGURE script  After the instantiation of the vnf-server we would configure it with the following  database_connectToDb.sh  script:  #!/bin/bash\n\necho  This is the ip of the vnf-database: ${database_vnet} \necho  This is the floating ip of the vnf-database: ${database_vnet_floatingIp} \necho  This is the hostname of the vnf-database: ${database_hostname} \n\n# ... Add the code to connect to the vnf-database with the ip: ${database_vnet} ...  Note1 :  database  is the type of the vnf-database,  vnet  is the name of the network.  Note2 : All the scripts need to be in a repository or in the vnf package (see the vnf package structure  here ).  In order to deploy the VNFs we have to create both the VNF descriptor:  vnf-database-descriptor.json  and  vnf-server-descriptor.json . Below we'll be showed the most relevant part of them:  vnf-database-descriptor.json  {\n     name : vnf-database ,\n     type : database ,\n     endpoint : generic ,\n    ...\n     lifecycle_event :[\n        {\n             event : INSTANTIATE ,\n             lifecycle_events :[\n                 instantiate-vnf-database.sh \n            ]\n        }\n    ],\n    ...\n}  Note:  to use the Generic VNFM for managing a VNF just set \"generic\" in the endpoint field.  vnf-server-descriptor.json  {\n     name : vnf-server ,\n     type : server ,\n     endpoint : generic ,\n    ...\n     configurations :{\n             name : config_name ,\n             configurationParameters :[\n            {\n                 confKey : ANSWER_TO_EVERYTHING ,\n                 value : 42 \n            }\n            ]\n    },\n    ...\n     lifecycle_event :[\n        {\n             event : INSTANTIATE ,\n             lifecycle_events :[\n                 instantiate-vnf-server.sh \n            ]\n        },\n        {\n             event : CONFIGURE ,\n             lifecycle_events :[\n                 database_connectToDb.sh \n            ]\n        }\n    ],\n    ...\n}  The result network service descriptor shall include both the vnf descriptors above and the dependency:  {\n     name : simple-nsd ,\n     vnfd :[\n        {\n             id : 29d918b9-6245-4dc4-abc6-b7dd6e84f2c1 \n        },\n        {\n             id : 87820607-4048-4fad-b02b-dbcab8bb5c1c \n        }\n    ],\n     vld :[\n        {\n             name : vnet \n        }\n    ],\n     vnf_dependency :[\n        {\n             source  : {\n                 name :  vnf-database \n            },\n             target :{\n                 name :  vnf-server \n            },\n             parameters :[\n                 vnet \n            ]\n        }\n    ]\n}  See the complete tutorial \u2192  VNFPackage tutorial .    \n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "EXAMPLE WITH DEPENDENCY AND SCRIPTS"
        }, 
        {
            "location": "/ns-descriptor/", 
            "text": "Network Service Descriptor\n\n\nThe Network Service Descriptor contains the values that are defined in \nETSI MANO specification\n. The NFVO is able to handle JSON file describing a Network Service Descriptor. An example of the most important fields follows:\n\n\n{  \n    \nname\n:\niperf-NSD\n,\n    \nvendor\n:\nfokus\n,\n    \nversion\n:\n0.1-ALPHA\n,\n    \nvnfd\n:[  ...  ],\n    \nvld\n:[  \n        {  \n            \nname\n:\nprivate\n\n        }\n    ],\n    \nvnf_dependency\n:[\n        {\n            \nsource\n : {\n                \nname\n: \niperf-server\n\n            },\n            \ntarget\n:{\n                \nname\n: \niperf-client\n\n            },\n            \nparameters\n:[\n                \nprivate\n\n            ]\n        }\n    ]\n}\n\n\n\n\nYou can see a complete NSD json \nhere\n.\n\n\n\n\n\n\n\n\nParams\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\nname\n\n\nThe name to give to the NetworkServiceDescriptor\n\n\n\n\n\n\nvendor\n\n\nThe vendor creating this NetworkServiceDescriptor\n\n\n\n\n\n\nversion\n\n\nThe version of the NetworkServiceDescriptor (can be any string)\n\n\n\n\n\n\nvnfd\n\n\nA list of VirtualNetworkFunctionDescriptors (see \nVirtualNetworkFunctionDescriptor\n)\n\n\n\n\n\n\nvld\n\n\nA list of VirtualLinkDescriptors\n\n\n\n\n\n\nvnf_dependency\n\n\nA list of VNF_Dependencies\n\n\n\n\n\n\n\n\nVirtualLinkDescriptor\n\n\nThe Virtual Link Descriptor (VLD) describes the basic topology of the connectivity between one or more VNFs connected to this VL.\nThe VLD must contain a parameter \nname\n with the value of a network that will be used by the VirtualNetworkFunctionDescriptors.\nIf the network exists, then this network will be used, if not a new one will be created.\n\n\nVNF Dependencies\n\n\nA VNF Dependency is composed by \n\n\n\n\n\n\n\n\nParams\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\nsource\n\n\nThe name of the VirtualNetworkFunctionDescriptor that provides one or more parameters (see \nVNFManager Generic\n and \nVNF Parameters\n)\n\n\n\n\n\n\ntarget\n\n\nThe name of the VirtualNetworkFunctionDescriptor that requires one or more parameters (see \nVNFManager Generic\n and \nVNF Parameters\n)\n\n\n\n\n\n\nparameters\n\n\nThe name of the parameters that the \ntarget\n requires\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Create the NSD"
        }, 
        {
            "location": "/ns-descriptor/#network-service-descriptor", 
            "text": "The Network Service Descriptor contains the values that are defined in  ETSI MANO specification . The NFVO is able to handle JSON file describing a Network Service Descriptor. An example of the most important fields follows:  {  \n     name : iperf-NSD ,\n     vendor : fokus ,\n     version : 0.1-ALPHA ,\n     vnfd :[  ...  ],\n     vld :[  \n        {  \n             name : private \n        }\n    ],\n     vnf_dependency :[\n        {\n             source  : {\n                 name :  iperf-server \n            },\n             target :{\n                 name :  iperf-client \n            },\n             parameters :[\n                 private \n            ]\n        }\n    ]\n}  You can see a complete NSD json  here .     Params  Meaning      name  The name to give to the NetworkServiceDescriptor    vendor  The vendor creating this NetworkServiceDescriptor    version  The version of the NetworkServiceDescriptor (can be any string)    vnfd  A list of VirtualNetworkFunctionDescriptors (see  VirtualNetworkFunctionDescriptor )    vld  A list of VirtualLinkDescriptors    vnf_dependency  A list of VNF_Dependencies     VirtualLinkDescriptor  The Virtual Link Descriptor (VLD) describes the basic topology of the connectivity between one or more VNFs connected to this VL.\nThe VLD must contain a parameter  name  with the value of a network that will be used by the VirtualNetworkFunctionDescriptors.\nIf the network exists, then this network will be used, if not a new one will be created.  VNF Dependencies  A VNF Dependency is composed by      Params  Meaning      source  The name of the VirtualNetworkFunctionDescriptor that provides one or more parameters (see  VNFManager Generic  and  VNF Parameters )    target  The name of the VirtualNetworkFunctionDescriptor that requires one or more parameters (see  VNFManager Generic  and  VNF Parameters )    parameters  The name of the parameters that the  target  requires       \n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Network Service Descriptor"
        }, 
        {
            "location": "/nfvo-how-to-use-gui/", 
            "text": "OpenBaton Dashboard\n\n\nThe Dashboard of OpenBaton helps you managing the lifecycle of different objects like \nVimInstaces, Network Service Descriptors/Records and Virtual Network Function Descriptors/Records in the OpenBaton environment.\n\n\nLogin\n\n\nThe first page that you will see after typing \nhttp://url-to-nfvo:8080\n or \nhttps://url-to-nfvo:8443\n (depends whether SSL is enabled or not) into your browser is the following login form.\n\n\n\n\nThe default user is called \nadmin\n and has the password \nopenbaton\n. \n\n\nOverview\n\n\nThe index page shows an overview of the state of the NFVO \n\n\n\n\nNumber of Network Service Records\n\n\nNumber of Virtual Network Functions\n\n\nNumber of Network Service Descriptors\n\n\n\n\n\n\nSecurity\n\n\nThe NFVO uses projects and users with assigned roles so that multiple selected users can work in the same project environment.\n\nThe parts of the GUI to manage users and projects are marked red in the following screenshot. \n\n\n\n\nIn the upper right corner you can see a the current project in which you are working next to the folder label.\n\nClick on it to switch to other projects you have access to.\n\nNext to this you can see your user name. Click on it to extend a menu with the logout button. \nYou can also change the password by choosing the command in this menu or use the \"help\" button to open the documentation. \n\n\nIf you select \nProjects\n or \nUsers\n under the \nIdentity\n menu item on the left side you will get to overviews of the selected subject. There you can see, add and remove projects and users \nif you are authorized\n. \n\n\nThe following screenshot shows the creation of a new user named \nnew user\n who is assigned to the project \ndefault\n as a \nGUEST\n and to the project \nanother project\n as an \nADMIN\n.\n\n\n\n\nThe NFVO also supports SSL. If SSL is enabled you have to use \nhttps://url-to-nfvo:8443\n to access the GUI. \n\n\nManage PoPs\n\n\nOn this page you can see the list of Vim Instances registered\n\n\n\n\nFor registering a new Vim Instance you should click on the button in the top-right corner \nRegister Vim\n of this page and select your json to register a Vim Instance\n\n\n\n\nIf you want to delete a Vim Instance you can click on the button \nAction\n and then \nDelete\n in the menu\n\n\nCatalogue\n\n\nIn the menu on the left side under the template \nCatalogue\n you can manage \n\n\n\n\nNS Descriptors\n\n\nVNF Packages\n\n\n\n\nNetwork Service Descriptors\n\n\nIn the menu on the left side under the template Catalogue you can find the \nNS Decriptors\n button.\nOn this page you can see the list of NS Descriptors stored in OpenBaton\n\n\n\n\nYou have two options for storing a NS Descriptor:\n\n\n\n\nCreate a NSD by using the VNFDs from the Packages\n\n\nCreate a NSD by using a json file\n\n\n\n\nUpload a json-file that contains the NSD\n\n\n\n\nCreate a NSD by using the VNFD from the Packages, just click on the button \"Create NSD\".\n\nThis is the form which allows you to choose the VNFDs to be used in the NSD come from the Catalogue (and contained inside the VNFPackages)\n\n\n\n\nOnce you have added the VNFDs to the NSD you can add one or more VLD and VNF Dependency like in the picture below using the + button\n\n\n\n\nIn the picture below you can see how to add a VNF Dependency to the NSD and possible parameters by clicking on \nDependencies +\n\n\n\n\nNetwork Service Descriptor Information\n\n\nIf you click on the id of a NSD shown in the list of NSDs you can see the information\nstored in this Network Service Descriptor.\n\n\n\n\nYou can observe the NSD in json format by clicking on the \nShow JSON\n button\n\n\n\n\nOn the page \nNetwork Service Descriptor Information\n you can also look at the \nGraphical view\n of the Network Service Descriptor \nby clicking on \nShow Graph\n\n\n\n\nIf you click on the \nAction\n button in the list of VNFDs you can delete the VNFD from the NSD\nand the information about the \nDependencies\n stored in the Network Service Descriptor\n\n\n\n\nIf you click on the \nAction\n button in the list of VNFDependencies you can delete the VNFDependency from the NSD\n\n\nEdit a Network Service Descriptor\n\n\nIf you want to Edit the NSD just click on the \nEdit\n button under the button \nAction\n in the list of NSD\n\n\n\n\nThe same for the VNF inside the NSD\n\n\n\n\n\n\nAnd the same for the VDU inside the VNF\n\n\n\n\n\n\nVirtual Network Function Descriptor Information\n\n\nIn the list of Virtual Network Function Descriptors in NSD template you can click on the id of a Virtual Network Function Descriptor to get to this page\n\n\n\n\nAt the bottom of the page you can see the Virtual Deployment Unit (VDU) tab and if you click on the \nid\n of the \nVDU you can see the details of it\n\n\n\n\nVNF Packages\n\n\nOn this page you can upload the \nVNF Package\n. For more information about the VNF Package please read the \nVNF Package documentation\n \nFor uploading a \n.tar\n you can click on the button \nUpload VNFPackage\n and this window will be shown where you can drag \n drop the file or just click on the white area and choose your file using your file manager\n\n\n\n\nAfter you click on the button \nSend All\n the packages will be sent to the \nNFVO\n and once the process is finished you will see the package appearing in the list\n\n\n\n\n\n\nNetwork Service Records\n\n\nIn the menu on the left side if you click on the \nOrchestrator NS\n and then \nNS Records\n you will see the list of \nNetwork Service Records\n\nLike in this screenshot \n\n\n\n\nOn this page you can see the details of a Network Service Record by clicking on the id\n\n\n\n\nOn this page you can look at the JSON file of the NSR by clicking on the link \nShow JSON\n and also the \nGraphical view\n. \nof Network Service Record by clicking on the link \nShow Graph\n. \nIn the table of VNF Records you can delete a VNFR by clicking on \nAction\n and then \nDelete\n. \nTo look at the details of a VNFR just click on the \nid\n of it.\n\n\n\n\nEvent\n\n\nThe Events are sent by the Orchestrator to the specific \nEndPoint\n where an external component is listening to be aware when the Orchestrator \nchanges the STATE of a particular \nvirtualNetworkFunctionId\n or \nnetworkServiceId\n\n\nTo add a new Event just click the button \"Create event\" and will be shown the form as follow:\n\n\n\n\nFor getting the information click on the id link of the Event\n\n\n\n\nThis are the information of the Event selected\n\n\n\n\n\n\n\n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  &amp;&amp; (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Use via the Dashboard"
        }, 
        {
            "location": "/nfvo-how-to-use-gui/#openbaton-dashboard", 
            "text": "The Dashboard of OpenBaton helps you managing the lifecycle of different objects like \nVimInstaces, Network Service Descriptors/Records and Virtual Network Function Descriptors/Records in the OpenBaton environment.", 
            "title": "OpenBaton Dashboard"
        }, 
        {
            "location": "/nfvo-how-to-use-gui/#login", 
            "text": "The first page that you will see after typing  http://url-to-nfvo:8080  or  https://url-to-nfvo:8443  (depends whether SSL is enabled or not) into your browser is the following login form.   The default user is called  admin  and has the password  openbaton .", 
            "title": "Login"
        }, 
        {
            "location": "/nfvo-how-to-use-gui/#overview", 
            "text": "The index page shows an overview of the state of the NFVO    Number of Network Service Records  Number of Virtual Network Functions  Number of Network Service Descriptors", 
            "title": "Overview"
        }, 
        {
            "location": "/nfvo-how-to-use-gui/#security", 
            "text": "The NFVO uses projects and users with assigned roles so that multiple selected users can work in the same project environment. \nThe parts of the GUI to manage users and projects are marked red in the following screenshot.    In the upper right corner you can see a the current project in which you are working next to the folder label. \nClick on it to switch to other projects you have access to. \nNext to this you can see your user name. Click on it to extend a menu with the logout button. \nYou can also change the password by choosing the command in this menu or use the \"help\" button to open the documentation.   If you select  Projects  or  Users  under the  Identity  menu item on the left side you will get to overviews of the selected subject. There you can see, add and remove projects and users  if you are authorized .   The following screenshot shows the creation of a new user named  new user  who is assigned to the project  default  as a  GUEST  and to the project  another project  as an  ADMIN .   The NFVO also supports SSL. If SSL is enabled you have to use  https://url-to-nfvo:8443  to access the GUI.", 
            "title": "Security"
        }, 
        {
            "location": "/nfvo-how-to-use-gui/#manage-pops", 
            "text": "On this page you can see the list of Vim Instances registered   For registering a new Vim Instance you should click on the button in the top-right corner  Register Vim  of this page and select your json to register a Vim Instance   If you want to delete a Vim Instance you can click on the button  Action  and then  Delete  in the menu", 
            "title": "Manage PoPs"
        }, 
        {
            "location": "/nfvo-how-to-use-gui/#catalogue", 
            "text": "In the menu on the left side under the template  Catalogue  you can manage    NS Descriptors  VNF Packages   Network Service Descriptors  In the menu on the left side under the template Catalogue you can find the  NS Decriptors  button.\nOn this page you can see the list of NS Descriptors stored in OpenBaton   You have two options for storing a NS Descriptor:   Create a NSD by using the VNFDs from the Packages  Create a NSD by using a json file   Upload a json-file that contains the NSD   Create a NSD by using the VNFD from the Packages, just click on the button \"Create NSD\". \nThis is the form which allows you to choose the VNFDs to be used in the NSD come from the Catalogue (and contained inside the VNFPackages)   Once you have added the VNFDs to the NSD you can add one or more VLD and VNF Dependency like in the picture below using the + button   In the picture below you can see how to add a VNF Dependency to the NSD and possible parameters by clicking on  Dependencies +   Network Service Descriptor Information  If you click on the id of a NSD shown in the list of NSDs you can see the information\nstored in this Network Service Descriptor.   You can observe the NSD in json format by clicking on the  Show JSON  button   On the page  Network Service Descriptor Information  you can also look at the  Graphical view  of the Network Service Descriptor \nby clicking on  Show Graph   If you click on the  Action  button in the list of VNFDs you can delete the VNFD from the NSD\nand the information about the  Dependencies  stored in the Network Service Descriptor   If you click on the  Action  button in the list of VNFDependencies you can delete the VNFDependency from the NSD  Edit a Network Service Descriptor  If you want to Edit the NSD just click on the  Edit  button under the button  Action  in the list of NSD   The same for the VNF inside the NSD    And the same for the VDU inside the VNF    Virtual Network Function Descriptor Information  In the list of Virtual Network Function Descriptors in NSD template you can click on the id of a Virtual Network Function Descriptor to get to this page   At the bottom of the page you can see the Virtual Deployment Unit (VDU) tab and if you click on the  id  of the \nVDU you can see the details of it   VNF Packages  On this page you can upload the  VNF Package . For more information about the VNF Package please read the  VNF Package documentation  \nFor uploading a  .tar  you can click on the button  Upload VNFPackage  and this window will be shown where you can drag   drop the file or just click on the white area and choose your file using your file manager   After you click on the button  Send All  the packages will be sent to the  NFVO  and once the process is finished you will see the package appearing in the list", 
            "title": "Catalogue"
        }, 
        {
            "location": "/nfvo-how-to-use-gui/#network-service-records", 
            "text": "In the menu on the left side if you click on the  Orchestrator NS  and then  NS Records  you will see the list of  Network Service Records \nLike in this screenshot    On this page you can see the details of a Network Service Record by clicking on the id   On this page you can look at the JSON file of the NSR by clicking on the link  Show JSON  and also the  Graphical view . \nof Network Service Record by clicking on the link  Show Graph . \nIn the table of VNF Records you can delete a VNFR by clicking on  Action  and then  Delete . \nTo look at the details of a VNFR just click on the  id  of it.", 
            "title": "Network Service Records"
        }, 
        {
            "location": "/nfvo-how-to-use-gui/#event", 
            "text": "The Events are sent by the Orchestrator to the specific  EndPoint  where an external component is listening to be aware when the Orchestrator \nchanges the STATE of a particular  virtualNetworkFunctionId  or  networkServiceId  To add a new Event just click the button \"Create event\" and will be shown the form as follow:   For getting the information click on the id link of the Event   This are the information of the Event selected    \n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  &amp;&amp; (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Event"
        }, 
        {
            "location": "/nfvo-how-to-use-cli/", 
            "text": "OpenBaton Command Line Interface (CLI)\n\n\nThe Openbaton Client project provides a command-line interface, which enables you to use the NFVO's API and send commands to it. \n\n\nInstall the Openbaton Client\n\n\nGit clone the project. Navigate into the root directory of the project and execute \n./gradlew build\n.\n\n\ngit clone https://github.com/openbaton/openbaton-client.git\ncd openbaton-client\n./gradlew build\n\n\n\n\nSet the required environment variables\n\n\nNavigate into the project's root directory and execute \nsource nfvo.properties\n. A dialog appears and will ask you for some properties. \n\n\ncd openbaton-client\nsource nfvo.properties\n\n\n\n\nOpenbaton Client usage\n\n\nAfter you typed in all the required properties you can start using the cli for sending commands to the NFVO. \n\n\nRun a command:\n\n\n### openbaton.sh command-name [arg-1] [arg-2] [arg-3]\n\n\n\n\nShow the configuration:\n\n\nopenbaton.sh -c\n\n\n\n\nActivate debug mode:\n\n\nopenbaton.sh -d command-name [arg-1] [arg-2] [arg-3]\n\n\n\n\nPrint help:\n\n\nopenbaton.sh -h\n\n\n\n\nPrint help for a command:\n\n\nopenbaton.sh command-name help\n\n\n\n\nList the available commands:\n\n\nopenbaton.sh -l\n\n\n\n\nFor help on a specific openbaton command, enter:\n\n\n $ openbaton.sh COMMAND help\n\n\n\n\nAvailable commands\n\n\nIn the following section we list all the currently avalilable commands for the cli grouped by the components they work with. \n\n\nVim Instance Subcommands\n\n\ncreate\n\n\n\n\nCreate a Vim Instance \n\n\n\n\n $ openbaton.sh VimInstance-create file.json\n\n\n\n\ndelete\n\n\n\n\nDelete the Vim Instance with the specified id\n\n\n\n\n $ openbaton.sh VimInstance-delete id-vim-instance\n\n\n\n\nupdate\n\n\n\n\nUpdate a Vim Instance by passing a file containing the new one and the id of the old one\n\n\n\n\n $ openbaton.sh VimInstance-update file.json id-vim-instance\n\n\n\n\nfindAll\n\n\n\n\nFind all Vim Instances\n\n\n\n\n $ openbaton.sh VimInstance-findAll\n\n\n\n\nfindById\n\n\n\n\nFind a Vim Instance specified by the id\n\n\n\n\n $ openbaton.sh VimInstance-findById id-vim-instance\n\n\n\n\nNetwork Service Descriptor Subcommands\n\n\ncreate\n\n\n\n\nCreate a Network Service Descriptor\n\n\n\n\n $ openbaton.sh NetworkServiceDescriptor-create file.json\n\n\n\n\ndelete\n\n\n\n\nDelete a Network Service Descriptor passing its id\n\n\n\n\n $ openbaton.sh NetworkServiceDescriptor-delete id-network-service-descriptor\n\n\n\n\nfindAll\n\n\n\n\nFind all Network Service Descriptors\n\n\n\n\n $ openbaton.sh NetworkServiceDescriptor-findAll\n\n\n\n\nfindById\n\n\n\n\nFind a Network Service Descriptor by passing its id\n\n\n\n\n $ openbaton.sh NetworkServiceDescriptor-findById id-network-service-descriptor\n\n\n\n\ncreateVNFDependency\n\n\n\n\nCreate a Virtual Network Function Descriptor dependency for a Network Service Descriptor with a specific id\n\n\n\n\n $ openbaton.sh NetworkServiceDescriptor-createVNFDependency id-network-service-descriptor file.json\n\n\n\n\nThe file should look similar to this:\n\n\n{\n \nparameters\n:[\ntheParameter\n], \n \nversion\n:1, \n \nsource\n:{\nid\n:\n950811b6-ebb6-4a17-bf4e-ab61974acbc8\n}, \n \ntarget\n: {\nid\n:\n9873ad54-2963-424d-ab5d-39403a5dd544\n}\n}\n\n\n\n\nThe ids belong to the particular VirtualNettworkFunctionDescriptor.\n\n\ndeleteVNFDependency\n\n\n\n\nDelete the Virtual Network Function Descriptor dependency of a Network Service Descriptor with a specific id\n\n\n\n\n   $ openbaton.sh NetworkServiceDescriptor-deleteVNFDependency id-network-service-descriptor id-vnfdependency\n\n\n\n\ngetVNFDependencies\n\n\n\n\nGet all the Virtual Network Function Descriptor Dependencies of a Network Service Descriptor with a specific id\n\n\n\n\n $ openbaton.sh NetworkServiceDescriptor-getVNFDependencies id-network-service-descriptor\n\n\n\n\ngetVNFDependency\n\n\n\n\nGet the VirtualNetwork Function Descriptor Dependency with a specific id of a Network Service Descriptor with a specific id\n\n\n\n\n $ openbaton.sh NetworkServiceDescriptor-getVNFDependency id-network-service-descriptor id-vnfdependency\n\n\n\n\ngetVirtualNetworkFunctionDescriptors\n\n\n\n\nFind all Virtual Network Function Descriptors\n\n\n\n\n $ openbaton.sh NetworkServiceDescriptor-getVirtualNetworkFunctionDescriptors id-network-service-descriptor\n\n\n\n\ngetVirtualNetworkFunctionDescriptor\n\n\n\n\nFind a Virtual Network Function Descriptor specified by its id\n\n\n\n\n$ openbaton.sh NetworkServiceDescriptor-getVirtualNetworkFunctionDescriptor id-network-service-descriptor id-vnfd\n\n\n\n\nVirtual Network Function Descriptor Subcommands\n\n\n\n\ncreate\n\n\nCreate a Virtual Network Function Descriptor\n\n\n\n\n $ openbaton.sh VirtualNetworkFunctionDescriptor-create file.json\n\n\n\n\n\n\ndelete\n\n\nDelete a Virtual Network Function Descriptor passing its id\n\n\n\n\n $ openbaton.sh VirtualNetworkFunctionDescriptor-delete id-virtual-network-function-descriptor\n\n\n\n\n\n\nfindAll\n\n\nFind all Virtual Network Function Descriptors\n\n\n\n\n $ openbaton.sh VirtualNetworkFunctionDescriptor-findAll\n\n\n\n\n\n\nfindById\n\n\nFind a Virtual Network Function Descriptor by passing its id\n\n\n\n\n $ openbaton.sh VirtualNetworkFunctionDescriptor-findById id-virtual-network-function-descriptor\n\n\n\n\nNetwork Service Record Subcommands\n\n\ncreate\n\n\n\n\nCreate a Network Service Record from a file\n\n\n\n\n $ openbaton.sh NetworkServiceRecord-create file.json\n\n\n\n\ncreate\n\n\n\n\nCreate a Network Service Record from a Network Service Descriptor stored in the orchestrator\n\n\n\n\n $ openbaton.sh NetworkServiceRecord-create id-network-service-descriptor\n\n\n\n\ndelete\n\n\n\n\nDelete a Network Service Record passing its id\n\n\n\n\n $ openbaton.sh NetworkServiceRecord-delete id-network-service-record\n\n\n\n\nupdate\n\n\n\n\nUpdate the Network Service Record by passing a file with the new version of it and the id of the Network Service Record to update\n\n\n\n\n$ openbaton.sh NetworkServiceRecord-update file.json id-network-service-record \n\n\n\n\nfindAll\n\n\n\n\nFind all Network Service Records\n\n\n\n\n $ openbaton.sh NetworkServiceRecord-findAll \n\n\n\n\nfindById\n\n\n\n\nFind a Network Service Record by passing its id\n\n\n\n\n $ openbaton.sh NetworkServiceRecord-findById id-network-service-record\n\n\n\n\ngetVirtualNetworkFunctionRecords\n\n\n\n\nGet all the Virtual Network Function Records of a Network Service Record with a specific id\n\n\n\n\n $ openbaton.sh NetworkServiceRecord-getVirtualNetworkFunctionRecords id-network-service-record\n\n\n\n\ngetVirtualNetworkFunctionRecord\n\n\n\n\nGet the Virtual Network Function Record by providing its id of a Network Service Record with a specific id\n\n\n\n\n $ openbaton.sh NetworkServiceRecord-getVirtualNetworkFunctionRecord id-network-service-record id-vnfr\n\n\n\n\ndeleteVirtualNetworkFunctionRecord\n\n\n\n\nDelete the Virtual Network Function Record of a Network Service Record with a specific id\n\n\n\n\n $ openbaton.sh NetworkServiceRecord-deleteVirtualNetworkFunctionRecord id-network-service-record id-vnfr\n\n\n\n\n\n\n\n\ncreateVNFDependency\n\n\n\n\n\n\nCreate a Virtual Network Function Record Dependency of a NetworkServiceRecord with a specific id\n\n\n\n\n\n\n $ openbaton.sh NetworkServiceRecord-createVNFDependency id-network-service-record file.json\n\n\n\n\n\n\n\n\ndeleteVNFDependency\n\n\n\n\n\n\nDelete the Virtual Network Function Record Dependency of a NetworkServiceRecord with a specific id\n  \nsh\n   $ openbaton.sh NetworkServiceRecord-deleteVNFDependency id-network-service-record id-vnfdependency\n\n\n\n\n\n\ngetVNFDependencies\n\n\n\n\n\n\nGet all the Virtual Network Function Record Dependencies of a Network Service Record with a specific id\n\n\n\n\n\n\n $ openbaton.sh NetworkServiceRecord-getVNFDependencies id-network-service-record\n\n\n\n\n\n\n\n\ngetVNFDependency\n\n\n\n\n\n\nGet the Virtual Network Function Record Dependency of a Network Service Record with a specific id\n\n\n\n\n\n\n $ openbaton.sh NetworkServiceRecord-getVNFDependency id-network-service-record id-vnfdependency\n\n\n\n\ncreateVNFCInstance\n\n\n\n\nPerform a SCALE_OUT operation on a Virtual Network Function by adding a VNFCInstance to its Virtual Network Function Record\n\n\n\n\n$ openbaton.sh NetworkServiceRecord-createVNFCInstance id-network-service-record id-virtual-network-function-record file.json\n\n\n\n\ndeleteVNFCInstance\n\n\n\n\nPerform a SCALE_IN operation on a Virtual Network Function by deleting a VNFCInstance from the Virtual Network Function Record\n\n\n\n\n$ openbaton.sh NetworkServiceRecord-deleteVNFCInstance id-network-service-record id-virtual-network-function-record\n\n\n\n\nEvent Subcommands\n\n\ncreate\n\n\n\n\nCreate an Event\n\n\n\n\n $ openbaton.sh Event-create file.json\n\n\n\n\ndelete\n\n\n\n\nDelete an Event passing its id\n\n\n\n\n$ openbaton.sh Event-delete id-event\n\n\n\n\nfindAll\n\n\n\n\nFind all Events\n\n\n\n\n$ openbaton.sh Event-findAll\n\n\n\n\nfindById\n\n\n\n\nFind an Event by passing its id\n\n\n\n\n$ openbaton.sh Event-findById id-event\n\n\n\n\nConfiguration Subcommands\n\n\ncreate\n\n\n\n\nCreate a Configuration\n\n\n\n\n$ openbaton.sh Configuration-create file.json\n\n\n\n\ndelete\n\n\n\n\nDelete a Configuration passing its id\n\n\n\n\n $ openbaton.sh Configuration-delete id-configuration\n\n\n\n\nfindAll\n\n\n\n\nFind all Configurations\n\n\n\n\n $ openbaton.sh Configuration-findAll\n\n\n\n\nfindById\n\n\n\n\nFind a Configuration by passint its id\n\n\n\n\n $ openbaton.sh Configuration-findById id-configuration\n\n\n\n\nImage Subcommands\n\n\ncreate\n\n\n\n\nCreate an Image\n\n\n\n\n $ openbaton.sh Image-create file.json\n\n\n\n\ndelete\n\n\n\n\nDelete an Image passing its id\n\n\n\n\n$ openbaton.sh Image-delete id-image\n\n\n\n\nfindAll\n\n\n\n\nFind all Images\n\n\n\n\n $ openbaton.sh Image-findAll\n\n\n\n\nfindById\n\n\n\n\nFind an Image by passing its id\n\n\n\n\n $ openbaton.sh Image-findById id-image \n\n\n\n\nVirtualLink Subcommands\n\n\ncreate\n\n\n\n\nCreate a Virtual Link\n\n\n\n\n $ openbaton.sh VirtualLink-create file.json \n\n\n\n\ndelete\n\n\n\n\nDelete a Virtual Link by passing its id\n\n\n\n\n $ openbaton.sh VirtualLink-delete id-virtual-link \n\n\n\n\nupdate\n\n\n\n\nUpdate a Virtual Link passing the new object and the id of the old Virtual Link\n\n\n\n\n $ openbaton.sh VirtualLink-update file.json id-virtual-link\n\n\n\n\nfindAll\n\n\n\n\nFind all Virtual Links\n\n\n\n\n $ openbaton.sh VirtualLink-findAll\n\n\n\n\nfindById\n\n\n\n\nFind a Virtual Link by passing its id\n\n\n\n\n $ openbaton.sh VirtualLink-findById id-virtual-link\n\n\n\n\nVNFPackage Subcommands\n\n\ncreate\n\n\n\n\nCreate a VNFPackage by uploading a tar file to the NFVO\n\n\n\n\n $ openbaton.sh VNFPackage-upload file.tar \n\n\n\n\ndelete\n\n\n\n\nDelete a VNFPackage by passing its id\n\n\n\n\n $ openbaton.sh VNFPackage-delete id-vnfPackage \n\n\n\n\nfindAll\n\n\n\n\nFind all VNFPackages\n\n\n\n\n $ openbaton.sh VNFPackage-findAll\n\n\n\n\nfindById\n\n\n\n\nFind a VNFPackage by passing its id\n\n\n\n\n $ openbaton.sh VNFPackage-findById id-vnfPackage\n\n\n\n\n\n\n\n\n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Use via the CLI"
        }, 
        {
            "location": "/nfvo-how-to-use-cli/#openbaton-command-line-interface-cli", 
            "text": "The Openbaton Client project provides a command-line interface, which enables you to use the NFVO's API and send commands to it.", 
            "title": "OpenBaton Command Line Interface (CLI)"
        }, 
        {
            "location": "/nfvo-how-to-use-cli/#install-the-openbaton-client", 
            "text": "Git clone the project. Navigate into the root directory of the project and execute  ./gradlew build .  git clone https://github.com/openbaton/openbaton-client.git\ncd openbaton-client\n./gradlew build  Set the required environment variables  Navigate into the project's root directory and execute  source nfvo.properties . A dialog appears and will ask you for some properties.   cd openbaton-client\nsource nfvo.properties", 
            "title": "Install the Openbaton Client"
        }, 
        {
            "location": "/nfvo-how-to-use-cli/#openbaton-client-usage", 
            "text": "After you typed in all the required properties you can start using the cli for sending commands to the NFVO.   Run a command:  ### openbaton.sh command-name [arg-1] [arg-2] [arg-3]  Show the configuration:  openbaton.sh -c  Activate debug mode:  openbaton.sh -d command-name [arg-1] [arg-2] [arg-3]  Print help:  openbaton.sh -h  Print help for a command:  openbaton.sh command-name help  List the available commands:  openbaton.sh -l  For help on a specific openbaton command, enter:   $ openbaton.sh COMMAND help", 
            "title": "Openbaton Client usage"
        }, 
        {
            "location": "/nfvo-how-to-use-cli/#available-commands", 
            "text": "In the following section we list all the currently avalilable commands for the cli grouped by the components they work with.   Vim Instance Subcommands  create   Create a Vim Instance     $ openbaton.sh VimInstance-create file.json  delete   Delete the Vim Instance with the specified id    $ openbaton.sh VimInstance-delete id-vim-instance  update   Update a Vim Instance by passing a file containing the new one and the id of the old one    $ openbaton.sh VimInstance-update file.json id-vim-instance  findAll   Find all Vim Instances    $ openbaton.sh VimInstance-findAll  findById   Find a Vim Instance specified by the id    $ openbaton.sh VimInstance-findById id-vim-instance  Network Service Descriptor Subcommands  create   Create a Network Service Descriptor    $ openbaton.sh NetworkServiceDescriptor-create file.json  delete   Delete a Network Service Descriptor passing its id    $ openbaton.sh NetworkServiceDescriptor-delete id-network-service-descriptor  findAll   Find all Network Service Descriptors    $ openbaton.sh NetworkServiceDescriptor-findAll  findById   Find a Network Service Descriptor by passing its id    $ openbaton.sh NetworkServiceDescriptor-findById id-network-service-descriptor  createVNFDependency   Create a Virtual Network Function Descriptor dependency for a Network Service Descriptor with a specific id    $ openbaton.sh NetworkServiceDescriptor-createVNFDependency id-network-service-descriptor file.json  The file should look similar to this:  {\n  parameters :[ theParameter ], \n  version :1, \n  source :{ id : 950811b6-ebb6-4a17-bf4e-ab61974acbc8 }, \n  target : { id : 9873ad54-2963-424d-ab5d-39403a5dd544 }\n}  The ids belong to the particular VirtualNettworkFunctionDescriptor.  deleteVNFDependency   Delete the Virtual Network Function Descriptor dependency of a Network Service Descriptor with a specific id      $ openbaton.sh NetworkServiceDescriptor-deleteVNFDependency id-network-service-descriptor id-vnfdependency  getVNFDependencies   Get all the Virtual Network Function Descriptor Dependencies of a Network Service Descriptor with a specific id    $ openbaton.sh NetworkServiceDescriptor-getVNFDependencies id-network-service-descriptor  getVNFDependency   Get the VirtualNetwork Function Descriptor Dependency with a specific id of a Network Service Descriptor with a specific id    $ openbaton.sh NetworkServiceDescriptor-getVNFDependency id-network-service-descriptor id-vnfdependency  getVirtualNetworkFunctionDescriptors   Find all Virtual Network Function Descriptors    $ openbaton.sh NetworkServiceDescriptor-getVirtualNetworkFunctionDescriptors id-network-service-descriptor  getVirtualNetworkFunctionDescriptor   Find a Virtual Network Function Descriptor specified by its id   $ openbaton.sh NetworkServiceDescriptor-getVirtualNetworkFunctionDescriptor id-network-service-descriptor id-vnfd  Virtual Network Function Descriptor Subcommands   create  Create a Virtual Network Function Descriptor    $ openbaton.sh VirtualNetworkFunctionDescriptor-create file.json   delete  Delete a Virtual Network Function Descriptor passing its id    $ openbaton.sh VirtualNetworkFunctionDescriptor-delete id-virtual-network-function-descriptor   findAll  Find all Virtual Network Function Descriptors    $ openbaton.sh VirtualNetworkFunctionDescriptor-findAll   findById  Find a Virtual Network Function Descriptor by passing its id    $ openbaton.sh VirtualNetworkFunctionDescriptor-findById id-virtual-network-function-descriptor  Network Service Record Subcommands  create   Create a Network Service Record from a file    $ openbaton.sh NetworkServiceRecord-create file.json  create   Create a Network Service Record from a Network Service Descriptor stored in the orchestrator    $ openbaton.sh NetworkServiceRecord-create id-network-service-descriptor  delete   Delete a Network Service Record passing its id    $ openbaton.sh NetworkServiceRecord-delete id-network-service-record  update   Update the Network Service Record by passing a file with the new version of it and the id of the Network Service Record to update   $ openbaton.sh NetworkServiceRecord-update file.json id-network-service-record   findAll   Find all Network Service Records    $ openbaton.sh NetworkServiceRecord-findAll   findById   Find a Network Service Record by passing its id    $ openbaton.sh NetworkServiceRecord-findById id-network-service-record  getVirtualNetworkFunctionRecords   Get all the Virtual Network Function Records of a Network Service Record with a specific id    $ openbaton.sh NetworkServiceRecord-getVirtualNetworkFunctionRecords id-network-service-record  getVirtualNetworkFunctionRecord   Get the Virtual Network Function Record by providing its id of a Network Service Record with a specific id    $ openbaton.sh NetworkServiceRecord-getVirtualNetworkFunctionRecord id-network-service-record id-vnfr  deleteVirtualNetworkFunctionRecord   Delete the Virtual Network Function Record of a Network Service Record with a specific id    $ openbaton.sh NetworkServiceRecord-deleteVirtualNetworkFunctionRecord id-network-service-record id-vnfr    createVNFDependency    Create a Virtual Network Function Record Dependency of a NetworkServiceRecord with a specific id     $ openbaton.sh NetworkServiceRecord-createVNFDependency id-network-service-record file.json    deleteVNFDependency    Delete the Virtual Network Function Record Dependency of a NetworkServiceRecord with a specific id\n   sh\n   $ openbaton.sh NetworkServiceRecord-deleteVNFDependency id-network-service-record id-vnfdependency    getVNFDependencies    Get all the Virtual Network Function Record Dependencies of a Network Service Record with a specific id     $ openbaton.sh NetworkServiceRecord-getVNFDependencies id-network-service-record    getVNFDependency    Get the Virtual Network Function Record Dependency of a Network Service Record with a specific id     $ openbaton.sh NetworkServiceRecord-getVNFDependency id-network-service-record id-vnfdependency  createVNFCInstance   Perform a SCALE_OUT operation on a Virtual Network Function by adding a VNFCInstance to its Virtual Network Function Record   $ openbaton.sh NetworkServiceRecord-createVNFCInstance id-network-service-record id-virtual-network-function-record file.json  deleteVNFCInstance   Perform a SCALE_IN operation on a Virtual Network Function by deleting a VNFCInstance from the Virtual Network Function Record   $ openbaton.sh NetworkServiceRecord-deleteVNFCInstance id-network-service-record id-virtual-network-function-record  Event Subcommands  create   Create an Event    $ openbaton.sh Event-create file.json  delete   Delete an Event passing its id   $ openbaton.sh Event-delete id-event  findAll   Find all Events   $ openbaton.sh Event-findAll  findById   Find an Event by passing its id   $ openbaton.sh Event-findById id-event  Configuration Subcommands  create   Create a Configuration   $ openbaton.sh Configuration-create file.json  delete   Delete a Configuration passing its id    $ openbaton.sh Configuration-delete id-configuration  findAll   Find all Configurations    $ openbaton.sh Configuration-findAll  findById   Find a Configuration by passint its id    $ openbaton.sh Configuration-findById id-configuration  Image Subcommands  create   Create an Image    $ openbaton.sh Image-create file.json  delete   Delete an Image passing its id   $ openbaton.sh Image-delete id-image  findAll   Find all Images    $ openbaton.sh Image-findAll  findById   Find an Image by passing its id    $ openbaton.sh Image-findById id-image   VirtualLink Subcommands  create   Create a Virtual Link    $ openbaton.sh VirtualLink-create file.json   delete   Delete a Virtual Link by passing its id    $ openbaton.sh VirtualLink-delete id-virtual-link   update   Update a Virtual Link passing the new object and the id of the old Virtual Link    $ openbaton.sh VirtualLink-update file.json id-virtual-link  findAll   Find all Virtual Links    $ openbaton.sh VirtualLink-findAll  findById   Find a Virtual Link by passing its id    $ openbaton.sh VirtualLink-findById id-virtual-link  VNFPackage Subcommands  create   Create a VNFPackage by uploading a tar file to the NFVO    $ openbaton.sh VNFPackage-upload file.tar   delete   Delete a VNFPackage by passing its id    $ openbaton.sh VNFPackage-delete id-vnfPackage   findAll   Find all VNFPackages    $ openbaton.sh VNFPackage-findAll  findById   Find a VNFPackage by passing its id    $ openbaton.sh VNFPackage-findById id-vnfPackage   \n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Available commands"
        }, 
        {
            "location": "/nfvo-sdk/", 
            "text": "NFVO SDK\n\n\nA SDK is available if you want to use the NFVO from a java application.\n\n\nImport it\n\n\nThe build.gradle file must contain:\n\n\nrepositories {\n    mavenCentral()\n    maven {\n        url \nhttp://get.openbaton.org:8081/nexus/content/groups/public\n\n    }\n}\n\ndependencies {\n    compile 'org.openbaton:sdk:2.1.1'\n}\n\n\n\n\nIn this way you will have access to the NFVO SDK.\n\n\nAnd then?\n\n\nThe UML diagram of the classes follows:\n\n\n\n\nThe NFVORequestor is the main and only class you need to use. From this class it is possible to retrieve all the Agents that are in charge of making calls to the NFVO. The NFVORequestor takes as constructor parameters:\n\n\n\n\n\n\n\n\nParams\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nusername\n\n\nthe username\n\n\n\n\n\n\npassword\n\n\nthe password\n\n\n\n\n\n\nprojectId\n\n\nthe id of the project to use\n\n\n\n\n\n\nsslEnabled\n\n\nset this to true if the NFVO uses SSL\n\n\n\n\n\n\nnfvoIp\n\n\nthe ip of the NFVO\n\n\n\n\n\n\nnfvoPort\n\n\nthe port of the orchestrator\n\n\n\n\n\n\nversion\n\n\nthe API version. Now only \"1\" is available\n\n\n\n\n\n\n\n\nOnce you have the NFVORequestor object, you can get the Agents. Available agents are:\n\n\n\n\nConfigurationRestRequest\n\n\nEventAgent\n\n\nImageRestAgent\n\n\nNetworkServiceDescriptorRestAgent\n\n\nVirtualNetworkFunctionDescriptorRestAgent\n\n\nNetworkServiceRecordRestAgent\n\n\nProjectAgent\n\n\nUserAgent\n\n\nVimInstanceRestAgent\n\n\nVirtualLinkRestAgent\n\n\nVNFFGRestAgent\n\n\nVNFPackageAgent\n\n\n\n\neach of them exposes these methods:\n\n\n\n\ncreate\n\n\nfindById\n\n\nfindAll\n\n\ndelete\n\n\nupdate\n\n\n\n\nplus some specific methods and they refer to the \ncatalogue\n class contained in the name of the Agent. For instance, the NetworkServiceDescriptorRestAgent refers to NetworkServiceDescriptor class and, besides the above methods, exposes:\n\n\n\n\ngetVirtualNetworkFunctionDescriptors\n\n\ngetVirtualNetworkFunctionDescriptor\n\n\ndeleteVirtualNetworkFunctionDescriptors\n\n\ncreateVNFD\n\n\nupdateVNFD\n\n\ngetVNFDependencies\n\n\ngetVNFDependency\n\n\ndeleteVNFDependency\n\n\ncreateVNFDependency\n\n\nupdateVNFD\n\n\ngetPhysicalNetworkFunctionDescriptors\n\n\ngetPhysicalNetworkFunctionDescriptor\n\n\ndeletePhysicalNetworkFunctionDescriptor\n\n\ncreatePhysicalNetworkFunctionDescriptor\n\n\nupdatePNFD\n\n\ngetSecurities\n\n\ndeleteSecurity\n\n\ncreateSecurity\n\n\nupdateSecurity\n\n\n\n\nThe method names are explicit, they do what the name explains.\n\n\nUsage example\n\n\nCreate a VimInstance using the SDK\n\n\npublic class Main {\n\n    public static void main(String[] args) {\n        boolean sslEnabled = true;\n        NFVORequestor nfvoRequestor = new NFVORequestor(\nusername\n, \npassword\n, \nprojectId\n, sslEnabled, \nnfvo_ip\n, \nnfvo_port\n, \n1\n);\n        VimInstanceRestAgent vimInstanceAgent = nfvoRequestor.getVimInstanceAgent();\n\n        VimInstance vimInstance = new VimInstance();\n\n        // fill the vimInstance object accordingly to your VIM chosen\n\n        try {\n            vimInstance = vimInstanceAgent.create(vimInstance);\n        } catch (SDKException e) {\n            e.printStackTrace();\n        }\n\n        System.out.println(\nCreated VimInstance with id: \n + vimInstance.getId());\n    }\n}", 
            "title": "Use via the SDK"
        }, 
        {
            "location": "/nfvo-sdk/#nfvo-sdk", 
            "text": "A SDK is available if you want to use the NFVO from a java application.  Import it  The build.gradle file must contain:  repositories {\n    mavenCentral()\n    maven {\n        url  http://get.openbaton.org:8081/nexus/content/groups/public \n    }\n}\n\ndependencies {\n    compile 'org.openbaton:sdk:2.1.1'\n}  In this way you will have access to the NFVO SDK.  And then?  The UML diagram of the classes follows:   The NFVORequestor is the main and only class you need to use. From this class it is possible to retrieve all the Agents that are in charge of making calls to the NFVO. The NFVORequestor takes as constructor parameters:     Params  Description      username  the username    password  the password    projectId  the id of the project to use    sslEnabled  set this to true if the NFVO uses SSL    nfvoIp  the ip of the NFVO    nfvoPort  the port of the orchestrator    version  the API version. Now only \"1\" is available     Once you have the NFVORequestor object, you can get the Agents. Available agents are:   ConfigurationRestRequest  EventAgent  ImageRestAgent  NetworkServiceDescriptorRestAgent  VirtualNetworkFunctionDescriptorRestAgent  NetworkServiceRecordRestAgent  ProjectAgent  UserAgent  VimInstanceRestAgent  VirtualLinkRestAgent  VNFFGRestAgent  VNFPackageAgent   each of them exposes these methods:   create  findById  findAll  delete  update   plus some specific methods and they refer to the  catalogue  class contained in the name of the Agent. For instance, the NetworkServiceDescriptorRestAgent refers to NetworkServiceDescriptor class and, besides the above methods, exposes:   getVirtualNetworkFunctionDescriptors  getVirtualNetworkFunctionDescriptor  deleteVirtualNetworkFunctionDescriptors  createVNFD  updateVNFD  getVNFDependencies  getVNFDependency  deleteVNFDependency  createVNFDependency  updateVNFD  getPhysicalNetworkFunctionDescriptors  getPhysicalNetworkFunctionDescriptor  deletePhysicalNetworkFunctionDescriptor  createPhysicalNetworkFunctionDescriptor  updatePNFD  getSecurities  deleteSecurity  createSecurity  updateSecurity   The method names are explicit, they do what the name explains.  Usage example  Create a VimInstance using the SDK  public class Main {\n\n    public static void main(String[] args) {\n        boolean sslEnabled = true;\n        NFVORequestor nfvoRequestor = new NFVORequestor( username ,  password ,  projectId , sslEnabled,  nfvo_ip ,  nfvo_port ,  1 );\n        VimInstanceRestAgent vimInstanceAgent = nfvoRequestor.getVimInstanceAgent();\n\n        VimInstance vimInstance = new VimInstance();\n\n        // fill the vimInstance object accordingly to your VIM chosen\n\n        try {\n            vimInstance = vimInstanceAgent.create(vimInstance);\n        } catch (SDKException e) {\n            e.printStackTrace();\n        }\n\n        System.out.println( Created VimInstance with id:   + vimInstance.getId());\n    }\n}", 
            "title": "NFVO SDK"
        }, 
        {
            "location": "/zabbix-plugin/", 
            "text": "Zabbix plugin\n\n\nZabbix plugin (see it on \nGitHub\n) is an open source project providing a reference implementation of two interfaces of the VIM, based on the ETSI \nNFV MANO\n specification.\n\n\nThe two interfaces are:\n-   VirtualisedResourceFaultManagement\n-   VirtualisedResourcePerformanceManagement\n\n\nA detailed description of the interfaces is in the last ETSI Draft \nIFA005_Or-Vi_ref_point_Spec\n.\n\nIn particular with the Zabbix plugin you can create/delete items, trigger and action on-demand. \n\n\n\n\nSome of the benefits introduced by the usage of such plugin: \n1) Make the consumers (NFVO, VNFM) indipendent to the monitoring system.\n\n2) The communication between the consumers and zabbix-plugin is JSON based, so the consumers can be written in any languages.\n\n3) The values of the items are cached and updated periodically in order to avoid to contact the zabbix server each time a specific metric is required.\n4) If your consumer is written in java, we provide a simple class MonitoringPluginCaller which handle the communication via RabbitMQ.\n\n\nGetting Started\n\n\nPrerequisites\n\n\nThe prerequisites are:  \n\n\n\n\nZabbix server installed and running. See \nhow to configure Zabbix server\n.\n\n\nRabbitMQ server installed and running  \n\n\nGit installed\n\n\nGradle installed\n\n\n\n\nAdditional Zabbix Server configuration required for receiving notifications\n\n\nHow is the zabbix-plugin receiving notification from the Zabbix Server? \n\n\nWhen using the method createThreshold provided by the plugin,it automatically creates an \naction\n executed when the specific condition is met. \nIf the threshold is crossed (the status of the trigger goes from OK to PROBLEM or viceversa) the action is performed. The action gets the informations of the threshold and sends them to a custom alertScript.\nThe custom alertscripts is executed on the zabbix server and its task is to send the informations received from the action to the zabbix-plugin. \n\n\nThe zabbix-pluging waits for notifications at the url: http://zabbix-plugin-ip:defaultPort/defaultContext.\n\n\nDefatult context and ports are specified in the configuration file as: \n\n \nnotification-receiver-server-context\n.\n\n \nnotification-receiver-server-port\n.\n\n\nThe custom alert script we use is the following:  \n\n\n#!/bin/bash\nto=$1\nbody=$3\ncurl -X POST -H \nAccept: application/json\n -H \nContent-Type: application/json\n -d \n$body\n http://$to\n\n\n\n\nCopy this script in the directory defined in the Zabbix server configuration file as AlertScriptsPath variable.\nThe variable 'to' is the endpoint where zabbix-plugin receives the notification (specified in \nnotification-receiver-server-context\n property). \nAfter you copied the script in the right directoy, the Zabbix server needs to be configured correctly in order to use \ncustom alertscripts\n. \nThis configuration will be automatized in later releases. \n\n\nInstallation\n\n\nOnce the prerequisites are met, you can clone the following project from git, compile it using gradle and launch it:  \n\n\ngit clone https://github.com/openbaton/zabbix-plugin.git\ncd zabbix-plugin\n./gradlew build\njava -jar build/lib/zabbix-agent-\nversion\n.jar\n\n\n\n\nConfiguration\n\n\nCreate a configuration file called zabbix-plugin.conf in the path /etc/openbaton/plugins/ and fill it with the configuration parameter explained in the following section.\n\n\n\n\n\n\n\n\nParameter\n\n\nDescription\n\n\nDefault\n\n\n\n\n\n\n\n\n\n\nzabbix-ip\n\n\nIP of the Zabbix Server\n\n\nnot null\n\n\n\n\n\n\nzabbix-port\n\n\nPort of the Zabbix Server\n\n\ncan be empty\n\n\n\n\n\n\ntype\n\n\nThe type of the plugin\n\n\nzabbix-plugin\n\n\n\n\n\n\nuser-zbx\n\n\nUser of the Zabbix Server\n\n\n\n\n\n\n\n\npassword-zbx\n\n\nPassword of Zabbix Server\n\n\n\n\n\n\n\n\nclient-request-frequency\n\n\nUpdate cache period (Basically each time t, the zabbix plugin ask to every items value for all hosts and fill the local cache)\n\n\n15 (seconds)\n\n\n\n\n\n\nhistory-length\n\n\nHow long is the history. If the client-request-frequency is 10 seconds and history-length 100, we have available the value of the items of the previous 1000 seconds.\n\n\n250\n\n\n\n\n\n\nnotification-receiver-server-context\n\n\nContext where the zabbix-plugin receive the notifications by the zabbix server. (see the section 'How to configure Zabbix to get notifications')\n\n\n/zabbixplugin/notifications\n\n\n\n\n\n\nnotification-receiver-server-port\n\n\nPort where the zabbix-plugin receive the notifications by the zabbix server.\n\n\n8010\n\n\n\n\n\n\nexternal-properties-file\n\n\nFull path of the configuration file.\n\n\n/etc/openbaton/plugins/zabbix-plugin.conf\n\n\n\n\n\n\n\n\nThe configuration file should look like the one below:\n\n\nzabbix-ip = xxx.xxx.xxx.xxx\nzabbix-port = xxxxx\ntype = zabbix-plugin\nuser-zbx = zabbixUSer\npassword-zbx = zabbixPassword\nclient-request-frequency = 10\nhistory-length = 250\n\nnotification-receiver-server-context = /zabbixplugin/notifications\nnotification-receiver-server-port = 8010\n\nexternal-properties-file=/etc/openbaton/plugins/zabbix-plugin.conf\n\n\n\n\nUsing it via MonitoringPluginCaller\n\n\nIn order to use the MonitorPluginCaller you need to import the relative plugin-sdk, coming from \nOpenbaton\n project.\nTo import the plugin-sdk, please add in your gradle file the following dependencies:\n\n\nrepositories {\n       maven { url \nhttp://get.openbaton.org:8081/nexus/content/groups/public/\n }\n}\n\ndependencies {\n    compile 'org.openbaton:plugin-sdk:2.0.0'\n}\n\n\n\n\nThen in your main, obtain the MonitoringPluginCaller as follow:\n\n\nMonitoringPluginCaller monitoringPluginCaller=null;\ntry {\n    monitoringPluginCaller = new MonitoringPluginCaller(\nzabbix\n,\n15672\n);\n} catch (TimeoutException e) {\n    e.printStackTrace();\n} catch (NotFoundException e) {\n    e.printStackTrace();\n} catch (IOException e) {\n    e.printStackTrace();\n}\n\n\n\n\nFunctionalities provided by the Zabbix Plugin Interface\n\n\nVirtualisedResourcePerformanceManagement interface\n\n\n\n\n\n\n\n\nMethods\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nCREATE PM JOB\n\n\nCreate one or more items to be monitored in one or more hosts.\n\n\n\n\n\n\nDELETE PM JOB\n\n\nDelete a PM job.\n\n\n\n\n\n\nQUERY PM JOB\n\n\nGet item values from one or more host. Fast method since the item values are cached.\n\n\n\n\n\n\nSUBSCRIBE\n\n\nSubscribe to a pm job or a threshold in order to be notified.\n\n\n\n\n\n\nNOTIFY\n\n\nNotification method invoked by zabbix plugin, the customer must not invoke directly this method.\n\n\n\n\n\n\nCREATE THRESHOLD\n\n\nCreate trigger on a specific item for one or more hosts\n\n\n\n\n\n\nDELETE THRESHOLD\n\n\nDelete a threshold.\n\n\n\n\n\n\nQUERY THRESHOLD\n\n\nGet information about the status of the thresholds\n\n\n\n\n\n\n\n\nVirtualisedResourceFaultManagement interface\n\n\n\n\n\n\n\n\nMethods\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nSUBSCRIBE\n\n\nSubscribe for alarm coming from an host\n\n\n\n\n\n\nNOTIFY\n\n\nNotification method invoked by zabbix plugin, the customer must not invoke directly this method.\n\n\n\n\n\n\nGET ALARM LIST\n\n\nGet alarms and relative status\n\n\n\n\n\n\n\n\nVirtualisedResourcePerformanceManagement interface\n\n\nCreate PM Job\n\n\nString createPMJob(ObjectSelection selector, List\nString\n performanceMetrics, List\nString\n performanceMetricGroup, Integer collectionPeriod,Integer reportingPeriod) throws MonitoringException;\n\n\n\n\nThis method create one or more items to be monitored in one or more hosts.\n\n\nselector\n: object to select the hosts in which we want to add the items.\n\n\nperformanceMetrics\n: List of items. We can create items which are available in the \nZabbix documentation 2.2\n.\n\n\nperformanceMetricGroup\n: pre-defined list of metrics. (NOT YET IMPLEMENTED, please pass an empty list of string).\n\n\ncollectionPeriod\n: Update interval of the item/s in seconds.\n\n\nreportingPeriod\n: Specifies the periodicity at which the VIM will report to the customers about performance information\u0000\u0000. (NOT YET IMPLEMENTED, please pass an integer \n= 0 ).\n\n\nIn the following example we create two items ('net.tcp.listen[8080]' and 'agent.ping') for two hosts ('host-1' and 'host-2'). As a return value we get the ID of the PMJob.\n\n\nObjectSelection objectSelection = getObjectSelector(\nhost-1\n,\nhost-2\n);\nList\nString\n performanceMetrics = getPerformanceMetrics(\nnet.tcp.listen[8080]\n,\nagent.ping\n);\nString pmJobId = monitoringPluginCaller.createPMJob(objectSelection, performanceMetrics, new ArrayList\nString\n(),60, 0);\nSystem.out.println(\nPmJobId is: \n+pmJobId);\n\n\n\n\nHere the methods getObjectSelector and getPerformanceMetrics:\n\n\nprivate List\nString\n getPerformanceMetrics(String ... performanceMetrics) {\n    List\nString\n result = new ArrayList\nString\n();\n    for(String performanceMetric : performanceMetrics){\n        result.add(performanceMetric);\n    }\n    return result;\n}\n\nprivate ObjectSelection getObjectSelector(String ... hosts) {\n    ObjectSelection objectSelection = new ObjectSelection();\n    for(String host : hosts){\n        objectSelection.addObjectInstanceId(host);\n    }\n    return objectSelection;\n}\n\n\n\n\nDelete Pm Job\n\n\nList\nString\n deletePMJob(List\nString\n pmJobIdsToDelete) throws MonitoringException;\n\n\n\n\nThis method delete an existing PmJob. We can get the id of the PmJob after the creation with createPMJob. As a return value we get the ID of the PMJobs effectively deleted.\n\n\nQuery Pm Job\n\n\nList\nItem\n queryPMJob(List\nString\n hostnames, List\nString\n performanceMetrics, String period) throws MonitoringException;\n\n\n\n\nThis method get item values from one or more host. As a return value we get the list of items.\n\n\nhostnames\n: list of hostnames which we want to know items values.\n\n\nperformanceMetrics\n: List of items. We can get items which are available in: the \nZabbix documentation 2.2\n and in the \nhostnames\n.\n\n\nperiod\n: period in seconds. If period is 0 than you get the last available value of the item. If \n 0 you get the average of the values inside that period.\n    Remember than the zabbix-plugin read all value of the all hosts every \nclient-request-frequency\n (see the configuration section) and keep them in the history.\n    So if \nclient-request-frequency\n is 15 seconds and the period 30 seconds you get the average of the previous 2 values of the item.\n\n\nIn the following example we ask for the last value of two items ('net.tcp.listen[8080]' and 'agent.ping') for the hosts 'host-1'.\n\n\nArrayList\nString\n hostnames = getHostnames(\nhost-1\n);\nArrayList\nString\n performanceMetrics = getPerformanceMetrics(\nnet.tcp.listen[8080]\n,\nagent.ping\n);\nList\nItem\n items = monitoringPluginCaller.queryPMJob(hostnames,performanceMetrics,\n0\n);\n\n\n\n\nitems\n: list of items. An item is a simple object of openbaton-libs which contains properties like: metric, hostname, lastValue, value.\n\n\nSubscribe \n notifyInfo\n\n\nNOT YET IMPLEMENTED\n\n\nCreate Threshold\n\n\nString createThreshold(ObjectSelection selector, String performanceMetric, ThresholdType thresholdType, ThresholdDetails thresholdDetails) throws MonitoringException;\n\n\n\n\nThis method create a trigger on a specific item for one or more hosts. As a return value we get the id of the threshold.\n\n\nselector\n: object to select the hosts which will be part of the trigger.\n\n\nperformanceMetric\n: item to include in the trigger. The item need to be already present in the hosts specified in the \nselector\n.\n\n\nthresholdType\n: defines the type of threshold\u0000. (NOT YET IMPLEMENTED, please pass ThresholdType.SINGLE for the moment).\n\n\nthresholdDetails\n: details of the threshold. It contains:\n\n\n\n\nfunction: refer to \nZabbix trigger function 2.2\n \u0000\n\n\ntriggerOperator: operator\n\n\nperceiverSeverity: severity of the trigger.\n\n\nvalue: threshold value to compare with the actual value of the \nperformanceMetric\n.\n\n\nhostOperator: can be \"|\" or \"\n\", meaning that the threshold will trigger when at least one host or all the hosts cross the threshold value.\n\n\n\n\nIn the following example we create a treshold for two hosts ('host-1' and 'host-2').\n\n\nObjectSelection objectSelector = getObjectSelector(\nhost-1\n,\nhost-2\n);\nThresholdDetails thresholdDetails= new ThresholdDetails(\nlast(0)\n,\n=\n,PerceivedSeverity.CRITICAL,\n0\n,\n|\n);\nString thresholdId = zabbixMonitoringAgent.createThreshold(objectSelector,\nnet.tcp.listen[5001]\n,ThresholdType.SINGLE_VALUE,thresholdDetails);\n\n\n\n\nThe trigger that will be created has this expression: {host-1:net.tcp.listen[5001].last(0)}=0|{host-2:net.tcp.listen[5001].last(0)}=0.\nIt means that if host-1 OR host-2 have no more process listening on the port 5001 then create an alarm with severity critical.\nRefer to \nZabbix expression 2.2\n to understand better the expression.\n\n\nDelete Threshold\n\n\nList\nString\n deleteThreshold(List\nString\n thresholdIds) throws MonitoringException;\n\n\n\n\nThis method delete an existing threshold/s. We can get the id of the threshold after the creation with createThreshold. As a return value we get the list of the ID of the threshold effectively deleted.\n\n\nQuery Threshold\n\n\nNOT YET IMPLEMENTED\n\n\nVirtualisedResourceFaultManagement interface\n\n\nSubscribe\n\n\nString subscribeForFault(AlarmEndpoint filter) throws MonitoringException;\n\n\n\n\nSubscribe for alarm generated by thresholds. As a return value we get the id of the subscription.\n\nfilter\n: AlarmEndpoint object which contains:\n-  name: name of the alarmEndpoint.\n-  resourceId: hostname which we want to subscribe.\n-  type: REST or JMS.\n-  endpoint: endpoint where we want to be notified. It is and url for REST or a queue name for JMS. (actually only rest is supported).\n-  perceivedSeverity: define the severity of the alarm we want to get.\n    If we specify PerceivedSeverity.WARNING we will able to get notification from alarm with severity equals or higher than WARNING.\n\n\nIn the following example we subscribe for all alarms with severity higher than WARNING coming from the host 'host-1'.\n\n\nAlarmEndpoint alarmEndpoint = new AlarmEndpoint(\nfault-manager-of-host-1\n,\nhost-1\n,EndpointType.REST,\nhttp://localhost:5555/alarm\n,PerceivedSeverity.WARNING);\nString subscriptionId = monitoringPluginCaller.subscribeForFault(alarmEndpoint);\n\n\n\n\nUnsubscribe\n\n\nString unsubscribeForFault(String subscriptionId) throws MonitoringException;\n\n\n\n\nThis method detele the subscription with the ID passed as a argument. As a return value we get the id of the subscription effectively deleted.\nWe can get the id of the subscription after the creation with subscribeForFault.\n\n\nGet alarm list\n\n\nNOT YET IMPLEMENTED\n\n\nNotify\n\n\nThis method cannot be invoked by the customers as specified in the ETSI draft \nIFA005_Or-Vi_ref_point_Spec\n.\n\n\nZabbix severity mapping with ETSI severity\n\n\nIn Zabbix we can specify a severity of a trigger: not classified, information, warning, average, high, disaster.\n\n\nIn the ETSI draft there are different level of severity, called perceived severity: Indeterminate, warning, minor, major, critical.\n\n\nSo the mapping in the zabbix plugin is showed in the following table:\n\n\n\n\n\n\n\n\nZabbix severity\n\n\nETSI perceived severity\n\n\n\n\n\n\n\n\n\n\nNot classified\n\n\nIndeterminate\n\n\n\n\n\n\nInformation\n\n\nWarning\n\n\n\n\n\n\nWarning\n\n\nWarning\n\n\n\n\n\n\nAverage\n\n\nMinor\n\n\n\n\n\n\nHigh\n\n\nMajor\n\n\n\n\n\n\nDisaster\n\n\nCritical\n\n\n\n\n\n\n\n\nNotifications types\n\n\nWhen we create a new threshold, we would like to get a notification as soon as the threshold is crossed. Both interfaces send notifications with the method notify.\nAccording to ETSI specification there are 4 types of notifications. \n\n\nThe interface VirtualisedResourcePerformanceManagement sends two types of notifications:  \n\n\n\n\nPerformanceInformationAvailableNotification (NOT YET IMPLEMENTED) \u0000: this notification informs the receiver that performance information is available.  \u0000   \n\n\nhresholdCrossedNotification\u0000 (NOT YET IMPLEMENTED) : his notification informs the receiver that a threshold value has been crossed.\u0000  \n\n\n\n\nThe interface VirtualisedResourceFaultManagement sends the following notifications:\n\n\n\n\nAlarmNotification\u0000: This notification informs the receiver of alarms resulting from the faults related to the virtualised resources managed by the VIM\u0000. It contains the Alarm with all the information about the fault.\n\n\nAlarmStateChangedNotification\u0000: This notification informs the receiver of state change of alarm related to the virtualised resources managed by the VIM, e.g. the alarm shall be set to \u201ccleared\u201d if the corresponding fault has been solved.\n    It contains the id of the Alarm and the actual status which could be (CLEARED,FIRED,UPDATED).\u0000\n\n\n\n\nActually the zabbix-plugin when receives the notification by zabbix server, \nif the trigger has severity higher than Information\n, \nit creates an alarm (mapping zabbix notification into standard Alarm) and notify the subscribers with a AlarmNotification. If the notification is not new, then it sends an AlarmStateChangedNotification.", 
            "title": "Use Zabbix plugin"
        }, 
        {
            "location": "/zabbix-plugin/#zabbix-plugin", 
            "text": "Zabbix plugin (see it on  GitHub ) is an open source project providing a reference implementation of two interfaces of the VIM, based on the ETSI  NFV MANO  specification.  The two interfaces are:\n-   VirtualisedResourceFaultManagement\n-   VirtualisedResourcePerformanceManagement  A detailed description of the interfaces is in the last ETSI Draft  IFA005_Or-Vi_ref_point_Spec . \nIn particular with the Zabbix plugin you can create/delete items, trigger and action on-demand.    Some of the benefits introduced by the usage of such plugin: \n1) Make the consumers (NFVO, VNFM) indipendent to the monitoring system. \n2) The communication between the consumers and zabbix-plugin is JSON based, so the consumers can be written in any languages. \n3) The values of the items are cached and updated periodically in order to avoid to contact the zabbix server each time a specific metric is required.\n4) If your consumer is written in java, we provide a simple class MonitoringPluginCaller which handle the communication via RabbitMQ.", 
            "title": "Zabbix plugin"
        }, 
        {
            "location": "/zabbix-plugin/#getting-started", 
            "text": "Prerequisites  The prerequisites are:     Zabbix server installed and running. See  how to configure Zabbix server .  RabbitMQ server installed and running    Git installed  Gradle installed", 
            "title": "Getting Started"
        }, 
        {
            "location": "/zabbix-plugin/#additional-zabbix-server-configuration-required-for-receiving-notifications", 
            "text": "How is the zabbix-plugin receiving notification from the Zabbix Server?   When using the method createThreshold provided by the plugin,it automatically creates an  action  executed when the specific condition is met. \nIf the threshold is crossed (the status of the trigger goes from OK to PROBLEM or viceversa) the action is performed. The action gets the informations of the threshold and sends them to a custom alertScript.\nThe custom alertscripts is executed on the zabbix server and its task is to send the informations received from the action to the zabbix-plugin.   The zabbix-pluging waits for notifications at the url: http://zabbix-plugin-ip:defaultPort/defaultContext.  Defatult context and ports are specified in the configuration file as:    notification-receiver-server-context .   notification-receiver-server-port .  The custom alert script we use is the following:    #!/bin/bash\nto=$1\nbody=$3\ncurl -X POST -H  Accept: application/json  -H  Content-Type: application/json  -d  $body  http://$to  Copy this script in the directory defined in the Zabbix server configuration file as AlertScriptsPath variable.\nThe variable 'to' is the endpoint where zabbix-plugin receives the notification (specified in  notification-receiver-server-context  property). \nAfter you copied the script in the right directoy, the Zabbix server needs to be configured correctly in order to use  custom alertscripts . \nThis configuration will be automatized in later releases.   Installation  Once the prerequisites are met, you can clone the following project from git, compile it using gradle and launch it:    git clone https://github.com/openbaton/zabbix-plugin.git\ncd zabbix-plugin\n./gradlew build\njava -jar build/lib/zabbix-agent- version .jar  Configuration  Create a configuration file called zabbix-plugin.conf in the path /etc/openbaton/plugins/ and fill it with the configuration parameter explained in the following section.     Parameter  Description  Default      zabbix-ip  IP of the Zabbix Server  not null    zabbix-port  Port of the Zabbix Server  can be empty    type  The type of the plugin  zabbix-plugin    user-zbx  User of the Zabbix Server     password-zbx  Password of Zabbix Server     client-request-frequency  Update cache period (Basically each time t, the zabbix plugin ask to every items value for all hosts and fill the local cache)  15 (seconds)    history-length  How long is the history. If the client-request-frequency is 10 seconds and history-length 100, we have available the value of the items of the previous 1000 seconds.  250    notification-receiver-server-context  Context where the zabbix-plugin receive the notifications by the zabbix server. (see the section 'How to configure Zabbix to get notifications')  /zabbixplugin/notifications    notification-receiver-server-port  Port where the zabbix-plugin receive the notifications by the zabbix server.  8010    external-properties-file  Full path of the configuration file.  /etc/openbaton/plugins/zabbix-plugin.conf     The configuration file should look like the one below:  zabbix-ip = xxx.xxx.xxx.xxx\nzabbix-port = xxxxx\ntype = zabbix-plugin\nuser-zbx = zabbixUSer\npassword-zbx = zabbixPassword\nclient-request-frequency = 10\nhistory-length = 250\n\nnotification-receiver-server-context = /zabbixplugin/notifications\nnotification-receiver-server-port = 8010\n\nexternal-properties-file=/etc/openbaton/plugins/zabbix-plugin.conf", 
            "title": "Additional Zabbix Server configuration required for receiving notifications"
        }, 
        {
            "location": "/zabbix-plugin/#using-it-via-monitoringplugincaller", 
            "text": "In order to use the MonitorPluginCaller you need to import the relative plugin-sdk, coming from  Openbaton  project.\nTo import the plugin-sdk, please add in your gradle file the following dependencies:  repositories {\n       maven { url  http://get.openbaton.org:8081/nexus/content/groups/public/  }\n}\n\ndependencies {\n    compile 'org.openbaton:plugin-sdk:2.0.0'\n}  Then in your main, obtain the MonitoringPluginCaller as follow:  MonitoringPluginCaller monitoringPluginCaller=null;\ntry {\n    monitoringPluginCaller = new MonitoringPluginCaller( zabbix , 15672 );\n} catch (TimeoutException e) {\n    e.printStackTrace();\n} catch (NotFoundException e) {\n    e.printStackTrace();\n} catch (IOException e) {\n    e.printStackTrace();\n}", 
            "title": "Using it via MonitoringPluginCaller"
        }, 
        {
            "location": "/zabbix-plugin/#functionalities-provided-by-the-zabbix-plugin-interface", 
            "text": "VirtualisedResourcePerformanceManagement interface     Methods  Description      CREATE PM JOB  Create one or more items to be monitored in one or more hosts.    DELETE PM JOB  Delete a PM job.    QUERY PM JOB  Get item values from one or more host. Fast method since the item values are cached.    SUBSCRIBE  Subscribe to a pm job or a threshold in order to be notified.    NOTIFY  Notification method invoked by zabbix plugin, the customer must not invoke directly this method.    CREATE THRESHOLD  Create trigger on a specific item for one or more hosts    DELETE THRESHOLD  Delete a threshold.    QUERY THRESHOLD  Get information about the status of the thresholds     VirtualisedResourceFaultManagement interface     Methods  Description      SUBSCRIBE  Subscribe for alarm coming from an host    NOTIFY  Notification method invoked by zabbix plugin, the customer must not invoke directly this method.    GET ALARM LIST  Get alarms and relative status     VirtualisedResourcePerformanceManagement interface  Create PM Job  String createPMJob(ObjectSelection selector, List String  performanceMetrics, List String  performanceMetricGroup, Integer collectionPeriod,Integer reportingPeriod) throws MonitoringException;  This method create one or more items to be monitored in one or more hosts.  selector : object to select the hosts in which we want to add the items.  performanceMetrics : List of items. We can create items which are available in the  Zabbix documentation 2.2 .  performanceMetricGroup : pre-defined list of metrics. (NOT YET IMPLEMENTED, please pass an empty list of string).  collectionPeriod : Update interval of the item/s in seconds.  reportingPeriod : Specifies the periodicity at which the VIM will report to the customers about performance information\u0000\u0000. (NOT YET IMPLEMENTED, please pass an integer  = 0 ).  In the following example we create two items ('net.tcp.listen[8080]' and 'agent.ping') for two hosts ('host-1' and 'host-2'). As a return value we get the ID of the PMJob.  ObjectSelection objectSelection = getObjectSelector( host-1 , host-2 );\nList String  performanceMetrics = getPerformanceMetrics( net.tcp.listen[8080] , agent.ping );\nString pmJobId = monitoringPluginCaller.createPMJob(objectSelection, performanceMetrics, new ArrayList String (),60, 0);\nSystem.out.println( PmJobId is:  +pmJobId);  Here the methods getObjectSelector and getPerformanceMetrics:  private List String  getPerformanceMetrics(String ... performanceMetrics) {\n    List String  result = new ArrayList String ();\n    for(String performanceMetric : performanceMetrics){\n        result.add(performanceMetric);\n    }\n    return result;\n}\n\nprivate ObjectSelection getObjectSelector(String ... hosts) {\n    ObjectSelection objectSelection = new ObjectSelection();\n    for(String host : hosts){\n        objectSelection.addObjectInstanceId(host);\n    }\n    return objectSelection;\n}  Delete Pm Job  List String  deletePMJob(List String  pmJobIdsToDelete) throws MonitoringException;  This method delete an existing PmJob. We can get the id of the PmJob after the creation with createPMJob. As a return value we get the ID of the PMJobs effectively deleted.  Query Pm Job  List Item  queryPMJob(List String  hostnames, List String  performanceMetrics, String period) throws MonitoringException;  This method get item values from one or more host. As a return value we get the list of items.  hostnames : list of hostnames which we want to know items values.  performanceMetrics : List of items. We can get items which are available in: the  Zabbix documentation 2.2  and in the  hostnames .  period : period in seconds. If period is 0 than you get the last available value of the item. If   0 you get the average of the values inside that period.\n    Remember than the zabbix-plugin read all value of the all hosts every  client-request-frequency  (see the configuration section) and keep them in the history.\n    So if  client-request-frequency  is 15 seconds and the period 30 seconds you get the average of the previous 2 values of the item.  In the following example we ask for the last value of two items ('net.tcp.listen[8080]' and 'agent.ping') for the hosts 'host-1'.  ArrayList String  hostnames = getHostnames( host-1 );\nArrayList String  performanceMetrics = getPerformanceMetrics( net.tcp.listen[8080] , agent.ping );\nList Item  items = monitoringPluginCaller.queryPMJob(hostnames,performanceMetrics, 0 );  items : list of items. An item is a simple object of openbaton-libs which contains properties like: metric, hostname, lastValue, value.  Subscribe   notifyInfo  NOT YET IMPLEMENTED  Create Threshold  String createThreshold(ObjectSelection selector, String performanceMetric, ThresholdType thresholdType, ThresholdDetails thresholdDetails) throws MonitoringException;  This method create a trigger on a specific item for one or more hosts. As a return value we get the id of the threshold.  selector : object to select the hosts which will be part of the trigger.  performanceMetric : item to include in the trigger. The item need to be already present in the hosts specified in the  selector .  thresholdType : defines the type of threshold\u0000. (NOT YET IMPLEMENTED, please pass ThresholdType.SINGLE for the moment).  thresholdDetails : details of the threshold. It contains:   function: refer to  Zabbix trigger function 2.2  \u0000  triggerOperator: operator  perceiverSeverity: severity of the trigger.  value: threshold value to compare with the actual value of the  performanceMetric .  hostOperator: can be \"|\" or \" \", meaning that the threshold will trigger when at least one host or all the hosts cross the threshold value.   In the following example we create a treshold for two hosts ('host-1' and 'host-2').  ObjectSelection objectSelector = getObjectSelector( host-1 , host-2 );\nThresholdDetails thresholdDetails= new ThresholdDetails( last(0) , = ,PerceivedSeverity.CRITICAL, 0 , | );\nString thresholdId = zabbixMonitoringAgent.createThreshold(objectSelector, net.tcp.listen[5001] ,ThresholdType.SINGLE_VALUE,thresholdDetails);  The trigger that will be created has this expression: {host-1:net.tcp.listen[5001].last(0)}=0|{host-2:net.tcp.listen[5001].last(0)}=0.\nIt means that if host-1 OR host-2 have no more process listening on the port 5001 then create an alarm with severity critical.\nRefer to  Zabbix expression 2.2  to understand better the expression.  Delete Threshold  List String  deleteThreshold(List String  thresholdIds) throws MonitoringException;  This method delete an existing threshold/s. We can get the id of the threshold after the creation with createThreshold. As a return value we get the list of the ID of the threshold effectively deleted.  Query Threshold  NOT YET IMPLEMENTED  VirtualisedResourceFaultManagement interface  Subscribe  String subscribeForFault(AlarmEndpoint filter) throws MonitoringException;  Subscribe for alarm generated by thresholds. As a return value we get the id of the subscription. filter : AlarmEndpoint object which contains:\n-  name: name of the alarmEndpoint.\n-  resourceId: hostname which we want to subscribe.\n-  type: REST or JMS.\n-  endpoint: endpoint where we want to be notified. It is and url for REST or a queue name for JMS. (actually only rest is supported).\n-  perceivedSeverity: define the severity of the alarm we want to get.\n    If we specify PerceivedSeverity.WARNING we will able to get notification from alarm with severity equals or higher than WARNING.  In the following example we subscribe for all alarms with severity higher than WARNING coming from the host 'host-1'.  AlarmEndpoint alarmEndpoint = new AlarmEndpoint( fault-manager-of-host-1 , host-1 ,EndpointType.REST, http://localhost:5555/alarm ,PerceivedSeverity.WARNING);\nString subscriptionId = monitoringPluginCaller.subscribeForFault(alarmEndpoint);  Unsubscribe  String unsubscribeForFault(String subscriptionId) throws MonitoringException;  This method detele the subscription with the ID passed as a argument. As a return value we get the id of the subscription effectively deleted.\nWe can get the id of the subscription after the creation with subscribeForFault.  Get alarm list  NOT YET IMPLEMENTED  Notify  This method cannot be invoked by the customers as specified in the ETSI draft  IFA005_Or-Vi_ref_point_Spec .", 
            "title": "Functionalities provided by the Zabbix Plugin Interface"
        }, 
        {
            "location": "/zabbix-plugin/#zabbix-severity-mapping-with-etsi-severity", 
            "text": "In Zabbix we can specify a severity of a trigger: not classified, information, warning, average, high, disaster.  In the ETSI draft there are different level of severity, called perceived severity: Indeterminate, warning, minor, major, critical.  So the mapping in the zabbix plugin is showed in the following table:     Zabbix severity  ETSI perceived severity      Not classified  Indeterminate    Information  Warning    Warning  Warning    Average  Minor    High  Major    Disaster  Critical", 
            "title": "Zabbix severity mapping with ETSI severity"
        }, 
        {
            "location": "/zabbix-plugin/#notifications-types", 
            "text": "When we create a new threshold, we would like to get a notification as soon as the threshold is crossed. Both interfaces send notifications with the method notify.\nAccording to ETSI specification there are 4 types of notifications.   The interface VirtualisedResourcePerformanceManagement sends two types of notifications:     PerformanceInformationAvailableNotification (NOT YET IMPLEMENTED) \u0000: this notification informs the receiver that performance information is available.  \u0000     hresholdCrossedNotification\u0000 (NOT YET IMPLEMENTED) : his notification informs the receiver that a threshold value has been crossed.\u0000     The interface VirtualisedResourceFaultManagement sends the following notifications:   AlarmNotification\u0000: This notification informs the receiver of alarms resulting from the faults related to the virtualised resources managed by the VIM\u0000. It contains the Alarm with all the information about the fault.  AlarmStateChangedNotification\u0000: This notification informs the receiver of state change of alarm related to the virtualised resources managed by the VIM, e.g. the alarm shall be set to \u201ccleared\u201d if the corresponding fault has been solved.\n    It contains the id of the Alarm and the actual status which could be (CLEARED,FIRED,UPDATED).\u0000   Actually the zabbix-plugin when receives the notification by zabbix server,  if the trigger has severity higher than Information , \nit creates an alarm (mapping zabbix notification into standard Alarm) and notify the subscribers with a AlarmNotification. If the notification is not new, then it sends an AlarmStateChangedNotification.", 
            "title": "Notifications types"
        }, 
        {
            "location": "/tosca-iperf-scenario/", 
            "text": "TOSCA definition\n\n\nThe definition follows the TOSCA Simple Profile for Network Functions Virtualization (NFV) \nVersion 1.0\n\nRegarding the objects defined from ETSI please see: \nETSI GS NFV-MAN 001\n\n\nPremise: some of the objects are defined by OpenBaton\n\n\nPrerequisites\n\n\nThe prerequisites are:\n\n\n\n\nOpenBaton running\n\n\nGeneric VNFM running\n\n\nVim Instance\n stored in the Catalogue\n\n\n\n\nMapping between TOSCA and ETSI NFV\n\n\n\n\n\n\n\n\nTOSCA Type\n\n\nETSI Entity\n\n\n\n\n\n\n\n\n\n\nopenbaton.type.VNF.GENERIC\n\n\nVirtual Network Function Descriptor (type: GENERIC)\n\n\n\n\n\n\nopenbaton.type.VDU\n\n\nVirtual Deployment Unit (vnfd:vdu)\n\n\n\n\n\n\ntosca.nodes.nfv.VL\n\n\nVirtual Link Descriptor\n\n\n\n\n\n\ntosca.nodes.nfv.CP\n\n\nConnection Point\n\n\n\n\n\n\n\n\nDeploy an Iperf TOSCA definition\n\n\nWe are going to create a NSD from TOSCA-definition that create a \niperf\n scenario.\n\n\nThe components in the definition are these in the picture below:\n\n\n\n\nNode Templates\n\n\nThe Node Templates are the description of the Objects which constitute the Network Service Descriptor.\nEach Object is defined by \nMap\nString , Object\n\n\nNode Template: VNF\n\n\nYou can see the definition of the VNF as described below:\n\n\niperf-server: #VNF1\n      type: openbaton.type.VNF.GENERIC\n      properties:\n        id:\n        vendor: Fokus\n        version: 0.1\n        configurations:\n          name: server-configurations\n          configurationParameters:\n            - key: value\n            - key2: value2\n        vnfPackageLocation: https://gitlab.fokus.fraunhofer.de/openbaton/scripts-test-public.git\n        deployment_flavour:\n          - flavour_key: m1.small\n      requirements:\n        - virtualLink: private\n        - host:\n            node: VDU2\n            type: openbaton.relationships.HostedOn\n      interfaces:\n        Standard: # lifecycle\n          create: install.sh\n          start: install-srv.sh\n\n\n\n\nThis VNF is called \niperf-server\n and below you can see the description of the fields:\n\n\n\n\n\n\n\n\nName\n\n\nValue\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntype\n\n\nopenbaton.type.VNF.GENERIC\n\n\nIt is the type of the VNF and defines the type of the Virtual Network Function Manager (VNFG) which will handle the VNF\n\n\n\n\n\n\nproperties\n\n\nSee the Table below\n\n\nIt is  a Object where are mapped some values for deploying the VNF\n\n\n\n\n\n\nrequirements\n\n\nSee the Table below\n\n\nIt describes the requirements for the VNF\n\n\n\n\n\n\ninterfaces\n\n\nSee the Table below\n\n\nIt is an Object which maps for each lifecycle interface  with the Script that will be executed for the lifecycle event specified\n\n\n\n\n\n\n\n\nThe \nProperties\n for the VNF are:\n\n\n\n\n\n\n\n\nName\n\n\nValue\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nid\n\n\nString\n\n\nIdentifier of the VNF\n\n\n\n\n\n\nvendor\n\n\nString\n\n\nName of the provider of the VNF\n\n\n\n\n\n\nversion\n\n\nString\n\n\nVersion of the provider of the VNF\n\n\n\n\n\n\nconfigurations\n\n\nObject with two values \nname\n, \nconfigurationParameters\n\n\nname\n: is a String with the name of the Configuration, \nconfigurationParameters\n: the list of Parameters defined by a pair of \n key, value \n\n\n\n\n\n\nvnfPackageLocation\n\n\nURL\n\n\nIt is URL where the Orchestrator will fetch the Scripts needed in the lifecycle events defined in the \ninterfaces\n\n\n\n\n\n\ndeployment_flavour\n\n\nList of flavour_key\n\n\nIt is a list flavors each one refers to Virtual hardware templates called \"flavors\" in OpenStack\n\n\n\n\n\n\n\n\nThe \nRequirements\n for the VNF are:\n\n\n\n\n\n\n\n\nName\n\n\nValue\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nvirtualLink\n\n\nList\n\n\nIt is the List of \nvirtuaLink\n where this VNF is connected\n\n\n\n\n\n\nhost\n\n\nList of VDU\n\n\nIt is the List of VDU. Each \nhost\n refers to a \nnode\n VDU. This parameter follows the ETSI definition of VNF which should have the list of VDU.\n\n\n\n\n\n\n\n\nThe \nInterfaces\n for the VNF cloud be of two types:\nThe TOSCA-Parser can handle both configurations.\n\n\n1. Standard\n\n\nThis interface follows the definition of \ntosca.interfaces.node.lifecycle.Standard\n described in the \nTOSCA Simple YAML\n standard.\n\n\n\n\n\n\n\n\nLifecycle event\n\n\nValue\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ncreate\n\n\nScript file\n\n\nThe Script will be called for this Lifecycle event\n\n\n\n\n\n\nconfigure\n\n\nScript file\n\n\nThe Script will be called for this Lifecycle event\n\n\n\n\n\n\nstart\n\n\nScript file\n\n\nThe Script will be called for this Lifecycle event\n\n\n\n\n\n\nstop\n\n\nScript file\n\n\nThe Script will be called for this Lifecycle event\n\n\n\n\n\n\ndelete\n\n\nScript file\n\n\nThe Script will be called for this Lifecycle event\n\n\n\n\n\n\n\n\nNOTE\n You can define the relationship between two VNFs in the \nconfiguration\n event like you can see in the example below:\n\n\ninterfaces:\n   Standard: # lifecycle\n      create: install.sh\n      configure:\n         implementation: configure.sh\n         inputs:\n            server_ip: { get_attribute: [iperf-server, mgmt] }\n      start: start.sh\n\n\n\n\n\nThe \nconfigure\n has two fields:\n\n\n\n\nimplementation\n: refers to the script which will be execute for this event\n\n\ninputs\n: is the list of parameters that this VNF needs from the \nsource\n VNF in the case above the source is \niperf-server\n and the parameter is \nmgmt\n\n\n\n\n2. openbaton.interfaces.lifecycle\n\n\nThis Interface has these events compared with the definition by TOSCA this one follows the ETSI Lifecycle Events. \n\n\n\n\n\n\n\n\nLifecycle event\n\n\nValue\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nINSTANTIATE\n\n\nList of Script files\n\n\nThe Scripts will be called for this Lifecycle event\n\n\n\n\n\n\nCONFIGURE\n\n\nList of Script files\n\n\nThe Scripts will be called for this Lifecycle event\n\n\n\n\n\n\nSTART\n\n\nList of Script files\n\n\nThe Scripts will be called for this Lifecycle event\n\n\n\n\n\n\nSTOP\n\n\nList of Script files\n\n\nThe Scripts will be called for this Lifecycle event\n\n\n\n\n\n\nTERMINATE\n\n\nList of Script files\n\n\nThe Scripts will be called for this Lifecycle event\n\n\n\n\n\n\n\n\nNode Template: VDU\n\n\nThis is the definition of VDU called \nVDU1\n:\n\n\nVDU1:\n      type: openbaton.type.VDU\n      properties:\n        vm_image:\n          - ubuntu-14.04-server-cloudimg-amd64-disk1\n        scale_in_out: 2\n        vimInstanceName: vim-instance\n      requirements:\n         - virtual_link: [CP1]\n      capabilities:\n        host:\n          valid_source_types: openbaton.type.VDU\n\n\n\n\n\n\n\n\n\n\n\nName\n\n\nValue\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntype\n\n\nopenbaton.type.VDU\n\n\nIt is the type of the VDU\n\n\n\n\n\n\nproperties\n\n\nSee the Table below\n\n\nIt is  a Object where are mapped some values for deploying the VDU\n\n\n\n\n\n\nrequirements\n\n\nList of requirement\n\n\nIt describes the requirements for the VDU in the example above the VDU needs a virtual_link which is a list of Connection Point in this case \nCP1\n\n\n\n\n\n\ncapabilities\n\n\nObject\n\n\nType of capability offered\n\n\n\n\n\n\n\n\nThe \nProperties\n for the VDU are:\n\n\n\n\n\n\n\n\nName\n\n\nValue\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nvm_image\n\n\nList \n String \n\n\nIt is the list of images present in the OpenStack that will be used to instantiate a VNFC (aka Virtual Machine)\n\n\n\n\n\n\nscale_in_out\n\n\nInteger\n\n\nMaximum value of VNFCs that can be instantiated in the process of scale-in/out\n\n\n\n\n\n\nvimInstanceName\n\n\nString\n\n\nName of Point of Persistence (PoP aka Datacenter) where this VNFC will be instantiated\n\n\n\n\n\n\n\n\nNode Template: Connection Point (CP)\n\n\nThis is the definition of CP called \nCP2\n:\n\n\nCP2: #endpoint of VDU2\n      type: tosca.nodes.nfv.CP\n      properties:\n        floatingIp: random\n      requirements:\n        virtualbinding: VDU2\n      virtualLink: private\n\n\n\n\n\n\n\n\n\n\n\nName\n\n\nValue\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntype\n\n\ntosca.nodes.nfv.CP\n\n\nIt is the type of the CP\n\n\n\n\n\n\nproperties\n\n\nObject\n\n\nIt is a Object where are mapped some values for deploying the CP in this case \nfloatingIp\n means that has a public IP chosen \nrandom\n  by OpenStack\n\n\n\n\n\n\nrequirements\n\n\nObject\n\n\nIt describes the requirements for the CP in the example above the CP needs a virtualbinding to the VDU in this case \nVDU2\n\n\n\n\n\n\nvirtualLink\n\n\nString\n\n\nIt refers to Node Template which describes the Virtual Link in this case the Virtual Link is called \nprivate\n\n\n\n\n\n\n\n\nNode Template: Virtual Link (VL)\n\n\nOpenBaton uses virtual Link name as subnets from OpenStack.\n\n\nThis is the definition of VL called \nprivate\n:\n\n\nprivate:\n    type: tosca.nodes.nfv.VL\n    properties:\n      vendor: Fokus\n    capabilities:\n      virtual_linkable:\n        valid_source_types: tosca.nodes.nfv.CP\n\n\n\n\n\n\n\n\n\n\n\nName\n\n\nValue\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntype\n\n\ntosca.nodes.nfv.VL\n\n\nIt is the type of the CP\n\n\n\n\n\n\nproperties\n\n\nObject\n\n\nIt is a Object that has some information in this case vendor\n\n\n\n\n\n\ncapabilities\n\n\nObject\n\n\nType of capability offered\n\n\n\n\n\n\n\n\nRelationships Template\n\n\nThe Relationships Template creates the dependency between two VNFs.\nThis is the definition of Relationships Template called \nconnection_server_client\n:\n\n\n\nrelationships_template:\n  connection_server_client:\n    type: tosca.nodes.relationships.ConnectsTo\n    source: iperf-server\n    target: iperf-client\n    parameters:\n        - private\n\n\n\n\n\n\n\n\n\n\n\nName\n\n\nValue\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntype\n\n\ntosca.nodes.relationships.ConnectsTo\n\n\nIt is the type of the Relationships Template\n\n\n\n\n\n\nsource\n\n\nString\n\n\nIt is a String which refers to the Node Template that describes the source VNF that provides some parameters in order to realize the dependency with the target VNF\n\n\n\n\n\n\ntarget\n\n\nString\n\n\nIt is a String which refers to the Node Template that describes the target VNF that requires some parameters in order to realize the dependency with the source VNF\n\n\n\n\n\n\nparameters\n\n\nList \n String \n\n\nList of parameters for this dependency\n\n\n\n\n\n\n\n\nThe yaml definition that describe all the components and creates the Iperf-NSD is this below:\n\n\ntosca_definitions_version: tosca_iperf_1_0_0\ntosca_default_namespace:    # Optional. default namespace (schema, types version)\ndescription: NSD for deploing an iperf scenario\nmetadata:\n  ID:                 # ID of this Network Service Descriptor\n  vendor: Fokus       # Provider or vendor of the Network Service\n  version: 0.1 Alpha  # Version of the Network Service Descriptor\n\ntopology_template:\n  node_templates:\n    iperf-server: #VNF1\n      type: openbaton.type.VNF.GENERIC\n      properties:\n        id:\n        vendor: Fokus\n        version: 0.1\n        configurations:\n          name: server-configurations\n          configurationParameters:\n            - key: value\n            - key2: value2\n        vnfPackageLocation: https://gitlab.fokus.fraunhofer.de/openbaton/scripts-test-public.git\n        deployment_flavour:\n          - flavour_key: m1.small\n      requirements:\n        - virtualLink: private\n        - host:\n            node: VDU2\n            type: openbaton.relationships.HostedOn\n      interfaces:\n        Standard: # lifecycle\n          create: install.sh\n          start: install-srv.sh\n    iperf-client:\n      type: openbaton.type.VNF.GENERIC\n      properties:\n        id:\n        vendor: Fokus\n        version: 0.1\n        configurations:\n          name: client-configurations\n          configurationParameters:\n            - key: value\n            - key2: value2\n        vnfPackageLocation: https://gitlab.fokus.fraunhofer.de/openbaton/scripts-test-public.git\n        deployment_flavour:\n          - flavour_key: m1.small\n      requirements:\n        - virtualLink: private\n        - host:\n            node: VDU1\n            type: openbaton.relationships.HostedOn\n      interfaces:\n        openbaton.interfaces.lifecycle: # lifecycle\n          INSTANCIATE:\n            - install.sh\n          CONFIGURE:\n            - server_configure_only.sh\n          START:\n            - iperf_client_start.sh\n    VDU1:\n      type: openbaton.type.VDU\n      properties:\n        vm_image:\n          - ubuntu-14.04-server-cloudimg-amd64-disk1\n        scale_in_out: 2\n        vimInstanceName: vim-instance\n      requirements:\n         - virtual_link: [CP1]\n      capabilities:\n        host:\n          valid_source_types: openbaton.type.VDU\n    VDU2:\n      type: openbaton.type.VDU\n      properties:\n        vm_image:\n          - ubuntu-14.04-server-cloudimg-amd64-disk1\n        scale_in_out: 2\n        vimInstanceName: vim-instance\n      requirements:\n        - virtual_link: [CP2]\n      capabilities:\n        host:\n          valid_source_types: openbaton.type.VDU\n\n    private:\n      type: tosca.nodes.nfv.VL\n      properties:\n        vendor: Fokus\n      capabilities:\n        virtual_linkable:\n          valid_source_types: tosca.nodes.nfv.CP\n\n    CP1: #endpoint of VDU1\n      type: tosca.nodes.nfv.CP\n      properties:\n      requirements:\n        virtualbinding: VDU1\n      virtualLink: private\n\n    CP2: #endpoint of VDU2\n      type: tosca.nodes.nfv.CP\n      properties:\n        floatingIp: random\n      requirements:\n        virtualbinding: VDU2\n      virtualLink: private\n\nrelationships_template:\n  connection_server_client:\n    type: tosca.nodes.relationships.ConnectsTo\n    source: iperf-server\n    target: iperf-client\n    parameters:\n        - private\n\n\n\n\n\n\nNOTE\n: Save the definition in a file called iperf-TOSCA.yaml.\n\n\nTo store this NSD written in TOSCA in the NFVO catalogue you need to send it to the NFVO with this curl command:\n\n\n$ curl -i -X POST http://localhost:8080/api/v1/tosca -H \nContent-Type: text/yaml\n \nAccept: application/json\n --data-binary @iperf-TOSCA.yaml\n\n\n\n\nThe NFVO will answer with json translation of the NSD. \nTo retrieve or to instantiate this NSD please use the Dashboard of OpenBaton in the page under the menu Catalogue \n NS Descriptors.\n\n\n\n\n\n\n\n\n\n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "TOSCA iperf scenario"
        }, 
        {
            "location": "/tosca-iperf-scenario/#tosca-definition", 
            "text": "The definition follows the TOSCA Simple Profile for Network Functions Virtualization (NFV)  Version 1.0 \nRegarding the objects defined from ETSI please see:  ETSI GS NFV-MAN 001  Premise: some of the objects are defined by OpenBaton", 
            "title": "TOSCA definition"
        }, 
        {
            "location": "/tosca-iperf-scenario/#prerequisites", 
            "text": "The prerequisites are:   OpenBaton running  Generic VNFM running  Vim Instance  stored in the Catalogue", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/tosca-iperf-scenario/#mapping-between-tosca-and-etsi-nfv", 
            "text": "TOSCA Type  ETSI Entity      openbaton.type.VNF.GENERIC  Virtual Network Function Descriptor (type: GENERIC)    openbaton.type.VDU  Virtual Deployment Unit (vnfd:vdu)    tosca.nodes.nfv.VL  Virtual Link Descriptor    tosca.nodes.nfv.CP  Connection Point", 
            "title": "Mapping between TOSCA and ETSI NFV"
        }, 
        {
            "location": "/tosca-iperf-scenario/#deploy-an-iperf-tosca-definition", 
            "text": "We are going to create a NSD from TOSCA-definition that create a  iperf  scenario.  The components in the definition are these in the picture below:", 
            "title": "Deploy an Iperf TOSCA definition"
        }, 
        {
            "location": "/tosca-iperf-scenario/#node-templates", 
            "text": "The Node Templates are the description of the Objects which constitute the Network Service Descriptor.\nEach Object is defined by  Map String , Object  Node Template: VNF  You can see the definition of the VNF as described below:  iperf-server: #VNF1\n      type: openbaton.type.VNF.GENERIC\n      properties:\n        id:\n        vendor: Fokus\n        version: 0.1\n        configurations:\n          name: server-configurations\n          configurationParameters:\n            - key: value\n            - key2: value2\n        vnfPackageLocation: https://gitlab.fokus.fraunhofer.de/openbaton/scripts-test-public.git\n        deployment_flavour:\n          - flavour_key: m1.small\n      requirements:\n        - virtualLink: private\n        - host:\n            node: VDU2\n            type: openbaton.relationships.HostedOn\n      interfaces:\n        Standard: # lifecycle\n          create: install.sh\n          start: install-srv.sh  This VNF is called  iperf-server  and below you can see the description of the fields:     Name  Value  Description      type  openbaton.type.VNF.GENERIC  It is the type of the VNF and defines the type of the Virtual Network Function Manager (VNFG) which will handle the VNF    properties  See the Table below  It is  a Object where are mapped some values for deploying the VNF    requirements  See the Table below  It describes the requirements for the VNF    interfaces  See the Table below  It is an Object which maps for each lifecycle interface  with the Script that will be executed for the lifecycle event specified     The  Properties  for the VNF are:     Name  Value  Description      id  String  Identifier of the VNF    vendor  String  Name of the provider of the VNF    version  String  Version of the provider of the VNF    configurations  Object with two values  name ,  configurationParameters  name : is a String with the name of the Configuration,  configurationParameters : the list of Parameters defined by a pair of   key, value     vnfPackageLocation  URL  It is URL where the Orchestrator will fetch the Scripts needed in the lifecycle events defined in the  interfaces    deployment_flavour  List of flavour_key  It is a list flavors each one refers to Virtual hardware templates called \"flavors\" in OpenStack     The  Requirements  for the VNF are:     Name  Value  Description      virtualLink  List  It is the List of  virtuaLink  where this VNF is connected    host  List of VDU  It is the List of VDU. Each  host  refers to a  node  VDU. This parameter follows the ETSI definition of VNF which should have the list of VDU.     The  Interfaces  for the VNF cloud be of two types:\nThe TOSCA-Parser can handle both configurations.  1. Standard  This interface follows the definition of  tosca.interfaces.node.lifecycle.Standard  described in the  TOSCA Simple YAML  standard.     Lifecycle event  Value  Description      create  Script file  The Script will be called for this Lifecycle event    configure  Script file  The Script will be called for this Lifecycle event    start  Script file  The Script will be called for this Lifecycle event    stop  Script file  The Script will be called for this Lifecycle event    delete  Script file  The Script will be called for this Lifecycle event     NOTE  You can define the relationship between two VNFs in the  configuration  event like you can see in the example below:  interfaces:\n   Standard: # lifecycle\n      create: install.sh\n      configure:\n         implementation: configure.sh\n         inputs:\n            server_ip: { get_attribute: [iperf-server, mgmt] }\n      start: start.sh  The  configure  has two fields:   implementation : refers to the script which will be execute for this event  inputs : is the list of parameters that this VNF needs from the  source  VNF in the case above the source is  iperf-server  and the parameter is  mgmt   2. openbaton.interfaces.lifecycle  This Interface has these events compared with the definition by TOSCA this one follows the ETSI Lifecycle Events.      Lifecycle event  Value  Description      INSTANTIATE  List of Script files  The Scripts will be called for this Lifecycle event    CONFIGURE  List of Script files  The Scripts will be called for this Lifecycle event    START  List of Script files  The Scripts will be called for this Lifecycle event    STOP  List of Script files  The Scripts will be called for this Lifecycle event    TERMINATE  List of Script files  The Scripts will be called for this Lifecycle event     Node Template: VDU  This is the definition of VDU called  VDU1 :  VDU1:\n      type: openbaton.type.VDU\n      properties:\n        vm_image:\n          - ubuntu-14.04-server-cloudimg-amd64-disk1\n        scale_in_out: 2\n        vimInstanceName: vim-instance\n      requirements:\n         - virtual_link: [CP1]\n      capabilities:\n        host:\n          valid_source_types: openbaton.type.VDU     Name  Value  Description      type  openbaton.type.VDU  It is the type of the VDU    properties  See the Table below  It is  a Object where are mapped some values for deploying the VDU    requirements  List of requirement  It describes the requirements for the VDU in the example above the VDU needs a virtual_link which is a list of Connection Point in this case  CP1    capabilities  Object  Type of capability offered     The  Properties  for the VDU are:     Name  Value  Description      vm_image  List   String   It is the list of images present in the OpenStack that will be used to instantiate a VNFC (aka Virtual Machine)    scale_in_out  Integer  Maximum value of VNFCs that can be instantiated in the process of scale-in/out    vimInstanceName  String  Name of Point of Persistence (PoP aka Datacenter) where this VNFC will be instantiated     Node Template: Connection Point (CP)  This is the definition of CP called  CP2 :  CP2: #endpoint of VDU2\n      type: tosca.nodes.nfv.CP\n      properties:\n        floatingIp: random\n      requirements:\n        virtualbinding: VDU2\n      virtualLink: private     Name  Value  Description      type  tosca.nodes.nfv.CP  It is the type of the CP    properties  Object  It is a Object where are mapped some values for deploying the CP in this case  floatingIp  means that has a public IP chosen  random   by OpenStack    requirements  Object  It describes the requirements for the CP in the example above the CP needs a virtualbinding to the VDU in this case  VDU2    virtualLink  String  It refers to Node Template which describes the Virtual Link in this case the Virtual Link is called  private     Node Template: Virtual Link (VL)  OpenBaton uses virtual Link name as subnets from OpenStack.  This is the definition of VL called  private :  private:\n    type: tosca.nodes.nfv.VL\n    properties:\n      vendor: Fokus\n    capabilities:\n      virtual_linkable:\n        valid_source_types: tosca.nodes.nfv.CP     Name  Value  Description      type  tosca.nodes.nfv.VL  It is the type of the CP    properties  Object  It is a Object that has some information in this case vendor    capabilities  Object  Type of capability offered     Relationships Template  The Relationships Template creates the dependency between two VNFs.\nThis is the definition of Relationships Template called  connection_server_client :  \nrelationships_template:\n  connection_server_client:\n    type: tosca.nodes.relationships.ConnectsTo\n    source: iperf-server\n    target: iperf-client\n    parameters:\n        - private     Name  Value  Description      type  tosca.nodes.relationships.ConnectsTo  It is the type of the Relationships Template    source  String  It is a String which refers to the Node Template that describes the source VNF that provides some parameters in order to realize the dependency with the target VNF    target  String  It is a String which refers to the Node Template that describes the target VNF that requires some parameters in order to realize the dependency with the source VNF    parameters  List   String   List of parameters for this dependency     The yaml definition that describe all the components and creates the Iperf-NSD is this below:  tosca_definitions_version: tosca_iperf_1_0_0\ntosca_default_namespace:    # Optional. default namespace (schema, types version)\ndescription: NSD for deploing an iperf scenario\nmetadata:\n  ID:                 # ID of this Network Service Descriptor\n  vendor: Fokus       # Provider or vendor of the Network Service\n  version: 0.1 Alpha  # Version of the Network Service Descriptor\n\ntopology_template:\n  node_templates:\n    iperf-server: #VNF1\n      type: openbaton.type.VNF.GENERIC\n      properties:\n        id:\n        vendor: Fokus\n        version: 0.1\n        configurations:\n          name: server-configurations\n          configurationParameters:\n            - key: value\n            - key2: value2\n        vnfPackageLocation: https://gitlab.fokus.fraunhofer.de/openbaton/scripts-test-public.git\n        deployment_flavour:\n          - flavour_key: m1.small\n      requirements:\n        - virtualLink: private\n        - host:\n            node: VDU2\n            type: openbaton.relationships.HostedOn\n      interfaces:\n        Standard: # lifecycle\n          create: install.sh\n          start: install-srv.sh\n    iperf-client:\n      type: openbaton.type.VNF.GENERIC\n      properties:\n        id:\n        vendor: Fokus\n        version: 0.1\n        configurations:\n          name: client-configurations\n          configurationParameters:\n            - key: value\n            - key2: value2\n        vnfPackageLocation: https://gitlab.fokus.fraunhofer.de/openbaton/scripts-test-public.git\n        deployment_flavour:\n          - flavour_key: m1.small\n      requirements:\n        - virtualLink: private\n        - host:\n            node: VDU1\n            type: openbaton.relationships.HostedOn\n      interfaces:\n        openbaton.interfaces.lifecycle: # lifecycle\n          INSTANCIATE:\n            - install.sh\n          CONFIGURE:\n            - server_configure_only.sh\n          START:\n            - iperf_client_start.sh\n    VDU1:\n      type: openbaton.type.VDU\n      properties:\n        vm_image:\n          - ubuntu-14.04-server-cloudimg-amd64-disk1\n        scale_in_out: 2\n        vimInstanceName: vim-instance\n      requirements:\n         - virtual_link: [CP1]\n      capabilities:\n        host:\n          valid_source_types: openbaton.type.VDU\n    VDU2:\n      type: openbaton.type.VDU\n      properties:\n        vm_image:\n          - ubuntu-14.04-server-cloudimg-amd64-disk1\n        scale_in_out: 2\n        vimInstanceName: vim-instance\n      requirements:\n        - virtual_link: [CP2]\n      capabilities:\n        host:\n          valid_source_types: openbaton.type.VDU\n\n    private:\n      type: tosca.nodes.nfv.VL\n      properties:\n        vendor: Fokus\n      capabilities:\n        virtual_linkable:\n          valid_source_types: tosca.nodes.nfv.CP\n\n    CP1: #endpoint of VDU1\n      type: tosca.nodes.nfv.CP\n      properties:\n      requirements:\n        virtualbinding: VDU1\n      virtualLink: private\n\n    CP2: #endpoint of VDU2\n      type: tosca.nodes.nfv.CP\n      properties:\n        floatingIp: random\n      requirements:\n        virtualbinding: VDU2\n      virtualLink: private\n\nrelationships_template:\n  connection_server_client:\n    type: tosca.nodes.relationships.ConnectsTo\n    source: iperf-server\n    target: iperf-client\n    parameters:\n        - private  NOTE : Save the definition in a file called iperf-TOSCA.yaml.  To store this NSD written in TOSCA in the NFVO catalogue you need to send it to the NFVO with this curl command:  $ curl -i -X POST http://localhost:8080/api/v1/tosca -H  Content-Type: text/yaml   Accept: application/json  --data-binary @iperf-TOSCA.yaml  The NFVO will answer with json translation of the NSD. \nTo retrieve or to instantiate this NSD please use the Dashboard of OpenBaton in the page under the menu Catalogue   NS Descriptors.    \n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Node Templates"
        }, 
        {
            "location": "/tosca-CSAR-onboarding/", 
            "text": "TOSCA CSAR on-boarding\n\n\nThe Cloud Service Archive \nCSAR\n is a package defined by OASIS TOSCA.\nIt is a compressed file that includes a TOSCA definition template of a Network Service, and all the scripts or files that a VNF needs for the lifecycle time from creation to termination.\nThe CSAR is a zip file with this structure:\n\n\n\u251c\u2500\u2500 Definitions\n|   \u2514\u2500\u2500 toscav1.yaml\n\u251c\u2500\u2500 Scripts\n|   \u251c\u2500\u2500 install.sh\n|   \u2514\u2500\u2500 ...\n\u2514\u2500\u2500 TOSCA-Metadata\n    \u2514\u2500\u2500 TOSCA.meta\n\n\n\n\nThe TOSCA.meta file must contain the reference to the definition that will be translated in VNFs in this case \nEntry-Definitions: Definitions/toscav1.yaml\n\n\nTOSCA-Meta-File-Version: 1.0\nCSAR-Version: 1.1\nCreated-By: OASIS TOSCA TC\nEntry-Definitions: Definitions/toscav1.yaml\n\n\n\n\nThe Scripts folder contains all the files required from the lifecycle interfaces of the VNFs.\n\n\nThe \ntoscav1.yaml\n is a Definition of Network Service. It contains this descriptor.\n\n\n\ntosca_definitions_version: tosca_iperf_nsd\ntosca_default_namespace:    # Optional. default namespace (schema, types version)\ndescription: NSD for deploing an iperf scenario\nmetadata:\n  ID:                 # ID of this Network Service Descriptor\n  vendor: Fokus       # Provider or vendor of the Network Service\n  version: 0.1 Alpha  # Version of the Network Service Descriptor imports:\n\n\ntopology_template:\n  node_templates:\n    iperf-server: #VNF1\n      type: openbaton.type.VNF.GENERIC\n      properties:\n        id:\n        vendor: Fokus\n        version:\n        configurations:\n          name: server-configurations\n          configurationParameters:\n            - key: value\n            - key2: value2\n        vnfPackageLocation: \n        deployment_flavour:\n          - flavour_key: m1.small\n      requirements:\n        - virtualLink: private\n        - host:\n            node: VDU2\n            type: openbaton.relationships.HostedOn\n      interfaces:\n        Standard: # lifecycle\n          create: install.sh\n          start: install-srv.sh\n    iperf-client:\n      type: openbaton.type.VNF.GENERIC\n      properties:\n        id:\n        vendor: Fokus\n        version: 0.1\n        configurations:\n          name: server-configurations\n          configurationParameters:\n            - key: value\n            - key2: value2\n        vnfPackageLocation: \n        deployment_flavour:\n          - flavour_key: m1.small\n      requirements:\n        - virtualLink: private\n        - host:\n            node: VDU1\n            type: openbaton.relationships.HostedOn\n      interfaces:\n        openbaton.interfaces.lifecycle: # lifecycle\n          INSTANCIATE:\n            - install.sh\n          CONFIGURE:\n            - server_configure_only.sh\n          START:\n            - iperf_client_start.sh\n    VDU1:\n      type: openbaton.type.VDU\n      properties:\n        vm_image:\n          - ubuntu-14.04-server-cloudimg-amd64-disk1\n        scale_in_out: 2\n        vimInstanceName: vim-instance\n      requirements:\n         - virtual_link: [CP1]\n      capabilities:\n        host:\n          valid_source_types: openbaton.type.VDU\n    VDU2:\n      type: openbaton.type.VDU\n      properties:\n        vm_image:\n          - ubuntu-14.04-server-cloudimg-amd64-disk1\n        scale_in_out: 2\n        vimInstanceName: vim-instance\n      requirements:\n        - virtual_link: [CP2]\n      capabilities:\n        host:\n          valid_source_types: openbaton.type.VDU\n\n    private:\n      type: tosca.nodes.nfv.VL\n      properties:\n        vendor: Fokus\n      capabilities:\n        virtual_linkable:\n          valid_source_types: tosca.nodes.nfv.CP\n\n    CP1: #endpoint of VNF1\n      type: tosca.nodes.nfv.CP\n      properties:\n        floatingIp: random\n      requirements:\n        virtualbinding: VDU1\n      virtualLink: private\n\n    CP2: #endpoint of VNF2\n      type: tosca.nodes.nfv.CP\n      properties:\n        floatingIp: random\n      requirements:\n        virtualbinding: VDU2\n      virtualLink: private\n\n\n\n\n\n\nTOSCA lifecycle interface to OpenBaton lifecycle event\n\n\nIn \nTOSCA simple profile YAML\n is defined the interface \ntosca.interfaces.node.lifecycle.Standard\n . This interface defines the lifecycle of a service since \nOpenBaton is using different lifecycle events the mapping between these two definitions follows the rules described in the table below:\n\n\n\n\n\n\n\n\ntosca.interfaces.node.lifecycle.Standard\n\n\nopenbaton.interfaces.lifecycle\n\n\n\n\n\n\n\n\n\n\ncreate\n\n\nINSTANTIATE\n\n\n\n\n\n\nconfigure\n\n\nCONFIGURE\n\n\n\n\n\n\nstart\n\n\nSTART\n\n\n\n\n\n\nstop\n\n\nSTOP\n\n\n\n\n\n\ndelete\n\n\nTERMINATE\n\n\n\n\n\n\n\n\nCSAR on-bording\n\n\nAfter create the CSAR with all scripts in the folder and the link to the definition, you can store this package and OpenBaton will persist all the Scripts and the VNFs inside of the definition. \nTo retrieve the files you can use the dashboard in the page of VNFPackages under Catalogue menu, also you can use the page of VNF Descriptors to see the VNFs defined in \ntoscav1.yaml\n\n\nFor on-boarding the CSAR use this command:\n\n\n$ curl -X POST -v -F file=@iperf.csar \nhttp://localhost:8080/api/v1/csar\n\n\n\n\n\n\n\n\n\n\n\n\n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "TOSCA CSAR on-boarding"
        }, 
        {
            "location": "/tosca-CSAR-onboarding/#tosca-csar-on-boarding", 
            "text": "The Cloud Service Archive  CSAR  is a package defined by OASIS TOSCA.\nIt is a compressed file that includes a TOSCA definition template of a Network Service, and all the scripts or files that a VNF needs for the lifecycle time from creation to termination.\nThe CSAR is a zip file with this structure:  \u251c\u2500\u2500 Definitions\n|   \u2514\u2500\u2500 toscav1.yaml\n\u251c\u2500\u2500 Scripts\n|   \u251c\u2500\u2500 install.sh\n|   \u2514\u2500\u2500 ...\n\u2514\u2500\u2500 TOSCA-Metadata\n    \u2514\u2500\u2500 TOSCA.meta  The TOSCA.meta file must contain the reference to the definition that will be translated in VNFs in this case  Entry-Definitions: Definitions/toscav1.yaml  TOSCA-Meta-File-Version: 1.0\nCSAR-Version: 1.1\nCreated-By: OASIS TOSCA TC\nEntry-Definitions: Definitions/toscav1.yaml  The Scripts folder contains all the files required from the lifecycle interfaces of the VNFs.  The  toscav1.yaml  is a Definition of Network Service. It contains this descriptor.  \ntosca_definitions_version: tosca_iperf_nsd\ntosca_default_namespace:    # Optional. default namespace (schema, types version)\ndescription: NSD for deploing an iperf scenario\nmetadata:\n  ID:                 # ID of this Network Service Descriptor\n  vendor: Fokus       # Provider or vendor of the Network Service\n  version: 0.1 Alpha  # Version of the Network Service Descriptor imports:\n\n\ntopology_template:\n  node_templates:\n    iperf-server: #VNF1\n      type: openbaton.type.VNF.GENERIC\n      properties:\n        id:\n        vendor: Fokus\n        version:\n        configurations:\n          name: server-configurations\n          configurationParameters:\n            - key: value\n            - key2: value2\n        vnfPackageLocation: \n        deployment_flavour:\n          - flavour_key: m1.small\n      requirements:\n        - virtualLink: private\n        - host:\n            node: VDU2\n            type: openbaton.relationships.HostedOn\n      interfaces:\n        Standard: # lifecycle\n          create: install.sh\n          start: install-srv.sh\n    iperf-client:\n      type: openbaton.type.VNF.GENERIC\n      properties:\n        id:\n        vendor: Fokus\n        version: 0.1\n        configurations:\n          name: server-configurations\n          configurationParameters:\n            - key: value\n            - key2: value2\n        vnfPackageLocation: \n        deployment_flavour:\n          - flavour_key: m1.small\n      requirements:\n        - virtualLink: private\n        - host:\n            node: VDU1\n            type: openbaton.relationships.HostedOn\n      interfaces:\n        openbaton.interfaces.lifecycle: # lifecycle\n          INSTANCIATE:\n            - install.sh\n          CONFIGURE:\n            - server_configure_only.sh\n          START:\n            - iperf_client_start.sh\n    VDU1:\n      type: openbaton.type.VDU\n      properties:\n        vm_image:\n          - ubuntu-14.04-server-cloudimg-amd64-disk1\n        scale_in_out: 2\n        vimInstanceName: vim-instance\n      requirements:\n         - virtual_link: [CP1]\n      capabilities:\n        host:\n          valid_source_types: openbaton.type.VDU\n    VDU2:\n      type: openbaton.type.VDU\n      properties:\n        vm_image:\n          - ubuntu-14.04-server-cloudimg-amd64-disk1\n        scale_in_out: 2\n        vimInstanceName: vim-instance\n      requirements:\n        - virtual_link: [CP2]\n      capabilities:\n        host:\n          valid_source_types: openbaton.type.VDU\n\n    private:\n      type: tosca.nodes.nfv.VL\n      properties:\n        vendor: Fokus\n      capabilities:\n        virtual_linkable:\n          valid_source_types: tosca.nodes.nfv.CP\n\n    CP1: #endpoint of VNF1\n      type: tosca.nodes.nfv.CP\n      properties:\n        floatingIp: random\n      requirements:\n        virtualbinding: VDU1\n      virtualLink: private\n\n    CP2: #endpoint of VNF2\n      type: tosca.nodes.nfv.CP\n      properties:\n        floatingIp: random\n      requirements:\n        virtualbinding: VDU2\n      virtualLink: private", 
            "title": "TOSCA CSAR on-boarding"
        }, 
        {
            "location": "/tosca-CSAR-onboarding/#tosca-lifecycle-interface-to-openbaton-lifecycle-event", 
            "text": "In  TOSCA simple profile YAML  is defined the interface  tosca.interfaces.node.lifecycle.Standard  . This interface defines the lifecycle of a service since \nOpenBaton is using different lifecycle events the mapping between these two definitions follows the rules described in the table below:     tosca.interfaces.node.lifecycle.Standard  openbaton.interfaces.lifecycle      create  INSTANTIATE    configure  CONFIGURE    start  START    stop  STOP    delete  TERMINATE", 
            "title": "TOSCA lifecycle interface to OpenBaton lifecycle event"
        }, 
        {
            "location": "/tosca-CSAR-onboarding/#csar-on-bording", 
            "text": "After create the CSAR with all scripts in the folder and the link to the definition, you can store this package and OpenBaton will persist all the Scripts and the VNFs inside of the definition. \nTo retrieve the files you can use the dashboard in the page of VNFPackages under Catalogue menu, also you can use the page of VNF Descriptors to see the VNFs defined in  toscav1.yaml  For on-boarding the CSAR use this command:  $ curl -X POST -v -F file=@iperf.csar  http://localhost:8080/api/v1/csar     \n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "CSAR on-bording"
        }, 
        {
            "location": "/dummy-NSR/", 
            "text": "Tutorial: Dummy Network Service Record\n\n\n\n\nThis tutorial explains how to deploy a Network Service Record composed by Dummy VNFs. It is typically used for testing that the installation of the NFVO went fine. This tutorial makes use of: \n\n\nRequirements\n\n\nIn order to execute this scenario, you need to have the following components up and running: \n\n\n\n\nNFVO\n\n\nTest plugin\n\n\nDummy-VNFM\n \n\n\n\n\nPreparation\n\n\nIf not yet running start the NFVO and the Dummy-VNFM (refer to it's readme file on how to start it).\n\n\nStore the VimInstance\n\n\nUpload a VimInstance with the type \ntest\n to the NFVO (e.g. this \nVimInstance\n). \nThe type \ntest\n will make sure that the NFVO uses the test-plugin for network services deployed using this VimInstance.  \n\n\nStore the Network Service Descriptor\n\n\nDownload the following \nNSD\n and upload it to the NFVO either using the dashboard or the cli. \n\n\nDeploy the Network Service Descriptor\n\n\nDeploy the stored NSD either using the dashboard or the cli. Below you find a view from the dashboard for doing it: \n\n\n\n\nConclusions\n\n\nAfter the Dummy-Vnfm and the NFVO finished their work the deployed NSR will change to \nACTIVE\n state.\n\nNo virtual machines were created and no real network service was deployed.\n\nThe test-plugin ensured that the NFVO thought that all the required resources were allocated and the VimInstance created. \nThe Dummy-Vnfm lead the NFVO to believe that it created virtual machines and executed the lifecycle event scripts on them. \n\n\n\n\n\n\n\n\n\n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Dummy NSR"
        }, 
        {
            "location": "/dummy-NSR/#tutorial-dummy-network-service-record", 
            "text": "This tutorial explains how to deploy a Network Service Record composed by Dummy VNFs. It is typically used for testing that the installation of the NFVO went fine. This tutorial makes use of:", 
            "title": "Tutorial: Dummy Network Service Record"
        }, 
        {
            "location": "/dummy-NSR/#requirements", 
            "text": "In order to execute this scenario, you need to have the following components up and running:    NFVO  Test plugin  Dummy-VNFM", 
            "title": "Requirements"
        }, 
        {
            "location": "/dummy-NSR/#preparation", 
            "text": "If not yet running start the NFVO and the Dummy-VNFM (refer to it's readme file on how to start it).", 
            "title": "Preparation"
        }, 
        {
            "location": "/dummy-NSR/#store-the-viminstance", 
            "text": "Upload a VimInstance with the type  test  to the NFVO (e.g. this  VimInstance ). \nThe type  test  will make sure that the NFVO uses the test-plugin for network services deployed using this VimInstance.", 
            "title": "Store the VimInstance"
        }, 
        {
            "location": "/dummy-NSR/#store-the-network-service-descriptor", 
            "text": "Download the following  NSD  and upload it to the NFVO either using the dashboard or the cli.", 
            "title": "Store the Network Service Descriptor"
        }, 
        {
            "location": "/dummy-NSR/#deploy-the-network-service-descriptor", 
            "text": "Deploy the stored NSD either using the dashboard or the cli. Below you find a view from the dashboard for doing it:", 
            "title": "Deploy the Network Service Descriptor"
        }, 
        {
            "location": "/dummy-NSR/#conclusions", 
            "text": "After the Dummy-Vnfm and the NFVO finished their work the deployed NSR will change to  ACTIVE  state. \nNo virtual machines were created and no real network service was deployed. \nThe test-plugin ensured that the NFVO thought that all the required resources were allocated and the VimInstance created. \nThe Dummy-Vnfm lead the NFVO to believe that it created virtual machines and executed the lifecycle event scripts on them.     \n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Conclusions"
        }, 
        {
            "location": "/iperf-NSR/", 
            "text": "Tutorial: iPerf Network Service\n\n\n\n\nThis tutorial explains how to deploy Network Service that uses iPerf. iPerf is a tool for active measurements of the maximum achievable bandwidth between two or more machines.\nThis tutorial makes use of:\n\n\n\n\nGeneric VNFM (\ngeneric-vnfm\n)\n\n\nGeneric EMS (\ngeneric ems\n)\n\n\nOpenStack plugin (\nopenstack-plugin\n)\n\n\n\n\nRequirements\n\n\nIn order to execute this scenario, you need to have the following components up and running:\n\n\n\n\nThe NFVO\n\n\nthe OpenStack plugin\n\n\nthe Generic VNFM (includes already generic EMS)\n\n\na PoP (of type openstack) registered. You can use the following \njson descriptor\n by changing the values to your needs.\n\n\n\n\nStore the Network Service Descriptor\n\n\nDownload the following \niPerf NSD using private IPs\n or \niPerf NSD using floating IPs\n, and upload it in the catalogue either using the dashboard or the cli.\n\n\nUsing dashboard\n\n\nIf you want to use the Dashboard (checkout the \ndashboard documentation\n for more information on how to use it), open it at the URL http://your-ip-here:8080 and log in (default username and password are \nadmin\n and \nopenbaton\n). Go to \nCatalogue -\n NS Descriptors\n and choose the NSD of your choice by clicking on \nUpload NSD\n and selecting the Descriptor's json file.\n\n\n\n\nUsing CLI\n\n\nIf you want to use the CLI (checkout the \nopenbaton-client documentation\n for more information on how to install it), you need to execute the following command in order to onboard the NSD iof the iPerf scenario by using private IPs:\n\n\n$./openbaton.sh NetworkServiceDescriptor-create tutorial-iperf-NSR-privateIPs.json\n\n\n\n\nOnce this request is processed successfully it returns the following:\n\n\n+------------------ +------------------------------------------------------------------ +\n| PROPERTY          | VALUE                                                             |\n+------------------ +------------------------------------------------------------------ +\n| VNFD              |                                                                   |\n|                   | id: 4625f79d-8d02-44bf-a97b-d93c991d8bef - name:  iperf-server    |\n|                   | id: 703f09db-0b05-4260-bbf0-89ee4d976ae3 - name:  iperf-client    |\n|                   |                                                                   |\n| VNF_DEPENDENCY    |                                                                   |\n|                   | id: b1e850b7-0194-4062-9bdb-75ee356e1dce                          |\n|                   |                                                                   |\n| id                | 658c2b21-4af6-4489-84f7-ee864159404c                              |\n|                   |                                                                   |\n| hb_version        | 1                                                                 |\n|                   |                                                                   |\n| name              | NSD iperf + privateIPs                                            |\n|                   |                                                                   |\n| vendor            | FOKUS                                                             |\n|                   |                                                                   |\n| version           | 1.0                                                               |\n|                   |                                                                   |\n| VLD               |                                                                   |\n|                   | id: 53ab8671-126c-4918-b3e1-34aaa449558a - name:  private         |\n|                   |                                                                   |\n+------------------ +------------------------------------------------------------------ +\n\n\n\n\n\nDeploy the Network Service Descriptor\n\n\nAs soon as you onboarded the NSD to the NFVO you can deploy this NSD either by using the dashboard or the CLI.\n\n\nUsing dashboard\n\n\nThis part shows you how to deploy an onboarded NSD via the dashboard. You need to go again to the GUI, go to \nCatalogue -\n NS Descriptors\n, and open the drop down menu by clicking on \nAction\n. Afterwards you need to press the \nLaunch\n button in order to start the deployment of this NSD.\n\n\n\n\nIf you go to \nOrchestrate NS -\n NS Records\n in the menu on the left side, you can follow the deployment process and check the current status of the deploying NSD.\n\n\nUsing CLI\n\n\nYou can also use the CLI for deploying existing NSDs. Therefore, you need to execute the following command in order to start the deployment. The ID of the NSD to deploy can be found either by using the dashboard or getting it from the output when onboarding a new NSD as done in the previous step. The command to deploy the previously onboarded NSD looks like shown below:\n\n\n$./openbaton.sh NetworkServiceRecord-create 658c2b21-4af6-4489-84f7-ee864159404c\n\n\n\n\nThe execution of this command produces the following output:\n\n\n+------------------------ +------------------------------------------------------------- +\n| PROPERTY                | VALUE                                                        |\n+------------------------ +------------------------------------------------------------- +\n| id                      | 8c6cca05-9042-4a9b-8736-4178c75f5c54                         |\n|                         |                                                              |\n| vendor                  | FOKUS                                                        |\n|                         |                                                              |\n| version                 | 1.0                                                          |\n|                         |                                                              |\n| VLR                     |                                                              |\n|                         | id: 09dfce1d-12ee-450c-8ca8-eb3c68ecf768 - name:  private    |\n|                         |                                                              |\n| VNF_DEPENDENCY          |                                                              |\n|                         | id: e88b2593-d339-4ec8-9606-f9300cf6163e                     |\n|                         |                                                              |\n| descriptor_reference    | 658c2b21-4af6-4489-84f7-ee864159404c                         |\n|                         |                                                              |\n| status                  | NULL                                                         |\n|                         |                                                              |\n| name                    | NSD iperf + privateIPs                                       |\n|                         |                                                              |\n+------------------------ +------------------------------------------------------------- +\n\n\n\n\nIn order to follow the deployment process you can retrieve information by passing the ID of the deploying NSR:\n\n\n$./openbaton.sh NetworkServiceRecord-findById 8c6cca05-9042-4a9b-8736-4178c75f5c54\n+------------------------ +------------------------------------------------------------------ +\n| PROPERTY                | VALUE                                                             |\n+------------------------ +------------------------------------------------------------------ +\n| id                      | 8c6cca05-9042-4a9b-8736-4178c75f5c54                              |\n|                         |                                                                   |\n| vendor                  | FOKUS                                                             |\n|                         |                                                                   |\n| version                 | 1.0                                                               |\n|                         |                                                                   |\n| VLR                     |                                                                   |\n|                         | id: 09dfce1d-12ee-450c-8ca8-eb3c68ecf768 - name:  private         |\n|                         |                                                                   |\n| VNFR                    |                                                                   |\n|                         | id: f1ed92eb-8b41-4113-a4c0-958e629dd425 - name:  iperf-client    |\n|                         | id: d11c93ff-c7b2-4ad2-8e7e-32571a5cd3b0 - name:  iperf-server    |\n|                         |                                                                   |\n| VNF_DEPENDENCY          |                                                                   |\n|                         | id: e88b2593-d339-4ec8-9606-f9300cf6163e                          |\n|                         |                                                                   |\n| descriptor_reference    | 658c2b21-4af6-4489-84f7-ee864159404c                              |\n|                         |                                                                   |\n| status                  | ACTIVE                                                            |\n|                         |                                                                   |\n| name                    | NSD iperf + privateIPs                                            |\n|                         |                                                                   |\n+------------------------ +------------------------------------------------------------------ +\n\n\n\n\nConclusions\n\n\nWhen all the VNF Records are done with all of the scripts defined in the lifecycle events, the NFVO will put the state of the VNF Record to ACTIVE and when all the VNF Records are in state ACTIVE, also the Network Service Record will be in state ACTIVE. This means that the service was correctly run.\n\n\nAddtional information about this scenario\n\n\nIn this page there is a full use case example explaining how the deployment process works, step-by-step. We assume that the NFVO and the Generic VNFM are ready to receive invocations.\n\n\nThe following pictures shows what is going to be deployed, an \nIperf\n client and an Iperf server.\n\n\n\n\nAs shown in the picture, the iperf server is the source of the dependency and the client is the target. In this case the client needs the IP of the server. The semantics of the vnf dependency is: the source provides some parameters to the target.\n\n\nBefore starting we need to send the VimInstance to the NFVO and the Network Service Descriptor. For doing this please have a look into the \nVim instance documentation\n, \nVNF Package documentation\n and \nNetwork Service Descriptor documentation\n. In fact, for creating a Network Service Record, we need to have a Network Service Descriptor loaded into the catalogue with two Virtual Network Functions (iperf client and server) created from a VNF Package. A Virtual Network Function Descriptor Json-File for Iperf client looks like this:\n\n\n{\n  \nname\n:\niperf-client\n,\n  \nvendor\n:\nFOKUS\n,\n  \nversion\n:\n1.0\n,\n  \nlifecycle_event\n:[\n    {\n      \nevent\n:\nCONFIGURE\n,\n      \nlifecycle_events\n:[\n        \nserver_configure.sh\n\n      ]\n    },\n    {\n      \nevent\n:\nINSTANTIATE\n,\n      \nlifecycle_events\n:[\n        \ninstall.sh\n\n      ]\n    }\n  ],\n  \nvdu\n:[\n    {\n      \nvm_image\n:[\n        \nubuntu-14.04-server-cloudimg-amd64-disk1\n\n      ],\n      \nscale_in_out\n:1,\n      \nvnfc\n:[\n        {\n          \nconnection_point\n:[\n            {\n              \nvirtual_link_reference\n:\nprivate\n\n            }\n          ]\n        }\n      ],\n      \nvimInstanceName\n:[\nvim-instance\n]\n    }\n  ],\n  \nvirtual_link\n:[\n    {\n      \nname\n:\nprivate\n\n    }\n  ],\n  \ndeployment_flavour\n:[\n    {\n      \nflavour_key\n:\nm1.small\n\n    }\n  ],\n  \ntype\n:\nclient\n,\n  \nendpoint\n:\ngeneric\n,\n  \nvnfPackageLocation\n:\nhttps://github.com/openbaton/vnf-scripts.git\n\n}\n\n\n\n\nThis is a perfect example of a dependency. The VNFManager Generic, after creation of the client VNF described, will run the \ninstall.sh\n script during the instantiate method. The install.sh script is:\n\n\n#!/bin/bash\n\nsudo apt-get update \n sudo apt-get install -y iperf screen\n\n\n\n\nAs said before in the documentation \nVNFManager Generic\n, \nthe scripts in the CONFIGURE lifecycle event need to start with the type of the source VNF followed by _ and the name of the script\n, so the `server_configure.sh is:\n\n\n#!/bin/bash\n\nscreen -d -m -S client iperf -c $server_private -t 300\n\n\n\n\nThese scripts shown above, are contained in the VNF Package or in a git repository accessible from the VM. Be aware that all the scripts will be executed with root permissions. Once all these steps are done we are ready to create a Network Service Record from the id of the Network Service Descriptor. \n\n\nLet's again have a look at the sequence diagram of a create Network Service Record operation.\n\n\n\n\nWhen the Network Service Record create is called with the Iperf Network Service Descriptor's id, the steps defined in the sequence diagram above happen.\n\n\nINSTANTIATE Method\n\n\nThe first message sent to the Generic VNFM is the INSTANTIATE message \n(1)\n. This message contains the VNF Descriptor and some other parameters needed to create the VNF Record, for instance the list of Virtual Link Records. The Generic VNFM  is called and then the create Virtual Network Function Record and the Virtual Network Function Record is created \n(2)\n and sent back to the NFVO into a GrantOperation message \n(3)\n. This message will trigger the NFVO to check if there are enough resources to create that VNF Record. If so, then a GrantOperation message with the updated VNF Record is sent back to the Generic VNFManager. Then the Generic VNFManager creates an AllocateResources message with the received VNF Record and sends it to the NFVO \n(4)\n. The NFVO after creating the Resources (VMs) sends back the AllocateResources message to the VNFManager. Here the instantiate method is called \n(5)\n. Inside this method, the scripts (or the link to the git repository containing the scripts) contained in the VNF Package is sent to the EMS, the scripts are saved locally to the VM and then the Generic VNFManager will call the execution of each script defined in the VNF Descriptor \n(6)\n. Once all of the scripts are executed and there wasn't any error, the VNFManager sends the Instantiate message back to the NFVO \n(7)\n. \n\n\nMODIFY Method\n\n\nIf the VNF is target for some dependencies, like the iperf client, the MODIFY message is sent to the VNFManager by the NFVO \n(8)\n. Then the VNFManager executes the scripts contained in the CONFIGURE lifecycle event defined in the VNF Descriptor \n(9)\n, and sends back the modify message to the NFVO \n(10)\n, if no errors occurred. In this case, the scripts environment will contain the variables defined in the related VNF dependency.\n\n\nSTART Method\n\n\nHere exactly as before, the NFVO sends the START message to the Generic VNFManager \n(11)\n, and the VNFManager calls the EMS for execution of the scripts defined in the START lifecycle (none for this example) \n(12)\n. And the start message is then sent back to the NFVO meaning that no errors occurred \n(13)\n.\n\n\nConclusions\n\n\nWhen all the VNF Records are done with all of the scripts defined in the lifecycle events, the NFVO will put the state of the VNF Record to ACTIVE and when all the VNF Records are in state ACTIVE, also the Network Service Record will be in state ACTIVE. This means that the service was correctly run. For knowing more about the states of a VNF Record please refer to \nVNF Record state documentation\n\n\n\n\n\n\n\n\n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  &amp;&amp; (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Iperf Scenario"
        }, 
        {
            "location": "/iperf-NSR/#tutorial-iperf-network-service", 
            "text": "This tutorial explains how to deploy Network Service that uses iPerf. iPerf is a tool for active measurements of the maximum achievable bandwidth between two or more machines.\nThis tutorial makes use of:   Generic VNFM ( generic-vnfm )  Generic EMS ( generic ems )  OpenStack plugin ( openstack-plugin )", 
            "title": "Tutorial: iPerf Network Service"
        }, 
        {
            "location": "/iperf-NSR/#requirements", 
            "text": "In order to execute this scenario, you need to have the following components up and running:   The NFVO  the OpenStack plugin  the Generic VNFM (includes already generic EMS)  a PoP (of type openstack) registered. You can use the following  json descriptor  by changing the values to your needs.", 
            "title": "Requirements"
        }, 
        {
            "location": "/iperf-NSR/#store-the-network-service-descriptor", 
            "text": "Download the following  iPerf NSD using private IPs  or  iPerf NSD using floating IPs , and upload it in the catalogue either using the dashboard or the cli.  Using dashboard  If you want to use the Dashboard (checkout the  dashboard documentation  for more information on how to use it), open it at the URL http://your-ip-here:8080 and log in (default username and password are  admin  and  openbaton ). Go to  Catalogue -  NS Descriptors  and choose the NSD of your choice by clicking on  Upload NSD  and selecting the Descriptor's json file.   Using CLI  If you want to use the CLI (checkout the  openbaton-client documentation  for more information on how to install it), you need to execute the following command in order to onboard the NSD iof the iPerf scenario by using private IPs:  $./openbaton.sh NetworkServiceDescriptor-create tutorial-iperf-NSR-privateIPs.json  Once this request is processed successfully it returns the following:  +------------------ +------------------------------------------------------------------ +\n| PROPERTY          | VALUE                                                             |\n+------------------ +------------------------------------------------------------------ +\n| VNFD              |                                                                   |\n|                   | id: 4625f79d-8d02-44bf-a97b-d93c991d8bef - name:  iperf-server    |\n|                   | id: 703f09db-0b05-4260-bbf0-89ee4d976ae3 - name:  iperf-client    |\n|                   |                                                                   |\n| VNF_DEPENDENCY    |                                                                   |\n|                   | id: b1e850b7-0194-4062-9bdb-75ee356e1dce                          |\n|                   |                                                                   |\n| id                | 658c2b21-4af6-4489-84f7-ee864159404c                              |\n|                   |                                                                   |\n| hb_version        | 1                                                                 |\n|                   |                                                                   |\n| name              | NSD iperf + privateIPs                                            |\n|                   |                                                                   |\n| vendor            | FOKUS                                                             |\n|                   |                                                                   |\n| version           | 1.0                                                               |\n|                   |                                                                   |\n| VLD               |                                                                   |\n|                   | id: 53ab8671-126c-4918-b3e1-34aaa449558a - name:  private         |\n|                   |                                                                   |\n+------------------ +------------------------------------------------------------------ +", 
            "title": "Store the Network Service Descriptor"
        }, 
        {
            "location": "/iperf-NSR/#deploy-the-network-service-descriptor", 
            "text": "As soon as you onboarded the NSD to the NFVO you can deploy this NSD either by using the dashboard or the CLI.  Using dashboard  This part shows you how to deploy an onboarded NSD via the dashboard. You need to go again to the GUI, go to  Catalogue -  NS Descriptors , and open the drop down menu by clicking on  Action . Afterwards you need to press the  Launch  button in order to start the deployment of this NSD.   If you go to  Orchestrate NS -  NS Records  in the menu on the left side, you can follow the deployment process and check the current status of the deploying NSD.  Using CLI  You can also use the CLI for deploying existing NSDs. Therefore, you need to execute the following command in order to start the deployment. The ID of the NSD to deploy can be found either by using the dashboard or getting it from the output when onboarding a new NSD as done in the previous step. The command to deploy the previously onboarded NSD looks like shown below:  $./openbaton.sh NetworkServiceRecord-create 658c2b21-4af6-4489-84f7-ee864159404c  The execution of this command produces the following output:  +------------------------ +------------------------------------------------------------- +\n| PROPERTY                | VALUE                                                        |\n+------------------------ +------------------------------------------------------------- +\n| id                      | 8c6cca05-9042-4a9b-8736-4178c75f5c54                         |\n|                         |                                                              |\n| vendor                  | FOKUS                                                        |\n|                         |                                                              |\n| version                 | 1.0                                                          |\n|                         |                                                              |\n| VLR                     |                                                              |\n|                         | id: 09dfce1d-12ee-450c-8ca8-eb3c68ecf768 - name:  private    |\n|                         |                                                              |\n| VNF_DEPENDENCY          |                                                              |\n|                         | id: e88b2593-d339-4ec8-9606-f9300cf6163e                     |\n|                         |                                                              |\n| descriptor_reference    | 658c2b21-4af6-4489-84f7-ee864159404c                         |\n|                         |                                                              |\n| status                  | NULL                                                         |\n|                         |                                                              |\n| name                    | NSD iperf + privateIPs                                       |\n|                         |                                                              |\n+------------------------ +------------------------------------------------------------- +  In order to follow the deployment process you can retrieve information by passing the ID of the deploying NSR:  $./openbaton.sh NetworkServiceRecord-findById 8c6cca05-9042-4a9b-8736-4178c75f5c54\n+------------------------ +------------------------------------------------------------------ +\n| PROPERTY                | VALUE                                                             |\n+------------------------ +------------------------------------------------------------------ +\n| id                      | 8c6cca05-9042-4a9b-8736-4178c75f5c54                              |\n|                         |                                                                   |\n| vendor                  | FOKUS                                                             |\n|                         |                                                                   |\n| version                 | 1.0                                                               |\n|                         |                                                                   |\n| VLR                     |                                                                   |\n|                         | id: 09dfce1d-12ee-450c-8ca8-eb3c68ecf768 - name:  private         |\n|                         |                                                                   |\n| VNFR                    |                                                                   |\n|                         | id: f1ed92eb-8b41-4113-a4c0-958e629dd425 - name:  iperf-client    |\n|                         | id: d11c93ff-c7b2-4ad2-8e7e-32571a5cd3b0 - name:  iperf-server    |\n|                         |                                                                   |\n| VNF_DEPENDENCY          |                                                                   |\n|                         | id: e88b2593-d339-4ec8-9606-f9300cf6163e                          |\n|                         |                                                                   |\n| descriptor_reference    | 658c2b21-4af6-4489-84f7-ee864159404c                              |\n|                         |                                                                   |\n| status                  | ACTIVE                                                            |\n|                         |                                                                   |\n| name                    | NSD iperf + privateIPs                                            |\n|                         |                                                                   |\n+------------------------ +------------------------------------------------------------------ +", 
            "title": "Deploy the Network Service Descriptor"
        }, 
        {
            "location": "/iperf-NSR/#conclusions", 
            "text": "When all the VNF Records are done with all of the scripts defined in the lifecycle events, the NFVO will put the state of the VNF Record to ACTIVE and when all the VNF Records are in state ACTIVE, also the Network Service Record will be in state ACTIVE. This means that the service was correctly run.", 
            "title": "Conclusions"
        }, 
        {
            "location": "/iperf-NSR/#addtional-information-about-this-scenario", 
            "text": "In this page there is a full use case example explaining how the deployment process works, step-by-step. We assume that the NFVO and the Generic VNFM are ready to receive invocations.  The following pictures shows what is going to be deployed, an  Iperf  client and an Iperf server.   As shown in the picture, the iperf server is the source of the dependency and the client is the target. In this case the client needs the IP of the server. The semantics of the vnf dependency is: the source provides some parameters to the target.  Before starting we need to send the VimInstance to the NFVO and the Network Service Descriptor. For doing this please have a look into the  Vim instance documentation ,  VNF Package documentation  and  Network Service Descriptor documentation . In fact, for creating a Network Service Record, we need to have a Network Service Descriptor loaded into the catalogue with two Virtual Network Functions (iperf client and server) created from a VNF Package. A Virtual Network Function Descriptor Json-File for Iperf client looks like this:  {\n   name : iperf-client ,\n   vendor : FOKUS ,\n   version : 1.0 ,\n   lifecycle_event :[\n    {\n       event : CONFIGURE ,\n       lifecycle_events :[\n         server_configure.sh \n      ]\n    },\n    {\n       event : INSTANTIATE ,\n       lifecycle_events :[\n         install.sh \n      ]\n    }\n  ],\n   vdu :[\n    {\n       vm_image :[\n         ubuntu-14.04-server-cloudimg-amd64-disk1 \n      ],\n       scale_in_out :1,\n       vnfc :[\n        {\n           connection_point :[\n            {\n               virtual_link_reference : private \n            }\n          ]\n        }\n      ],\n       vimInstanceName :[ vim-instance ]\n    }\n  ],\n   virtual_link :[\n    {\n       name : private \n    }\n  ],\n   deployment_flavour :[\n    {\n       flavour_key : m1.small \n    }\n  ],\n   type : client ,\n   endpoint : generic ,\n   vnfPackageLocation : https://github.com/openbaton/vnf-scripts.git \n}  This is a perfect example of a dependency. The VNFManager Generic, after creation of the client VNF described, will run the  install.sh  script during the instantiate method. The install.sh script is:  #!/bin/bash\n\nsudo apt-get update   sudo apt-get install -y iperf screen  As said before in the documentation  VNFManager Generic ,  the scripts in the CONFIGURE lifecycle event need to start with the type of the source VNF followed by _ and the name of the script , so the `server_configure.sh is:  #!/bin/bash\n\nscreen -d -m -S client iperf -c $server_private -t 300  These scripts shown above, are contained in the VNF Package or in a git repository accessible from the VM. Be aware that all the scripts will be executed with root permissions. Once all these steps are done we are ready to create a Network Service Record from the id of the Network Service Descriptor.   Let's again have a look at the sequence diagram of a create Network Service Record operation.   When the Network Service Record create is called with the Iperf Network Service Descriptor's id, the steps defined in the sequence diagram above happen.  INSTANTIATE Method  The first message sent to the Generic VNFM is the INSTANTIATE message  (1) . This message contains the VNF Descriptor and some other parameters needed to create the VNF Record, for instance the list of Virtual Link Records. The Generic VNFM  is called and then the create Virtual Network Function Record and the Virtual Network Function Record is created  (2)  and sent back to the NFVO into a GrantOperation message  (3) . This message will trigger the NFVO to check if there are enough resources to create that VNF Record. If so, then a GrantOperation message with the updated VNF Record is sent back to the Generic VNFManager. Then the Generic VNFManager creates an AllocateResources message with the received VNF Record and sends it to the NFVO  (4) . The NFVO after creating the Resources (VMs) sends back the AllocateResources message to the VNFManager. Here the instantiate method is called  (5) . Inside this method, the scripts (or the link to the git repository containing the scripts) contained in the VNF Package is sent to the EMS, the scripts are saved locally to the VM and then the Generic VNFManager will call the execution of each script defined in the VNF Descriptor  (6) . Once all of the scripts are executed and there wasn't any error, the VNFManager sends the Instantiate message back to the NFVO  (7) .   MODIFY Method  If the VNF is target for some dependencies, like the iperf client, the MODIFY message is sent to the VNFManager by the NFVO  (8) . Then the VNFManager executes the scripts contained in the CONFIGURE lifecycle event defined in the VNF Descriptor  (9) , and sends back the modify message to the NFVO  (10) , if no errors occurred. In this case, the scripts environment will contain the variables defined in the related VNF dependency.  START Method  Here exactly as before, the NFVO sends the START message to the Generic VNFManager  (11) , and the VNFManager calls the EMS for execution of the scripts defined in the START lifecycle (none for this example)  (12) . And the start message is then sent back to the NFVO meaning that no errors occurred  (13) .", 
            "title": "Addtional information about this scenario"
        }, 
        {
            "location": "/iperf-NSR/#conclusions_1", 
            "text": "When all the VNF Records are done with all of the scripts defined in the lifecycle events, the NFVO will put the state of the VNF Record to ACTIVE and when all the VNF Records are in state ACTIVE, also the Network Service Record will be in state ACTIVE. This means that the service was correctly run. For knowing more about the states of a VNF Record please refer to  VNF Record state documentation    \n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  &amp;&amp; (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Conclusions"
        }, 
        {
            "location": "/ims-NSR/", 
            "text": "Tutorial: OpenIMSCore Network Service Record\n\n\n\n\nThis tutorial shows how to deploy a Network Service Record composed by 5 VNFs, a basic OpenIMSCore.\n\n\nCompared to the \nIperf-Server - Iperf-Client\n the example provided here is far more complex. So we assume you are fimiliar with the architecture.\n\n\nRequirements\n\n\nIn order to execute this scenario, you need to have the following components up and running: \n\n\n\n\nNFVO\n\n\nGeneric VNFM\n\n\nOpenstack-Plugin\n\n\n\n\nStore the VimInstance\n\n\nUpload a VimInstance to the NFVO (e.g. this \nVimInstance\n). \n\n\nPrepare the VNF Packages\n\n\nDownload the necessary \nfiles\n from the \ngithub repository\n and pack the \nVNF Packages\n for all 5 components ( scscf, icscf, pcscf, bind9, fhoss ).\n\n\nExample for creating the Icscf Virtual Network Function Package\n\n\n# Where to save the scripts\nGIT_REPO_LOC=/opt/vnf_packages_example_openimscore_openbaton\n# Clone the repository\ngit clone https://github.com/openbaton/opemimscore_example $GIT_REPO_LOC\n# Create the .tar file which needs to be uploaded\ncd $GIT_REPO_LOC/icscf\ntar -cf icscf.tar *\n\n\n\n\nFor this example we assume the network used to interconnect the components is called \"mgmt\", if you want to modify this example ensure you are naming the network accordingly, the scripts from the github do not handle different network names yet. Also the vimInstanceName may be different to you, depending on your setup. The deployment_flavor is optional but should containg enough RAM for the default configuration of the components to be able to run, else some components may crash on start. This example setup has been successfuly tested on clean \nUbuntu14.04 images\n with 2048 Mb RAM deployed on an \nOpenstack Kilo (2015.1.3)\n. Ensure that the image name defined in the Metadata.yaml of each package is existing.\n\n\nFinally onboard the packages.\n\n\nStore the Network Service Descriptor\n\n\nDownload the following \nNSD\n and upload it to the NFVO either using the dashboard or the cli. \nTake care to replace the vnfd ids with the ones you deployed.\n\n\nOpen the Dashboard (checkout the \ndashboard documentation\n for more information on how to use it), open it at the URL http://your-ip-here:8080 and log in (default username and password are \nadmin\n and \nopenbaton\n). Go to \nCatalogue -\n NS Descriptors\n and choose the NSD of your choice by clicking on \nUpload NSD\n and selecting the Descriptor's json file.\n\n\nDeploy the Network Service Descriptor\n\n\nDeploy the stored NSD either using the dashboard.\n\n\nYou need to go again to the GUI, go to \nCatalogue -\n NS Descriptors\n, and open the drop down menu by clicking on \nAction\n. Afterwards you need to press the \nLaunch\n button in order to start the deployment of this NSD.\n\n\nIf you go to \nOrchestrate NS -\n NS Records\n in the menu on the left side, you can follow the deployment process and check the current status of the deploying NSD.\n\n\nConclusions\n\n\nOnce the Network Service Record went to \"ACTIVE\" your \nOpenIMSCore\n - \nBind9\n - \nFHoSS\n deployment is finished.\n\n\n\n\nTo test your \nOpenIMSCore\n you may use a Sip client of your choice. Be sure to use the realm defined in your \nBind9 Virtual Network Function Descriptor\n while testing registration and call. By default the \nFHoSS\n conaints 2 users : alice and bob. The user is the same as the password, but you may also alter it to your needs modifying the \nFHoSS Virtual Network Function Descriptor\n ( You will find the users in \"var_user_data.sql\" file under the fhoss folder)\n\n\nFor Benchmarking we can use \nIMS Bench SIPp\n but then you should add more users to the \nFHoSS\n database since by default it only contains 2 users.\n\n\n\n\n\n\n\n\n\n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "OpenIMSCore example"
        }, 
        {
            "location": "/ims-NSR/#tutorial-openimscore-network-service-record", 
            "text": "This tutorial shows how to deploy a Network Service Record composed by 5 VNFs, a basic OpenIMSCore.  Compared to the  Iperf-Server - Iperf-Client  the example provided here is far more complex. So we assume you are fimiliar with the architecture.", 
            "title": "Tutorial: OpenIMSCore Network Service Record"
        }, 
        {
            "location": "/ims-NSR/#requirements", 
            "text": "In order to execute this scenario, you need to have the following components up and running:    NFVO  Generic VNFM  Openstack-Plugin", 
            "title": "Requirements"
        }, 
        {
            "location": "/ims-NSR/#store-the-viminstance", 
            "text": "Upload a VimInstance to the NFVO (e.g. this  VimInstance ).", 
            "title": "Store the VimInstance"
        }, 
        {
            "location": "/ims-NSR/#prepare-the-vnf-packages", 
            "text": "Download the necessary  files  from the  github repository  and pack the  VNF Packages  for all 5 components ( scscf, icscf, pcscf, bind9, fhoss ).  Example for creating the Icscf Virtual Network Function Package  # Where to save the scripts\nGIT_REPO_LOC=/opt/vnf_packages_example_openimscore_openbaton\n# Clone the repository\ngit clone https://github.com/openbaton/opemimscore_example $GIT_REPO_LOC\n# Create the .tar file which needs to be uploaded\ncd $GIT_REPO_LOC/icscf\ntar -cf icscf.tar *  For this example we assume the network used to interconnect the components is called \"mgmt\", if you want to modify this example ensure you are naming the network accordingly, the scripts from the github do not handle different network names yet. Also the vimInstanceName may be different to you, depending on your setup. The deployment_flavor is optional but should containg enough RAM for the default configuration of the components to be able to run, else some components may crash on start. This example setup has been successfuly tested on clean  Ubuntu14.04 images  with 2048 Mb RAM deployed on an  Openstack Kilo (2015.1.3) . Ensure that the image name defined in the Metadata.yaml of each package is existing.  Finally onboard the packages.", 
            "title": "Prepare the VNF Packages"
        }, 
        {
            "location": "/ims-NSR/#store-the-network-service-descriptor", 
            "text": "Download the following  NSD  and upload it to the NFVO either using the dashboard or the cli. \nTake care to replace the vnfd ids with the ones you deployed.  Open the Dashboard (checkout the  dashboard documentation  for more information on how to use it), open it at the URL http://your-ip-here:8080 and log in (default username and password are  admin  and  openbaton ). Go to  Catalogue -  NS Descriptors  and choose the NSD of your choice by clicking on  Upload NSD  and selecting the Descriptor's json file.", 
            "title": "Store the Network Service Descriptor"
        }, 
        {
            "location": "/ims-NSR/#deploy-the-network-service-descriptor", 
            "text": "Deploy the stored NSD either using the dashboard.  You need to go again to the GUI, go to  Catalogue -  NS Descriptors , and open the drop down menu by clicking on  Action . Afterwards you need to press the  Launch  button in order to start the deployment of this NSD.  If you go to  Orchestrate NS -  NS Records  in the menu on the left side, you can follow the deployment process and check the current status of the deploying NSD.", 
            "title": "Deploy the Network Service Descriptor"
        }, 
        {
            "location": "/ims-NSR/#conclusions", 
            "text": "Once the Network Service Record went to \"ACTIVE\" your  OpenIMSCore  -  Bind9  -  FHoSS  deployment is finished.   To test your  OpenIMSCore  you may use a Sip client of your choice. Be sure to use the realm defined in your  Bind9 Virtual Network Function Descriptor  while testing registration and call. By default the  FHoSS  conaints 2 users : alice and bob. The user is the same as the password, but you may also alter it to your needs modifying the  FHoSS Virtual Network Function Descriptor  ( You will find the users in \"var_user_data.sql\" file under the fhoss folder)  For Benchmarking we can use  IMS Bench SIPp  but then you should add more users to the  FHoSS  database since by default it only contains 2 users.    \n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Conclusions"
        }, 
        {
            "location": "/integration-test-use/", 
            "text": "How to use the Integration Tests\n\n\nOverview\n\n\nThis project provides integration tests for OpenBaton. \nTen tests are run.\n\n\nTest descriptions\n\n\n\n\nscenario-dummy-iperf\n\n\nscenario-many-dependencies\n\n\nscenario-real-iperf\n\n\nscenario-complex-ncat\n\n\nscenario-scaling\n\n\nerror-in-configure\n\n\nerror-in-instantiate\n\n\nerror-in-start\n\n\nerror-in-terminate\n\n\nwrong-lifecycle-event\n\n\n\n\nscenario-dummy-iperf\n uses the \nDummy VNFM\n to simulate a VNFM and therefore tests the communication between NFVO and VNFM. \nIt does not actually deploy a network service. The fake network service is a simple iperf scenario with one server and one client. \n\n\nscenario-many-dependencies\n also uses the Dummy VNFM but its fake network service is a little bit more complex in the sense that it has many VNFD with many dependencies between them. \n\n\nThe test \nscenario-real-iperf\n actually deploys a network service on openstack. \nIt consists of two VNFD and deploys one iperf server and two iperf clients. The clients contact the server. \n\n\nThe test \nscenario-complex-ncat\n deploys a more complex network service on openstack. \nFive virtual machines will be running and acting as peers. \nThe following picture shows the architecture in which the peers connect to each other using ncat and send their ip address. \nA peer at the beginning of an arrow acts as an ncat client and connects to the peer at the end of the arrow. \nThe receiving peer stores the ip address of the sender so that it is possible to verify which peer connected to which. \nThe two colours represent the two different networks on which the peers are running and connecting. \nBlue is the network \nprivate\n and black \nprivate2\n.\n\n\n\n\nThe test \nscenario-scaling\n tests the scaling function of Openbaton. \nIt starts by deploying two VMs one acting as an ncat server and one as an ncat client which sends his ip address to the server so that it is possible to check if the client actually connected to the server. \nThen it executes some scaling functions like scale out and scale in and checks if new instances of the server and the client are deployed. Cases like scale in on just one instance and scale out on the maximum number of instances are included. \nIt also examines if the client instances are provided with the ip addresses of the new server instances, so that they are able to connect to them. \nTo see detailed information about which scaling functions are executed exactly please refer to the \nscenario-scaling.ini\n file in the project.\n\n\nThe tests \nerror-in-configure\n, \nerror-in-instantiate\n, \nerror-in-start\n, \nerror-in-terminate\n each deploy a network service from a NSD which contains a failing script in the particular lifecycle event and tests if the NFVO handles it correctly. \n\n\nThe test \nwrong-lifecycle-event\n tries to onboard a NSD to the NFVO which contains an undefined lifecycle event. The test will pass if the onboarding is not successful. \n\n\nIn every test a vim instance and a network service descriptor are stored on the orchestrator and the network service launched. \nIf that is successful, the network service is stopped and the network service record, network service descriptor and the vim instance are removed. \nIn the cases of the \nscenario-real-iperf\n, \nscenario-complex-ncat\n and \nscenario-scaling\n test also the service itself is tested, i.e. if iperf is running and the clients can connect to the server. Therefore the integration tests will execute some scripts for testing on the virtual machines. \n\n\nRequirements\n\n\n\n\nA running NFVO with the openstack-plugin and test-plugin\n\n\nA running Generic VNFM\n\n\nA running Dummy VNFM AMQP\n\n\n\n\nInstallation and configuration\n\n\nIf your NFVO does not yet contain the test-plugin and openstack-plugin (look for jars named \ntest-plugin\n and \nopenstack-plugin\n in the directory \nnfvo/plugins/vim-drivers\n) you will have to get them first. Therefore git clone the \ntest-plugin\n project to your machine, use a shell to navigate to the project's root directory and execute \n./gradlew build\n. You will find the test-plugin jar in the folder \nbuild/libs/\n. Copy it into the directory \nnfvo/plugins/vim-drivers\n of the NFVO. Do the same for the \nopenstack-plugin\n.\n\n\nUse git to clone the integration-test project to your machine. \nIn \nintegration-tests/src/main/resources\n is a file named integration-test.properties. \nOpen it and set the property values according to your needs. \n\n\n\n\n\n\n\n\nField\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nnfvo-ip\n\n\nThe ip of the machine on which the NFVO you want to use is running\n\n\n\n\n\n\nnfvo-port\n\n\nThe port on which the NFVO is running\n\n\n\n\n\n\nnfvo-usr\n\n\nThe username required for logging in the NFVO\n\n\n\n\n\n\nnfvo-pwd\n\n\nThe password required for logging in the NFVO\n\n\n\n\n\n\nnfvo-project-id\n\n\nThe id of the project that the integration tests shall use\n\n\n\n\n\n\nnfvo-ssl-enabled\n\n\nSet this to \ntrue\n if the NFVO uses SSL\n\n\n\n\n\n\nlocal-ip\n\n\nThe ip of the machine on which the integration test is running\n\n\n\n\n\n\nclear-after-test\n\n\nIf set to \ntrue\n, the NFVO will be cleared of all the remaining NSRs, NSD, VNFPackages and Vim-Instances left from previous test\n\n\n\n\n\n\nintegration-test-scenarios\n\n\nHere you can specify a folder in which you can put integration test scenarios. If \n.ini\n files exist in this folder, the integration test will use just those files. If there are no files it will use the ones in the projects resource folder\n\n\n\n\n\n\nexternal-properties-file\n\n\nIf you want to use another file for fetching the properties. It is already preset to \n/etc/openbaton/integration-test/integration-test.properties\n. If it does not exist it will not be used.\n\n\n\n\n\n\n\n\nAfter that you will also need a keypair for openstack. Create one and download the private key as a .pem file. \nRename it to \nintegration-test.pem\n and provide it with the needed permissions by executing \nchmod 400 integration-test.pem\n.\nIf it does not exist already create the directory \n/etc/openbaton/integration-test\n on your machine and move the pem file into it. \nThe next step is to create a vim file. \nHere is an example where you just have to change some fields. \n\n\n{\n  \nname\n:\nvim-instance\n,\n  \nauthUrl\n:\nhttp://your-openstack-url\n,\n  \ntenant\n:\nthe tenant you use\n,\n  \nusername\n:\nopenstack username\n,\n  \npassword\n:\nopenstack password\n,\n  \nkeyPair\n:\nin here the one you created\n,\n  \nsecurityGroups\n: [\n    \ndefault\n\n  ],\n  \ntype\n:\nopenstack\n,\n  \nlocation\n:{\n    \nname\n:\nyour location\n,\n    \nlatitude\n:\nthe latitude\n,\n    \nlongitude\n:\nthe longitude\n\n  }\n}\n\n\n\n\nName the vim file \nreal-vim.json\n and add it to the folder \nintegration-tests/src/main/resources/etc/json_file/vim_instances/\n in the project.\nIn the folder \nintegration-tests/src/main/resources/etc/json_file/network_service_descriptors\n of the project you will find a file named NetworkServiceDescriptor-iperf-real.json and one named NetworkServiceDescriptor-complex-iperf.json. \nWe used the image ubuntu-14.04-server-cloudimg-amd64-disk1 for the virtual machines in openstack. \nIf you want to use another image, change every occurence of the above mentioned image in those two files to the name of the one you want to use and of course make sure it is available on openstack. \n\n\nIf you want to use another image, change every occurence of the above mentioned image to the name of the one you want to use and of course make sure it is available on openstack. \nIf you are using another image, you also have to configure the .ini files of the scenario-complex-iperf and scenario-real-iperf. \nThat is you have to look for the tasks of \nGenericServiceTester\n and change the value of vm-scripts-path to the path where you want to have the test scripts stored on your virtual machine and the value of user-name according to the user name used on the virtual machines deployed by the image. These were the steps to use another image.\n\n\nThe scenario \nerror-in-terminate.ini\n needs some special configuration in the NFVO if you want to run it. Change \nnfvo.delete.vnfr.wait\n to \ntrue\n in openbaton.properties before starting the NFVO.\n\n\nThen use a shell to navigate into the project's root directory. \nExecute the command \n./integration-tests.sh compile\n.\n\n\nStart the integration test\n\n\nBefore starting the integration tests be sure that the NFVO, Generic VNFM and Dummy VNFM you want to use are already running. \nThen start the test by executing \n./integration-tests.sh start\n.\nIt is possible to specify the test scenarios you want to run so that not every test in the \n/src/main/resources/integration-test-scenarios\n folder is executed. \nTherefore use additional command line arguments while starting the integration tests. Every scenario occuring as an argument will be executed. For example \n./integration-tests.sh start scenario-real-iperf.ini scenario-scaling.ini\n will just execute the tests described in the files \nscenario-real-iperf.ini\n and \nscenario-scaling.ini\n located in the folder \n/src/main/resources/integration-test-scenarios\n.\nIf you do not pass any command line arguments, every available scenario will be executed. To see which scenarios are available execute \n./integration-tests.sh list\n.\n\n\nTest results\n\n\nWhile the tests are running they will produce output to the console. This output will be logged in the file integration-test.log which is in the project's root directory. \nIf a test finished it will either tell you that it passed successfully or not. \nIf it did not pass correctly you will find the reason in the log file. \n\n\nWrite your own integration tests\n\n\nPlease refer to \nthis page\n.\n\n\n\n\n\n\n\n\n\n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Integration Tests"
        }, 
        {
            "location": "/integration-test-use/#how-to-use-the-integration-tests", 
            "text": "", 
            "title": "How to use the Integration Tests"
        }, 
        {
            "location": "/integration-test-use/#overview", 
            "text": "This project provides integration tests for OpenBaton. \nTen tests are run.", 
            "title": "Overview"
        }, 
        {
            "location": "/integration-test-use/#test-descriptions", 
            "text": "scenario-dummy-iperf  scenario-many-dependencies  scenario-real-iperf  scenario-complex-ncat  scenario-scaling  error-in-configure  error-in-instantiate  error-in-start  error-in-terminate  wrong-lifecycle-event   scenario-dummy-iperf  uses the  Dummy VNFM  to simulate a VNFM and therefore tests the communication between NFVO and VNFM. \nIt does not actually deploy a network service. The fake network service is a simple iperf scenario with one server and one client.   scenario-many-dependencies  also uses the Dummy VNFM but its fake network service is a little bit more complex in the sense that it has many VNFD with many dependencies between them.   The test  scenario-real-iperf  actually deploys a network service on openstack. \nIt consists of two VNFD and deploys one iperf server and two iperf clients. The clients contact the server.   The test  scenario-complex-ncat  deploys a more complex network service on openstack. \nFive virtual machines will be running and acting as peers. \nThe following picture shows the architecture in which the peers connect to each other using ncat and send their ip address. \nA peer at the beginning of an arrow acts as an ncat client and connects to the peer at the end of the arrow. \nThe receiving peer stores the ip address of the sender so that it is possible to verify which peer connected to which. \nThe two colours represent the two different networks on which the peers are running and connecting. \nBlue is the network  private  and black  private2 .   The test  scenario-scaling  tests the scaling function of Openbaton. \nIt starts by deploying two VMs one acting as an ncat server and one as an ncat client which sends his ip address to the server so that it is possible to check if the client actually connected to the server. \nThen it executes some scaling functions like scale out and scale in and checks if new instances of the server and the client are deployed. Cases like scale in on just one instance and scale out on the maximum number of instances are included. \nIt also examines if the client instances are provided with the ip addresses of the new server instances, so that they are able to connect to them. \nTo see detailed information about which scaling functions are executed exactly please refer to the  scenario-scaling.ini  file in the project.  The tests  error-in-configure ,  error-in-instantiate ,  error-in-start ,  error-in-terminate  each deploy a network service from a NSD which contains a failing script in the particular lifecycle event and tests if the NFVO handles it correctly.   The test  wrong-lifecycle-event  tries to onboard a NSD to the NFVO which contains an undefined lifecycle event. The test will pass if the onboarding is not successful.   In every test a vim instance and a network service descriptor are stored on the orchestrator and the network service launched. \nIf that is successful, the network service is stopped and the network service record, network service descriptor and the vim instance are removed. \nIn the cases of the  scenario-real-iperf ,  scenario-complex-ncat  and  scenario-scaling  test also the service itself is tested, i.e. if iperf is running and the clients can connect to the server. Therefore the integration tests will execute some scripts for testing on the virtual machines.", 
            "title": "Test descriptions"
        }, 
        {
            "location": "/integration-test-use/#requirements", 
            "text": "A running NFVO with the openstack-plugin and test-plugin  A running Generic VNFM  A running Dummy VNFM AMQP", 
            "title": "Requirements"
        }, 
        {
            "location": "/integration-test-use/#installation-and-configuration", 
            "text": "If your NFVO does not yet contain the test-plugin and openstack-plugin (look for jars named  test-plugin  and  openstack-plugin  in the directory  nfvo/plugins/vim-drivers ) you will have to get them first. Therefore git clone the  test-plugin  project to your machine, use a shell to navigate to the project's root directory and execute  ./gradlew build . You will find the test-plugin jar in the folder  build/libs/ . Copy it into the directory  nfvo/plugins/vim-drivers  of the NFVO. Do the same for the  openstack-plugin .  Use git to clone the integration-test project to your machine. \nIn  integration-tests/src/main/resources  is a file named integration-test.properties. \nOpen it and set the property values according to your needs.      Field  Value      nfvo-ip  The ip of the machine on which the NFVO you want to use is running    nfvo-port  The port on which the NFVO is running    nfvo-usr  The username required for logging in the NFVO    nfvo-pwd  The password required for logging in the NFVO    nfvo-project-id  The id of the project that the integration tests shall use    nfvo-ssl-enabled  Set this to  true  if the NFVO uses SSL    local-ip  The ip of the machine on which the integration test is running    clear-after-test  If set to  true , the NFVO will be cleared of all the remaining NSRs, NSD, VNFPackages and Vim-Instances left from previous test    integration-test-scenarios  Here you can specify a folder in which you can put integration test scenarios. If  .ini  files exist in this folder, the integration test will use just those files. If there are no files it will use the ones in the projects resource folder    external-properties-file  If you want to use another file for fetching the properties. It is already preset to  /etc/openbaton/integration-test/integration-test.properties . If it does not exist it will not be used.     After that you will also need a keypair for openstack. Create one and download the private key as a .pem file. \nRename it to  integration-test.pem  and provide it with the needed permissions by executing  chmod 400 integration-test.pem .\nIf it does not exist already create the directory  /etc/openbaton/integration-test  on your machine and move the pem file into it. \nThe next step is to create a vim file. \nHere is an example where you just have to change some fields.   {\n   name : vim-instance ,\n   authUrl : http://your-openstack-url ,\n   tenant : the tenant you use ,\n   username : openstack username ,\n   password : openstack password ,\n   keyPair : in here the one you created ,\n   securityGroups : [\n     default \n  ],\n   type : openstack ,\n   location :{\n     name : your location ,\n     latitude : the latitude ,\n     longitude : the longitude \n  }\n}  Name the vim file  real-vim.json  and add it to the folder  integration-tests/src/main/resources/etc/json_file/vim_instances/  in the project.\nIn the folder  integration-tests/src/main/resources/etc/json_file/network_service_descriptors  of the project you will find a file named NetworkServiceDescriptor-iperf-real.json and one named NetworkServiceDescriptor-complex-iperf.json. \nWe used the image ubuntu-14.04-server-cloudimg-amd64-disk1 for the virtual machines in openstack. \nIf you want to use another image, change every occurence of the above mentioned image in those two files to the name of the one you want to use and of course make sure it is available on openstack.   If you want to use another image, change every occurence of the above mentioned image to the name of the one you want to use and of course make sure it is available on openstack. \nIf you are using another image, you also have to configure the .ini files of the scenario-complex-iperf and scenario-real-iperf. \nThat is you have to look for the tasks of  GenericServiceTester  and change the value of vm-scripts-path to the path where you want to have the test scripts stored on your virtual machine and the value of user-name according to the user name used on the virtual machines deployed by the image. These were the steps to use another image.  The scenario  error-in-terminate.ini  needs some special configuration in the NFVO if you want to run it. Change  nfvo.delete.vnfr.wait  to  true  in openbaton.properties before starting the NFVO.  Then use a shell to navigate into the project's root directory. \nExecute the command  ./integration-tests.sh compile .", 
            "title": "Installation and configuration"
        }, 
        {
            "location": "/integration-test-use/#start-the-integration-test", 
            "text": "Before starting the integration tests be sure that the NFVO, Generic VNFM and Dummy VNFM you want to use are already running. \nThen start the test by executing  ./integration-tests.sh start .\nIt is possible to specify the test scenarios you want to run so that not every test in the  /src/main/resources/integration-test-scenarios  folder is executed. \nTherefore use additional command line arguments while starting the integration tests. Every scenario occuring as an argument will be executed. For example  ./integration-tests.sh start scenario-real-iperf.ini scenario-scaling.ini  will just execute the tests described in the files  scenario-real-iperf.ini  and  scenario-scaling.ini  located in the folder  /src/main/resources/integration-test-scenarios .\nIf you do not pass any command line arguments, every available scenario will be executed. To see which scenarios are available execute  ./integration-tests.sh list .", 
            "title": "Start the integration test"
        }, 
        {
            "location": "/integration-test-use/#test-results", 
            "text": "While the tests are running they will produce output to the console. This output will be logged in the file integration-test.log which is in the project's root directory. \nIf a test finished it will either tell you that it passed successfully or not. \nIf it did not pass correctly you will find the reason in the log file.", 
            "title": "Test results"
        }, 
        {
            "location": "/integration-test-use/#write-your-own-integration-tests", 
            "text": "Please refer to  this page .    \n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Write your own integration tests"
        }, 
        {
            "location": "/extend/", 
            "text": "Extend OpenBaton\n\n\nBeing an open source implementation, OpenBaton can be easily extended for supporting additional features or capabilities.\n\n\nExtend the NFVO\n\n\nThe NFVO has been implemented as a java modular application using the Spring.io framework. It is pretty easy to add a new module for extending the supported features. Please refer to the \nNFVO documentation\n for learning a bit more about the NFVO architecture.\n\n\nIt is possible to extend the NFVO by implementing new plugins. The options available is to implement a new Monitoring plugin or a new VIM plugin. The procedure is the same so we will explain how to write a VIM plugin, please see the \nplugin sdk documentation page\n\n\nBefore doing that you can have a look inside the architecture of the NFVO in the \nfollowing page\n\n\n\n\n\n\n\n\n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Extend it"
        }, 
        {
            "location": "/extend/#extend-openbaton", 
            "text": "Being an open source implementation, OpenBaton can be easily extended for supporting additional features or capabilities.  Extend the NFVO  The NFVO has been implemented as a java modular application using the Spring.io framework. It is pretty easy to add a new module for extending the supported features. Please refer to the  NFVO documentation  for learning a bit more about the NFVO architecture.  It is possible to extend the NFVO by implementing new plugins. The options available is to implement a new Monitoring plugin or a new VIM plugin. The procedure is the same so we will explain how to write a VIM plugin, please see the  plugin sdk documentation page  Before doing that you can have a look inside the architecture of the NFVO in the  following page    \n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Extend OpenBaton"
        }, 
        {
            "location": "/nfvo-architecture/", 
            "text": "NFVO Architecture\n\n\nNFVO\n is a modular software composed by the modules illustrated in the following picture:\n\n\n\n\nAPI\n\n\nThis module contains the necessary classes exposing APIs as ReST server. The most importat ones are the classes managing VimInstances, NetworkServiceDescriptors and NetworkServiceRecords. For more details please see \nthe api documentation\n\n\nMAIN\n\n\nThis module contains the classes in charge of the startup of the whole system and gathering configuratons for instance.\n\n\nCOMMON\n\n\nThis module contains the classes that are common to the NFVO\n\n\nCLI\n\n\nThis module contains the NFVO console.\n\n\nDASHBOARD\n\n\nThis module contains the web dashboard available at localhost:8080\n\n\nCORE-INT\n\n\nThis module contains the interfaces of the core functionalities regarding only the internal NFVO interfaces. Most of them are definend in \nETSI MANO specification\n in NFV-MANO interfaces section.\n\n\nCORE-IMPL\n\n\nThis module contains the beans implementing the core-int interfaces.\n\n\nVNFM-INT\n\n\nThis module contains the interfaces of the core functionalities regarding only the NFVO interfaces to the VnfManagers. Most of them are definend in \nETSI MANO specification\n in NFV-MANO interfaces section.\n\n\nVNFM-IMPL\n\n\nThis module contains the beans implementing the vnfm-int interfaces.\n\n\nREPOSITORY\n\n\nThis module contains specific repositories interfacing the database in a generic way.\n\n\nCATALOGUE\n\n\nThis module contains the complete model of NFVO that is sharde in the openbaton libraries.\n\n\nVIM-INT\n\n\nThis module contains the interfaces of the core functionalities regarding only the NFVO interfaces to the VIM. Most of them are definend in \nETSI MANO specification\n in NFV-MANO interfaces section.\n\n\nVIM-IMPL\n\n\nThis module contains the beans implementing the vim-int interfaces.\n\n\nPLUGIN\n\n\nThis module contains the utility classes used to interface to the openbaton plugins.\n\n\nVIM-DRIVERS\n\n\nThis module contains the interface for the VIM openbaton plugins.\n\n\nEXCEPTION\n\n\nThis module contains all the exception classes common to every project containing openbaton libraries.\n\n\nMONITORING\n\n\nThis module contains the interface for the monitoring of the openbaton plugins.\n\n\n\n\n\n\n\n\n\n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "NFVO Architecture"
        }, 
        {
            "location": "/nfvo-architecture/#nfvo-architecture", 
            "text": "NFVO  is a modular software composed by the modules illustrated in the following picture:   API  This module contains the necessary classes exposing APIs as ReST server. The most importat ones are the classes managing VimInstances, NetworkServiceDescriptors and NetworkServiceRecords. For more details please see  the api documentation  MAIN  This module contains the classes in charge of the startup of the whole system and gathering configuratons for instance.  COMMON  This module contains the classes that are common to the NFVO  CLI  This module contains the NFVO console.  DASHBOARD  This module contains the web dashboard available at localhost:8080  CORE-INT  This module contains the interfaces of the core functionalities regarding only the internal NFVO interfaces. Most of them are definend in  ETSI MANO specification  in NFV-MANO interfaces section.  CORE-IMPL  This module contains the beans implementing the core-int interfaces.  VNFM-INT  This module contains the interfaces of the core functionalities regarding only the NFVO interfaces to the VnfManagers. Most of them are definend in  ETSI MANO specification  in NFV-MANO interfaces section.  VNFM-IMPL  This module contains the beans implementing the vnfm-int interfaces.  REPOSITORY  This module contains specific repositories interfacing the database in a generic way.  CATALOGUE  This module contains the complete model of NFVO that is sharde in the openbaton libraries.  VIM-INT  This module contains the interfaces of the core functionalities regarding only the NFVO interfaces to the VIM. Most of them are definend in  ETSI MANO specification  in NFV-MANO interfaces section.  VIM-IMPL  This module contains the beans implementing the vim-int interfaces.  PLUGIN  This module contains the utility classes used to interface to the openbaton plugins.  VIM-DRIVERS  This module contains the interface for the VIM openbaton plugins.  EXCEPTION  This module contains all the exception classes common to every project containing openbaton libraries.  MONITORING  This module contains the interface for the monitoring of the openbaton plugins.    \n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "NFVO Architecture"
        }, 
        {
            "location": "/vim-plugin/", 
            "text": "Create Vim Plugin\n\n\nOpenBaton is an open source project providing a reference implementation of the NFVO and VNFM based on the ETSI specification, it is implemented in java using the spring.io framework. It consists of two main components: a NFVO and a generic VNFM. This project plugin-sdk contains modules that are needed to implement a plugin for OpenBaton system.\n\n\nHow does this work?\n\n\nOpenBaton use the Remote Procedure Call (RPC) mechanism for implementing the Plugins. It offers an implementation of an interface that is used by the NFVO. \n\n\nRequirements\n\n\nBefore you can start with developing your own Vim Plugin you need to prepare your programming environment by installing/configuring the following requirements:\n\n\n\n\nJDK 7 (\ninstallation\n)\n\n\nGradle (\ninstallation\n)\n\n\n\n\nCreate a new project\n\n\nOnce you have started the IDE, click on File -\n New -\n Project...\n\n\nIn this dialog click on Gradle on the left and select java in the main properties window in the middle.\n\n\n\n\nThen click on next to go to the next window.\n\n\nIn the next dialog you need to define the GroupId, ArtifactId and the Version.\nMore information on the specific meaning can be found \nhere\n.\n\n\n\n\nContinue with the next dialog.\n\n\nIn this dialog you need to specify which gradle you want to use.\nIt is recommend to use the default gradle wrapper.\nAdditionally you can enable the auto-import.\n\n\n\n\nContinue with the next dialog by clicking on Next.\n\n\nIn the last dialog, you need to define the project name and the project location.\n\n\n\n\nOnce this is done you can click on Finish and continue with creating the Main Class.\n\n\nCreate the Main Class\n\n\nAfterwards, you need to create the Main Class of the VIM plugin which will be started in the end.\nFor doing so, right click on the root folder my-vim, then click on New -\n Directory and insert what is show below.\n\n\n\n\nClick on OK to continue.\n\n\nAdditionally you need to create a new package.\nThis is done by a right-click on the previously created directory java.\nClick on New -\n Package.\nHere you can define the package name.\n\n\n\n\nFinally you can create your MyVim Class by clicking (right click) on the previously created package and click on New -\n Java Class.\n\n\n\n\nOnce you did all these steps, the initial project structure is created.\nWhat we miss right now is the configuration of the gradle files to define and fetch dependencies we need for implementing the Vim plugin.\nThis is described in later sections.\n\n\nIn order to create a VIM plugin for OpenBaton system you need to add to your \nbuild.gradle\n file:\n\n\n\ngroup 'org.myplugin.example'\nversion '1.0-SNAPSHOT'\n\nbuildscript {\n    repositories {\n        mavenLocal()\n        mavenCentral()\n    }\n    dependencies {\n        classpath(\norg.springframework.boot:spring-boot-gradle-plugin:1.2.6.RELEASE\n)\n    }\n}\n\nrepositories {\n    maven { url \nhttp://get.openbaton.org:8081/nexus/content/groups/public/\n }\n}\n\napply plugin: 'java'\napply plugin: 'maven'\napply plugin: 'spring-boot'\n\n\nmainClassName = 'org.myplugin.example.Starter'\n\n\ndependencies {\n    compile 'org.openbaton:plugin-sdk:2.1.1'\n    compile'org.springframework:spring-context:4.2.1.RELEASE'\n}\n\n\n\n\n\nWrite your Vim plugin\n\n\nThe Vim plugin is splitted into two classes \n\n\n\n\nImplementation of \nVimDriver\n\n\nThe \nStarter Class\n that contain the main function for bootstrapping the Vim plugin\n\n\n\n\nType of Vim Instance\n\n\nOpenBaton provides a specific class for handling the \nopenstack\n type or the \ntest\n type thus these two types are supported. For all the other types a generic class will handle the communication between the NFVO and your plugin.\n\n\n1. Implement VimDriver\n\n\nThe \nVimDriver\n is an bastract class that contains tha basic functionalities that a Vim Instance has to provide. \n\n\nNOTE\n: If you want to implement a Monitoring plugin, then you need to implement the Abstract Class \nMonitoringPlugin\n\n\nYour \nMyVim\n class will implement the methods inherited from \nVimDriver\n that manages your Vim Instance:\n\n\n\n\n\n\n\n\nFunction\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nList\\\nNFVImage> listImages\n\n\nReturns the list of Images\n\n\n\n\n\n\nList\\\nServer> listServer\n\n\nReturns the list of Servers\n\n\n\n\n\n\nList\\\nNetwork> listNetworks\n\n\nReturns the list of Network\n\n\n\n\n\n\nList\\\nDeploymentFlavour> listFlavors\n\n\nReturns the list of DeploymentFlavour\n\n\n\n\n\n\nServer launchInstanceAndWait\n\n\nCreates a new Server\n\n\n\n\n\n\nvoid deleteServerByIdAndWait\n\n\nRemoves the Server with id\n\n\n\n\n\n\nNetwork createNetwork\n\n\nCreates a new Network\n\n\n\n\n\n\nNetwork getNetworkById\n\n\nReturns the Network with id\n\n\n\n\n\n\nNetwork updateNetwork\n\n\nUpdates a new Network\n\n\n\n\n\n\nboolean deleteNetwork\n\n\nDeletes the Network\n\n\n\n\n\n\nSubnet createSubnet\n\n\nCreates a new Subnet\n\n\n\n\n\n\nSubnet updateSubnet\n\n\nUpdates the Subnet\n\n\n\n\n\n\nboolean deleteSubnet\n\n\nDeletes the Subnet\n\n\n\n\n\n\nList\\\nString> getSubnetsExtIds\n\n\nReturns the list of SubnetsExtId\n\n\n\n\n\n\nDeploymentFlavour addFlavor\n\n\nAdds a new DeploymentFlavour\n\n\n\n\n\n\nDeploymentFlavour updateFlavor\n\n\nUpdates the DeploymentFlavour\n\n\n\n\n\n\nboolean deleteFlavor\n\n\nDeletes the DeploymentFlavour\n\n\n\n\n\n\nNFVImage addImage\n\n\nAdds a new NFVImage\n\n\n\n\n\n\nNFVImage updateImage\n\n\nUpdates the NFVImage\n\n\n\n\n\n\nNFVImage copyImage\n\n\nCopies the NFVImage\n\n\n\n\n\n\nboolean deleteImage\n\n\nDeletes the NFVImage\n\n\n\n\n\n\nQuota getQuota\n\n\nReturns the Quota\n\n\n\n\n\n\nString getType\n\n\nReturns the type\n\n\n\n\n\n\n\n\nAn example of the class:\n\n\npackage org.myplugin.example;\n\nimport org.openbaton.catalogue.mano.common.DeploymentFlavour;\nimport org.openbaton.catalogue.nfvo.*;\nimport org.openbaton.exceptions.VimDriverException;\nimport org.openbaton.vim.drivers.interfaces.VimDriver;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.context.annotation.Scope;\nimport org.springframework.stereotype.Service;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Set;\n\n@Service\n@Scope(\nprototype\n)\npublic class MyVim extends VimDriver{\n\n\n    private Logger log = LoggerFactory.getLogger(this.getClass());\n\n    @Override\n    public Server launchInstance(VimInstance vimInstance, String name, String image, String flavor, String keypair, Set\nString\n network, Set\nString\n secGroup, String userData) throws RemoteException {\n        // ...\n    }\n\n    @Override\n    public String getType(VimInstance vimInstance) {\n        // ...\n    }\n\n    @Override\n    public List\nNFVImage\n listImages(VimInstance vimInstance) {\n        // ...\n    }\n\n\n    public static void main(String[] args) {\n        PluginStarter.registerPlugin(MyVim.class, \nmy-type\n, \nbroker-ip\n, 5672, 10);\n    }\n}\n\n\n\n\nAs you can notice, there is the need of a \nmain\n method to start multiple instances of the plugin (in this example are 10, the last parameter).\n\n\nRun your Vim plugin in OpenBaton environment\n\n\nUnder the folder of your project \nsrc/main/resources\n you should create a file \nplugin.conf.properties\n and write the variable \ntype = \nthe-vim-type\n.\nThe structure of your project should be like:\n\n\n\n\nNow you can run \n./gradlew build\n and Gradle will create the jar that you can find in the folder \nbuild/libs/myPlugin-1.0-SNAPSHOT.jar\n.\n\n\nOnce all these steps are done, you can copy and paste the \nmyPlugin-1.0-SNAPSHOT.jar\n under the folder specified in the \nopenbaton.properties\n (under \n/etc/openbaton\n folder) \nplugin-installation-dir\n property, as default path_to_NFVO/plugins.\nThe plugin sends the log messages to NFVO, the NFVO writes them into a log file. The path to this file can be set with nfvo.plugin.log.path properties in the /etc/openbaton/openbaton.properties. \nCongratulations you have your version of the interface for your Vim Instance that will be used by NFVO\n\n\nUse my plugin\n\n\nOnce you copied the jar file into the right folder, you need to (re)start the NFVO. The plugin will automatically register and you can see that there will be a log file in the NFVO folder called \nplugin-myPlugin.log\n containing the logs of the plugin. The myPlugin now acts as a normal plugin so for using it check out the \nVim instance documentation\n in order to point out to the new plugin.\n\n\nNOTE\n: you can also launch your plugin from your command line just typing\n\n\n$ java -jar myPlugin-1.0-SNAPSHOT.jar\n\n\n\n\n\n\n\n\n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Write your own Plugin"
        }, 
        {
            "location": "/vim-plugin/#create-vim-plugin", 
            "text": "OpenBaton is an open source project providing a reference implementation of the NFVO and VNFM based on the ETSI specification, it is implemented in java using the spring.io framework. It consists of two main components: a NFVO and a generic VNFM. This project plugin-sdk contains modules that are needed to implement a plugin for OpenBaton system.", 
            "title": "Create Vim Plugin"
        }, 
        {
            "location": "/vim-plugin/#how-does-this-work", 
            "text": "OpenBaton use the Remote Procedure Call (RPC) mechanism for implementing the Plugins. It offers an implementation of an interface that is used by the NFVO.", 
            "title": "How does this work?"
        }, 
        {
            "location": "/vim-plugin/#requirements", 
            "text": "Before you can start with developing your own Vim Plugin you need to prepare your programming environment by installing/configuring the following requirements:   JDK 7 ( installation )  Gradle ( installation )   Create a new project  Once you have started the IDE, click on File -  New -  Project...  In this dialog click on Gradle on the left and select java in the main properties window in the middle.   Then click on next to go to the next window.  In the next dialog you need to define the GroupId, ArtifactId and the Version.\nMore information on the specific meaning can be found  here .   Continue with the next dialog.  In this dialog you need to specify which gradle you want to use.\nIt is recommend to use the default gradle wrapper.\nAdditionally you can enable the auto-import.   Continue with the next dialog by clicking on Next.  In the last dialog, you need to define the project name and the project location.   Once this is done you can click on Finish and continue with creating the Main Class.  Create the Main Class  Afterwards, you need to create the Main Class of the VIM plugin which will be started in the end.\nFor doing so, right click on the root folder my-vim, then click on New -  Directory and insert what is show below.   Click on OK to continue.  Additionally you need to create a new package.\nThis is done by a right-click on the previously created directory java.\nClick on New -  Package.\nHere you can define the package name.   Finally you can create your MyVim Class by clicking (right click) on the previously created package and click on New -  Java Class.   Once you did all these steps, the initial project structure is created.\nWhat we miss right now is the configuration of the gradle files to define and fetch dependencies we need for implementing the Vim plugin.\nThis is described in later sections.  In order to create a VIM plugin for OpenBaton system you need to add to your  build.gradle  file:  \ngroup 'org.myplugin.example'\nversion '1.0-SNAPSHOT'\n\nbuildscript {\n    repositories {\n        mavenLocal()\n        mavenCentral()\n    }\n    dependencies {\n        classpath( org.springframework.boot:spring-boot-gradle-plugin:1.2.6.RELEASE )\n    }\n}\n\nrepositories {\n    maven { url  http://get.openbaton.org:8081/nexus/content/groups/public/  }\n}\n\napply plugin: 'java'\napply plugin: 'maven'\napply plugin: 'spring-boot'\n\n\nmainClassName = 'org.myplugin.example.Starter'\n\n\ndependencies {\n    compile 'org.openbaton:plugin-sdk:2.1.1'\n    compile'org.springframework:spring-context:4.2.1.RELEASE'\n}", 
            "title": "Requirements"
        }, 
        {
            "location": "/vim-plugin/#write-your-vim-plugin", 
            "text": "The Vim plugin is splitted into two classes    Implementation of  VimDriver  The  Starter Class  that contain the main function for bootstrapping the Vim plugin   Type of Vim Instance  OpenBaton provides a specific class for handling the  openstack  type or the  test  type thus these two types are supported. For all the other types a generic class will handle the communication between the NFVO and your plugin.  1. Implement VimDriver  The  VimDriver  is an bastract class that contains tha basic functionalities that a Vim Instance has to provide.   NOTE : If you want to implement a Monitoring plugin, then you need to implement the Abstract Class  MonitoringPlugin  Your  MyVim  class will implement the methods inherited from  VimDriver  that manages your Vim Instance:     Function  Description      List\\ NFVImage> listImages  Returns the list of Images    List\\ Server> listServer  Returns the list of Servers    List\\ Network> listNetworks  Returns the list of Network    List\\ DeploymentFlavour> listFlavors  Returns the list of DeploymentFlavour    Server launchInstanceAndWait  Creates a new Server    void deleteServerByIdAndWait  Removes the Server with id    Network createNetwork  Creates a new Network    Network getNetworkById  Returns the Network with id    Network updateNetwork  Updates a new Network    boolean deleteNetwork  Deletes the Network    Subnet createSubnet  Creates a new Subnet    Subnet updateSubnet  Updates the Subnet    boolean deleteSubnet  Deletes the Subnet    List\\ String> getSubnetsExtIds  Returns the list of SubnetsExtId    DeploymentFlavour addFlavor  Adds a new DeploymentFlavour    DeploymentFlavour updateFlavor  Updates the DeploymentFlavour    boolean deleteFlavor  Deletes the DeploymentFlavour    NFVImage addImage  Adds a new NFVImage    NFVImage updateImage  Updates the NFVImage    NFVImage copyImage  Copies the NFVImage    boolean deleteImage  Deletes the NFVImage    Quota getQuota  Returns the Quota    String getType  Returns the type     An example of the class:  package org.myplugin.example;\n\nimport org.openbaton.catalogue.mano.common.DeploymentFlavour;\nimport org.openbaton.catalogue.nfvo.*;\nimport org.openbaton.exceptions.VimDriverException;\nimport org.openbaton.vim.drivers.interfaces.VimDriver;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.context.annotation.Scope;\nimport org.springframework.stereotype.Service;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Set;\n\n@Service\n@Scope( prototype )\npublic class MyVim extends VimDriver{\n\n\n    private Logger log = LoggerFactory.getLogger(this.getClass());\n\n    @Override\n    public Server launchInstance(VimInstance vimInstance, String name, String image, String flavor, String keypair, Set String  network, Set String  secGroup, String userData) throws RemoteException {\n        // ...\n    }\n\n    @Override\n    public String getType(VimInstance vimInstance) {\n        // ...\n    }\n\n    @Override\n    public List NFVImage  listImages(VimInstance vimInstance) {\n        // ...\n    }\n\n\n    public static void main(String[] args) {\n        PluginStarter.registerPlugin(MyVim.class,  my-type ,  broker-ip , 5672, 10);\n    }\n}  As you can notice, there is the need of a  main  method to start multiple instances of the plugin (in this example are 10, the last parameter).", 
            "title": "Write your Vim plugin"
        }, 
        {
            "location": "/vim-plugin/#run-your-vim-plugin-in-openbaton-environment", 
            "text": "Under the folder of your project  src/main/resources  you should create a file  plugin.conf.properties  and write the variable  type =  the-vim-type .\nThe structure of your project should be like:   Now you can run  ./gradlew build  and Gradle will create the jar that you can find in the folder  build/libs/myPlugin-1.0-SNAPSHOT.jar .  Once all these steps are done, you can copy and paste the  myPlugin-1.0-SNAPSHOT.jar  under the folder specified in the  openbaton.properties  (under  /etc/openbaton  folder)  plugin-installation-dir  property, as default path_to_NFVO/plugins.\nThe plugin sends the log messages to NFVO, the NFVO writes them into a log file. The path to this file can be set with nfvo.plugin.log.path properties in the /etc/openbaton/openbaton.properties. \nCongratulations you have your version of the interface for your Vim Instance that will be used by NFVO", 
            "title": "Run your Vim plugin in OpenBaton environment"
        }, 
        {
            "location": "/vim-plugin/#use-my-plugin", 
            "text": "Once you copied the jar file into the right folder, you need to (re)start the NFVO. The plugin will automatically register and you can see that there will be a log file in the NFVO folder called  plugin-myPlugin.log  containing the logs of the plugin. The myPlugin now acts as a normal plugin so for using it check out the  Vim instance documentation  in order to point out to the new plugin.  NOTE : you can also launch your plugin from your command line just typing  $ java -jar myPlugin-1.0-SNAPSHOT.jar   \n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Use my plugin"
        }, 
        {
            "location": "/vnfm-how-to-write/", 
            "text": "How to write a VNFManager\n\n\nThis section is going to describe how to write your own VNFManager by using any vnfm-sdk.\nMoreover, the vnfm-sdk contains all the things you may need for the development of the VNFManager of your choice as well.\n\n\nThe vnfm-sdk provides the following things:\n\n\n\n\nmultiple \nvnfm-sdks\n where you can choose your preferred type of communication\n\n\nCatalogue, shared with the NFVO containing all entities\n\n\nVNFMHelper\n for providing some methods out of the box\n\n\n\n\nRequirements\n\n\nBefore you can start with developing your own VNFManager you need to prepare your programming environment by installing/configuring the following requirements:\n\n\n\n\nJDK 7 (\ninstallation\n)\n\n\nGradle 1.12 or above (\ninstallation\n)\n\n\n\n\nDevelop your own VNFManager\n\n\nThis part is going to describe the steps you need to do to develop your own VNFManager with the help of any vnfm-sdk.\n\n\nThe practical parts of implementing a basic VNFManager will focus on the usage of a specific vnfm-sdk, namely the vnfm-sdk-jms.\n\n\nPreparations\n\n\nThis section describes the initial steps for creating the project structure and configuring essential files for developing your own VNFManager.\nThis can be done in two ways.\nEither you may use your favorite IDE or you may do everything manually via the command line.\n\n\nOnce this is done, you can start implementing your VNFManager by using different communication models, the catalogue and several helpers.\n\n\nUsing your favorite IDE\n\n\nIn the following we will create the project and setup the configuration files by using your favorite IDE.\nSo first of all, start your IDE and go to the next step.\nAll the details base on the usage of \nIntelliJIdea\n.\n\n\nCreate a new project\n\n\nOnce you have started the IDE, click on File -\n New -\n Project...\n\n\nIn this dialog click on Gradle on the left and select java in the main properties window in the middle.\n\n\n\n\nThen click on next to go to the next window.\n\n\nIn the next dialog you need to define the GroupId, ArtifactId and the Version.\nMore information on the specific meaning can be found \nhere\n.\n\n\n\n\nContinue with the next dialog.\n\n\nIn this dialog you need to specify which gradle you want to use.\nIt is recommend to use the default gradle wrapper.\nAdditionally you can enable the auto-import.\n\n\n\n\nContinue with the next dialog by clicking on Next.\n\n\nIn the last dialog, you need to define the project name and the project location.\n\n\n\n\nOnce this is done you can click on Finish and continue with creating the Main Class.\n\n\nCreate the Main Class\n\n\nAfterwards, you need to create the Main Class of the VNFManager which will be started in the end.\nFor doing so, right click on the root folder my-vnfm, then click on New -\n Directory and insert what is show below.\n\n\n\n\nClick on OK to continue.\n\n\nAdditionally you need to create a new package.\nThis is done by a right-click on the previously created directory java.\nClick on New -\n Package.\nHere you can define the package name.\n\n\n\n\nFinally you can create your Main Class by clicking (right click) on the previously created package and click on New -\n Java Class.\n\n\n\n\nOnce you did all these steps, the initial project structure is created.\nWhat we miss right now is the configuration of the gradle files to define and fetch dependencies we need for implementing the VNFManager.\nThis is described in later sections.\n\n\nCreate the properties files\n\n\nThe properties files are used to define several parameters you need at runtime.\nSo just create the following file structure.\n\n\nDo a right-click on the main folder located in the src folder.\nClick on New -\n Directory and create a new folder with the name resources.\n\n\nDo again a right-click on the newly created folder resources and click on New -\n File.\nThis you need to do two times.\nThe first file is called application.properties and the second one is called conf.properties.\n\n\nWhat these files should contain is explained \nhere\n.\n\n\nUsing the command line\n\n\nThis section refers to the developers which don't like to use any IDE.\nBy not using any IDE we need to create all the folders and configuration files manually.\nSo we start with creating the project structure, the Main Class, initializing the gradle wrapper and according configuration files.\n\n\nCreate project folder\n\n\nFirst of all you need to create a new directory for your VNFManager.\nHere we call the new VNFManager my-vnfm.\nSo this can be replaced by whatever you want.\n\n\n$ mkdir my-vnfm\n\n\n\n\nCreate the Main Class\n\n\nThe Main class is the most important class you need to consider.\nHere you implement your main method and also methods you need to have for your VNFManager.\nFurther explanations are done in the according sections.\nThis is only for creating a proper file structure.\nSo execute the following commands to create the Main class in a proper folder and package structure.\n\n\nFirst, you need to create the folders and package by executing the following command in your root folder of the project.\n\n\n$ mkdir -p src/main/java/org/openbaton/vnfm\n\n\n\n\nThis creates the java folder src/main/java with the proposed package name org.openbaton.vnfm.\n\n\nIn the next step you create the Main Class called MyVNFM in this case.\n\n\n$ vim src/main/java/org/openbaton/vnfm/MyVNFM.java\n\n\n\n\nAt this point you create only the basic Java Class used later as the Main Class for implementing your VNFManager.\nThe newly created Java Class should contain the following lines for now.\n\n\npackage org.openbaton.vnfm;\n\npublic class MyVNFM {\n}\n\n\n\n\nIf you have chosen a different package name you need to replace it as well at this point.\nOnce this is done, you need to initialize the gradle wrapper and configuring according files.\n\n\nThe Build.Gradle file\n\n\nFirst you need to create the build.gradle file by executing the following command from your root project folder.\n\n\n$ vim build.gradle\n\n\n\n\nThis gradle configuration file needs to contain initially the following lines.\n\n\nbuildscript {\n    repositories {\n        mavenCentral()\n    }\n\n    dependencies {\n        classpath(\norg.springframework.boot:spring-boot-gradle-plugin:1.3.1.RELEASE\n)\n    }\n}\n\napply plugin: 'java'\napply plugin: 'spring-boot'\n\n\n\n\nThe second gradle configuration is called settings.gradle.\nThis file contains only the project name.\nSo create a new file called settings.gradle in your root folder.\n\n\n$ vim settings.gradle\n\n\n\n\nAfterwards you need to add the following line containing your project name.\nIn our case my-vnfm.\n\n\nrootProject.name = 'my-vnfm'\n\n\n\n\nAfterwards go back to the root folder and run the following command to create automatically the gradle wrapper which is used for code management and compilation.\nFor more information on how to use the gradle wrapper have a look at the gradle wrapper documentation \nhere\n.\n\n\n$ gradle wrapper\n\n\n\n\nOnce you did all these steps, the initial project structure is created.\nWhat we miss right now is the configuration of the gradle files to define and fetch dependencies we need for implementing the VNFManager.\nThis is described in later sections.\n\n\nCreate the properties files\n\n\nThe properties files are used to define several parameters you need at runtime.\nSo just create the following file structure by executing the following commands.\n\n\n$ mkdir src/main/resources\n\n\n\n\nNow you need to create two new files by running both commands you can find in the following\n\n\n$ touch src/main/resources/application.properties\n$ touch src/main/resources/conf.properties\n\n\n\n\nWhat these files should contain is explained \nhere\n.\n\n\nConfigure Gradle\n\n\nFinally you need to extend your build.gradle for announcing the Main Class, plugins to apply and repositories to use.\nSo open the build.gradle an add missing line so that the file contains the following line.\n\n\n//...\n\nbootRepackage {\n    mainClass = 'org.openbaton.vnfm.MyVNFM'\n}\n\n//...\n\n\n\n\nTake care about the configuration of the mainClass.\nIf the name or package of your mainClass is different, you need to replace it here as well.\n\n\nProperty files\n\n\nThe previously created properties files are used to define several things.\nThey are located in src/main/resources and are called application.properties and conf.properties.\n\n\nThe \napplication.properties\n contains parameters for setting up all log levels. This file is useful for configuring the springframework (see \nSpring Boot configuration file\n). This file can contain the following lines.\n\n\nlogging.level.org.springframework=INFO\nlogging.level.org.hibernate=INFO\nlogging.level.org.apache=INFO\nlogging.level.org.jclouds=WARN\n# logging.level.org.springframework.security=WARN\nlogging.level.org.springframework.web = WARN\n\n# Level for loggers on classes inside the root package \norg.project.openbaton\n (and its\n# sub-packages)\nlogging.level.org.openbaton=INFO\n\n# Direct log to a log file\nlogging.file=/var/log/openbaton.log\n\nvnfm.rabbitmq.brokerIp=localhost\nvnfm.rabbitmq.management.port=15672\nvnfm.rabbitmq.autodelete=true\nvnfm.rabbitmq.durable=false\nvnfm.rabbitmq.exclusive=false\nvnfm.rabbitmq.minConcurrency=5\nvnfm.rabbitmq.maxConcurrency=15\n\n#########################################\n############## RabbitMQ #################\n#########################################\n\n# Comma-separated list of addresses to which the client should connect to.\n# spring.rabbitmq.addresses= 192.168.145.54\n# Create an AmqpAdmin bean.\n# spring.rabbitmq.dynamic=true\n# RabbitMQ host.\nspring.rabbitmq.host=${vnfm.rabbitmq.brokerIp}\n# Acknowledge mode of container.\n# spring.rabbitmq.listener.acknowledge-mode=\n# Start the container automatically on startup.\n# spring.rabbitmq.listener.auto-startup=true\n# Minimum number of consumers.\nspring.rabbitmq.listener.concurrency=5\n# Maximum number of consumers.\nspring.rabbitmq.listener.max-concurrency=30\n# Number of messages to be handled in a single request. It should be greater than or equal to the transaction size (if used).\n# spring.rabbitmq.listener.prefetch=\n# Number of messages to be processed in a transaction. For best results it should be less than or equal to the prefetch count.\n# spring.rabbitmq.listener.transaction-size=\n# Login user to authenticate to the broker.\nspring.rabbitmq.username=admin\n# Login to authenticate against the broker.\nspring.rabbitmq.password=openbaton\n# RabbitMQ port.\nspring.rabbitmq.port=5672\n# Requested heartbeat timeout, in seconds; zero for none.\n# spring.rabbitmq.requested-heartbeat=\n# Enable SSL support.\n# spring.rabbitmq.ssl.enabled=false\n# Path to the key store that holds the SSL certificate.\n# spring.rabbitmq.ssl.key-store=\n# Password used to access the key store.\n# spring.rabbitmq.ssl.key-store-password=\n# Trust store that holds SSL certificates.\n# spring.rabbitmq.ssl.trust-store=\n# Password used to access the trust store.\n# spring.rabbitmq.ssl.trust-store-password=\n# Virtual host to use when connecting to the broker.\n# spring.rabbitmq.virtual-host=\n\n\n\n\nIf you want to change log levels you need to adapt it here.\n\n\nNOTE\n: \nIf your VNFManager is running on a different machine than the rabbitmq broker, you need to change the \nvnfm.rabbit.brokerIp\n accordingly with the ip of the rabbitmq broker.\n\n\nThe \nconf.properties\n is also a very important configuration file.\nHere you need to define the type and endpoint of your VNFManager that is later used for registering on the NFVO.\nFurthermore, you can define your own parameters which can be used at runtime for whatever you want.\nSo this file has to contain at least the type and endpoint.\nAdditionally, it is defined the folder where the vim-plugins are located.\nIn this case the file should contain the following lines.\n\n\ntype=my-vnfm\nendpoint=my-vnfm-endpoint\nallocate = false\ndescription=The VNFM able to handle all the VNFs that follow specific conventions, see http://openbaton.github.io/\nenabled = true\nendpoint-type = RABBIT\nscript-max-time = 300000\nconcurrency = 15\ntransacted = false\n\n\n#### Additionally\nvim-plugin-dir = ./plugins\n\n\n\n\nWhere the parameters mean:\n\n\n\n\n\n\n\n\nParams\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\ntype\n\n\nThe type of VNF you are going to handle\n\n\n\n\n\n\nendpoint\n\n\nThe endpoint used for requesting this VNFManager\n\n\n\n\n\n\ndescription\n\n\nJust a useless description\n\n\n\n\n\n\nendpoint-type\n\n\ntype of the endpoint, either RABBIT or REST, depending on the sdk chosen. Check out next section\n\n\n\n\n\n\nenabled\n\n\ntrue if you want your vnfm to be enabled\n\n\n\n\n\n\nallocate\n\n\ntrue if the NFVO will ALLOCATE_RESOURCES, false if the VNFManager will do\n\n\n\n\n\n\nconcurrency\n\n\nThe number of concurrent Receiver (only for vnfm-sdk-jms)\n\n\n\n\n\n\ntransacted\n\n\nWhenever the JMS receiver method shoud be transacted, this allows the message to be resent in case of exception VNFManager side (only for vnfm-sdk-jms)\n\n\n\n\n\n\n\n\nChoose a vnfm-sdk\n\n\nBefore you can start with the implementation you need to select the type of communication you want to use for the communication between the Orchestrator (NFVO) and the VNFManager.\nEither you can use the vnfm-sdk-amqp for using the \nRabbitMQ\n or the vnfm-sdk-rest for using the \nReST\n interface.\nHowever, your choice doesn't effect the upcoming implementation, because the communication itself is done automatically in the background.\nBut have in mind that both libraries depend on \nSpringBoot\n.\nSo, if you want to avoid this dependency, a third option might be: just use the simple vnfm-sdk artifact.\nBy using the simple vnfm-sdk you need to take care about all the communication between NFVO and VNFManager by yourself.\n\n\nOnce you have imported one of the vnfm-sdks you will have access to all the model classes and the vnfm-sdk classes needed to implement a VNFManager.\n\n\nThe following section shows you how to import the vnfm-sdk-jms, representative for all the other opportunities.\n\n\nImport a vnfm-sdk\n\n\nThis section shows how to import and configure your VNFManager to make use of the vnfm-sdk-amqp.\n\n\nFor gathering the vnfm-sdk-amqp library you need to import the libraries by adding the missing lines to your build.gradle:\n\n\n//...\n\ndependencies {\n    compile 'org.hibernate:hibernate-core:4.3.10.Final'\n    compile 'org.openbaton:vnfm-sdk-amqp:2.1.1'\n}\n\n//...\n\n\n\n\nNote\n To make use of the vnfm-sdk-rest you need to change 'vnfm-sdk-amqp' to 'vnfm-sdk-rest' only.\n\n\nSo the final build.gradle file results like:\n\n\nbuildscript {\n    repositories {\n        mavenCentral()\n    }\n    dependencies {\n        classpath(\norg.springframework.boot:spring-boot-gradle-plugin:1.3.1.RELEASE\n)\n    }   \n\n}\n\napply plugin: 'java'\napply plugin: 'spring-boot'\n\nrepositories {\n    mavenCentral()\n    maven {\n            url \nhttp://get.openbaton.org:8081/nexus/content/groups/public\n\n    }\n}\n\ndependencies {\n    compile 'org.openbaton:vnfm-sdk-amqp:2.0.0'\n    compile 'org.hibernate:hibernate-core:4.3.10.Final'\n}\n\ngroup 'your.group'\nversion '1.0-SNAPSHOT'\n\nbootRepackage {\n    mainClass = 'org.openbaton.vnfm.MyVNFM'\n}\n\n\n\n\nOnce you did this, you need to trigger the gradle build process by running the following command via the command line in your project's root folder.\n\n\n$ ./gradlew build\n\n\n\n\nThis will fetch all the dependencies defined in the build.gradle and gives you access to all the Classes you need.\nYou can also do this by using the IDE by running the corresponding gradle task.\n\n\nImplementation of the VNFManager\n\n\nThis section is going to describe the implementation of a basic VNFManager by using the vnfm-sdk-jms.\nIn the end, the VNFManager will be able to allocate and terminate resources by using its own openstack-plugin.\n\n\nSo first of all you need to define the main method used for starting your VNFManager.\nSo add the following to your Main Class that it looks as follows:\n\n\npackage org.openbaton.vnfm;\n\nimport org.springframework.boot.SpringApplication;\n\npublic class MyVNFM {\n\n    public static void main(String[] args){\n        SpringApplication.run(MyVNFM.class);\n    }\n}\n\n\n\n\nAfterwards you need to extend your Main Class (in this case MyVNFM) with the \nAbstractVnfmSpringAmqp\n.\n\n\nThe \nAbstractVnfmSpringAmqp\n takes care of all the configuration you need to register/unregister the VNFManager to the NFVO and handles incoming messages.\nWhereas the \nAbstractVnfm\n, extended by the \nAbstractVnfmSpringAmqp\n, is independent of the type of communication.\nThis means more in detail that the \nAbstractVnfm\n processes the incoming messages and executes the right method depending on the defined Action inside the message.\nMoreover, it is responsible for loading predefined configuration files, setting up the VNFManager itself, creating the VNFR (based on the VNFD received in the first step) and doing essential parts like requesting the NFVO for granting operations or deciding who is responsible for allocate resources.\n\n\nOnce you extended your VNFMManger, you need to implement all the methods coming from the extension of \nAbstractVnfmSpringAmqp\n as shown below:\n\n\npackage org.openbaton.vnfm;\n\nimport org.openbaton.catalogue.mano.record.VNFCInstance;\nimport org.openbaton.catalogue.mano.record.VNFRecordDependency;\nimport org.openbaton.catalogue.mano.record.VirtualNetworkFunctionRecord;\nimport org.openbaton.catalogue.nfvo.Action;\nimport org.openbaton.catalogue.nfvo.VimInstance;\nimport org.openbaton.common.vnfm_sdk.amqp.AbstractVnfmSpringAmqp;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\nimport java.util.Collection;\nimport java.util.Map;\n\n@SpringBootApplication\npublic class MyVNFM extends AbstractVnfmSpringAmqp{\n\n    public static void main(String[] args){\n        SpringApplication.run(MyVNFM.class);\n    }\n\n    /**\n     * This operation allows creating a VNF instance.\n     *\n     * @param virtualNetworkFunctionRecord\n     * @param scripts\n     * @param vimInstances\n     */\n    @Override\n    public VirtualNetworkFunctionRecord instantiate(VirtualNetworkFunctionRecord virtualNetworkFunctionRecord, Object scripts, Map\nString, Collection\nVimInstance\n vimInstances) throws Exception {\n        return virtualNetworkFunctionRecord;\n    }\n\n    /**\n     * This operation allows retrieving\n     * VNF instance state and attributes.\n     */\n    @Override\n    public void query() {\n\n    }\n\n    /**\n     * This operation allows scaling\n     * (out/in, up/down) a VNF instance.\n     */\n    @Override\n    public VirtualNetworkFunctionRecord scale(Action scaleInOrOut, VirtualNetworkFunctionRecord virtualNetworkFunctionRecord, VNFCInstance component, Object scripts, VNFRecordDependency dependency) throws Exception {\n        return virtualNetworkFunctionRecord;\n    }\n\n    /**\n     * This operation allows verifying if\n     * the VNF instantiation is possible.\n     */\n    @Override\n    public void checkInstantiationFeasibility() {\n\n    }\n\n    /**\n     * This operation is called when one the VNFs fails\n     */\n    @Override\n    public VirtualNetworkFunctionRecord heal(VirtualNetworkFunctionRecord virtualNetworkFunctionRecord, VNFCInstance component, String cause) throws Exception {\n        return virtualNetworkFunctionRecord;\n    }\n\n    /**\n     * This operation allows applying a minor/limited\n     * software update (e.g. patch) to a VNF instance.\n     */\n    @Override\n    public void updateSoftware() {\n\n    }\n\n    /**\n     * This operation allows making structural changes\n     * (e.g. configuration, topology, behavior,\n     * redundancy model) to a VNF instance.\n     *\n     * @param virtualNetworkFunctionRecord\n     * @param dependency\n     */\n    @Override\n    public VirtualNetworkFunctionRecord modify(VirtualNetworkFunctionRecord virtualNetworkFunctionRecord, VNFRecordDependency dependency) throws Exception {\n        return virtualNetworkFunctionRecord;\n    }\n\n    /**\n     * This operation allows deploying a new\n     * software release to a VNF instance.\n     */\n    @Override\n    public void upgradeSoftware() {\n\n    }\n\n    /**\n     * This operation allows terminating gracefully\n     * or forcefully a previously created VNF instance.\n     * @param virtualNetworkFunctionRecord\n     */\n    @Override\n    public VirtualNetworkFunctionRecord terminate(VirtualNetworkFunctionRecord virtualNetworkFunctionRecord) throws Exception {\n        return virtualNetworkFunctionRecord;\n    }\n\n    @Override\n    public void handleError(VirtualNetworkFunctionRecord virtualNetworkFunctionRecord) {\n\n    }\n\n    @Override\n    protected void checkEmsStarted(String hostname) throws RuntimeException {\n\n    }\n\n    @Override\n    public VirtualNetworkFunctionRecord start(VirtualNetworkFunctionRecord virtualNetworkFunctionRecord) throws Exception {\n        return virtualNetworkFunctionRecord;\n    }\n\n    @Override\n    public VirtualNetworkFunctionRecord configure(VirtualNetworkFunctionRecord virtualNetworkFunctionRecord) throws Exception {\n        return virtualNetworkFunctionRecord;\n    }\n\n    /**\n     * This operation allows providing notifications on state changes\n     * of a VNF instance, related to the VNF Lifecycle.\n     */\n    @Override\n    public void NotifyChange() {\n\n    }\n}\n\n\n\n\n\n\nNow you can implement whatever you want. If the VirtualNetworkFunctionRecord is returned, it will go back directly to the NFVO.\n\n\nOne of the methods that can be overwritten is the \nfillParameters\n. This method is important when you have specified some \"provides\" in your VNFD, in facts you can fill them in this method and make them available afterwards to the scripts (see \nHow to use the parameters\n). \n\n\nAn example of allocating and terminating resource by using a plugin can be found \nhere\n and \nhere\n.\n\n\nNote\n If you use vnfm-sdk-amqp or vnfm-sdk-rest \nthe VNFManager main class needs to be stateless\n since it can (will) run each method potentially in parallel.\nFor what concerns vnfm-sdk-amqp, even setting concurrency to 1, will not ensure to have always the same instance of the class.\n\n\nUsing the VnfmHelper\n\n\nAdditionally you can autowire the VnfmHelper to make use of several helper methods that are very useful.\nIn this case your VNFManager should look like this:\n\n\npackage org.openbaton.vnfm;\n\nimport org.springframework.beans.factory.annotation.Autowired;\n\npublic class MyVNFM extends AbstractVnfmSpringAmqp {\n\n    @Autowired\n    private VnfmHelper vnfmHelper;\n\n    [...]\n}\n\n\n\n\nThe vnfmHelper helps with some methods out of the box:\n\n\npackage org.openbaton.common.vnfm_sdk;\n\nimport org.openbaton.catalogue.nfvo.messages.Interfaces.NFVMessage;\n\npublic abstract class VnfmHelper {\n\n    /**\n     * This operation sends a NFVMessage\n     * to the NFVO and doesn't wait for answer.\n     * @param nfvMessage\n     */\n    public abstract void sendToNfvo(NFVMessage nfvMessage);\n\n    /**\n     * This operation send a NFVMessage\n     * to the NFVO and waits for the answer.\n     * @param nfvMessage\n     */\n    public abstract NFVMessage sendAndReceive(NFVMessage nfvMessage) throws Exception;\n}\n\n\n\n\nAt the moment, the main purpose of the VnfmHelper is to send messages to the NFVO and wait for the answer if needed.\n\n\nNote\n This class needs to be implemented in case you want to use only the vnfm-sdk and must be provided to the AbstractVnfm.\n\n\nUsing plugins\n\n\nThis section describes the initialization and usage of plugins.\nTherefore, you need to do several things:\n\n\n\n\nStart the plugins\n\n\nConnect an according VIM to the plugin or use the plugin directly\n\n\n\n\nNote\n If you want to use the Vim with plugins, you need to fetch also the interfaces and VIM implementations by adding the following lines to your build.gradle dependencies\n\n\ncompile 'org.openbaton:vim-int:2.1.1'\ncompile 'org.openbaton:vim-impl:2.1.1'\ncompile 'org.openbaton:sdk:2.1.1'\n\n\n\n\nAfter that you need to rebuild your project for fetching the dependencies automatically.\n\n\nNow you can use the ResourceManagement interface.\nIn the end it should look like the following:\n\n\npackage org.openbaton.vnfm;\n\nimport org.openbaton.catalogue.mano.record.VNFCInstance;\nimport org.openbaton.catalogue.mano.record.VNFRecordDependency;\nimport org.openbaton.catalogue.mano.record.VirtualNetworkFunctionRecord;\nimport org.openbaton.catalogue.nfvo.Action;\nimport org.openbaton.catalogue.nfvo.VimInstance;\nimport org.openbaton.common.vnfm_sdk.amqp.AbstractVnfmSpringAmqp;\nimport org.openbaton.nfvo.vim_interfaces.resource_management.ResourceManagement;\nimport org.openbaton.plugin.utils.PluginStartup;\nimport org.openbaton.plugin.utils.RabbitPluginBroker;\nimport org.openbaton.vim.drivers.VimDriverCaller;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.context.ConfigurableApplicationContext;\n\nimport java.io.IOException;\nimport java.util.Collection;\nimport java.util.Map;\n\npublic class MyVNFM extends AbstractVnfmSpringJMS {\n\n    @Autowired\n    private ConfigurableApplicationContext context;\n\n    private ResourceManagement resourceManagement;\n\n    private VimDriverCaller client;\n\n    [...]\n\n    @Override\n    protected void setup() {\n        super.setup();\n        try {\n            //Start all the plugins that are located in ./plugins\n            PluginStartup.startPluginRecursive(\n./plugins\n, true, \nlocalhost\n, \n5672\n, 15, \nadmin\n, \nopenbaton\n, \n15672\n);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        //Fetching the OpenstackVim using the openstack-plugin\n        resourceManagement = (ResourceManagement) context.getBean(\nopenstackVIM\n, 19345, \n15672\n);\n        //Using the openstack-plugin directly\n        client = (VimDriverCaller) ((RabbitPluginBroker) context.getBean(\nrabbitPluginBroker\n)).getVimDriverCaller(\nlocalhost\n, \nadmin\n, \nopenbaton\n, 5672, \nopenstack\n, \nopenstack\n, \n15672\n);\n    }\n}\n\n\n\n\nThis code expects that the plugins are located in ./plugins.\nSo just copy the openstack plugin of your choice to this path.\nNow you are able to use a VIM inside or the directly the plugin in your VNFManager to allocate and release resources whenever you want.\n\n\nAllocate Resources\n\n\nThe following code snippet shows how to instantiate (allocate) resources at VNFManager side with the help of the VIM.\n\n\n/**\n * This operation allows creating a VNF instance.\n *\n * @param virtualNetworkFunctionRecord\n * @param scripts\n * @param vimInstances\n */\n@Override\npublic VirtualNetworkFunctionRecord instantiate(VirtualNetworkFunctionRecord virtualNetworkFunctionRecord, Object scripts, Map\nString, Collection\nVimInstance\n vimInstances) throws Exception {\n    log.debug(\nProcessing allocation of Resources for vnfr: \n + virtualNetworkFunctionRecord);\n    /**\n     * Allocation of Resources\n     *  the grant operation is already done before this method\n     */\n    log.debug(\nProcessing allocation of Recources for vnfr: \n + virtualNetworkFunctionRecord);\n    for (VirtualDeploymentUnit vdu : virtualNetworkFunctionRecord.getVdu()) {\n        VimInstance vimInstance = vimInstances.get(vdu.getParent_vdu()).iterator().next();\n        List\nFuture\nVNFCInstance\n vnfcInstancesFuturePerVDU = new ArrayList\n();\n        log.debug(\nCreating \n + vdu.getVnfc().size() + \n VMs\n);\n        for (VNFComponent vnfComponent : vdu.getVnfc()) {\n            Map\nString, String\n floatingIps = new HashMap\n();\n            for (VNFDConnectionPoint connectionPoint : vnfComponent.getConnection_point()) {\n                if (connectionPoint.getFloatingIp() != null \n !connectionPoint.getFloatingIp().equals(\n)) {\n                    floatingIps.put(connectionPoint.getVirtual_link_reference(), connectionPoint.getFloatingIp());\n                }\n            }\n            Future\nVNFCInstance\n allocate = null;\n            try {\n                allocate = resourceManagement.allocate(vimInstance, vdu, virtualNetworkFunctionRecord, vnfComponent, \n, floatingIps);\n                vnfcInstancesFuturePerVDU.add(allocate);\n            } catch (VimException e) {\n                log.error(e.getMessage());\n                if (log.isDebugEnabled())\n                    log.error(e.getMessage(), e);\n            }\n        }\n        //Print ids of deployed VNFCInstances\n        for (Future\nVNFCInstance\n vnfcInstanceFuture : vnfcInstancesFuturePerVDU) {\n            try {\n                VNFCInstance vnfcInstance = vnfcInstanceFuture.get();\n                vdu.getVnfc_instance().add(vnfcInstance);\n                log.debug(\nCreated VNFCInstance with id: \n + vnfcInstance);\n            } catch (InterruptedException e) {\n                log.error(e.getMessage());\n                if (log.isDebugEnabled())\n                    log.error(e.getMessage(), e);\n                //throw new RuntimeException(e.getMessage(), e);\n            } catch (ExecutionException e) {\n                log.error(e.getMessage());\n                if (log.isDebugEnabled())\n                    log.error(e.getMessage(), e);\n                //throw new RuntimeException(e.getMessage(), e);\n            }\n        }\n    }\n    log.debug(\nAllocated all Resources for vnfr: \n + virtualNetworkFunctionRecord);\n    return virtualNetworkFunctionRecord;\n}\n\n\n\n\nNote\n Keep in mind that you need to set \nallocate\n to false in conf.properties, if you want to allocate resources on the VNFManager side. Otherwise the NFVO will allocate resources as well.\n\n\nRelease Resources\n\n\nThe next code snippet shows an implementation of the terminate method used for releasing resources at VNFManager side.\n\n\n/**\n * This operation allows terminating gracefully\n * or forcefully a previously created VNF instance.\n *\n * @param virtualNetworkFunctionRecord\n */\n@Override\npublic VirtualNetworkFunctionRecord terminate(VirtualNetworkFunctionRecord virtualNetworkFunctionRecord) {\n    log.info(\nTerminating vnfr with id \n + virtualNetworkFunctionRecord.getId());\n    NFVORequestor nfvoRequestor = new NFVORequestor(\nadmin\n, \nopenbaton\n, \nlocalhost\n, \n8080\n, \n1\n);\n    for (VirtualDeploymentUnit vdu : virtualNetworkFunctionRecord.getVdu()) {\n        Set\nVNFCInstance\n vnfciToRem = new HashSet\n();\n        List\nVimInstance\n vimInstances = new ArrayList\n();\n        VimInstance vimInstance = null;\n        try {\n            vimInstances = nfvoRequestor.getVimInstanceAgent().findAll();\n        } catch (SDKException e) {\n            log.error(e.getMessage(), e);\n        } catch (ClassNotFoundException e) {\n            log.error(e.getMessage(), e);\n        }\n        for (VimInstance vimInstanceFind : vimInstances) {\n            if (vdu.getVimInstanceName().contains(vimInstanceFind.getName())) {\n                vimInstance = vimInstanceFind;\n                break;\n            }\n        }\n        for (VNFCInstance vnfcInstance : vdu.getVnfc_instance()) {\n            log.debug(\nReleasing resources for vdu with id \n + vdu.getId());\n            try {\n                resourceManagement.release(vnfcInstance, vimInstance);\n            } catch (VimException e) {\n                log.error(e.getMessage(), e);\n                throw new RuntimeException(e.getMessage(), e);\n            }\n            vnfciToRem.add(vnfcInstance);\n            log.debug(\nReleased resources for vdu with id \n + vdu.getId());\n        }\n        vdu.getVnfc_instance().removeAll(vnfciToRem);\n    }\n    log.info(\nTerminated vnfr with id \n + virtualNetworkFunctionRecord.getId());\n    return virtualNetworkFunctionRecord;\n}\n\n\n\n\nStart the VNFManager\n\n\nOnce you finalized your VNFManager you can compile and start it with the following commands.\n\n\n$ ./gradlew clean build\n$ java -jar build/libs/my-vnfm-{version}.jar\n\n\n\n\nIf everything is fine, your VNFManager will register to NFVO and is able now to receive requests and process them.\n\n\n\n\n\n\n\n\n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  &amp;&amp; (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Write your own VNFM"
        }, 
        {
            "location": "/vnfm-how-to-write/#how-to-write-a-vnfmanager", 
            "text": "This section is going to describe how to write your own VNFManager by using any vnfm-sdk.\nMoreover, the vnfm-sdk contains all the things you may need for the development of the VNFManager of your choice as well.  The vnfm-sdk provides the following things:   multiple  vnfm-sdks  where you can choose your preferred type of communication  Catalogue, shared with the NFVO containing all entities  VNFMHelper  for providing some methods out of the box", 
            "title": "How to write a VNFManager"
        }, 
        {
            "location": "/vnfm-how-to-write/#requirements", 
            "text": "Before you can start with developing your own VNFManager you need to prepare your programming environment by installing/configuring the following requirements:   JDK 7 ( installation )  Gradle 1.12 or above ( installation )", 
            "title": "Requirements"
        }, 
        {
            "location": "/vnfm-how-to-write/#develop-your-own-vnfmanager", 
            "text": "This part is going to describe the steps you need to do to develop your own VNFManager with the help of any vnfm-sdk.  The practical parts of implementing a basic VNFManager will focus on the usage of a specific vnfm-sdk, namely the vnfm-sdk-jms.  Preparations  This section describes the initial steps for creating the project structure and configuring essential files for developing your own VNFManager.\nThis can be done in two ways.\nEither you may use your favorite IDE or you may do everything manually via the command line.  Once this is done, you can start implementing your VNFManager by using different communication models, the catalogue and several helpers.  Using your favorite IDE  In the following we will create the project and setup the configuration files by using your favorite IDE.\nSo first of all, start your IDE and go to the next step.\nAll the details base on the usage of  IntelliJIdea .  Create a new project  Once you have started the IDE, click on File -  New -  Project...  In this dialog click on Gradle on the left and select java in the main properties window in the middle.   Then click on next to go to the next window.  In the next dialog you need to define the GroupId, ArtifactId and the Version.\nMore information on the specific meaning can be found  here .   Continue with the next dialog.  In this dialog you need to specify which gradle you want to use.\nIt is recommend to use the default gradle wrapper.\nAdditionally you can enable the auto-import.   Continue with the next dialog by clicking on Next.  In the last dialog, you need to define the project name and the project location.   Once this is done you can click on Finish and continue with creating the Main Class.  Create the Main Class  Afterwards, you need to create the Main Class of the VNFManager which will be started in the end.\nFor doing so, right click on the root folder my-vnfm, then click on New -  Directory and insert what is show below.   Click on OK to continue.  Additionally you need to create a new package.\nThis is done by a right-click on the previously created directory java.\nClick on New -  Package.\nHere you can define the package name.   Finally you can create your Main Class by clicking (right click) on the previously created package and click on New -  Java Class.   Once you did all these steps, the initial project structure is created.\nWhat we miss right now is the configuration of the gradle files to define and fetch dependencies we need for implementing the VNFManager.\nThis is described in later sections.  Create the properties files  The properties files are used to define several parameters you need at runtime.\nSo just create the following file structure.  Do a right-click on the main folder located in the src folder.\nClick on New -  Directory and create a new folder with the name resources.  Do again a right-click on the newly created folder resources and click on New -  File.\nThis you need to do two times.\nThe first file is called application.properties and the second one is called conf.properties.  What these files should contain is explained  here .  Using the command line  This section refers to the developers which don't like to use any IDE.\nBy not using any IDE we need to create all the folders and configuration files manually.\nSo we start with creating the project structure, the Main Class, initializing the gradle wrapper and according configuration files.  Create project folder  First of all you need to create a new directory for your VNFManager.\nHere we call the new VNFManager my-vnfm.\nSo this can be replaced by whatever you want.  $ mkdir my-vnfm  Create the Main Class  The Main class is the most important class you need to consider.\nHere you implement your main method and also methods you need to have for your VNFManager.\nFurther explanations are done in the according sections.\nThis is only for creating a proper file structure.\nSo execute the following commands to create the Main class in a proper folder and package structure.  First, you need to create the folders and package by executing the following command in your root folder of the project.  $ mkdir -p src/main/java/org/openbaton/vnfm  This creates the java folder src/main/java with the proposed package name org.openbaton.vnfm.  In the next step you create the Main Class called MyVNFM in this case.  $ vim src/main/java/org/openbaton/vnfm/MyVNFM.java  At this point you create only the basic Java Class used later as the Main Class for implementing your VNFManager.\nThe newly created Java Class should contain the following lines for now.  package org.openbaton.vnfm;\n\npublic class MyVNFM {\n}  If you have chosen a different package name you need to replace it as well at this point.\nOnce this is done, you need to initialize the gradle wrapper and configuring according files.  The Build.Gradle file  First you need to create the build.gradle file by executing the following command from your root project folder.  $ vim build.gradle  This gradle configuration file needs to contain initially the following lines.  buildscript {\n    repositories {\n        mavenCentral()\n    }\n\n    dependencies {\n        classpath( org.springframework.boot:spring-boot-gradle-plugin:1.3.1.RELEASE )\n    }\n}\n\napply plugin: 'java'\napply plugin: 'spring-boot'  The second gradle configuration is called settings.gradle.\nThis file contains only the project name.\nSo create a new file called settings.gradle in your root folder.  $ vim settings.gradle  Afterwards you need to add the following line containing your project name.\nIn our case my-vnfm.  rootProject.name = 'my-vnfm'  Afterwards go back to the root folder and run the following command to create automatically the gradle wrapper which is used for code management and compilation.\nFor more information on how to use the gradle wrapper have a look at the gradle wrapper documentation  here .  $ gradle wrapper  Once you did all these steps, the initial project structure is created.\nWhat we miss right now is the configuration of the gradle files to define and fetch dependencies we need for implementing the VNFManager.\nThis is described in later sections.  Create the properties files  The properties files are used to define several parameters you need at runtime.\nSo just create the following file structure by executing the following commands.  $ mkdir src/main/resources  Now you need to create two new files by running both commands you can find in the following  $ touch src/main/resources/application.properties\n$ touch src/main/resources/conf.properties  What these files should contain is explained  here .  Configure Gradle  Finally you need to extend your build.gradle for announcing the Main Class, plugins to apply and repositories to use.\nSo open the build.gradle an add missing line so that the file contains the following line.  //...\n\nbootRepackage {\n    mainClass = 'org.openbaton.vnfm.MyVNFM'\n}\n\n//...  Take care about the configuration of the mainClass.\nIf the name or package of your mainClass is different, you need to replace it here as well.  Property files  The previously created properties files are used to define several things.\nThey are located in src/main/resources and are called application.properties and conf.properties.  The  application.properties  contains parameters for setting up all log levels. This file is useful for configuring the springframework (see  Spring Boot configuration file ). This file can contain the following lines.  logging.level.org.springframework=INFO\nlogging.level.org.hibernate=INFO\nlogging.level.org.apache=INFO\nlogging.level.org.jclouds=WARN\n# logging.level.org.springframework.security=WARN\nlogging.level.org.springframework.web = WARN\n\n# Level for loggers on classes inside the root package  org.project.openbaton  (and its\n# sub-packages)\nlogging.level.org.openbaton=INFO\n\n# Direct log to a log file\nlogging.file=/var/log/openbaton.log\n\nvnfm.rabbitmq.brokerIp=localhost\nvnfm.rabbitmq.management.port=15672\nvnfm.rabbitmq.autodelete=true\nvnfm.rabbitmq.durable=false\nvnfm.rabbitmq.exclusive=false\nvnfm.rabbitmq.minConcurrency=5\nvnfm.rabbitmq.maxConcurrency=15\n\n#########################################\n############## RabbitMQ #################\n#########################################\n\n# Comma-separated list of addresses to which the client should connect to.\n# spring.rabbitmq.addresses= 192.168.145.54\n# Create an AmqpAdmin bean.\n# spring.rabbitmq.dynamic=true\n# RabbitMQ host.\nspring.rabbitmq.host=${vnfm.rabbitmq.brokerIp}\n# Acknowledge mode of container.\n# spring.rabbitmq.listener.acknowledge-mode=\n# Start the container automatically on startup.\n# spring.rabbitmq.listener.auto-startup=true\n# Minimum number of consumers.\nspring.rabbitmq.listener.concurrency=5\n# Maximum number of consumers.\nspring.rabbitmq.listener.max-concurrency=30\n# Number of messages to be handled in a single request. It should be greater than or equal to the transaction size (if used).\n# spring.rabbitmq.listener.prefetch=\n# Number of messages to be processed in a transaction. For best results it should be less than or equal to the prefetch count.\n# spring.rabbitmq.listener.transaction-size=\n# Login user to authenticate to the broker.\nspring.rabbitmq.username=admin\n# Login to authenticate against the broker.\nspring.rabbitmq.password=openbaton\n# RabbitMQ port.\nspring.rabbitmq.port=5672\n# Requested heartbeat timeout, in seconds; zero for none.\n# spring.rabbitmq.requested-heartbeat=\n# Enable SSL support.\n# spring.rabbitmq.ssl.enabled=false\n# Path to the key store that holds the SSL certificate.\n# spring.rabbitmq.ssl.key-store=\n# Password used to access the key store.\n# spring.rabbitmq.ssl.key-store-password=\n# Trust store that holds SSL certificates.\n# spring.rabbitmq.ssl.trust-store=\n# Password used to access the trust store.\n# spring.rabbitmq.ssl.trust-store-password=\n# Virtual host to use when connecting to the broker.\n# spring.rabbitmq.virtual-host=  If you want to change log levels you need to adapt it here.  NOTE :  If your VNFManager is running on a different machine than the rabbitmq broker, you need to change the  vnfm.rabbit.brokerIp  accordingly with the ip of the rabbitmq broker.  The  conf.properties  is also a very important configuration file.\nHere you need to define the type and endpoint of your VNFManager that is later used for registering on the NFVO.\nFurthermore, you can define your own parameters which can be used at runtime for whatever you want.\nSo this file has to contain at least the type and endpoint.\nAdditionally, it is defined the folder where the vim-plugins are located.\nIn this case the file should contain the following lines.  type=my-vnfm\nendpoint=my-vnfm-endpoint\nallocate = false\ndescription=The VNFM able to handle all the VNFs that follow specific conventions, see http://openbaton.github.io/\nenabled = true\nendpoint-type = RABBIT\nscript-max-time = 300000\nconcurrency = 15\ntransacted = false\n\n\n#### Additionally\nvim-plugin-dir = ./plugins  Where the parameters mean:     Params  Meaning      type  The type of VNF you are going to handle    endpoint  The endpoint used for requesting this VNFManager    description  Just a useless description    endpoint-type  type of the endpoint, either RABBIT or REST, depending on the sdk chosen. Check out next section    enabled  true if you want your vnfm to be enabled    allocate  true if the NFVO will ALLOCATE_RESOURCES, false if the VNFManager will do    concurrency  The number of concurrent Receiver (only for vnfm-sdk-jms)    transacted  Whenever the JMS receiver method shoud be transacted, this allows the message to be resent in case of exception VNFManager side (only for vnfm-sdk-jms)", 
            "title": "Develop your own VNFManager"
        }, 
        {
            "location": "/vnfm-how-to-write/#choose-a-vnfm-sdk", 
            "text": "Before you can start with the implementation you need to select the type of communication you want to use for the communication between the Orchestrator (NFVO) and the VNFManager.\nEither you can use the vnfm-sdk-amqp for using the  RabbitMQ  or the vnfm-sdk-rest for using the  ReST  interface.\nHowever, your choice doesn't effect the upcoming implementation, because the communication itself is done automatically in the background.\nBut have in mind that both libraries depend on  SpringBoot .\nSo, if you want to avoid this dependency, a third option might be: just use the simple vnfm-sdk artifact.\nBy using the simple vnfm-sdk you need to take care about all the communication between NFVO and VNFManager by yourself.  Once you have imported one of the vnfm-sdks you will have access to all the model classes and the vnfm-sdk classes needed to implement a VNFManager.  The following section shows you how to import the vnfm-sdk-jms, representative for all the other opportunities.  Import a vnfm-sdk  This section shows how to import and configure your VNFManager to make use of the vnfm-sdk-amqp.  For gathering the vnfm-sdk-amqp library you need to import the libraries by adding the missing lines to your build.gradle:  //...\n\ndependencies {\n    compile 'org.hibernate:hibernate-core:4.3.10.Final'\n    compile 'org.openbaton:vnfm-sdk-amqp:2.1.1'\n}\n\n//...  Note  To make use of the vnfm-sdk-rest you need to change 'vnfm-sdk-amqp' to 'vnfm-sdk-rest' only.  So the final build.gradle file results like:  buildscript {\n    repositories {\n        mavenCentral()\n    }\n    dependencies {\n        classpath( org.springframework.boot:spring-boot-gradle-plugin:1.3.1.RELEASE )\n    }   \n\n}\n\napply plugin: 'java'\napply plugin: 'spring-boot'\n\nrepositories {\n    mavenCentral()\n    maven {\n            url  http://get.openbaton.org:8081/nexus/content/groups/public \n    }\n}\n\ndependencies {\n    compile 'org.openbaton:vnfm-sdk-amqp:2.0.0'\n    compile 'org.hibernate:hibernate-core:4.3.10.Final'\n}\n\ngroup 'your.group'\nversion '1.0-SNAPSHOT'\n\nbootRepackage {\n    mainClass = 'org.openbaton.vnfm.MyVNFM'\n}  Once you did this, you need to trigger the gradle build process by running the following command via the command line in your project's root folder.  $ ./gradlew build  This will fetch all the dependencies defined in the build.gradle and gives you access to all the Classes you need.\nYou can also do this by using the IDE by running the corresponding gradle task.", 
            "title": "Choose a vnfm-sdk"
        }, 
        {
            "location": "/vnfm-how-to-write/#implementation-of-the-vnfmanager", 
            "text": "This section is going to describe the implementation of a basic VNFManager by using the vnfm-sdk-jms.\nIn the end, the VNFManager will be able to allocate and terminate resources by using its own openstack-plugin.  So first of all you need to define the main method used for starting your VNFManager.\nSo add the following to your Main Class that it looks as follows:  package org.openbaton.vnfm;\n\nimport org.springframework.boot.SpringApplication;\n\npublic class MyVNFM {\n\n    public static void main(String[] args){\n        SpringApplication.run(MyVNFM.class);\n    }\n}  Afterwards you need to extend your Main Class (in this case MyVNFM) with the  AbstractVnfmSpringAmqp .  The  AbstractVnfmSpringAmqp  takes care of all the configuration you need to register/unregister the VNFManager to the NFVO and handles incoming messages.\nWhereas the  AbstractVnfm , extended by the  AbstractVnfmSpringAmqp , is independent of the type of communication.\nThis means more in detail that the  AbstractVnfm  processes the incoming messages and executes the right method depending on the defined Action inside the message.\nMoreover, it is responsible for loading predefined configuration files, setting up the VNFManager itself, creating the VNFR (based on the VNFD received in the first step) and doing essential parts like requesting the NFVO for granting operations or deciding who is responsible for allocate resources.  Once you extended your VNFMManger, you need to implement all the methods coming from the extension of  AbstractVnfmSpringAmqp  as shown below:  package org.openbaton.vnfm;\n\nimport org.openbaton.catalogue.mano.record.VNFCInstance;\nimport org.openbaton.catalogue.mano.record.VNFRecordDependency;\nimport org.openbaton.catalogue.mano.record.VirtualNetworkFunctionRecord;\nimport org.openbaton.catalogue.nfvo.Action;\nimport org.openbaton.catalogue.nfvo.VimInstance;\nimport org.openbaton.common.vnfm_sdk.amqp.AbstractVnfmSpringAmqp;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\nimport java.util.Collection;\nimport java.util.Map;\n\n@SpringBootApplication\npublic class MyVNFM extends AbstractVnfmSpringAmqp{\n\n    public static void main(String[] args){\n        SpringApplication.run(MyVNFM.class);\n    }\n\n    /**\n     * This operation allows creating a VNF instance.\n     *\n     * @param virtualNetworkFunctionRecord\n     * @param scripts\n     * @param vimInstances\n     */\n    @Override\n    public VirtualNetworkFunctionRecord instantiate(VirtualNetworkFunctionRecord virtualNetworkFunctionRecord, Object scripts, Map String, Collection VimInstance  vimInstances) throws Exception {\n        return virtualNetworkFunctionRecord;\n    }\n\n    /**\n     * This operation allows retrieving\n     * VNF instance state and attributes.\n     */\n    @Override\n    public void query() {\n\n    }\n\n    /**\n     * This operation allows scaling\n     * (out/in, up/down) a VNF instance.\n     */\n    @Override\n    public VirtualNetworkFunctionRecord scale(Action scaleInOrOut, VirtualNetworkFunctionRecord virtualNetworkFunctionRecord, VNFCInstance component, Object scripts, VNFRecordDependency dependency) throws Exception {\n        return virtualNetworkFunctionRecord;\n    }\n\n    /**\n     * This operation allows verifying if\n     * the VNF instantiation is possible.\n     */\n    @Override\n    public void checkInstantiationFeasibility() {\n\n    }\n\n    /**\n     * This operation is called when one the VNFs fails\n     */\n    @Override\n    public VirtualNetworkFunctionRecord heal(VirtualNetworkFunctionRecord virtualNetworkFunctionRecord, VNFCInstance component, String cause) throws Exception {\n        return virtualNetworkFunctionRecord;\n    }\n\n    /**\n     * This operation allows applying a minor/limited\n     * software update (e.g. patch) to a VNF instance.\n     */\n    @Override\n    public void updateSoftware() {\n\n    }\n\n    /**\n     * This operation allows making structural changes\n     * (e.g. configuration, topology, behavior,\n     * redundancy model) to a VNF instance.\n     *\n     * @param virtualNetworkFunctionRecord\n     * @param dependency\n     */\n    @Override\n    public VirtualNetworkFunctionRecord modify(VirtualNetworkFunctionRecord virtualNetworkFunctionRecord, VNFRecordDependency dependency) throws Exception {\n        return virtualNetworkFunctionRecord;\n    }\n\n    /**\n     * This operation allows deploying a new\n     * software release to a VNF instance.\n     */\n    @Override\n    public void upgradeSoftware() {\n\n    }\n\n    /**\n     * This operation allows terminating gracefully\n     * or forcefully a previously created VNF instance.\n     * @param virtualNetworkFunctionRecord\n     */\n    @Override\n    public VirtualNetworkFunctionRecord terminate(VirtualNetworkFunctionRecord virtualNetworkFunctionRecord) throws Exception {\n        return virtualNetworkFunctionRecord;\n    }\n\n    @Override\n    public void handleError(VirtualNetworkFunctionRecord virtualNetworkFunctionRecord) {\n\n    }\n\n    @Override\n    protected void checkEmsStarted(String hostname) throws RuntimeException {\n\n    }\n\n    @Override\n    public VirtualNetworkFunctionRecord start(VirtualNetworkFunctionRecord virtualNetworkFunctionRecord) throws Exception {\n        return virtualNetworkFunctionRecord;\n    }\n\n    @Override\n    public VirtualNetworkFunctionRecord configure(VirtualNetworkFunctionRecord virtualNetworkFunctionRecord) throws Exception {\n        return virtualNetworkFunctionRecord;\n    }\n\n    /**\n     * This operation allows providing notifications on state changes\n     * of a VNF instance, related to the VNF Lifecycle.\n     */\n    @Override\n    public void NotifyChange() {\n\n    }\n}  Now you can implement whatever you want. If the VirtualNetworkFunctionRecord is returned, it will go back directly to the NFVO.  One of the methods that can be overwritten is the  fillParameters . This method is important when you have specified some \"provides\" in your VNFD, in facts you can fill them in this method and make them available afterwards to the scripts (see  How to use the parameters ).   An example of allocating and terminating resource by using a plugin can be found  here  and  here .  Note  If you use vnfm-sdk-amqp or vnfm-sdk-rest  the VNFManager main class needs to be stateless  since it can (will) run each method potentially in parallel.\nFor what concerns vnfm-sdk-amqp, even setting concurrency to 1, will not ensure to have always the same instance of the class.  Using the VnfmHelper  Additionally you can autowire the VnfmHelper to make use of several helper methods that are very useful.\nIn this case your VNFManager should look like this:  package org.openbaton.vnfm;\n\nimport org.springframework.beans.factory.annotation.Autowired;\n\npublic class MyVNFM extends AbstractVnfmSpringAmqp {\n\n    @Autowired\n    private VnfmHelper vnfmHelper;\n\n    [...]\n}  The vnfmHelper helps with some methods out of the box:  package org.openbaton.common.vnfm_sdk;\n\nimport org.openbaton.catalogue.nfvo.messages.Interfaces.NFVMessage;\n\npublic abstract class VnfmHelper {\n\n    /**\n     * This operation sends a NFVMessage\n     * to the NFVO and doesn't wait for answer.\n     * @param nfvMessage\n     */\n    public abstract void sendToNfvo(NFVMessage nfvMessage);\n\n    /**\n     * This operation send a NFVMessage\n     * to the NFVO and waits for the answer.\n     * @param nfvMessage\n     */\n    public abstract NFVMessage sendAndReceive(NFVMessage nfvMessage) throws Exception;\n}  At the moment, the main purpose of the VnfmHelper is to send messages to the NFVO and wait for the answer if needed.  Note  This class needs to be implemented in case you want to use only the vnfm-sdk and must be provided to the AbstractVnfm.  Using plugins  This section describes the initialization and usage of plugins.\nTherefore, you need to do several things:   Start the plugins  Connect an according VIM to the plugin or use the plugin directly   Note  If you want to use the Vim with plugins, you need to fetch also the interfaces and VIM implementations by adding the following lines to your build.gradle dependencies  compile 'org.openbaton:vim-int:2.1.1'\ncompile 'org.openbaton:vim-impl:2.1.1'\ncompile 'org.openbaton:sdk:2.1.1'  After that you need to rebuild your project for fetching the dependencies automatically.  Now you can use the ResourceManagement interface.\nIn the end it should look like the following:  package org.openbaton.vnfm;\n\nimport org.openbaton.catalogue.mano.record.VNFCInstance;\nimport org.openbaton.catalogue.mano.record.VNFRecordDependency;\nimport org.openbaton.catalogue.mano.record.VirtualNetworkFunctionRecord;\nimport org.openbaton.catalogue.nfvo.Action;\nimport org.openbaton.catalogue.nfvo.VimInstance;\nimport org.openbaton.common.vnfm_sdk.amqp.AbstractVnfmSpringAmqp;\nimport org.openbaton.nfvo.vim_interfaces.resource_management.ResourceManagement;\nimport org.openbaton.plugin.utils.PluginStartup;\nimport org.openbaton.plugin.utils.RabbitPluginBroker;\nimport org.openbaton.vim.drivers.VimDriverCaller;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.context.ConfigurableApplicationContext;\n\nimport java.io.IOException;\nimport java.util.Collection;\nimport java.util.Map;\n\npublic class MyVNFM extends AbstractVnfmSpringJMS {\n\n    @Autowired\n    private ConfigurableApplicationContext context;\n\n    private ResourceManagement resourceManagement;\n\n    private VimDriverCaller client;\n\n    [...]\n\n    @Override\n    protected void setup() {\n        super.setup();\n        try {\n            //Start all the plugins that are located in ./plugins\n            PluginStartup.startPluginRecursive( ./plugins , true,  localhost ,  5672 , 15,  admin ,  openbaton ,  15672 );\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        //Fetching the OpenstackVim using the openstack-plugin\n        resourceManagement = (ResourceManagement) context.getBean( openstackVIM , 19345,  15672 );\n        //Using the openstack-plugin directly\n        client = (VimDriverCaller) ((RabbitPluginBroker) context.getBean( rabbitPluginBroker )).getVimDriverCaller( localhost ,  admin ,  openbaton , 5672,  openstack ,  openstack ,  15672 );\n    }\n}  This code expects that the plugins are located in ./plugins.\nSo just copy the openstack plugin of your choice to this path.\nNow you are able to use a VIM inside or the directly the plugin in your VNFManager to allocate and release resources whenever you want.  Allocate Resources  The following code snippet shows how to instantiate (allocate) resources at VNFManager side with the help of the VIM.  /**\n * This operation allows creating a VNF instance.\n *\n * @param virtualNetworkFunctionRecord\n * @param scripts\n * @param vimInstances\n */\n@Override\npublic VirtualNetworkFunctionRecord instantiate(VirtualNetworkFunctionRecord virtualNetworkFunctionRecord, Object scripts, Map String, Collection VimInstance  vimInstances) throws Exception {\n    log.debug( Processing allocation of Resources for vnfr:   + virtualNetworkFunctionRecord);\n    /**\n     * Allocation of Resources\n     *  the grant operation is already done before this method\n     */\n    log.debug( Processing allocation of Recources for vnfr:   + virtualNetworkFunctionRecord);\n    for (VirtualDeploymentUnit vdu : virtualNetworkFunctionRecord.getVdu()) {\n        VimInstance vimInstance = vimInstances.get(vdu.getParent_vdu()).iterator().next();\n        List Future VNFCInstance  vnfcInstancesFuturePerVDU = new ArrayList ();\n        log.debug( Creating   + vdu.getVnfc().size() +   VMs );\n        for (VNFComponent vnfComponent : vdu.getVnfc()) {\n            Map String, String  floatingIps = new HashMap ();\n            for (VNFDConnectionPoint connectionPoint : vnfComponent.getConnection_point()) {\n                if (connectionPoint.getFloatingIp() != null   !connectionPoint.getFloatingIp().equals( )) {\n                    floatingIps.put(connectionPoint.getVirtual_link_reference(), connectionPoint.getFloatingIp());\n                }\n            }\n            Future VNFCInstance  allocate = null;\n            try {\n                allocate = resourceManagement.allocate(vimInstance, vdu, virtualNetworkFunctionRecord, vnfComponent,  , floatingIps);\n                vnfcInstancesFuturePerVDU.add(allocate);\n            } catch (VimException e) {\n                log.error(e.getMessage());\n                if (log.isDebugEnabled())\n                    log.error(e.getMessage(), e);\n            }\n        }\n        //Print ids of deployed VNFCInstances\n        for (Future VNFCInstance  vnfcInstanceFuture : vnfcInstancesFuturePerVDU) {\n            try {\n                VNFCInstance vnfcInstance = vnfcInstanceFuture.get();\n                vdu.getVnfc_instance().add(vnfcInstance);\n                log.debug( Created VNFCInstance with id:   + vnfcInstance);\n            } catch (InterruptedException e) {\n                log.error(e.getMessage());\n                if (log.isDebugEnabled())\n                    log.error(e.getMessage(), e);\n                //throw new RuntimeException(e.getMessage(), e);\n            } catch (ExecutionException e) {\n                log.error(e.getMessage());\n                if (log.isDebugEnabled())\n                    log.error(e.getMessage(), e);\n                //throw new RuntimeException(e.getMessage(), e);\n            }\n        }\n    }\n    log.debug( Allocated all Resources for vnfr:   + virtualNetworkFunctionRecord);\n    return virtualNetworkFunctionRecord;\n}  Note  Keep in mind that you need to set  allocate  to false in conf.properties, if you want to allocate resources on the VNFManager side. Otherwise the NFVO will allocate resources as well.  Release Resources  The next code snippet shows an implementation of the terminate method used for releasing resources at VNFManager side.  /**\n * This operation allows terminating gracefully\n * or forcefully a previously created VNF instance.\n *\n * @param virtualNetworkFunctionRecord\n */\n@Override\npublic VirtualNetworkFunctionRecord terminate(VirtualNetworkFunctionRecord virtualNetworkFunctionRecord) {\n    log.info( Terminating vnfr with id   + virtualNetworkFunctionRecord.getId());\n    NFVORequestor nfvoRequestor = new NFVORequestor( admin ,  openbaton ,  localhost ,  8080 ,  1 );\n    for (VirtualDeploymentUnit vdu : virtualNetworkFunctionRecord.getVdu()) {\n        Set VNFCInstance  vnfciToRem = new HashSet ();\n        List VimInstance  vimInstances = new ArrayList ();\n        VimInstance vimInstance = null;\n        try {\n            vimInstances = nfvoRequestor.getVimInstanceAgent().findAll();\n        } catch (SDKException e) {\n            log.error(e.getMessage(), e);\n        } catch (ClassNotFoundException e) {\n            log.error(e.getMessage(), e);\n        }\n        for (VimInstance vimInstanceFind : vimInstances) {\n            if (vdu.getVimInstanceName().contains(vimInstanceFind.getName())) {\n                vimInstance = vimInstanceFind;\n                break;\n            }\n        }\n        for (VNFCInstance vnfcInstance : vdu.getVnfc_instance()) {\n            log.debug( Releasing resources for vdu with id   + vdu.getId());\n            try {\n                resourceManagement.release(vnfcInstance, vimInstance);\n            } catch (VimException e) {\n                log.error(e.getMessage(), e);\n                throw new RuntimeException(e.getMessage(), e);\n            }\n            vnfciToRem.add(vnfcInstance);\n            log.debug( Released resources for vdu with id   + vdu.getId());\n        }\n        vdu.getVnfc_instance().removeAll(vnfciToRem);\n    }\n    log.info( Terminated vnfr with id   + virtualNetworkFunctionRecord.getId());\n    return virtualNetworkFunctionRecord;\n}  Start the VNFManager  Once you finalized your VNFManager you can compile and start it with the following commands.  $ ./gradlew clean build\n$ java -jar build/libs/my-vnfm-{version}.jar  If everything is fine, your VNFManager will register to NFVO and is able now to receive requests and process them.    \n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  &amp;&amp; (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Implementation of the VNFManager"
        }, 
        {
            "location": "/vnfm-vendor-specific/", 
            "text": "Use my VNFM\n\n\nIn this section are described the REST interfaces which allow you to integrate your VNFM with Openbaton's NFVO.\n\n\nNFVO - VNFM ReST interface\n\n\nNfvo exposes a ReST interface for the communication with the VnfManagers. The sequence diagram regarding the instantiation of a NetworkServiceRecord is shown in the following picture.\n\n\n\n\nAs shown in the picture, NFVO calls some ReST methods on the vnfm in a particular order. Then it expects some kind of back call. The list of these call exchange is described in the following sections. The ALLOCATE_RESOURCES call is not needed if the vnfm will take care of creating VMs. The communication with the EMS is particular to each VnfManagers. In order to be able to be found, the Vnfm needs to register to the NFVO. This can be done through a particular call.\n\n\nIn the following 'Vnfm-Or' means that the Vnfm sends to the Nfvo and 'Or-Vnfm' means that the Nfvo sends to the Vnfm.\n\n\n\n\n\n\n\n\nParams\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\nOrEndpoint\n\n\nthe endpoint of the NFVO (i.e. http://127.0.0.1:8080)\n\n\n\n\n\n\nVnfmEnpoint\n\n\nthe endpoint of the Vnfm. this is given to the nfvo while registering\n\n\n\n\n\n\n\n\nRegistering a Vnfm to the Nfvo (Vnfm-Or)\n\n\nThis call registers a vnfm to a nfvo. \n\n\nrequest path\n\n\nPOST request on\n\n\nOrEndpoint\n/admin/v1/vnfm-register\n\n\nrequest body\n\n\n{\n    \ntype\n:\ndummy\n,\n    \nendpointType\n:\nREST\n,\n    \nendpoint\n:\nVnfmEndpoint\n,\n    \ndescription\n:\nMyVnfm\n,\n    \nenabled\n:\ntrue\n\n}\n\n\n\n\nrequest structure\n\n\n\n\n\n\n\n\nField\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\ntype\n\n\nthe vnfm type you are going to handle (specified in VirtualNetowrkFunctionDescriptor \u2192 endpoint)\n\n\n\n\n\n\nendpointType\n\n\nthe vnfm type you are going to implement (REST or AMQP)\n\n\n\n\n\n\nendpoint\n\n\nthe vnfm endpoint you have chosen (basically http://\nIP>:\nPORT>)\n\n\n\n\n\n\n\n\nINSTANTIATE (Or-Vnfm)\n\n\nThis call sends the Vnfm the Virtual Network Function Descriptor, which shall be used to create the Virtual Network Funtion Record and also sends to the Vnfm all the scripts which are executed in actions like INSTANTIATE, MODIFY or START. This call triggers the creation of a virtual machine for the sent vnfd and the execution of the scripts which are associated with the INSTANTIATE lifecycle event in the vnfd. \n\n\nrequest path\n\n\nPOST request on \nVnfmEnpoint\n\n\nrequest body\n\n\n{\n    \nvnfd\n:{  ...  }, \n    \nvnfdf\n:{  ...  },\n    \nvlrs\n:[  ...  ],\n    \nextention\n:{  \n      \nnsr-id\n:\n...\n,\n      \nbrokerIp\n:\n...\n,\n      ...\n    },\n    \naction\n:\nINSTANTIATE\n,\n    \nvimInstances\n: {\n      \nvdu_id\n:[\n        { ... },\n        { ... }\n      ]\n    },\n    \nvnfPackage\n: { ... };     \n}\n\n\n\n\nrequest structure\n\n\n\n\n\n\n\n\nField\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\nvnfd\n\n\nthe VirtualNetworkFunctionDescriptor from which a VirtualNetworkFunctionRecord is created\n\n\n\n\n\n\nvnfdf\n\n\nthe deployment flavours to be used\n\n\n\n\n\n\nvlrs\n\n\nthe list of VirtualLinkRecords of the NetworkServiceRecord\n\n\n\n\n\n\nextention\n\n\nsome info like the NetworkServiceRecord id\n\n\n\n\n\n\naction\n\n\nthe action to be executed\n\n\n\n\n\n\nvimInstances\n\n\na map containing per each vdu id the list of VimInstance objects\n\n\n\n\n\n\nvnfPackage\n\n\nthe VNFPackage of the VirtualNetowrkFunctionRecord\n\n\n\n\n\n\n\n\nGrantOperation (Vnfm-Or)\n\n\nThis call sends the Virtual Network Function Record to the Nfvo in order to ask if there are enough resources\n\n\nrequest path\n\n\nPOST request on \nOrEndpoint\n/admin/v1/vnfm-core-grant\n\n\nrequest body\n\n\n{\n    \nvirtualNetworkFunctionDescriptor\n:{..},\n    \nvduSet\n:[\n      { ... }\n    ],\n    \ndeploymentFlavourKey\n:\nwhatever\n,\n    \naction\n:\nGRANT_OPERATION\n,\n    \nvirtualNetworkFunctionRecord\n:{..}\n}\n\n\n\n\nrequest structure\n\n\n\n\n\n\n\n\nField\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\naction\n\n\nthe action has to be executed\n\n\n\n\n\n\nvirtualNetworkFunctionRecord\n\n\nthe VirtualNetowrkFunctionRecord\n\n\n\n\n\n\nvirtualNetworkFunctionDescriptor\n\n\nthe virtualNetworkFunctionDescriptor\n\n\n\n\n\n\nvduSet\n\n\nthe Set of all the VDU of this virtualNetworkFunctionRecord\n\n\n\n\n\n\n\n\nGrantOperation (Or-Vnfm)\n\n\nThis call returns the answer from the Nfvo of the grant operation\n\n\nrequest path\n\n\nPOST request on \nVnfmEnpoint\n\n\nrequest body\n\n\n{\n    \ngrantAllowed\n: true,\n    \nvduVim\n: {\n      \nvdu_id\n: {  }\n    },\n    \nvirtualNetworkFunctionRecord\n:{}\n}\n\n\n\n\nrequest structure\n\n\n\n\n\n\n\n\nField\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\ngrantAllowed\n\n\nif the nfvo has granted the allocate resources\n\n\n\n\n\n\nvduVim\n\n\nwhich vim was chosen per vdu\n\n\n\n\n\n\nvirtualNetworkFunctionRecord\n\n\nthe virtualNetworkFunctionRecord\n\n\n\n\n\n\n\n\nAllocateResources (Vnfm-Or)\n\n\nThis call sends the Virtual Network Function Record to the Nfvo in order to allocate resources\n\n\nrequest path\n\n\nPOST request on \nOrEndpoint\n/admin/v1/vnfm-core-allocate\n\n\nrequest body\n\n\n{\n    \nvirtualNetworkFunctionRecord\n:{..},\n    \nvimInstances\n:{\n      \nvdu_id\n:{ ... }\n    },\n    \nuserdata\n:\n\n}\n\n\n\n\nrequest structure\n\n\n\n\n\n\n\n\nField\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\nvirtualNetworkFunctionRecord\n\n\nthe VirtualNetowrkFunctionRecord\n\n\n\n\n\n\nvimInstances\n\n\nthe chosen vim per vdu\n\n\n\n\n\n\nuserdata\n\n\nthe userdata\n\n\n\n\n\n\n\n\nAllocateResources (Or-Vnfm)\n\n\nThis call returns the new VirtualNetowrkFunctionRecord to the Vnfm\n\n\nrequest path\n\n\nPOST request on \nVnfmEnpoint\n\n\nrequest body\n\n\n{\n    \nvnfr\n: { ... }\n}\n\n\n\n\nrequest structure\n\n\n\n\n\n\n\n\nField\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\nvirtualNetworkFunctionRecord\n\n\nthe virtualNetworkFunctionRecord updated\n\n\n\n\n\n\n\n\nInstantiate (Vnfm-Or)\n\n\nThis call sends back the created Virtual Network Function Record to the Nfvo. \n\n\nrequest path\n\n\nPOST request on \nOrEndpoint\n/admin/v1/vnfm-core-actions\n\n\nrequest body\n\n\n{\n    \nvirtualNetworkFunctionRecord\n:{  ...  }, \n    \naction\n:\nINSTANTIATE\n\n}\n\n\n\n\nrequest structure\n\n\n\n\n\n\n\n\nField\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\nvirtualNetworkFunctionRecord\n\n\nthe created VirtualNetworkFunctionRecord\n\n\n\n\n\n\naction\n\n\nthe action that was executed\n\n\n\n\n\n\n\n\nModify (aka AddRelations) (Or-Vnfm)\n\n\nThe Nfvo uses this request to provide dependencies of Virtual Network Functions to the Vnfm. The scripts associated with the CONFIGURATION lifecycle event in the vnfr will be executed.\n\n\nrequest path\n\n\nPOST request on\n\n\nVnfmEnpoint\n\n\nrequest body\n\n\n{\n    \nvnfr\n:{ ... }, \n    \nvnfrd\n:{ ... }, \n    \naction\n:\nMODIFY\n\n}\n\n\n\n\nrequest structure\n\n\n\n\n\n\n\n\nField\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\nvnfr\n\n\nthe VirtualNetowrkFunctionRecord target of the depedendecy\n\n\n\n\n\n\nvnfrd\n\n\nthe VNFDependency containing all the source parameters needed by the scripts\n\n\n\n\n\n\naction\n\n\nthe action to be executed\n\n\n\n\n\n\n\n\nModify (aka AddRelations) (Vnfm-Or)\n\n\nThis call sends back the modified Virtual Network Function Record to the Nfvo. \n\n\nrequest path\n\n\nPOST request on\n\n\nOrEndpoint\n/admin/v1/vnfm-core-actions\n\n\nrequest body\n\n\n{\n    \nvirtualNetworkFunctionRecord\n:{ ... },\n    \naction\n:\nMODIFY\n\n}\n\n\n\n\nrequest structure\n\n\n\n\n\n\n\n\nField\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\nvirtualNetworkFunctionRecord\n\n\nthe VirtualNetworkFunctionRecord\n\n\n\n\n\n\naction\n\n\nthe action that was executed\n\n\n\n\n\n\n\n\nStart (Or-Vnfm)\n\n\nThis call will trigger the execution of the scripts associated with the START lifecycle event in the vnfr. \n\n\nrequest path\n\n\nPOST request on\n\n\nVnfmEnpoint\n\n\nrequest body\n\n\n{\n    \nvnfr\n:{  ...  },\n    \naction\n:\nSTART\n\n}\n\n\n\n\nrequest structure\n\n\n\n\n\n\n\n\nField\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\nvnfr\n\n\n\n\n\n\n\n\naction\n\n\nthe action to be executed\n\n\n\n\n\n\n\n\nStart (Vnfm-Or)\n\n\nrequest path\n\n\nPOST request on\n\n\nOrEndpoint\n/admin/v1/vnfm-core-actions\n\n\nrequest body\n\n\n{\n    \nvirtualNetworkFunctionRecord\n:{  ...  },\n    \naction\n:\nSTART\n\n}\n\n\n\n\nrequest structure\n\n\n\n\n\n\n\n\nField\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\nvirtualNetworkFunctionRecord\n\n\nthe Virtual Network Function Record\n\n\n\n\n\n\naction\n\n\nthe action that was executed\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Integrate your own VNFM"
        }, 
        {
            "location": "/vnfm-vendor-specific/#use-my-vnfm", 
            "text": "In this section are described the REST interfaces which allow you to integrate your VNFM with Openbaton's NFVO.", 
            "title": "Use my VNFM"
        }, 
        {
            "location": "/vnfm-vendor-specific/#nfvo-vnfm-rest-interface", 
            "text": "Nfvo exposes a ReST interface for the communication with the VnfManagers. The sequence diagram regarding the instantiation of a NetworkServiceRecord is shown in the following picture.   As shown in the picture, NFVO calls some ReST methods on the vnfm in a particular order. Then it expects some kind of back call. The list of these call exchange is described in the following sections. The ALLOCATE_RESOURCES call is not needed if the vnfm will take care of creating VMs. The communication with the EMS is particular to each VnfManagers. In order to be able to be found, the Vnfm needs to register to the NFVO. This can be done through a particular call.  In the following 'Vnfm-Or' means that the Vnfm sends to the Nfvo and 'Or-Vnfm' means that the Nfvo sends to the Vnfm.     Params  Meaning      OrEndpoint  the endpoint of the NFVO (i.e. http://127.0.0.1:8080)    VnfmEnpoint  the endpoint of the Vnfm. this is given to the nfvo while registering     Registering a Vnfm to the Nfvo (Vnfm-Or)  This call registers a vnfm to a nfvo.   request path  POST request on  OrEndpoint /admin/v1/vnfm-register  request body  {\n     type : dummy ,\n     endpointType : REST ,\n     endpoint : VnfmEndpoint ,\n     description : MyVnfm ,\n     enabled : true \n}  request structure     Field  Meaning      type  the vnfm type you are going to handle (specified in VirtualNetowrkFunctionDescriptor \u2192 endpoint)    endpointType  the vnfm type you are going to implement (REST or AMQP)    endpoint  the vnfm endpoint you have chosen (basically http:// IP>: PORT>)     INSTANTIATE (Or-Vnfm)  This call sends the Vnfm the Virtual Network Function Descriptor, which shall be used to create the Virtual Network Funtion Record and also sends to the Vnfm all the scripts which are executed in actions like INSTANTIATE, MODIFY or START. This call triggers the creation of a virtual machine for the sent vnfd and the execution of the scripts which are associated with the INSTANTIATE lifecycle event in the vnfd.   request path  POST request on  VnfmEnpoint  request body  {\n     vnfd :{  ...  }, \n     vnfdf :{  ...  },\n     vlrs :[  ...  ],\n     extention :{  \n       nsr-id : ... ,\n       brokerIp : ... ,\n      ...\n    },\n     action : INSTANTIATE ,\n     vimInstances : {\n       vdu_id :[\n        { ... },\n        { ... }\n      ]\n    },\n     vnfPackage : { ... };     \n}  request structure     Field  Meaning      vnfd  the VirtualNetworkFunctionDescriptor from which a VirtualNetworkFunctionRecord is created    vnfdf  the deployment flavours to be used    vlrs  the list of VirtualLinkRecords of the NetworkServiceRecord    extention  some info like the NetworkServiceRecord id    action  the action to be executed    vimInstances  a map containing per each vdu id the list of VimInstance objects    vnfPackage  the VNFPackage of the VirtualNetowrkFunctionRecord     GrantOperation (Vnfm-Or)  This call sends the Virtual Network Function Record to the Nfvo in order to ask if there are enough resources  request path  POST request on  OrEndpoint /admin/v1/vnfm-core-grant  request body  {\n     virtualNetworkFunctionDescriptor :{..},\n     vduSet :[\n      { ... }\n    ],\n     deploymentFlavourKey : whatever ,\n     action : GRANT_OPERATION ,\n     virtualNetworkFunctionRecord :{..}\n}  request structure     Field  Meaning      action  the action has to be executed    virtualNetworkFunctionRecord  the VirtualNetowrkFunctionRecord    virtualNetworkFunctionDescriptor  the virtualNetworkFunctionDescriptor    vduSet  the Set of all the VDU of this virtualNetworkFunctionRecord     GrantOperation (Or-Vnfm)  This call returns the answer from the Nfvo of the grant operation  request path  POST request on  VnfmEnpoint  request body  {\n     grantAllowed : true,\n     vduVim : {\n       vdu_id : {  }\n    },\n     virtualNetworkFunctionRecord :{}\n}  request structure     Field  Meaning      grantAllowed  if the nfvo has granted the allocate resources    vduVim  which vim was chosen per vdu    virtualNetworkFunctionRecord  the virtualNetworkFunctionRecord     AllocateResources (Vnfm-Or)  This call sends the Virtual Network Function Record to the Nfvo in order to allocate resources  request path  POST request on  OrEndpoint /admin/v1/vnfm-core-allocate  request body  {\n     virtualNetworkFunctionRecord :{..},\n     vimInstances :{\n       vdu_id :{ ... }\n    },\n     userdata : \n}  request structure     Field  Meaning      virtualNetworkFunctionRecord  the VirtualNetowrkFunctionRecord    vimInstances  the chosen vim per vdu    userdata  the userdata     AllocateResources (Or-Vnfm)  This call returns the new VirtualNetowrkFunctionRecord to the Vnfm  request path  POST request on  VnfmEnpoint  request body  {\n     vnfr : { ... }\n}  request structure     Field  Meaning      virtualNetworkFunctionRecord  the virtualNetworkFunctionRecord updated     Instantiate (Vnfm-Or)  This call sends back the created Virtual Network Function Record to the Nfvo.   request path  POST request on  OrEndpoint /admin/v1/vnfm-core-actions  request body  {\n     virtualNetworkFunctionRecord :{  ...  }, \n     action : INSTANTIATE \n}  request structure     Field  Meaning      virtualNetworkFunctionRecord  the created VirtualNetworkFunctionRecord    action  the action that was executed     Modify (aka AddRelations) (Or-Vnfm)  The Nfvo uses this request to provide dependencies of Virtual Network Functions to the Vnfm. The scripts associated with the CONFIGURATION lifecycle event in the vnfr will be executed.  request path  POST request on  VnfmEnpoint  request body  {\n     vnfr :{ ... }, \n     vnfrd :{ ... }, \n     action : MODIFY \n}  request structure     Field  Meaning      vnfr  the VirtualNetowrkFunctionRecord target of the depedendecy    vnfrd  the VNFDependency containing all the source parameters needed by the scripts    action  the action to be executed     Modify (aka AddRelations) (Vnfm-Or)  This call sends back the modified Virtual Network Function Record to the Nfvo.   request path  POST request on  OrEndpoint /admin/v1/vnfm-core-actions  request body  {\n     virtualNetworkFunctionRecord :{ ... },\n     action : MODIFY \n}  request structure     Field  Meaning      virtualNetworkFunctionRecord  the VirtualNetworkFunctionRecord    action  the action that was executed     Start (Or-Vnfm)  This call will trigger the execution of the scripts associated with the START lifecycle event in the vnfr.   request path  POST request on  VnfmEnpoint  request body  {\n     vnfr :{  ...  },\n     action : START \n}  request structure     Field  Meaning      vnfr     action  the action to be executed     Start (Vnfm-Or)  request path  POST request on  OrEndpoint /admin/v1/vnfm-core-actions  request body  {\n     virtualNetworkFunctionRecord :{  ...  },\n     action : START \n}  request structure     Field  Meaning      virtualNetworkFunctionRecord  the Virtual Network Function Record    action  the action that was executed       \n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "NFVO - VNFM ReST interface"
        }, 
        {
            "location": "/FAQ/", 
            "text": "Frequently Asked Questions (FAQ)\n\n\nQ1: What type of database is the NFVO using?\n\n\nThe NFVO uses Hibernate for managing transactions with a relational database. By default the NFVO is configured with an in memory database (HSQL). \nOther types of databases are supported, for instance MySQL. This can be changed directly from the configuration file, outcommenting the : \n\n\n# mysql jdbc\nspring.datasource.url=jdbc:mysql://localhost:3306/openbaton\nspring.datasource.driver-class-name=com.mysql.jdbc.Driver\nspring.jpa.database-platform=org.hibernate.dialect.MySQLDialect\n\n\n\n\nQ2: The EMS does not register to the VNFM and the connection timeouts\n\n\nDouble check that you configured correctly the \nopenbaton.properties\n with the correct IP of the host where the NFVO is running\n\n\n# The broker ip that needs to be reachable from all the components\nnfvo.rabbit.brokerIp = the broker ip here \n\n\n\n\n\n\n\n\n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "FAQ"
        }, 
        {
            "location": "/FAQ/#frequently-asked-questions-faq", 
            "text": "Q1: What type of database is the NFVO using?  The NFVO uses Hibernate for managing transactions with a relational database. By default the NFVO is configured with an in memory database (HSQL). \nOther types of databases are supported, for instance MySQL. This can be changed directly from the configuration file, outcommenting the :   # mysql jdbc\nspring.datasource.url=jdbc:mysql://localhost:3306/openbaton\nspring.datasource.driver-class-name=com.mysql.jdbc.Driver\nspring.jpa.database-platform=org.hibernate.dialect.MySQLDialect  Q2: The EMS does not register to the VNFM and the connection timeouts  Double check that you configured correctly the  openbaton.properties  with the correct IP of the host where the NFVO is running  # The broker ip that needs to be reachable from all the components\nnfvo.rabbit.brokerIp = the broker ip here    \n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Frequently Asked Questions (FAQ)"
        }, 
        {
            "location": "/vnf-descriptor/", 
            "text": "Virtual Network Function Descriptor\n\n\nThe VirtualNetworkFunctionDescriptor is contained inside the Network Service Descriptor (NSD). It is a json file and is defined as follows:\n\n\n{  \n    \nvendor\n:\nfokus\n,\n    \nversion\n:\n0.2\n,\n    \nname\n:\niperf-server\n,\n    \ntype\n:\nserver\n,\n    \nendpoint\n:\ngeneric\n,\n    \nconfigurations\n:{\n        \nname\n:\nconfig_name\n,\n        \nconfigurationParameters\n:[\n        {\n            \nconfKey\n:\nkey\n,\n            \nvalue\n:\nvalue\n\n        }\n        ]\n    },\n    \nvdu\n:[  \n        {  \n            \nvm_image\n:[  \n                \nubuntu-14.04-server-cloudimg-amd64-disk1\n\n            ],\n            \nvimInstanceName\n:[\nvim-instance\n],\n            \nscale_in_out\n:2,\n            \nvnfc\n:[  \n                {  \n                    \nconnection_point\n:[  \n                        {  \n                            \nfloatingIp\n:\nrandom\n,\n                            \nvirtual_link_reference\n:\nprivate\n\n                        }\n                    ]\n                }\n            ]\n        }\n    ],\n    \nvirtual_link\n:[  \n        {  \n            \nname\n:\nprivate\n\n        }\n    ],\n    \nlifecycle_event\n:[  \n        {  \n            \nevent\n:\nINSTANTIATE\n,\n            \nlifecycle_events\n:[  \n                \ninstall.sh\n,\n                \ninstall-srv.sh\n\n            ]\n        }\n    ],\n    \ndeployment_flavour\n:[  \n        {  \n            \nflavour_key\n:\nm1.small\n\n        }\n    ],\n    \nvnfPackageLocation\n:\nlink_to_gitrepo\n\n}\n\n\n\n\n\n\n\n\n\n\nParams\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\nname\n\n\nThe name to give to the VirtualNetworkFunctionDescriptor\n\n\n\n\n\n\nvendor\n\n\nThe vendor creating this VirtualNetworkFunctionDescriptor\n\n\n\n\n\n\nversion\n\n\nThe version of the VirtualNetworkFunctionDescriptor (can be any string)\n\n\n\n\n\n\ntype\n\n\nThe type of the VirtualNetworkFunctionDescriptor (can be any string) and it is used in the dependency parameters in the scripts\n\n\n\n\n\n\nendpoint\n\n\nThe endpoint of the VirtualNetworkFunctionDescriptor (can be any string) needs to point to a registered VnfManager\n\n\n\n\n\n\n\n\nThe other most important parameters are described in the following sections.\n\n\nVirtual Deployment Unit (VDU)\n\n\n\n\n\n\n\n\nParams\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\nvm_image\n\n\nThe list of image names or ids existing in the VimInstance or in the VNF Package\n\n\n\n\n\n\nvimInstanceName\n\n\nThe list of VimInstances. Only one of it will be chosen, randomly\n\n\n\n\n\n\nscale_in_out\n\n\nThe maximum number of instances (VMs) which can be created to support scale out/in.\n\n\n\n\n\n\nvnfc\n\n\nThis field contains a list of VNFComponents which will be deployed for this VNFD.\n\n\n\n\n\n\n\n\nVNFC\n\n\nAfter launching a network service, every VNFComponent will run on a separate virtual machine. If scaling is enabled by the scale_in_out field in the VDU, the number of instantiated VNFCs can increase.\nVNFCs contain the following fields:\n\n\n\n\n\n\n\n\nParams\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\nconnection_point\n\n\neach connection point is a reference to an Internal Virtual Link (see Connection Point at \nETSI NFV\n). Moreover you can specify a floatingIp to be assigned to this connection point. The possible values are the actual floatingip ip or \"random\" if no preference is specified. If omitted no floatingip will be assigned.\n\n\n\n\n\n\n\n\nConfigurations\n\n\nThe configuration object contains a list of parameters defined by key, value that can be used in the scripts (see \nVNF Parameters\n).\n\n\nVirtual Link (aka Internal Virtual Link)\n\n\nThe Internal Virtual Link points to a Virtual Link Descriptor defined in the Network Service Descriptor.\n\n\nNote:\n at the moment there are no difference between internal and external VL. All the available networks should be specified in the NSD-\nVLD, then in the VNFD-\nVL you specify which networks you want to use.\nFinally in the VNFD-\nVDU-\nVNFC-\nconnection_point you can specify which network to attach among those available in VNFD-\nVL. The virtual_link_reference parameter also must be filled with the exact same links.\n\n\nLifecycle Events\n\n\nA lifecycle event is composed by an Event and a list of strings that correspond to the script names needed to be run in that particular Event.\nCurrently supported events are:\n\n\n\n\n\n\n\n\nEvent name\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nINSTANTIATE\n\n\n...\n\n\n\n\n\n\nCONFIGURE\n\n\n...\n\n\n\n\n\n\nSTART\n\n\n...\n\n\n\n\n\n\nTERMINATE\n\n\n...\n\n\n\n\n\n\nSCALE_IN\n\n\n...\n\n\n\n\n\n\n\n\nThe VNF events state machine follows the  state diagram for the VNFR (and NSR) displayed in \nthis slide\n \n\n\nDeployment Flavour\n\n\nA delpoyment flavour corresponds to a flavour name existing in the VimInstance.\nFor example if you are using Openstack as Vim, the flavour_key parameter shall correspond to a \nflavour name of Openstack\n (e.q. m1.small).\n\n\nProvides\n\n\nThis list of parameter names defines the parameters that the VnfManager will fill at runtime. For that reason they have a meaning only if you \nwrite your own VnfManager\n. These parameters are then available in any scripts. For the usage of the parameters, please, refer to \nHow to use the parameters\n page.\n\n\nRequires\n\n\nThe requires field provides an alternative method for defining VNF dependencies. The regular way is to define VNF dependencies in the Network Service Descriptor by defining the source, target and parameters of the dependency. But you can also use the requires field in the VNFD to achieve the same result. Let's look at an example to understand how to do this. Here is a VNF dependency defined in the classic way. \n\n\n...\n\nvnf_dependency\n:[\n        {\n            \nsource\n:{\n                \nname\n:\nserver\n\n            },\n            \ntarget\n:{\n                \nname\n:\nclient\n\n            },\n            \nparameters\n:[\n                \nnetname_floatingIp\n\n            ]\n        }\n]\n...\n\n\n\n\nThis creates a VNF dependency that provides the floating ip of the VNFD with the type server to the VNFD with the type client. \nThe same can be done by writing the following in the requires field of the VNFD with type client: \n\n\n...\n\nrequires\n:{\n    \nserver\n:{\n        \nparameters\n:[\nnetname_floatingIp\n]\n    }\n}\n...\n\n\n\n\nThe \n\"server\"\n field specifies that the source of the dependency is the VNFD with the type server. The target is the VNFD that contains the requires field, in this case the VNFD with type client. \n\n\n\n\n\n\n\n\n\n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "**HIDDEN**"
        }, 
        {
            "location": "/vnf-descriptor/#virtual-network-function-descriptor", 
            "text": "The VirtualNetworkFunctionDescriptor is contained inside the Network Service Descriptor (NSD). It is a json file and is defined as follows:  {  \n     vendor : fokus ,\n     version : 0.2 ,\n     name : iperf-server ,\n     type : server ,\n     endpoint : generic ,\n     configurations :{\n         name : config_name ,\n         configurationParameters :[\n        {\n             confKey : key ,\n             value : value \n        }\n        ]\n    },\n     vdu :[  \n        {  \n             vm_image :[  \n                 ubuntu-14.04-server-cloudimg-amd64-disk1 \n            ],\n             vimInstanceName :[ vim-instance ],\n             scale_in_out :2,\n             vnfc :[  \n                {  \n                     connection_point :[  \n                        {  \n                             floatingIp : random ,\n                             virtual_link_reference : private \n                        }\n                    ]\n                }\n            ]\n        }\n    ],\n     virtual_link :[  \n        {  \n             name : private \n        }\n    ],\n     lifecycle_event :[  \n        {  \n             event : INSTANTIATE ,\n             lifecycle_events :[  \n                 install.sh ,\n                 install-srv.sh \n            ]\n        }\n    ],\n     deployment_flavour :[  \n        {  \n             flavour_key : m1.small \n        }\n    ],\n     vnfPackageLocation : link_to_gitrepo \n}     Params  Meaning      name  The name to give to the VirtualNetworkFunctionDescriptor    vendor  The vendor creating this VirtualNetworkFunctionDescriptor    version  The version of the VirtualNetworkFunctionDescriptor (can be any string)    type  The type of the VirtualNetworkFunctionDescriptor (can be any string) and it is used in the dependency parameters in the scripts    endpoint  The endpoint of the VirtualNetworkFunctionDescriptor (can be any string) needs to point to a registered VnfManager     The other most important parameters are described in the following sections.  Virtual Deployment Unit (VDU)     Params  Meaning      vm_image  The list of image names or ids existing in the VimInstance or in the VNF Package    vimInstanceName  The list of VimInstances. Only one of it will be chosen, randomly    scale_in_out  The maximum number of instances (VMs) which can be created to support scale out/in.    vnfc  This field contains a list of VNFComponents which will be deployed for this VNFD.     VNFC  After launching a network service, every VNFComponent will run on a separate virtual machine. If scaling is enabled by the scale_in_out field in the VDU, the number of instantiated VNFCs can increase.\nVNFCs contain the following fields:     Params  Meaning      connection_point  each connection point is a reference to an Internal Virtual Link (see Connection Point at  ETSI NFV ). Moreover you can specify a floatingIp to be assigned to this connection point. The possible values are the actual floatingip ip or \"random\" if no preference is specified. If omitted no floatingip will be assigned.     Configurations  The configuration object contains a list of parameters defined by key, value that can be used in the scripts (see  VNF Parameters ).  Virtual Link (aka Internal Virtual Link)  The Internal Virtual Link points to a Virtual Link Descriptor defined in the Network Service Descriptor.  Note:  at the moment there are no difference between internal and external VL. All the available networks should be specified in the NSD- VLD, then in the VNFD- VL you specify which networks you want to use.\nFinally in the VNFD- VDU- VNFC- connection_point you can specify which network to attach among those available in VNFD- VL. The virtual_link_reference parameter also must be filled with the exact same links.  Lifecycle Events  A lifecycle event is composed by an Event and a list of strings that correspond to the script names needed to be run in that particular Event.\nCurrently supported events are:     Event name  Description      INSTANTIATE  ...    CONFIGURE  ...    START  ...    TERMINATE  ...    SCALE_IN  ...     The VNF events state machine follows the  state diagram for the VNFR (and NSR) displayed in  this slide    Deployment Flavour  A delpoyment flavour corresponds to a flavour name existing in the VimInstance.\nFor example if you are using Openstack as Vim, the flavour_key parameter shall correspond to a  flavour name of Openstack  (e.q. m1.small).  Provides  This list of parameter names defines the parameters that the VnfManager will fill at runtime. For that reason they have a meaning only if you  write your own VnfManager . These parameters are then available in any scripts. For the usage of the parameters, please, refer to  How to use the parameters  page.  Requires  The requires field provides an alternative method for defining VNF dependencies. The regular way is to define VNF dependencies in the Network Service Descriptor by defining the source, target and parameters of the dependency. But you can also use the requires field in the VNFD to achieve the same result. Let's look at an example to understand how to do this. Here is a VNF dependency defined in the classic way.   ... vnf_dependency :[\n        {\n             source :{\n                 name : server \n            },\n             target :{\n                 name : client \n            },\n             parameters :[\n                 netname_floatingIp \n            ]\n        }\n]\n...  This creates a VNF dependency that provides the floating ip of the VNFD with the type server to the VNFD with the type client. \nThe same can be done by writing the following in the requires field of the VNFD with type client:   ... requires :{\n     server :{\n         parameters :[ netname_floatingIp ]\n    }\n}\n...  The  \"server\"  field specifies that the source of the dependency is the VNFD with the type server. The target is the VNFD that contains the requires field, in this case the VNFD with type client.     \n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Virtual Network Function Descriptor"
        }, 
        {
            "location": "/nfvo-installation/", 
            "text": "Install Open Baton from source code\n\n\nThis tutorial will guide towards the installation of a minimal Open Baton environment composed by the following components: \n\n\n\n\nThe NFVO implemented in java using the \nspring.io\n framework. For more details about the NFVO architecture, you can refer to the next sections\n\n\nRabbitMQ as messaging system \nRabbitMQ\n.\n\n\nTest plugin for being able to execute the \ndummy NSR\n tutorial without needing an OpenStack instance. \n\n\n\n\nAnd a set of optional components: \n\n\n\n\nGeneric VNFM\n\n\nOpenStack plugin: in case you want to use OpenStack as VIM\n\n\n\n\nInstall the latest stable Open Baton environment from source code\n\n\nThis installation guide will provide you details on how to install the minimal set of Open Baton components using the boostrap scripts.\n\n\nTo facilitate the installation procedures we provide a bootstrap script which will install the desired components and configure them for running a hello world VNF out of the box. To execute the bootstrap procedure you need to have curl installed (see http://curl.haxx.se/). This command should work on any linux system: \n\n\nsh \n(curl -s http://get.openbaton.org/bootstraps/bootstrap) develop\n\n\n\n\nNOTE - By default RabbitMQ is installed on the host of the NFVO. Be aware of the fact that during the installation you will be prompted for entering the RabbitMQ IP and Port. Please make sure that this IP can be\n  reached by external components (VMs, or host where will run other VNFMs) otherwise you will have runtime issues. If you are installing Open Baton on a VM running in OpenStack, the best is that you put here\n  the floating IP. \n\n\nDuring the bootstrap procedure you will be prompted for inputs. For instance you can choose to install or not the Generic VNFM, or enable or not SSL. \nAt the end of the bootstrap procedure, if there are no errors, the dashboard shuold be reachable at: \nlocalhost:8080\n and you should have the following structure:\n\n\n/opt/openbaton/\n\u251c\u2500\u2500 generic-vnfm\n\u2514\u2500\u2500 nfvo\n\n\n\n\nWhere:\n\n\n\n\ngeneric-vnfm\ncontains the source code and scripts required for dealing with the generic-vnfm  \n\n\nnfvo\n contains the source code and scripts of the NFVO\n\n\n\n\nAt this point the NFVO is ready to be used. Please refer to the \nIntroduction\n on how to start using it.\n\n\nStarting and stopping NFVO\n\n\nAfter the installation procedure the nfvo is running. If you want to stop it, enter this command:\n\n\ncd /opt/openbaton/nfvo\n./openbaton.sh stop\n\n\n\n\nNote (in case you are also using the generic-vnfm):\n remember to stop also the Generic VNFM with the following command:\n\n\ncd /opt/openbaton/generic-vnfm\n./generic-vnfm.sh stop\n\n\n\n\nTo start the nfvo, enter the command:\n\n\ncd /opt/openbaton/nfvo\n./openbaton.sh start\n\n\n\n\nNote (in case you are also using the generic-vnfm):\n remember to start also the Generic VNFM with the following command:\n\n\ncd /opt/openbaton/generic-vnfm\n./generic-vnfm.sh start\n\n\n\n\nNFVO properties overview\n\n\nAfter the bootstrap procedure, the NFVO the configuration file is located at: \n\n\n/etc/openbaton/openbaton.properties\n\n\n\n\nFeel free to modify that file for adding or removing specific functionalities. For instance, you can decide to change logging levels (TRACE, DEBUG, INFO, WARN, and ERROR) and mechanisms:\n\n\nlogging.level.org.springframework=INFO\nlogging.level.org.hibernate=INFO\nlogging.level.org.apache=INFO\nlogging.level.org.jclouds=WARN\nlogging.level.org.springframework.web = WARN\n\n# Level for loggers on classes inside the root package \norg.project.openbaton\n (and its sub-packages)\nlogging.level.org.openbaton=INFO\n\n# Direct log to a log file\nlogging.file=/var/log/openbaton.log\n\n\n\n\nOr parameters related with persistency (hibernate):\n\n\n# DB properties\nspring.datasource.username=admin\nspring.datasource.password=changeme\n# hsql jdbc\nspring.datasource.url=jdbc:hsqldb:file:/tmp/openbaton/openbaton.hsdb\nspring.datasource.driver-class-name=org.hsqldb.jdbc.JDBCDriver\nspring.jpa.database-platform=org.hibernate.dialect.HSQLDialect\n# mysql jdbc\n#spring.datasource.url=jdbc:mysql://localhost:3306/openbaton\n#spring.datasource.driver-class-name=com.mysql.jdbc.Driver\n#spring.jpa.database-platform=org.hibernate.dialect.MySQLDialect\n# hibernate properties\nspring.jpa.show-sql=false\nspring.jpa.hibernate.ddl-auto=create-drop\n\n\n\n\nIMPORTANT NOTES:\n\n\n(Keep in mind that whenever some of the parameters below referred are changed, you will need to restart the NFVO)\n\n\n1) By default RabbitMQ is installed on the host of the NFVO. Be aware of the fact that if you want your VNFM to be executed on a different host, you will need RabbitMQ to be reachable also from the outside.\n\nSo when you want to deploy a VNF (EMS) in a VM which runs on a different host in respect to the NFVO, you will need to configure the rabbitmq endpoint (\nnfvo.rabbit.brokerIp\n) with the real IP of the NFVO host (instead of localhost).\n\n\nThis can be done changing the following properties of the \n/etc/openbaton/openbaton.properties\n file:\n\n\nnfvo.rabbit.brokerIp = localhost \n\n\n\n\nto:\n\n\nnfvo.rabbit.brokerIp = the rabbitmq broker ip\n\n\n\n\n2) At the end of the installation the NFVO is working with a in-memory database. In order to start using persistency through mysql database, you need to make the properties changes shown below:\n\n\n# DB properties\nspring.datasource.username=admin\nspring.datasource.password=changeme\n# hsql jdbc\n# spring.datasource.url=jdbc:hsqldb:file:/tmp/openbaton/openbaton.hsdb\n# spring.datasource.driver-class-name=org.hsqldb.jdbc.JDBCDriver\n# spring.jpa.database-platform=org.hibernate.dialect.HSQLDialect\n\n# mysql jdbc\nspring.datasource.url=jdbc:mysql://localhost:3306/openbaton\nspring.datasource.driver-class-name=com.mysql.jdbc.Driver\nspring.jpa.database-platform=org.hibernate.dialect.MySQLDialect\n\n# hibernate properties\nspring.jpa.show-sql=false\n# spring.jpa.hibernate.ddl-auto=create-drop\nspring.jpa.hibernate.ddl-auto=update\n\n\n\n\nWhere:\n\n \nspring.datasource.username\n and \nspring.datasource.password\n need to be adapted to the mysql username and password.\n \nspring.jpa.hibernate.ddl-auto\n has to be set to \nupdate\n if you want the NFVO not to drop all the tables after being shut down and to make it reuse the same tables after restarting.\n\n\nFor more details please see the \nSpring Documentation\n regarding the configuration parameters.\n\n\nThese are other parameters about the configuration of Rabbit MQ:\n\n\n#########################################\n############## RabbitMQ #################\n#########################################\n\n# Comma-separated list of addresses to which the client should connect to.\n# spring.rabbitmq.addresses=${nfvo.rabbit.brokerIp}\n# Create an AmqpAdmin bean.\nspring.rabbitmq.dynamic=true\n# RabbitMQ host.\nspring.rabbitmq.host= ${nfvo.rabbit.brokerIp}\n# spring.rabbitmq.host= localhost\n# Acknowledge mode of container.\n# spring.rabbitmq.listener.acknowledge-mode=\n# Start the container automatically on startup.\n# spring.rabbitmq.listener.auto-startup=true\n# Minimum number of consumers.\nspring.rabbitmq.listener.concurrency= 5\n# Maximum number of consumers.\nspring.rabbitmq.listener.max-concurrency= 30\n# Number of messages to be handled in a single request. It should be greater than or equal to the transaction size (if used).\n# spring.rabbitmq.listener.prefetch=\n# Number of messages to be processed in a transaction. For best results it should be less than or equal to the prefetch count.\n# spring.rabbitmq.listener.transaction-size=\n# Login user to authenticate to the broker.\nspring.rabbitmq.username= admin\n# Login to authenticate against the broker.\nspring.rabbitmq.password= openbaton\n# RabbitMQ port.\nspring.rabbitmq.port=5672\n# Requested heartbeat timeout, in seconds; zero for none.\n# spring.rabbitmq.requested-heartbeat=\n# Enable SSL support.\n# spring.rabbitmq.ssl.enabled=false\n# Path to the key store that holds the SSL certificate.\n# spring.rabbitmq.ssl.key-store=\n# Password used to access the key store.\n# spring.rabbitmq.ssl.key-store-password=\n# Trust store that holds SSL certificates.\n# spring.rabbitmq.ssl.trust-store=\n# Password used to access the trust store.\n# spring.rabbitmq.ssl.trust-store-password=\n# Virtual host to use when connecting to the broker.\n# spring.rabbitmq.virtual-host=\n\n\n\n\n\nThese parameters represent the maximum file size of the VNF Package which can be uploaded to the NFVO and the total maximum request size\n\n\n# filesUpload\nmultipart.maxFileSize=2046MB\nmultipart.maxRequestSize=2046MB\n\n\n\n\nThe following properties are related to the plugin mechanism used for loading VIM and Monitoring instances. The \nvim-plugin-installation-dir\n is the directory where all the jar files are, which implement the VIM interface (see the \nvim plugin documentation\n). The NFVO will load them at runtime.  \n\n\n########## plugin install ###############\n# directory for the vim driver plugins\nplugin-installation-dir = /usr/local/lib/openbaton/plugins\n\n\n\n\nThis property allows the user to delete the Network Service Records no matter in which status are they. Pleas note that in any case it is possible to remove a Network Service Record in \nNULL\n state.\n\n\n# nfvo behaviour\nnfvo.delete.all-status = true\n\n\n\n\nMONITORING:\n Openbaton allows the monitoring of the VNFs via Zabbix. If you want to use this feature, install and configure Zabbix server following the guide at this page \nZabbix server configuration\n.\nOnce the Zabbix server is correctly configured and running, you need only to add following property. \nEvery time a new Network Service is instantiated, each VNFC (VM) is automatically registered to Zabbix server.\n\n\nnfvo.monitoring.ip = the Zabbix server ip\n\n\n\n\nThese are other parameters about the configuration of the nfvo behaviour:\n\n\n# Wait for the NSR to be deleted\nnfvo.delete.wait = false \n# The broker ip that needs to be reachable from all the components\nnfvo.rabbit.brokerIp = the broker ip here \n# Set the queues to be autodeleted after the shut down\nnfvo.rabbit.autodelete = true \n# Setting the number of plugin active consumers\nnfvo.plugin.active.consumers = 5 \n# Setting the number of minimum concurrency of the nfvo receivers\nnfvo.rabbit.minConcurrency = 5 \n# Setting the number of maximum concurrency of the nfvo receivers\nnfvo.rabbit.maxConcurrency = 15\n# Setting the management port number of rabbitmq\nnfvo.rabbit.management.port = 15672 \n\n# Setting the heartbeat between ems and the broker\nnfvo.ems.queue.heartbeat = 60\n# Set the ems queues to be autodeleted after the shut down\nnfvo.ems.queue.autodelete = true\n# Set the ems version to be installed\nnfvo.ems.version = 0.17\n\n# Allow infinite quotas during the GRANT_OPERATION\nnfvo.vim.drivers.allowInfiniteQuota = false\n# Execute the start event sequentially and in order based on the VNFDependencies. This implies the NSD not to have cycling dependencies\nnfvo.start.ordered = false\n# Avoid doing the GRANT_OPERATION\nnfvo.quota.check = true\n# if true, deleting the nsd will remove also its vnfd\nnfvo.vnfd.cascade.delete = false\n# if true, deleting the vnfd will remove also its vnfpackage\nvnfd.vnfp.cascade.delete = false\n# if true, after deleting a NSR, the nfvo will wait for \nnfvo.delete.vnfr.wait.timeout\n after that timeout the VMs and VNFR will be deleted anyway from the NFVO\nnfvo.delete.vnfr.wait = false\n# this timeout is useful only if \nnfvo.delete.vnfr.wait\n is set to true\nnfvo.delete.vnfr.wait.timeout = 60\n\n\n\n\nThose properties are needed in case you want to tune a bit the performances of the NFVO. When the VNFMs send a message to the NFVO, there is a pool of threads able to process these messages in parallel. These parameters allows you to change the pool configuration, for more details please check the \nspring documentation regarding thread pool executor\n \n\n\n# Thread pool executor configuration\n# for info see http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/scheduling/concurrent/ThreadPoolTaskExecutor.html\nnfvo.vmanager.executor.corepoolsize = 20\nnfvo.vmanager.executor.maxpoolsize = 30\nnfvo.vmanager.executor.queuecapacity = 500\nnfvo.vmanager.executor.keepalive = 30\n\n\n\n\nLet's move to the next step\n\n\nDependening on the approach used for deploying your VNF, you'll have either to install the generic-VNFM or install and register your own VNFM\n\n\n\n\n\n\n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "**HIDDEN**"
        }, 
        {
            "location": "/nfvo-installation/#install-open-baton-from-source-code", 
            "text": "This tutorial will guide towards the installation of a minimal Open Baton environment composed by the following components:    The NFVO implemented in java using the  spring.io  framework. For more details about the NFVO architecture, you can refer to the next sections  RabbitMQ as messaging system  RabbitMQ .  Test plugin for being able to execute the  dummy NSR  tutorial without needing an OpenStack instance.    And a set of optional components:    Generic VNFM  OpenStack plugin: in case you want to use OpenStack as VIM   Install the latest stable Open Baton environment from source code  This installation guide will provide you details on how to install the minimal set of Open Baton components using the boostrap scripts.  To facilitate the installation procedures we provide a bootstrap script which will install the desired components and configure them for running a hello world VNF out of the box. To execute the bootstrap procedure you need to have curl installed (see http://curl.haxx.se/). This command should work on any linux system:   sh  (curl -s http://get.openbaton.org/bootstraps/bootstrap) develop  NOTE - By default RabbitMQ is installed on the host of the NFVO. Be aware of the fact that during the installation you will be prompted for entering the RabbitMQ IP and Port. Please make sure that this IP can be\n  reached by external components (VMs, or host where will run other VNFMs) otherwise you will have runtime issues. If you are installing Open Baton on a VM running in OpenStack, the best is that you put here\n  the floating IP.   During the bootstrap procedure you will be prompted for inputs. For instance you can choose to install or not the Generic VNFM, or enable or not SSL. \nAt the end of the bootstrap procedure, if there are no errors, the dashboard shuold be reachable at:  localhost:8080  and you should have the following structure:  /opt/openbaton/\n\u251c\u2500\u2500 generic-vnfm\n\u2514\u2500\u2500 nfvo  Where:   generic-vnfm contains the source code and scripts required for dealing with the generic-vnfm    nfvo  contains the source code and scripts of the NFVO   At this point the NFVO is ready to be used. Please refer to the  Introduction  on how to start using it.  Starting and stopping NFVO  After the installation procedure the nfvo is running. If you want to stop it, enter this command:  cd /opt/openbaton/nfvo\n./openbaton.sh stop  Note (in case you are also using the generic-vnfm):  remember to stop also the Generic VNFM with the following command:  cd /opt/openbaton/generic-vnfm\n./generic-vnfm.sh stop  To start the nfvo, enter the command:  cd /opt/openbaton/nfvo\n./openbaton.sh start  Note (in case you are also using the generic-vnfm):  remember to start also the Generic VNFM with the following command:  cd /opt/openbaton/generic-vnfm\n./generic-vnfm.sh start  NFVO properties overview  After the bootstrap procedure, the NFVO the configuration file is located at:   /etc/openbaton/openbaton.properties  Feel free to modify that file for adding or removing specific functionalities. For instance, you can decide to change logging levels (TRACE, DEBUG, INFO, WARN, and ERROR) and mechanisms:  logging.level.org.springframework=INFO\nlogging.level.org.hibernate=INFO\nlogging.level.org.apache=INFO\nlogging.level.org.jclouds=WARN\nlogging.level.org.springframework.web = WARN\n\n# Level for loggers on classes inside the root package  org.project.openbaton  (and its sub-packages)\nlogging.level.org.openbaton=INFO\n\n# Direct log to a log file\nlogging.file=/var/log/openbaton.log  Or parameters related with persistency (hibernate):  # DB properties\nspring.datasource.username=admin\nspring.datasource.password=changeme\n# hsql jdbc\nspring.datasource.url=jdbc:hsqldb:file:/tmp/openbaton/openbaton.hsdb\nspring.datasource.driver-class-name=org.hsqldb.jdbc.JDBCDriver\nspring.jpa.database-platform=org.hibernate.dialect.HSQLDialect\n# mysql jdbc\n#spring.datasource.url=jdbc:mysql://localhost:3306/openbaton\n#spring.datasource.driver-class-name=com.mysql.jdbc.Driver\n#spring.jpa.database-platform=org.hibernate.dialect.MySQLDialect\n# hibernate properties\nspring.jpa.show-sql=false\nspring.jpa.hibernate.ddl-auto=create-drop  IMPORTANT NOTES:  (Keep in mind that whenever some of the parameters below referred are changed, you will need to restart the NFVO)  1) By default RabbitMQ is installed on the host of the NFVO. Be aware of the fact that if you want your VNFM to be executed on a different host, you will need RabbitMQ to be reachable also from the outside. \nSo when you want to deploy a VNF (EMS) in a VM which runs on a different host in respect to the NFVO, you will need to configure the rabbitmq endpoint ( nfvo.rabbit.brokerIp ) with the real IP of the NFVO host (instead of localhost).  This can be done changing the following properties of the  /etc/openbaton/openbaton.properties  file:  nfvo.rabbit.brokerIp = localhost   to:  nfvo.rabbit.brokerIp = the rabbitmq broker ip  2) At the end of the installation the NFVO is working with a in-memory database. In order to start using persistency through mysql database, you need to make the properties changes shown below:  # DB properties\nspring.datasource.username=admin\nspring.datasource.password=changeme\n# hsql jdbc\n# spring.datasource.url=jdbc:hsqldb:file:/tmp/openbaton/openbaton.hsdb\n# spring.datasource.driver-class-name=org.hsqldb.jdbc.JDBCDriver\n# spring.jpa.database-platform=org.hibernate.dialect.HSQLDialect\n\n# mysql jdbc\nspring.datasource.url=jdbc:mysql://localhost:3306/openbaton\nspring.datasource.driver-class-name=com.mysql.jdbc.Driver\nspring.jpa.database-platform=org.hibernate.dialect.MySQLDialect\n\n# hibernate properties\nspring.jpa.show-sql=false\n# spring.jpa.hibernate.ddl-auto=create-drop\nspring.jpa.hibernate.ddl-auto=update  Where:   spring.datasource.username  and  spring.datasource.password  need to be adapted to the mysql username and password.   spring.jpa.hibernate.ddl-auto  has to be set to  update  if you want the NFVO not to drop all the tables after being shut down and to make it reuse the same tables after restarting.  For more details please see the  Spring Documentation  regarding the configuration parameters.  These are other parameters about the configuration of Rabbit MQ:  #########################################\n############## RabbitMQ #################\n#########################################\n\n# Comma-separated list of addresses to which the client should connect to.\n# spring.rabbitmq.addresses=${nfvo.rabbit.brokerIp}\n# Create an AmqpAdmin bean.\nspring.rabbitmq.dynamic=true\n# RabbitMQ host.\nspring.rabbitmq.host= ${nfvo.rabbit.brokerIp}\n# spring.rabbitmq.host= localhost\n# Acknowledge mode of container.\n# spring.rabbitmq.listener.acknowledge-mode=\n# Start the container automatically on startup.\n# spring.rabbitmq.listener.auto-startup=true\n# Minimum number of consumers.\nspring.rabbitmq.listener.concurrency= 5\n# Maximum number of consumers.\nspring.rabbitmq.listener.max-concurrency= 30\n# Number of messages to be handled in a single request. It should be greater than or equal to the transaction size (if used).\n# spring.rabbitmq.listener.prefetch=\n# Number of messages to be processed in a transaction. For best results it should be less than or equal to the prefetch count.\n# spring.rabbitmq.listener.transaction-size=\n# Login user to authenticate to the broker.\nspring.rabbitmq.username= admin\n# Login to authenticate against the broker.\nspring.rabbitmq.password= openbaton\n# RabbitMQ port.\nspring.rabbitmq.port=5672\n# Requested heartbeat timeout, in seconds; zero for none.\n# spring.rabbitmq.requested-heartbeat=\n# Enable SSL support.\n# spring.rabbitmq.ssl.enabled=false\n# Path to the key store that holds the SSL certificate.\n# spring.rabbitmq.ssl.key-store=\n# Password used to access the key store.\n# spring.rabbitmq.ssl.key-store-password=\n# Trust store that holds SSL certificates.\n# spring.rabbitmq.ssl.trust-store=\n# Password used to access the trust store.\n# spring.rabbitmq.ssl.trust-store-password=\n# Virtual host to use when connecting to the broker.\n# spring.rabbitmq.virtual-host=  These parameters represent the maximum file size of the VNF Package which can be uploaded to the NFVO and the total maximum request size  # filesUpload\nmultipart.maxFileSize=2046MB\nmultipart.maxRequestSize=2046MB  The following properties are related to the plugin mechanism used for loading VIM and Monitoring instances. The  vim-plugin-installation-dir  is the directory where all the jar files are, which implement the VIM interface (see the  vim plugin documentation ). The NFVO will load them at runtime.    ########## plugin install ###############\n# directory for the vim driver plugins\nplugin-installation-dir = /usr/local/lib/openbaton/plugins  This property allows the user to delete the Network Service Records no matter in which status are they. Pleas note that in any case it is possible to remove a Network Service Record in  NULL  state.  # nfvo behaviour\nnfvo.delete.all-status = true  MONITORING:  Openbaton allows the monitoring of the VNFs via Zabbix. If you want to use this feature, install and configure Zabbix server following the guide at this page  Zabbix server configuration .\nOnce the Zabbix server is correctly configured and running, you need only to add following property. \nEvery time a new Network Service is instantiated, each VNFC (VM) is automatically registered to Zabbix server.  nfvo.monitoring.ip = the Zabbix server ip  These are other parameters about the configuration of the nfvo behaviour:  # Wait for the NSR to be deleted\nnfvo.delete.wait = false \n# The broker ip that needs to be reachable from all the components\nnfvo.rabbit.brokerIp = the broker ip here \n# Set the queues to be autodeleted after the shut down\nnfvo.rabbit.autodelete = true \n# Setting the number of plugin active consumers\nnfvo.plugin.active.consumers = 5 \n# Setting the number of minimum concurrency of the nfvo receivers\nnfvo.rabbit.minConcurrency = 5 \n# Setting the number of maximum concurrency of the nfvo receivers\nnfvo.rabbit.maxConcurrency = 15\n# Setting the management port number of rabbitmq\nnfvo.rabbit.management.port = 15672 \n\n# Setting the heartbeat between ems and the broker\nnfvo.ems.queue.heartbeat = 60\n# Set the ems queues to be autodeleted after the shut down\nnfvo.ems.queue.autodelete = true\n# Set the ems version to be installed\nnfvo.ems.version = 0.17\n\n# Allow infinite quotas during the GRANT_OPERATION\nnfvo.vim.drivers.allowInfiniteQuota = false\n# Execute the start event sequentially and in order based on the VNFDependencies. This implies the NSD not to have cycling dependencies\nnfvo.start.ordered = false\n# Avoid doing the GRANT_OPERATION\nnfvo.quota.check = true\n# if true, deleting the nsd will remove also its vnfd\nnfvo.vnfd.cascade.delete = false\n# if true, deleting the vnfd will remove also its vnfpackage\nvnfd.vnfp.cascade.delete = false\n# if true, after deleting a NSR, the nfvo will wait for  nfvo.delete.vnfr.wait.timeout  after that timeout the VMs and VNFR will be deleted anyway from the NFVO\nnfvo.delete.vnfr.wait = false\n# this timeout is useful only if  nfvo.delete.vnfr.wait  is set to true\nnfvo.delete.vnfr.wait.timeout = 60  Those properties are needed in case you want to tune a bit the performances of the NFVO. When the VNFMs send a message to the NFVO, there is a pool of threads able to process these messages in parallel. These parameters allows you to change the pool configuration, for more details please check the  spring documentation regarding thread pool executor    # Thread pool executor configuration\n# for info see http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/scheduling/concurrent/ThreadPoolTaskExecutor.html\nnfvo.vmanager.executor.corepoolsize = 20\nnfvo.vmanager.executor.maxpoolsize = 30\nnfvo.vmanager.executor.queuecapacity = 500\nnfvo.vmanager.executor.keepalive = 30  Let's move to the next step  Dependening on the approach used for deploying your VNF, you'll have either to install the generic-VNFM or install and register your own VNFM   \n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Install Open Baton from source code"
        }, 
        {
            "location": "/zabbix-server-configuration/", 
            "text": "Zabbix server installation and configuration\n\n\nOn Ubuntu 14.04\n\n\nWhile performing the installation on the same host where the NFVO was installed, remember that both systems are heavily consuming CPU and Memory resources, therefore you'll need a powerful machine in order to satisfy both requirements\n\n\nDuring the installation the installer will request to put a password for the user root of the mysql server. You can choose the password you like, however make sure you use the same password while configuring zabbix components\n\n\nsudo su\nwget http://repo.zabbix.com/zabbix/2.2/ubuntu/pool/main/z/zabbix-release/zabbix-release_2.2-1+trusty_all.deb\ndpkg -i zabbix-release_2.2-1+trusty_all.deb\napt-get update \n apt-get -y install mysql-server zabbix-server-mysql zabbix-frontend-php\n\n\n\n\nOnce done, you should configure the file /etc/php5/apache2/php.ini file with the following parameters: \n\n\n[PHP]\n.....\nmax_execution_time = 300\nmemory_limit = 128M\npost_max_size = 16M\nupload_max_filesize = 2M\nmax_input_time =  300\n......\n[Date]\ndate.timezone = Europe/Berlin\n\n\n\n\nRestart the apache service and you are almost done:\n\n\n/etc/init.d/apache2 restart\n\n\n\n\nAt this point the Zabbix frontend should be available at http://your-ip/zabbix in the browser. Default username/password is Admin/zabbix. It will pop up a wizard window which will guide you through the final configuration of the server. \n\n\nAdditionally, you need to configure the auto registration action so that VNFs hosts are added automatically into zabbix db when they are started. For doing it you can either do it via the zabbix dashboard reachable at  http://your-ip/zabbix/actionconf.php or using the provided sql file. Both options are explained below\n\n\nConfigure the auto registration using the dashboard\n\n\nFirst of all you need to open the actions tab\n\n\n\n\nThen you need to create an action:\n\n\n\n\nFinally you need to add two operations:\n\n\n\n\nadd host\n\n\nlink to template: you can select the template you prefer\n\n\n\n\n\n\nRemember to save all the changes in all tabs.\n\n\nConfigure the auto registration importing the sql file\n\n\nIn order to facilitate the configuration of the Zabbix Server, we also provide a zabbix.sql file with all the configuration already done. The file can be found in the folder zabbix-configuration of the zabbix-plugin project.\nYou should run the following command into the host: \n\n\n# Please note that this will overwrite whatever configuration or data is stored into the existing zabbix db.\nmysql -u root -p zabbix \n zabbix.sql\n\n\n\n\nAfter that, the zabbix server is ready to monitor your VNFs!", 
            "title": "**HIDDEN**"
        }, 
        {
            "location": "/zabbix-server-configuration/#zabbix-server-installation-and-configuration", 
            "text": "", 
            "title": "Zabbix server installation and configuration"
        }, 
        {
            "location": "/zabbix-server-configuration/#on-ubuntu-1404", 
            "text": "While performing the installation on the same host where the NFVO was installed, remember that both systems are heavily consuming CPU and Memory resources, therefore you'll need a powerful machine in order to satisfy both requirements  During the installation the installer will request to put a password for the user root of the mysql server. You can choose the password you like, however make sure you use the same password while configuring zabbix components  sudo su\nwget http://repo.zabbix.com/zabbix/2.2/ubuntu/pool/main/z/zabbix-release/zabbix-release_2.2-1+trusty_all.deb\ndpkg -i zabbix-release_2.2-1+trusty_all.deb\napt-get update   apt-get -y install mysql-server zabbix-server-mysql zabbix-frontend-php  Once done, you should configure the file /etc/php5/apache2/php.ini file with the following parameters:   [PHP]\n.....\nmax_execution_time = 300\nmemory_limit = 128M\npost_max_size = 16M\nupload_max_filesize = 2M\nmax_input_time =  300\n......\n[Date]\ndate.timezone = Europe/Berlin  Restart the apache service and you are almost done:  /etc/init.d/apache2 restart  At this point the Zabbix frontend should be available at http://your-ip/zabbix in the browser. Default username/password is Admin/zabbix. It will pop up a wizard window which will guide you through the final configuration of the server.   Additionally, you need to configure the auto registration action so that VNFs hosts are added automatically into zabbix db when they are started. For doing it you can either do it via the zabbix dashboard reachable at  http://your-ip/zabbix/actionconf.php or using the provided sql file. Both options are explained below", 
            "title": "On Ubuntu 14.04"
        }, 
        {
            "location": "/zabbix-server-configuration/#configure-the-auto-registration-using-the-dashboard", 
            "text": "First of all you need to open the actions tab   Then you need to create an action:   Finally you need to add two operations:   add host  link to template: you can select the template you prefer    Remember to save all the changes in all tabs.", 
            "title": "Configure the auto registration using the dashboard"
        }, 
        {
            "location": "/zabbix-server-configuration/#configure-the-auto-registration-importing-the-sql-file", 
            "text": "In order to facilitate the configuration of the Zabbix Server, we also provide a zabbix.sql file with all the configuration already done. The file can be found in the folder zabbix-configuration of the zabbix-plugin project.\nYou should run the following command into the host:   # Please note that this will overwrite whatever configuration or data is stored into the existing zabbix db.\nmysql -u root -p zabbix   zabbix.sql  After that, the zabbix server is ready to monitor your VNFs!", 
            "title": "Configure the auto registration importing the sql file"
        }, 
        {
            "location": "/vnfr-states/", 
            "text": "VNF Record States\n\n\n\n\nThe states of a VNF Record are reflecting the \nETSI NFV states\n and they are shown in the following picture.\n\n\n\n\nWhen the created NSR is called the VNF and the NSR are in state NULL. After the instantiate method is finished in the VNFManager, the corresponding VNFR state is set to INSTANTIATED. When all the VNFRs are in state INSTANTIATED then also the NSR goes into state INSTANTIATED. Then in case the VNFR is target of a dependency, the MODIFY message is sent to the VNFManager and when it comes back to the NFVO, the VNFR status is set to INACTIVE. When all the VNFR are in state INACTIVE then the NSR also goes in state INACTIVE. In any case the START message is sent to the VNFManager and when it comes back, the NFVO sets the VNFR state to ACTIVE. When all the VNFRs are in state ACTIVE then the NSR also goes into state ACTIVE. Then when the terminate NSR is called, the NFVO sends the TERMINATE message to all the VNFManagers. When this message returns to the NFVO, the related VNFR state is set to TERMINATED. When all the VNFRs are in state TERMINATED then the NSR is completely deleted from the database.\n\n\n\n\n\n\n\n\n\n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "**HIDDEN**"
        }, 
        {
            "location": "/vnfr-states/#vnf-record-states", 
            "text": "The states of a VNF Record are reflecting the  ETSI NFV states  and they are shown in the following picture.   When the created NSR is called the VNF and the NSR are in state NULL. After the instantiate method is finished in the VNFManager, the corresponding VNFR state is set to INSTANTIATED. When all the VNFRs are in state INSTANTIATED then also the NSR goes into state INSTANTIATED. Then in case the VNFR is target of a dependency, the MODIFY message is sent to the VNFManager and when it comes back to the NFVO, the VNFR status is set to INACTIVE. When all the VNFR are in state INACTIVE then the NSR also goes in state INACTIVE. In any case the START message is sent to the VNFManager and when it comes back, the NFVO sets the VNFR state to ACTIVE. When all the VNFRs are in state ACTIVE then the NSR also goes into state ACTIVE. Then when the terminate NSR is called, the NFVO sends the TERMINATE message to all the VNFManagers. When this message returns to the NFVO, the related VNFR state is set to TERMINATED. When all the VNFRs are in state TERMINATED then the NSR is completely deleted from the database.    \n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "VNF Record States"
        }, 
        {
            "location": "/vnf-parameters/", 
            "text": "VNF Parameters\n\n\n\n\nThe useful parameters that you can use in your scripts are defined in two different fields of a VNFD.\n\n\n...\n\nconfigurations\n:{\n                \nname\n:\nconfig_name\n,\n                \nconfigurationParameters\n:[\n                {\n                    \nconfKey\n:\nkey1\n,\n                    \nvalue\n:\nthe_value\n\n                }\n                ]\n            },\n\n...\n\n\nprovides\n:[\n        \nparam1\n,\n        \nparam2\n\n      ]\n...\n\n\n\n\nConfigurations\n\n\nThis field describes an Entity that has a list of ConfigurationParameters inside. This is a list of Entities containing key:value. These parameters are always available in your scripts. See the section below, \nhow to use the parameters\n, in order to see how to use them.\n\n\nProvides\n\n\nThis field is a list of parameter keys that will be available in all your scripts. The difference is that these parameters are parameters whose actual value will be known only at runtime. For that reason these parameters can only be filled by a specific VNFM. So you need to implement a VNFM able to handle these specific parameters in the fillSpecificParameters method (see \nHow to write a VNFM\n).\n\n\nNOTE\n: \n  there are some out-of-the-box parameters that will be added automatically to the VNFRecord. These parameters are:\n\n the networkName=IP,  key = \n network_name \n, value = \n actual-IP \n\n\n the hostname, key = \n hostname \n, value = the actual hostname\n* the floatingIp, key = \n network_name \n_floatingIp , value = the actual floatingIp\n\n\nHow to use the parameters\n\n\nAll the above parameters are available in all the scripts of the VNF that defines them. You just need to use them as environment variables, a script of the INSTANTIATE lifecycle event for instance would be:\n\n\n#!/bin/bash\n\necho \nthe value of the configuration parameter key1 is $key1\n\n\n\n\n\nAs described in the \nGeneric VNFM\n page, you can set up dependencies in order to use parameters from another VNF in the MODIFY lifecycle event. For doing that you need to specify in the Network Service Descriptor the VNF Dependency, for instance if a VNF vnf-1 is connected to network net1 and vnf-2 needs the ip of vnf-1 on that network the VNF Dependency will be:\n\n\n\n\nvnf_dependency\n:[\n        {\n            \nsource\n : {\n                \nname\n: \nvnf-1\n\n            },\n            \ntarget\n:{\n                \nname\n: \nvnf-2\n\n            },\n            \nparameters\n:[\n                \nnet1\n\n            ]\n        }\n    ]\n\n\n\n\n\nDone that, in the MODIFY scripts it is possible to use that ip in this way:\n\n\n#!/bin/bash\n\necho \nthe value of the ip on net1 of vnf-1 is $vnf1type_net1\n\n\n\n\n\nConclusion\n\n\nYou are always able to use the parameters of a VNF simply using the key as variable name, but when you want to use a parameter of a different VNF (like a relation) you need to specify the type followed by an underscore and then the name of the foreign parameter key (for instance \n$typeExt_key\n). In this last case, you can use them only in the MODIFY lifecycle event scripts.\n\n\n\n\n\n\n\n\n\n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "**HIDDEN**"
        }, 
        {
            "location": "/vnf-parameters/#vnf-parameters", 
            "text": "The useful parameters that you can use in your scripts are defined in two different fields of a VNFD.  ... configurations :{\n                 name : config_name ,\n                 configurationParameters :[\n                {\n                     confKey : key1 ,\n                     value : the_value \n                }\n                ]\n            },\n\n... provides :[\n         param1 ,\n         param2 \n      ]\n...  Configurations  This field describes an Entity that has a list of ConfigurationParameters inside. This is a list of Entities containing key:value. These parameters are always available in your scripts. See the section below,  how to use the parameters , in order to see how to use them.  Provides  This field is a list of parameter keys that will be available in all your scripts. The difference is that these parameters are parameters whose actual value will be known only at runtime. For that reason these parameters can only be filled by a specific VNFM. So you need to implement a VNFM able to handle these specific parameters in the fillSpecificParameters method (see  How to write a VNFM ).  NOTE : \n  there are some out-of-the-box parameters that will be added automatically to the VNFRecord. These parameters are:  the networkName=IP,  key =   network_name  , value =   actual-IP    the hostname, key =   hostname  , value = the actual hostname\n* the floatingIp, key =   network_name  _floatingIp , value = the actual floatingIp  How to use the parameters  All the above parameters are available in all the scripts of the VNF that defines them. You just need to use them as environment variables, a script of the INSTANTIATE lifecycle event for instance would be:  #!/bin/bash\n\necho  the value of the configuration parameter key1 is $key1   As described in the  Generic VNFM  page, you can set up dependencies in order to use parameters from another VNF in the MODIFY lifecycle event. For doing that you need to specify in the Network Service Descriptor the VNF Dependency, for instance if a VNF vnf-1 is connected to network net1 and vnf-2 needs the ip of vnf-1 on that network the VNF Dependency will be:   vnf_dependency :[\n        {\n             source  : {\n                 name :  vnf-1 \n            },\n             target :{\n                 name :  vnf-2 \n            },\n             parameters :[\n                 net1 \n            ]\n        }\n    ]  Done that, in the MODIFY scripts it is possible to use that ip in this way:  #!/bin/bash\n\necho  the value of the ip on net1 of vnf-1 is $vnf1type_net1   Conclusion  You are always able to use the parameters of a VNF simply using the key as variable name, but when you want to use a parameter of a different VNF (like a relation) you need to specify the type followed by an underscore and then the name of the foreign parameter key (for instance  $typeExt_key ). In this last case, you can use them only in the MODIFY lifecycle event scripts.    \n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "VNF Parameters"
        }, 
        {
            "location": "/nsd-json-example/", 
            "text": "This network service is composed by two VNF (iperf-server and iperf-client), which the iperf-client is composed by two VNFC.\n\n\nNote:\n no vnf package is used in this example. Only a link to reach the scripts. Basically could be a link to a git repository in which there are all the scripts.\n\n\n{\n   \nname\n:\niperf-NS\n,\n   \nvendor\n:\nFokus\n,\n   \nversion\n:\n0.1\n,\n   \nvnfd\n:[\n      {\n         \nvendor\n:\ntbr\n,\n         \nversion\n:\n0.1\n,\n         \nname\n:\niperf-server\n,\n         \ntype\n:\nserver\n,\n         \nendpoint\n:\ngeneric\n,\n         \nconfigurations\n:{\n            \nname\n:\nconfig_name\n,\n            \nconfigurationParameters\n:[]\n         },\n         \nvdu\n:[\n            {\n               \nvm_image\n:[\n                  \nubuntu-14.04-server-cloudimg-amd64-disk1\n\n               ],\n               \nvimInstanceName\n:[\nvim-instance\n],\n               \nscale_in_out\n:1,\n               \nvnfc\n:[\n                  {\n                     \nconnection_point\n:[\n                        {\n                           \nvirtual_link_reference\n:\nprivate\n\n                        }\n                     ]\n                  }\n               ]\n            }\n         ],\n         \nvirtual_link\n:[\n            {\n               \nname\n:\nprivate\n\n            }\n         ],\n         \nlifecycle_event\n:[\n            {\n               \nevent\n:\nINSTANTIATE\n,\n               \nlifecycle_events\n:[\n                  \ninstall.sh\n,\n          \nstart-srv.sh\n\n               ]\n            }\n         ],\n         \ndeployment_flavour\n:[\n            {\n               \nflavour_key\n:\nm1.small\n\n            }\n         ],\n            \nvnfPackageLocation\n:\nhttps://github.com/openbaton/vnf-scripts.git\n\n\n      },\n      {\n         \nvendor\n:\ntbr\n,\n         \nversion\n:\n0.1\n,\n         \nname\n:\niperf-client\n,\n         \ntype\n:\nclient\n,\n         \nendpoint\n:\ngeneric\n,\n         \nconfigurations\n:{\n            \nname\n:\nconfig_name\n,\n            \nconfigurationParameters\n:[\n\n            ]\n         },\n         \nvdu\n:[\n            {\n               \nvm_image\n:[\n                  \nubuntu-14.04-server-cloudimg-amd64-disk1\n\n               ],\n               \nvimInstanceName\n:[\nvim-instance\n],\n               \nscale_in_out\n:2,\n               \nvnfc\n:[\n                  {\n                     \nconnection_point\n:[\n                        {\n                           \nfloatingIp\n:\nrandom\n,\n                           \nvirtual_link_reference\n:\nprivate\n\n                        }\n                     ]\n                  },\n                  {\n                     \nconnection_point\n:[\n                        {\n                           \nfloatingIp\n:\nrandom\n,\n                           \nvirtual_link_reference\n:\nprivate\n\n                        }\n                     ]\n                  }\n               ]\n            }\n         ],\n         \nvirtual_link\n:[\n            {\n               \nname\n:\nprivate\n\n            }\n         ],\n         \nlifecycle_event\n:[\n            {\n               \nevent\n:\nINSTANTIATE\n,\n               \nlifecycle_events\n:[\n                  \ninstall.sh\n\n               ]\n            },\n            {\n               \nevent\n:\nCONFIGURE\n,\n               \nlifecycle_events\n:[\n                  \nserver_start-clt.sh\n\n               ]\n            }\n         ],\n         \ndeployment_flavour\n:[\n            {\n               \nflavour_key\n:\nm1.small\n\n            }\n         ],\n          \nvnfPackageLocation\n:\nhttps://github.com/openbaton/vnf-scripts.git\n\n      }\n   ],\n   \nvnffgd\n:[\n\n   ],\n   \nvld\n:[\n      {\n         \nname\n:\nprivate\n\n      }\n   ],\n   \nvnf_dependency\n:[\n      {\n         \nsource\n:{\n            \nname\n:\niperf-server\n\n         },\n         \ntarget\n:{\n            \nname\n:\niperf-client\n\n         },\n         \nparameters\n:[\n            \nprivate\n\n         ]\n      }\n   ]\n}", 
            "title": "**HIDDEN**"
        }, 
        {
            "location": "/integration-test-write/", 
            "text": "Write your own integration tests\n\n\nOverview\n\n\nIn this site we will describe how to write test cases for the integration tests. \nThe test scenarios are defined in .ini files which are in the directory \nintegration-tests/src/main/resources/integration-test-scenarios\n. If you want to add an integration test, just add its ini file to this folder. \n\n\nIni file structure\n\n\nIn the ini file you can describe a graph or tree like execution plan of different tasks. \nAs an example we will implement the test which is found in the \nscenario-real-iperf.ini\n file step by step. \nFirst we need a base node and define the maximum time of the integration test and the maximum number of concurrent successors. \n\n\n[it]\n;set the maximum time (in seconds) of the Integration test. e.g. 10 min = 600 seconds\nmax-integration-test-time = 800\n;set the maximum number of concurrent successors (max number of active child threads)\nmax-concurrent-successors = 10\n\n\n\n\nAfter that the first step is to store a vim instance to the orchestrator. \n\n\n[it]\n;set the maximum time (in seconds) of the Integration test. e.g. 10 min = 600 seconds\nmax-integration-test-time = 800\n;set the maximum number of concurrent successors (max number of active child threads)\nmax-concurrent-successors = 10\n\n;vimInstance-create\n[it/vim-c-1]\nclass-name = VimInstanceCreate\nname-file = real-vim.json\n\n\n\n\nThe node we just added will create a vim instance. That is defined by the class-name field. \nThe class VimInstanceCreate stores a vim instance from the \nreal-vim.json\n file to the orchestrator. \nA complete list of classes you can use is provided later in this document. \nThe file \nreal-vim.json\n has to be stored either in \n/etc/openbaton/integration-test/vim-instances/real-vim.json\n or in \n.../integration-tests/src/main/resources/etc/json_file/vim_instances/real-vim.json\n. \nThe file in the first folder has a higher priority than the one in the second one.\n\n\nWe already know that we want to delete this vim from the orchestrator at the end of the test. \nSo we can add the following:\n\n\n[it]\n;set the maximum time (in seconds) of the Integration test. e.g. 10 min = 600 seconds\nmax-integration-test-time = 800\n;set the maximum number of concurrent successors (max number of active child threads)\nmax-concurrent-successors = 10\n\n;vimInstance-create\n[it/vim-c-1]\nclass-name = VimInstanceCreate\nname-file = real-vim.json\nsuccessor-remover = vim-d-1\n\n[it/vim-c-1/vim-d-1]\nclass-name = VimInstanceDelete\n\n\n\n\nThe successor-remover field specifies, that the node \nvim-d-1\n will be executed after every child node/task of \nvim-c-1\n has finished. \nEvery node can only have one successor-remover. \nThe new node gets the information which vim instance it should delete passed from the first node. \n\n\nThe next step will be to create and delete a network service descriptor (NSD). \n\n\n[it]\n;set the maximum time (in seconds) of the Integration test. e.g. 10 min = 600 seconds\nmax-integration-test-time = 800\n;set the maximum number of concurrent successors (max number of active child threads)\nmax-concurrent-successors = 10\n\n;vimInstance-create\n[it/vim-c-1]\nclass-name = VimInstanceCreate\nname-file = real-vim.json\nsuccessor-remover = vim-d-1\n\n[it/vim-c-1/vim-d-1]\nclass-name = VimInstanceDelete\n\n;nsd-create\n[it/vim-c-1/nsd-c-1]\nclass-name = NetworkServiceDescriptorCreate\nnum_instances = 1\nsuccessor-remover = nsd-d-1\nname-file = NetworkServiceDescriptor-iperf-real.json\n\n;nsd-delete\n[it/vim-c-1/nsd-c-1/nsd-d-1]\nclass-name = NetworkServiceDescriptorDelete\n\n\n\n\nHere the new nodes are \nnsd-c-1\n and \nnsd-d-1\n. \n\nnsd-d-1\n is the successor remover of \nnsd-c-1\n and will be executed if every child node/task from \nnsd-c-1\n finished. \n\nnsd-c-1\n has some fields that need explanation. \nnum_instances\n specifies how many of those tasks should be created. \nAt the moment there is just one so only one NSD will be stored on the orchestrator. \nBut if we would provide for example a 2, then this task would be executed twice concurrently. \nEvery task would be independent and every child node which is defined for \nnsd-c-1\n would be executed for every instance separately. \nThe name-file specifies the .json file that shall be used to create the NSD. \nIt may be stored either in \n/etc/openbaton/integration-test/network-service-descriptors/NetworkServiceDescriptor-iperf-real.json\n or in \n.../integration-tests/src/main/resources/etc/json_file/network_service_descriptors/NetworkServiceDescriptor-iperf-real.json\n. \nAgain the former folder has a higher priority than the latter one. \n\n\nIn the next step we will deploy the network service record (NSR) from the created NSDs and wait for its instantiation. \n\n\n[it]\n;set the maximum time (in seconds) of the Integration test. e.g. 10 min = 600 seconds\nmax-integration-test-time = 800\n;set the maximum number of concurrent successors (max number of active child threads)\nmax-concurrent-successors = 10\n\n;vimInstance-create\n[it/vim-c-1]\nclass-name = VimInstanceCreate\nname-file = real-vim.json\nsuccessor-remover = vim-d-1\n\n[it/vim-c-1/vim-d-1]\nclass-name = VimInstanceDelete\n\n;nsd-create\n[it/vim-c-1/nsd-c-1]\nclass-name = NetworkServiceDescriptorCreate\nnum_instances = 1\nsuccessor-remover = nsd-d-1\nname-file = NetworkServiceDescriptor-iperf-real.json\n\n;nsd-delete\n[it/vim-c-1/nsd-c-1/nsd-d-1]\nclass-name = NetworkServiceDescriptorDelete\n\n;nsr-create\n[it/vim-c-1/nsd-c-1/nsr-c-1]\nclass-name = NetworkServiceRecordCreate\nnum_instances = 1\n\n;nsr-wait for creation\n[it/vim-c-1/nsd-c-1/nsr-c-1/nsr-w-1]\nclass-name = NetworkServiceRecordWait\n;the default timeout is 5 seconds\ntimeout = 600\naction = INSTANTIATE_FINISH\n\n\n\n\nnsr-c-1\n works similar to the creation of a NSD. It gets its information which NSD it should use from the preceiding task, so it has to be the NSD creation node. \nThe interesting part in this step is the \nnsr-w-1\n node. \nThis waits for the orchestrator to send the action INSTANTIATE_FINISH. If it receives it, the task was successful and the integration test proceeds. \n\n\nNow we will show how to test, if the network service is actually running.\nTherefore you can tell the integration test to ssh the instantiated virtual machines and execute commands.\nThose commands have to be written in scripts which can be placed in two locations.\nEither in \n/etc/openbaton/integration-test/scripts/\n or in \n/integration-tests/src/main/resources/etc/scripts/\n in the\nproject itself. The former directory is checked first for a script name. If it does not exist there the latter location is used. \nBash sources the scripts on the remote machines. \nBut where do I specify the Virtual Machines on which the scripts shall be executed? Well, also in the .ini file.\nUse the \nGenericServiceTester\n.\n\n\n[it]\n;set the maximum time (in seconds) of the Integration test. e.g. 10 min = 600 seconds\nmax-integration-test-time = 800\n;set the maximum number of concurrent successors (max number of active child threads)\nmax-concurrent-successors = 10\n\n;vimInstance-create\n[it/vim-c-1]\nclass-name = VimInstanceCreate\nname-file = real-vim.json\nsuccessor-remover = vim-d-1\n\n[it/vim-c-1/vim-d-1]\nclass-name = VimInstanceDelete\n\n;nsd-create\n[it/vim-c-1/nsd-c-1]\nclass-name = NetworkServiceDescriptorCreate\nnum_instances = 1\nsuccessor-remover = nsd-d-1\nname-file = NetworkServiceDescriptor-iperf-real.json\n\n;nsd-delete\n[it/vim-c-1/nsd-c-1/nsd-d-1]\nclass-name = NetworkServiceDescriptorDelete\n\n;nsr-create\n[it/vim-c-1/nsd-c-1/nsr-c-1]\nclass-name = NetworkServiceRecordCreate\nnum_instances = 1\n\n;nsr-wait for creation\n[it/vim-c-1/nsd-c-1/nsr-c-1/nsr-w-1]\nclass-name = NetworkServiceRecordWait\n;the default timeout is 5 seconds\ntimeout = 600\naction = INSTANTIATE_FINISH\n\n[it/vim-c-1/nsd-c-1/nsr-c-1/nsr-w-1/gst-1]\nclass-name = GenericServiceTester\nvnf-type = client\nuser-name = ubuntu\nvm-scripts-path = /home/ubuntu\nscript-1 = iperf-running.sh\nscript-2 = iperf-clt-connection.sh\n\n\n\n\nThe class name specifies, that we want to use the GenericServiceTester to test our service.\nThe vnf-type is used to say on which virtual network functions the scripts should be executed and is equal to the one you wrote into the network service descriptor.\nIn our example the integration test would execute them on a virtual machine, which runs the iperfserver VNF which has the type 'server'. \nIn user-name you have to specify the user name of the virtual machine, so that the integration test can ssh into the machine. \nAnd vm-scripts-path declares the directory in which the testing scripts should be stored on the virtual machine. Keep in mind that this directory has to already exist, it will not be created by the integration test. \nAnd finally you have to specify the script name. script-1 will be the first script executed in that task.\nIf you want to execute more than that, just add script-2, script-3 and so on.\n\n\nHere is the script \niperf-running.sh\n used to see if iperf is running:\n\n\n#!/bin/bash\n\niperf_count=`exec ps -aux | grep -v grep | grep iperf | wc -l`\nif [ $iperf_count -lt 1 ]\nthen\n  exit 1\nelse\n  exit 0\nfi\n\n\n\n\n\nAs you can see the script exits with status 0 on success and otherwise on 1 like usual. \nEvery script you write for the integration test should exit on a value not 0 if they fail. \nThe integration test will just pass if all the scripts exit on 0.\n\n\nSo, now we know that iperf is running on the client virtual machine. But are the client and server really communicating at the moment?\nTo test that we added another script \niperf-clt-connection.sh\n to the client task, that checks if there is an outgoing or incoming connection related to iperf and exits successfully if one exists. Here's the script:\n\n\n#!/bin/bash\n\n# this will return the ip of the remote partner of the communication, here the iperf-server\noutgoing=`sudo netstat -npt | grep iperf | awk '{print $5}' | sed 's/:.*//'` \n\n# check if the communication partner is really the iperf-server\nif [ $outgoing == ${server_ip} ]\nthen\n  exit 0\nelse\n  exit 1\nfi\n\n\n\n\n(You may wonder where '${server_ip}' comes from. It is a variable provided by the integration test as explained later. \nWe use sudo for the netstat command, because the iperf command was started by the root user.)\n\n\nWe now also add a node in the ini file for the server. \n\n\n[it]\n;set the maximum time (in seconds) of the Integration test. e.g. 10 min = 600 seconds\nmax-integration-test-time = 800\n;set the maximum number of concurrent successors (max number of active child threads)\nmax-concurrent-successors = 10\n\n;vimInstance-create\n[it/vim-c-1]\nclass-name = VimInstanceCreate\nname-file = real-vim.json\nsuccessor-remover = vim-d-1\n\n[it/vim-c-1/vim-d-1]\nclass-name = VimInstanceDelete\n\n;nsd-create\n[it/vim-c-1/nsd-c-1]\nclass-name = NetworkServiceDescriptorCreate\nnum_instances = 1\nsuccessor-remover = nsd-d-1\nname-file = NetworkServiceDescriptor-iperf-real.json\n\n;nsd-delete\n[it/vim-c-1/nsd-c-1/nsd-d-1]\nclass-name = NetworkServiceDescriptorDelete\n\n;nsr-create\n[it/vim-c-1/nsd-c-1/nsr-c-1]\nclass-name = NetworkServiceRecordCreate\nnum_instances = 1\n\n;nsr-wait for creation\n[it/vim-c-1/nsd-c-1/nsr-c-1/nsr-w-1]\nclass-name = NetworkServiceRecordWait\n;the default timeout is 5 seconds\ntimeout = 600\naction = INSTANTIATE_FINISH\n\n[it/vim-c-1/nsd-c-1/nsr-c-1/nsr-w-1/gst-1]\nclass-name = GenericServiceTester\nvnf-type = client\nuser-name = ubuntu\nvm-scripts-path = /home/ubuntu\nscript-1 = iperf-running.sh\nscript-2 = iperf-clt-connection.sh\n\n\n[it/vim-c-1/nsd-c-1/nsr-c-1/nsr-w-1/gst-1/gst-2]\nclass-name = GenericServiceTester\nvnf-type = server\nnet-name = private\nuser-name = ubuntu\nvm-scripts-path = /home/ubuntu\nscript-1 = iperf-running.sh\nscript-2 = iperf-srv-connection.sh\n\n\n\n\nThe second script for the server task looks like this:\n\n\n#!/bin/bash\n\n\nincoming=`sudo netstat -npt | grep iperf | wc -l`\n\nif [ $incoming -eq 0 ] \nthen\n  exit 1\nelse\n  exit 0\nfi\n\n\n\n\nHere we just count if there are incoming connections to the server. \n\n\nAfter the iperf-running.sh script, the iperf-srv-connection.sh script will be executed on the server virtual machines \nand on the client one's also iperf-running.sh and then the script iperf-clt-conection.sh.\n\n\nNow imagine, that you did not specify one virtual network function component in the client's NSD, but five. And you want to test them all.\nDo you have to create five tasks for that? No, if you define the task for the client as shown above, the integration test will execute\nthe scripts on every virtual machine, that was deployed by the vnfd with the type \nclient\n.\n\n\nAnd if you have some virtual network function components connected to two different networks but just want to test the ones connected\nto one of them, you can add a \nnet-name\n field to the task and just the ones connected to it will be involved like in the server task.\n\n\nAfterwards we want to delete the NSDs and simutaniously wait for a message from the orchestrator, that the deletion finished. \n\n\n[it]\n;set the maximum time (in seconds) of the Integration test. e.g. 10 min = 600 seconds\nmax-integration-test-time = 800\n;set the maximum number of concurrent successors (max number of active child threads)\nmax-concurrent-successors = 10\n\n;vimInstance-create\n[it/vim-c-1]\nclass-name = VimInstanceCreate\nname-file = real-vim.json\nsuccessor-remover = vim-d-1\n\n[it/vim-c-1/vim-d-1]\nclass-name = VimInstanceDelete\n\n;nsd-create\n[it/vim-c-1/nsd-c-1]\nclass-name = NetworkServiceDescriptorCreate\nnum_instances = 1\nsuccessor-remover = nsd-d-1\nname-file = NetworkServiceDescriptor-iperf-real.json\n\n;nsd-delete\n[it/vim-c-1/nsd-c-1/nsd-d-1]\nclass-name = NetworkServiceDescriptorDelete\n\n;nsr-create\n[it/vim-c-1/nsd-c-1/nsr-c-1]\nclass-name = NetworkServiceRecordCreate\nnum_instances = 1\n\n;nsr-wait for creation\n[it/vim-c-1/nsd-c-1/nsr-c-1/nsr-w-1]\nclass-name = NetworkServiceRecordWait\n;the default timeout is 5 seconds\ntimeout = 600\naction = INSTANTIATE_FINISH\n\n[it/vim-c-1/nsd-c-1/nsr-c-1/nsr-w-1/gst-1]\nclass-name = GenericServiceTester\nvnf-type = client\nuser-name = ubuntu\nvm-scripts-path = /home/ubuntu\nscript-1 = iperf-running.sh\nscript-2 = iperf-clt-connection.sh\n\n\n[it/vim-c-1/nsd-c-1/nsr-c-1/nsr-w-1/gst-1/gst-2]\nclass-name = GenericServiceTester\nvnf-type = server\nnet-name = private\nuser-name = ubuntu\nvm-scripts-path = /home/ubuntu\nscript-1 = iperf-running.sh\nscript-2 = iperf-srv-connection.sh\n\n;nsr-wait for deletion\n[it/vim-c-1/nsd-c-1/nsr-c-1/nsr-w-1/gst-1/gst-2/nsr-w-2]\nclass-name = NetworkServiceRecordWait\n;the default timeout is 5 seconds\ntimeout = 360\naction = RELEASE_RESOURCES_FINISH\n\n;nsr-delete\n[it/vim-c-1/nsd-c-1/nsr-c-1/nsr-w-1/gst-1/gst-2/nsr-d-1]\nclass-name = NetworkServiceRecordDelete\n\n\n\n\nAs you can see the nodes \nnsr-w-2\n and \nnsr-d-1\n are both child nodes of \ngst-2\n. \nThis means that they are executed concurrently. \nThe \nnsr-w-2\n node waits for the action RELEASE_RESOURCES_FINISH sent by the NFVO and finishes successfully if it receives it. \n\n\nNow are all the child nodes of \nnsd-c-1\n finished and its successor remover nsd-d-1 will be executed which deletes the stored NSDs. \nAfter that all the child nodes of \nvim-c-1\n finished and its successor remover \nvim-d-1\n starts to delete the stored vim instance. \n\n\nA little more on scripts\n\n\nNow we come back to the '${server_ip}' variable in the iperf-clt-connection script. As mentioned earlier this variable is provided \nby the integration test. It stores the ip of the server. If you wanted to access the IPs of the clients, you could use ${client_ip}. \nThe problem is, that we could for example also have two or more instances of clients. Which ip is chosen? \nActually the script, which contains this variable will be executed twice or more on the virtual machine until every possible substitution was handled. \nYou have access to the IPs, floating IPs and configurations. \nYou can access ips by writing ${vnfrtype_ip} or ${vnfrtype_network_ip} (don't forget the braces). The 'vnfrtype' in our example would be 'server' or 'client'. \nThe 'network' is the virtual_link you specified in the VNFD for the VNF Component and will only retrieve the VNFC ips which are connected to this network. \nIf you have more than one VNFC Instance which is deployed, so for example you have two iperf-servers \ndeployed from one VNFD, then there would be two possibilities to substitute ${server_ip}. If you want to execute a script on the virtual machine of the \niperf-client which contains this variable the integration test will do the following. Execute the script containing the \nvariable with first the ip of one server. And then executing the same script, but now replacing the variable with the other ip. \nThat way you just have to write one script and all the VNF Components of the VNF will be tested. \nYou can access the floating ips of VNFCs by writing ${vnfrtype_fip} or ${vnfrtype_network_fip}. \nOf course, this will only work if there is a floating ip for that virtual machine. \nThe configurations are accessible by typing ${vnfrtype_configurationkey}. \nFor all the variables it is essential, that you enclose them with braces otherwise they won't work. \n\n\nTask execution order\n\n\nJust to clarify the execution order of the tasks specified in the ini files here is a little example without describing what the tasks do. \nThe successor-removers of a task are just executed when all the other child tasks and their subsequent tasks finished.\n\n\n[it/A]\nsuccessor-remover = H\n\n[it/A/H]\n...\n\n[it/A/B]\n...\n\n[it/A/C]\n...\n\n[it/A/C/D]\nsuccessor-remover = G\n\n[it/A/C/D/G]\n...\n\n[it/A/C/D/E]\n...\n\n[it/A/C/D/F]\n...\n\n\n\n\nThe execution order of this example looks like this:\n\n\n\n\nTasks that are side by side can run concurrently. \n\n\nOther important information\n\n\nFor the integration test to be able to ssh to the virtual machines on openstack, you have to provide a .pem file of a key-pair you are using on openstack.\nDownload this file, name it \nintegration-test.pem\n and put it into the directory \n/etc/openbaton/integration-test/\n.\nFurthermore it has to have the correct permissions so you probably have to execute \nchmod 400 integration-test.pem\n.\nAnd don't forget to make the scripts executable.\nDo NOT use '-' in types of VNFDs or configuration names as you cannot use them in bash scripts it will not work for the integration test scripts. \n\n\nThe class-name types available\n\n\nAs mentioned earlier here is a summary of all the class-names available at the moment to use in a ini file node.\n\n\n\n\n\n\n\n\nclass-name\n\n\npurpose\n\n\nfields\n\n\nfield purpose\n\n\n\n\n\n\n\n\n\n\nGenericServiceTester\n\n\nTest the network service itself\n\n\nscript-1\n\n\nThe first script to be executed on the VM\n\n\n\n\n\n\n\n\n\n\n...\n\n\n\n\n\n\n\n\n\n\n\n\nscript-n\n\n\nThe n-th script to be executed on the VM\n\n\n\n\n\n\n\n\n\n\nvnf-type\n\n\nThe type of the VNFs that shall be tested\n\n\n\n\n\n\n\n\n\n\nuser-name\n\n\nThe user account on the VM on which the scripts will be executed\n\n\n\n\n\n\n\n\n\n\nvm-scripts-path\n\n\nThe path to the directory of the VM where the scripts will be stored before execution\n\n\n\n\n\n\n\n\n\n\nnet-name\n\n\nSpecifies the network/virtual-link to which the VMs that shall be tested are connected\n\n\n\n\n\n\nNetworkServiceDescriptorCreate\n\n\nStore a NSD on the NFVO\n\n\nexpected-to-fail\n\n\nIf set to true the task will fail if the onboarding of the NSD is successful\n\n\n\n\n\n\n\n\n\n\nname-file\n\n\nThe name of the json file which contains the NSD\n\n\n\n\n\n\nNetworkServiceDescriptorCreateFromPackage\n\n\nCreate a NSD by using a VNFPackage that was uploaded beforehand\n\n\nexpected-to-fail\n\n\nIf set to true the task will fail if the onboarding of the NSD is successful\n\n\n\n\n\n\n\n\n\n\nname-file\n\n\nThe name of the json file which contains the NSD\n\n\n\n\n\n\nNetworkServiceDescriptorDelete\n\n\nDelete a NSD from the NFVO\n\n\n\n\n\n\n\n\n\n\nNetworkServiceDescriptorWait\n\n\nWait for a specific event of the NFVO to happen that is related to NSDs\n\n\naction\n\n\nThe event which will be waited for to happen\n\n\n\n\n\n\nNetworkServiceRecordCreate\n\n\nDeploy a network service from a NSD and create the NSR\n\n\n\n\n\n\n\n\n\n\nNetworkServiceRecordDelete\n\n\nDelete the NSR\n\n\n\n\n\n\n\n\n\n\nNetworkServiceRecordGetLatest\n\n\nExpects to get passed a NSR from its preceding task, retrieves the latest version of this NSR from the NFVO and passes it to the following task\n\n\n\n\n\n\n\n\n\n\nNetworkServiceRecordWait\n\n\nWait for a specific event of the NFVO to happen that is related to NSRs\n\n\naction\n\n\nThe event which will be waited for to happen\n\n\n\n\n\n\n\n\n\n\ntimeout\n\n\nAfter this time (in seconds) the task will fail if the event did not occur yet\n\n\n\n\n\n\nPackageDelete\n\n\nDelete a VNFPackage\n\n\npackage-name\n\n\nThe name of the package that will be deleted\n\n\n\n\n\n\nPackageUpload\n\n\nUpload a VNFPackage\n\n\npackage-upload\n\n\nThe name of the package that will be uploaded\n\n\n\n\n\n\nPause\n\n\nUsed to elapse time until the next task will start\n\n\nduration\n\n\nThe time (in seconds) that this task shall do nothing and after which it will finish\n\n\n\n\n\n\nScaleIn\n\n\nTriggers one scale in operation on a VNFR specified in the ini file\n\n\nvnf-type\n\n\nThe type of VNFR that shall be scaled in\n\n\n\n\n\n\nScaleOut\n\n\nTriggers one scale out operation on a VNFR specified in the ini file\n\n\nfloating-ip\n\n\nThe floating IP which shall be assigned to the new instance\n\n\n\n\n\n\n\n\n\n\nvirtual-link\n\n\nThe network/virtual-link to which the new instance shall be connected\n\n\n\n\n\n\n\n\n\n\nvnf-type\n\n\nThe type of the VNFR on which the scale out shall be performed\n\n\n\n\n\n\nScalingTester\n\n\nVerifies if the number of VNFCInstances is equal to a given number and passes an updated NSR to the next task, which can be important after a scaling operation\n\n\nvnfc-count\n\n\nThe expected number of instances of this VNF\n\n\n\n\n\n\n\n\n\n\nvnf-type\n\n\nThe type of the VNFR whose number of VNFCs should be checked\n\n\n\n\n\n\nVimInstanceCreate\n\n\nStore a vim instance on the NFVO from a json file\n\n\nname-file\n\n\nThe name of the json file that contains the VimInstance\n\n\n\n\n\n\nVimInstanceDelete\n\n\nDelete a vim instance\n\n\n\n\n\n\n\n\n\n\nVirtualNetworkFunctionDescriptorDelete\n\n\nDelete the VNFDs of a NSD passed from the preceding task, filtered by vnfd name and/or type; if no name and type are passed, all the VNFDs associated to the passed NSD will be deleted\n\n\nvnf-type\n\n\nThe type of the VNFDs that shall be deleted; this field can be omitted if the type is not important for the choice of VNFDs to delete\n\n\n\n\n\n\n\n\n\n\nvnf-name\n\n\nThe name of the VNFDs that shall be deleted; this field can be omitted if the name is not important for the choice of VNFDs to delete\n\n\n\n\n\n\nVirtualNetworkFunctionRecordWait\n\n\nWait for an event sent by the NFVO which is related to a VNFR\n\n\naction\n\n\nThe event which will be waited for to happen\n\n\n\n\n\n\n\n\n\n\ntimeout\n\n\nAfter this time (in seconds) the task will fail if the event did not occur yet\n\n\n\n\n\n\n\n\n\n\nvnf-type\n\n\nThe type of the VNFR that should produce the awaited event\n\n\n\n\n\n\nVNFRStatusTester\n\n\nChecks if the status of a specified VNFR is as expected\n\n\nstatus\n\n\nThe expected status in which the VNFR should be\n\n\n\n\n\n\n\n\n\n\nvnf-type\n\n\nThe type of the VNFR whose status shall be checked\n\n\n\n\n\n\n\n\nUsing VNFPackages\n\n\nHere is an example on how to use VNFPackages in your tests. \n\n\n[it]\n;set the maximum time (in seconds) of the Integration test. e.g. 10 min = 600 seconds\nmax-integration-test-time = 800\n;set the maximum number of concurrent successors (max number of active child threads)\nmax-concurrent-successors = 10\n\n;vimInstance-create\n[it/vim-c-1]\nclass-name = VimInstanceCreate\nname-file = vim.json\nsuccessor-remover = vim-d-1\n\n[it/vim-c-1/vim-d-1]\nclass-name = VimInstanceDelete\n\n;package-create\n[it/vim-c-1/vnfp-c-1]\nclass-name = PackageUpload\npackage-name = iperf-server-package.tar\nsuccessor-remover = vnfp-d-1\n\n;package-delete\n[it/vim-c-1/vnfp-c-1/vnfp-d-1]\nclass-name = PackageDelete\npackage-name = iperfServerPackage\n\n;nsd-create\n[it/vim-c-1/vnfp-c-1/nsd-c-1]\nclass-name = NetworkServiceDescriptorCreateFromPackage\nname-file = NetworkServiceDescriptor.json\nsuccessor-remover = nsd-d-1\n\n;nsd-delete\n[it/vim-c-1/vnfp-c-1/nsd-c-1/nsd-d-1]\nclass-name = NetworkServiceDescriptorDelete\n\n\n\n\nThis example begins by storing a vim instance. Then the package iperf-server-package.tar is stored by specifying the package file name in the package-name attribute. \nThe packages have to be in the directory /etc/openbaton/integration-test/vnf-packages/. \nAfterwards a NSD is created from the VNFDs in the package and right after that deleted (to keep this example short we did not create a NSR from the NSD and so on). Be aware that you \nhave to use the class NetworkServiceDescriptorCreateFromPackage to store a NSD from a package. \nThen also the package will be deleted. You have to provide the name of the package you want to delete (not the file name this time but the name of the package defined in the Metadata.yaml). \nAt the end the vim instance is deleted. \n\n\nIf you create a NSD from a VNFPackage, the VNFD field of the NSD file would look something like this: \n\n\nvnfd\n:[\n{\n      \ntype\n:\nserver\n\n},\n{\n      \ntype\n:\nclient\n\n}\n\n   ],\n\n\n\n\nThe integration test will search for VNFDs with these types that were previously stored by a VNFPackage and use them for creating the NSD. \n\n\nScaling\n\n\nThere are three testers for Scaling already implemented. The first one is \nScaleOut\n. In the ini file this tester needs some additional attributes. Besides the normal \nclass-name\n you should also specify the VNFR type on which the scale out should be performed in the field \nvnf-type\n. Then you can also specify the virtual-link to which the new instance should be connected using \nvirtual-link\n. \nAnd you can determine a floating ip for the new instance using the field \nfloating-ip\n. \nHere is an example of a ScaleOut task in the ini file:\n\n\n[it/.../sc-o-1]\nclass-name = ScaleOut\nvnf-type = client\nvirtual-link = private\nfloating-ip = random\n\n\n\n\nThe second tester is \nScaleIn\n. Here you can just specify on which VNFR type the scale in should be executed. An example: \n\n\n[it/.../sc-i-1]\nclass-name = ScaleIn\nvnf-type = client\n\n\n\n\nAnd the third tester is used to see if after the scaling operation there is the right number of instances running. \nSpecify the VNFR type you want to test by providing \nvnf-type\n in the ini file and specify the number of expected VNFC instances by using \nvnfc-count\n. For example: \n\n\n[it/.../sc-t-1]\nclass-name = ScalingTester\nvnf-type = client\nvnfc-count = 2\n\n\n\n\nFurthermore note that the ScalingTester passes the updated NSR to the next tester. If you trigger a scaling function the NSR will change, but if you do not use ScalingTester (or NetworkServiceRecordGetLatest) the NSR used by the integration test will remain the old one before the scaling operation. \nSo the recommended proceeding after a scale out or scale in is to wait until the operation finishes and then use the \nScalingTester\n or at least the \nNetworkServiceRecordGetLatest\n to have the updated NSR. \n\n\nParser\n\n\nThe class Parser looks for a configuration file with this syntax:\n\n\nold_value = new_value\n\n\nIn the json file, passed to the method Parser.randomize(), all the old_value will be replace with new_value.\nIMPORTANT: in the json file, the old_value must have the following sintax:\n\n\n\"some_parameter\" = \"\n::old_value::\n\"\n\n\nIf we want to put random values:\n\n\nold_value = new_value***\n\n\nIn the json file, passed to the method Parser.randomize(), all the old_value will be replace\nwith new_value plus 3 random characters (e.g. new_valuezxd).\n\n\nSimple parser example\n\n\nParser properties file:\n\n\nadmin=admin***\n\n\n\n\nJson file:\n\n\n{\n\nusername\n:\n::admin::\n\n}\n\n\n\n\nThe new json file used by the integration tests will be:\n\n\n{\n\nusername\n:\nadminxkz\n\n}\n\n\n\n\nParser configuration\n\n\nIf you want to apply the parser on NSDs, create the file \n/etc/openbaton/integration-test/parser-properties/nsd.properties\n.\n\nIf you want to apply the parser on Vim Instances, create the file \n/etc/openbaton/integration-test/parser-properties/vim.properties\n.", 
            "title": "**HIDDEN**"
        }, 
        {
            "location": "/integration-test-write/#write-your-own-integration-tests", 
            "text": "", 
            "title": "Write your own integration tests"
        }, 
        {
            "location": "/integration-test-write/#overview", 
            "text": "In this site we will describe how to write test cases for the integration tests. \nThe test scenarios are defined in .ini files which are in the directory  integration-tests/src/main/resources/integration-test-scenarios . If you want to add an integration test, just add its ini file to this folder.   Ini file structure  In the ini file you can describe a graph or tree like execution plan of different tasks. \nAs an example we will implement the test which is found in the  scenario-real-iperf.ini  file step by step. \nFirst we need a base node and define the maximum time of the integration test and the maximum number of concurrent successors.   [it]\n;set the maximum time (in seconds) of the Integration test. e.g. 10 min = 600 seconds\nmax-integration-test-time = 800\n;set the maximum number of concurrent successors (max number of active child threads)\nmax-concurrent-successors = 10  After that the first step is to store a vim instance to the orchestrator.   [it]\n;set the maximum time (in seconds) of the Integration test. e.g. 10 min = 600 seconds\nmax-integration-test-time = 800\n;set the maximum number of concurrent successors (max number of active child threads)\nmax-concurrent-successors = 10\n\n;vimInstance-create\n[it/vim-c-1]\nclass-name = VimInstanceCreate\nname-file = real-vim.json  The node we just added will create a vim instance. That is defined by the class-name field. \nThe class VimInstanceCreate stores a vim instance from the  real-vim.json  file to the orchestrator. \nA complete list of classes you can use is provided later in this document. \nThe file  real-vim.json  has to be stored either in  /etc/openbaton/integration-test/vim-instances/real-vim.json  or in  .../integration-tests/src/main/resources/etc/json_file/vim_instances/real-vim.json . \nThe file in the first folder has a higher priority than the one in the second one.  We already know that we want to delete this vim from the orchestrator at the end of the test. \nSo we can add the following:  [it]\n;set the maximum time (in seconds) of the Integration test. e.g. 10 min = 600 seconds\nmax-integration-test-time = 800\n;set the maximum number of concurrent successors (max number of active child threads)\nmax-concurrent-successors = 10\n\n;vimInstance-create\n[it/vim-c-1]\nclass-name = VimInstanceCreate\nname-file = real-vim.json\nsuccessor-remover = vim-d-1\n\n[it/vim-c-1/vim-d-1]\nclass-name = VimInstanceDelete  The successor-remover field specifies, that the node  vim-d-1  will be executed after every child node/task of  vim-c-1  has finished. \nEvery node can only have one successor-remover. \nThe new node gets the information which vim instance it should delete passed from the first node.   The next step will be to create and delete a network service descriptor (NSD).   [it]\n;set the maximum time (in seconds) of the Integration test. e.g. 10 min = 600 seconds\nmax-integration-test-time = 800\n;set the maximum number of concurrent successors (max number of active child threads)\nmax-concurrent-successors = 10\n\n;vimInstance-create\n[it/vim-c-1]\nclass-name = VimInstanceCreate\nname-file = real-vim.json\nsuccessor-remover = vim-d-1\n\n[it/vim-c-1/vim-d-1]\nclass-name = VimInstanceDelete\n\n;nsd-create\n[it/vim-c-1/nsd-c-1]\nclass-name = NetworkServiceDescriptorCreate\nnum_instances = 1\nsuccessor-remover = nsd-d-1\nname-file = NetworkServiceDescriptor-iperf-real.json\n\n;nsd-delete\n[it/vim-c-1/nsd-c-1/nsd-d-1]\nclass-name = NetworkServiceDescriptorDelete  Here the new nodes are  nsd-c-1  and  nsd-d-1 .  nsd-d-1  is the successor remover of  nsd-c-1  and will be executed if every child node/task from  nsd-c-1  finished.  nsd-c-1  has some fields that need explanation.  num_instances  specifies how many of those tasks should be created. \nAt the moment there is just one so only one NSD will be stored on the orchestrator. \nBut if we would provide for example a 2, then this task would be executed twice concurrently. \nEvery task would be independent and every child node which is defined for  nsd-c-1  would be executed for every instance separately. \nThe name-file specifies the .json file that shall be used to create the NSD. \nIt may be stored either in  /etc/openbaton/integration-test/network-service-descriptors/NetworkServiceDescriptor-iperf-real.json  or in  .../integration-tests/src/main/resources/etc/json_file/network_service_descriptors/NetworkServiceDescriptor-iperf-real.json . \nAgain the former folder has a higher priority than the latter one.   In the next step we will deploy the network service record (NSR) from the created NSDs and wait for its instantiation.   [it]\n;set the maximum time (in seconds) of the Integration test. e.g. 10 min = 600 seconds\nmax-integration-test-time = 800\n;set the maximum number of concurrent successors (max number of active child threads)\nmax-concurrent-successors = 10\n\n;vimInstance-create\n[it/vim-c-1]\nclass-name = VimInstanceCreate\nname-file = real-vim.json\nsuccessor-remover = vim-d-1\n\n[it/vim-c-1/vim-d-1]\nclass-name = VimInstanceDelete\n\n;nsd-create\n[it/vim-c-1/nsd-c-1]\nclass-name = NetworkServiceDescriptorCreate\nnum_instances = 1\nsuccessor-remover = nsd-d-1\nname-file = NetworkServiceDescriptor-iperf-real.json\n\n;nsd-delete\n[it/vim-c-1/nsd-c-1/nsd-d-1]\nclass-name = NetworkServiceDescriptorDelete\n\n;nsr-create\n[it/vim-c-1/nsd-c-1/nsr-c-1]\nclass-name = NetworkServiceRecordCreate\nnum_instances = 1\n\n;nsr-wait for creation\n[it/vim-c-1/nsd-c-1/nsr-c-1/nsr-w-1]\nclass-name = NetworkServiceRecordWait\n;the default timeout is 5 seconds\ntimeout = 600\naction = INSTANTIATE_FINISH  nsr-c-1  works similar to the creation of a NSD. It gets its information which NSD it should use from the preceiding task, so it has to be the NSD creation node. \nThe interesting part in this step is the  nsr-w-1  node. \nThis waits for the orchestrator to send the action INSTANTIATE_FINISH. If it receives it, the task was successful and the integration test proceeds.   Now we will show how to test, if the network service is actually running.\nTherefore you can tell the integration test to ssh the instantiated virtual machines and execute commands.\nThose commands have to be written in scripts which can be placed in two locations.\nEither in  /etc/openbaton/integration-test/scripts/  or in  /integration-tests/src/main/resources/etc/scripts/  in the\nproject itself. The former directory is checked first for a script name. If it does not exist there the latter location is used. \nBash sources the scripts on the remote machines. \nBut where do I specify the Virtual Machines on which the scripts shall be executed? Well, also in the .ini file.\nUse the  GenericServiceTester .  [it]\n;set the maximum time (in seconds) of the Integration test. e.g. 10 min = 600 seconds\nmax-integration-test-time = 800\n;set the maximum number of concurrent successors (max number of active child threads)\nmax-concurrent-successors = 10\n\n;vimInstance-create\n[it/vim-c-1]\nclass-name = VimInstanceCreate\nname-file = real-vim.json\nsuccessor-remover = vim-d-1\n\n[it/vim-c-1/vim-d-1]\nclass-name = VimInstanceDelete\n\n;nsd-create\n[it/vim-c-1/nsd-c-1]\nclass-name = NetworkServiceDescriptorCreate\nnum_instances = 1\nsuccessor-remover = nsd-d-1\nname-file = NetworkServiceDescriptor-iperf-real.json\n\n;nsd-delete\n[it/vim-c-1/nsd-c-1/nsd-d-1]\nclass-name = NetworkServiceDescriptorDelete\n\n;nsr-create\n[it/vim-c-1/nsd-c-1/nsr-c-1]\nclass-name = NetworkServiceRecordCreate\nnum_instances = 1\n\n;nsr-wait for creation\n[it/vim-c-1/nsd-c-1/nsr-c-1/nsr-w-1]\nclass-name = NetworkServiceRecordWait\n;the default timeout is 5 seconds\ntimeout = 600\naction = INSTANTIATE_FINISH\n\n[it/vim-c-1/nsd-c-1/nsr-c-1/nsr-w-1/gst-1]\nclass-name = GenericServiceTester\nvnf-type = client\nuser-name = ubuntu\nvm-scripts-path = /home/ubuntu\nscript-1 = iperf-running.sh\nscript-2 = iperf-clt-connection.sh  The class name specifies, that we want to use the GenericServiceTester to test our service.\nThe vnf-type is used to say on which virtual network functions the scripts should be executed and is equal to the one you wrote into the network service descriptor.\nIn our example the integration test would execute them on a virtual machine, which runs the iperfserver VNF which has the type 'server'. \nIn user-name you have to specify the user name of the virtual machine, so that the integration test can ssh into the machine. \nAnd vm-scripts-path declares the directory in which the testing scripts should be stored on the virtual machine. Keep in mind that this directory has to already exist, it will not be created by the integration test. \nAnd finally you have to specify the script name. script-1 will be the first script executed in that task.\nIf you want to execute more than that, just add script-2, script-3 and so on.  Here is the script  iperf-running.sh  used to see if iperf is running:  #!/bin/bash\n\niperf_count=`exec ps -aux | grep -v grep | grep iperf | wc -l`\nif [ $iperf_count -lt 1 ]\nthen\n  exit 1\nelse\n  exit 0\nfi  As you can see the script exits with status 0 on success and otherwise on 1 like usual. \nEvery script you write for the integration test should exit on a value not 0 if they fail. \nThe integration test will just pass if all the scripts exit on 0.  So, now we know that iperf is running on the client virtual machine. But are the client and server really communicating at the moment?\nTo test that we added another script  iperf-clt-connection.sh  to the client task, that checks if there is an outgoing or incoming connection related to iperf and exits successfully if one exists. Here's the script:  #!/bin/bash\n\n# this will return the ip of the remote partner of the communication, here the iperf-server\noutgoing=`sudo netstat -npt | grep iperf | awk '{print $5}' | sed 's/:.*//'` \n\n# check if the communication partner is really the iperf-server\nif [ $outgoing == ${server_ip} ]\nthen\n  exit 0\nelse\n  exit 1\nfi  (You may wonder where '${server_ip}' comes from. It is a variable provided by the integration test as explained later. \nWe use sudo for the netstat command, because the iperf command was started by the root user.)  We now also add a node in the ini file for the server.   [it]\n;set the maximum time (in seconds) of the Integration test. e.g. 10 min = 600 seconds\nmax-integration-test-time = 800\n;set the maximum number of concurrent successors (max number of active child threads)\nmax-concurrent-successors = 10\n\n;vimInstance-create\n[it/vim-c-1]\nclass-name = VimInstanceCreate\nname-file = real-vim.json\nsuccessor-remover = vim-d-1\n\n[it/vim-c-1/vim-d-1]\nclass-name = VimInstanceDelete\n\n;nsd-create\n[it/vim-c-1/nsd-c-1]\nclass-name = NetworkServiceDescriptorCreate\nnum_instances = 1\nsuccessor-remover = nsd-d-1\nname-file = NetworkServiceDescriptor-iperf-real.json\n\n;nsd-delete\n[it/vim-c-1/nsd-c-1/nsd-d-1]\nclass-name = NetworkServiceDescriptorDelete\n\n;nsr-create\n[it/vim-c-1/nsd-c-1/nsr-c-1]\nclass-name = NetworkServiceRecordCreate\nnum_instances = 1\n\n;nsr-wait for creation\n[it/vim-c-1/nsd-c-1/nsr-c-1/nsr-w-1]\nclass-name = NetworkServiceRecordWait\n;the default timeout is 5 seconds\ntimeout = 600\naction = INSTANTIATE_FINISH\n\n[it/vim-c-1/nsd-c-1/nsr-c-1/nsr-w-1/gst-1]\nclass-name = GenericServiceTester\nvnf-type = client\nuser-name = ubuntu\nvm-scripts-path = /home/ubuntu\nscript-1 = iperf-running.sh\nscript-2 = iperf-clt-connection.sh\n\n\n[it/vim-c-1/nsd-c-1/nsr-c-1/nsr-w-1/gst-1/gst-2]\nclass-name = GenericServiceTester\nvnf-type = server\nnet-name = private\nuser-name = ubuntu\nvm-scripts-path = /home/ubuntu\nscript-1 = iperf-running.sh\nscript-2 = iperf-srv-connection.sh  The second script for the server task looks like this:  #!/bin/bash\n\n\nincoming=`sudo netstat -npt | grep iperf | wc -l`\n\nif [ $incoming -eq 0 ] \nthen\n  exit 1\nelse\n  exit 0\nfi  Here we just count if there are incoming connections to the server.   After the iperf-running.sh script, the iperf-srv-connection.sh script will be executed on the server virtual machines \nand on the client one's also iperf-running.sh and then the script iperf-clt-conection.sh.  Now imagine, that you did not specify one virtual network function component in the client's NSD, but five. And you want to test them all.\nDo you have to create five tasks for that? No, if you define the task for the client as shown above, the integration test will execute\nthe scripts on every virtual machine, that was deployed by the vnfd with the type  client .  And if you have some virtual network function components connected to two different networks but just want to test the ones connected\nto one of them, you can add a  net-name  field to the task and just the ones connected to it will be involved like in the server task.  Afterwards we want to delete the NSDs and simutaniously wait for a message from the orchestrator, that the deletion finished.   [it]\n;set the maximum time (in seconds) of the Integration test. e.g. 10 min = 600 seconds\nmax-integration-test-time = 800\n;set the maximum number of concurrent successors (max number of active child threads)\nmax-concurrent-successors = 10\n\n;vimInstance-create\n[it/vim-c-1]\nclass-name = VimInstanceCreate\nname-file = real-vim.json\nsuccessor-remover = vim-d-1\n\n[it/vim-c-1/vim-d-1]\nclass-name = VimInstanceDelete\n\n;nsd-create\n[it/vim-c-1/nsd-c-1]\nclass-name = NetworkServiceDescriptorCreate\nnum_instances = 1\nsuccessor-remover = nsd-d-1\nname-file = NetworkServiceDescriptor-iperf-real.json\n\n;nsd-delete\n[it/vim-c-1/nsd-c-1/nsd-d-1]\nclass-name = NetworkServiceDescriptorDelete\n\n;nsr-create\n[it/vim-c-1/nsd-c-1/nsr-c-1]\nclass-name = NetworkServiceRecordCreate\nnum_instances = 1\n\n;nsr-wait for creation\n[it/vim-c-1/nsd-c-1/nsr-c-1/nsr-w-1]\nclass-name = NetworkServiceRecordWait\n;the default timeout is 5 seconds\ntimeout = 600\naction = INSTANTIATE_FINISH\n\n[it/vim-c-1/nsd-c-1/nsr-c-1/nsr-w-1/gst-1]\nclass-name = GenericServiceTester\nvnf-type = client\nuser-name = ubuntu\nvm-scripts-path = /home/ubuntu\nscript-1 = iperf-running.sh\nscript-2 = iperf-clt-connection.sh\n\n\n[it/vim-c-1/nsd-c-1/nsr-c-1/nsr-w-1/gst-1/gst-2]\nclass-name = GenericServiceTester\nvnf-type = server\nnet-name = private\nuser-name = ubuntu\nvm-scripts-path = /home/ubuntu\nscript-1 = iperf-running.sh\nscript-2 = iperf-srv-connection.sh\n\n;nsr-wait for deletion\n[it/vim-c-1/nsd-c-1/nsr-c-1/nsr-w-1/gst-1/gst-2/nsr-w-2]\nclass-name = NetworkServiceRecordWait\n;the default timeout is 5 seconds\ntimeout = 360\naction = RELEASE_RESOURCES_FINISH\n\n;nsr-delete\n[it/vim-c-1/nsd-c-1/nsr-c-1/nsr-w-1/gst-1/gst-2/nsr-d-1]\nclass-name = NetworkServiceRecordDelete  As you can see the nodes  nsr-w-2  and  nsr-d-1  are both child nodes of  gst-2 . \nThis means that they are executed concurrently. \nThe  nsr-w-2  node waits for the action RELEASE_RESOURCES_FINISH sent by the NFVO and finishes successfully if it receives it.   Now are all the child nodes of  nsd-c-1  finished and its successor remover nsd-d-1 will be executed which deletes the stored NSDs. \nAfter that all the child nodes of  vim-c-1  finished and its successor remover  vim-d-1  starts to delete the stored vim instance.   A little more on scripts  Now we come back to the '${server_ip}' variable in the iperf-clt-connection script. As mentioned earlier this variable is provided \nby the integration test. It stores the ip of the server. If you wanted to access the IPs of the clients, you could use ${client_ip}. \nThe problem is, that we could for example also have two or more instances of clients. Which ip is chosen? \nActually the script, which contains this variable will be executed twice or more on the virtual machine until every possible substitution was handled. \nYou have access to the IPs, floating IPs and configurations. \nYou can access ips by writing ${vnfrtype_ip} or ${vnfrtype_network_ip} (don't forget the braces). The 'vnfrtype' in our example would be 'server' or 'client'. \nThe 'network' is the virtual_link you specified in the VNFD for the VNF Component and will only retrieve the VNFC ips which are connected to this network. \nIf you have more than one VNFC Instance which is deployed, so for example you have two iperf-servers \ndeployed from one VNFD, then there would be two possibilities to substitute ${server_ip}. If you want to execute a script on the virtual machine of the \niperf-client which contains this variable the integration test will do the following. Execute the script containing the \nvariable with first the ip of one server. And then executing the same script, but now replacing the variable with the other ip. \nThat way you just have to write one script and all the VNF Components of the VNF will be tested. \nYou can access the floating ips of VNFCs by writing ${vnfrtype_fip} or ${vnfrtype_network_fip}. \nOf course, this will only work if there is a floating ip for that virtual machine. \nThe configurations are accessible by typing ${vnfrtype_configurationkey}. \nFor all the variables it is essential, that you enclose them with braces otherwise they won't work.", 
            "title": "Overview"
        }, 
        {
            "location": "/integration-test-write/#task-execution-order", 
            "text": "Just to clarify the execution order of the tasks specified in the ini files here is a little example without describing what the tasks do. \nThe successor-removers of a task are just executed when all the other child tasks and their subsequent tasks finished.  [it/A]\nsuccessor-remover = H\n\n[it/A/H]\n...\n\n[it/A/B]\n...\n\n[it/A/C]\n...\n\n[it/A/C/D]\nsuccessor-remover = G\n\n[it/A/C/D/G]\n...\n\n[it/A/C/D/E]\n...\n\n[it/A/C/D/F]\n...  The execution order of this example looks like this:   Tasks that are side by side can run concurrently.", 
            "title": "Task execution order"
        }, 
        {
            "location": "/integration-test-write/#other-important-information", 
            "text": "For the integration test to be able to ssh to the virtual machines on openstack, you have to provide a .pem file of a key-pair you are using on openstack.\nDownload this file, name it  integration-test.pem  and put it into the directory  /etc/openbaton/integration-test/ .\nFurthermore it has to have the correct permissions so you probably have to execute  chmod 400 integration-test.pem .\nAnd don't forget to make the scripts executable.\nDo NOT use '-' in types of VNFDs or configuration names as you cannot use them in bash scripts it will not work for the integration test scripts.", 
            "title": "Other important information"
        }, 
        {
            "location": "/integration-test-write/#the-class-name-types-available", 
            "text": "As mentioned earlier here is a summary of all the class-names available at the moment to use in a ini file node.     class-name  purpose  fields  field purpose      GenericServiceTester  Test the network service itself  script-1  The first script to be executed on the VM      ...       script-n  The n-th script to be executed on the VM      vnf-type  The type of the VNFs that shall be tested      user-name  The user account on the VM on which the scripts will be executed      vm-scripts-path  The path to the directory of the VM where the scripts will be stored before execution      net-name  Specifies the network/virtual-link to which the VMs that shall be tested are connected    NetworkServiceDescriptorCreate  Store a NSD on the NFVO  expected-to-fail  If set to true the task will fail if the onboarding of the NSD is successful      name-file  The name of the json file which contains the NSD    NetworkServiceDescriptorCreateFromPackage  Create a NSD by using a VNFPackage that was uploaded beforehand  expected-to-fail  If set to true the task will fail if the onboarding of the NSD is successful      name-file  The name of the json file which contains the NSD    NetworkServiceDescriptorDelete  Delete a NSD from the NFVO      NetworkServiceDescriptorWait  Wait for a specific event of the NFVO to happen that is related to NSDs  action  The event which will be waited for to happen    NetworkServiceRecordCreate  Deploy a network service from a NSD and create the NSR      NetworkServiceRecordDelete  Delete the NSR      NetworkServiceRecordGetLatest  Expects to get passed a NSR from its preceding task, retrieves the latest version of this NSR from the NFVO and passes it to the following task      NetworkServiceRecordWait  Wait for a specific event of the NFVO to happen that is related to NSRs  action  The event which will be waited for to happen      timeout  After this time (in seconds) the task will fail if the event did not occur yet    PackageDelete  Delete a VNFPackage  package-name  The name of the package that will be deleted    PackageUpload  Upload a VNFPackage  package-upload  The name of the package that will be uploaded    Pause  Used to elapse time until the next task will start  duration  The time (in seconds) that this task shall do nothing and after which it will finish    ScaleIn  Triggers one scale in operation on a VNFR specified in the ini file  vnf-type  The type of VNFR that shall be scaled in    ScaleOut  Triggers one scale out operation on a VNFR specified in the ini file  floating-ip  The floating IP which shall be assigned to the new instance      virtual-link  The network/virtual-link to which the new instance shall be connected      vnf-type  The type of the VNFR on which the scale out shall be performed    ScalingTester  Verifies if the number of VNFCInstances is equal to a given number and passes an updated NSR to the next task, which can be important after a scaling operation  vnfc-count  The expected number of instances of this VNF      vnf-type  The type of the VNFR whose number of VNFCs should be checked    VimInstanceCreate  Store a vim instance on the NFVO from a json file  name-file  The name of the json file that contains the VimInstance    VimInstanceDelete  Delete a vim instance      VirtualNetworkFunctionDescriptorDelete  Delete the VNFDs of a NSD passed from the preceding task, filtered by vnfd name and/or type; if no name and type are passed, all the VNFDs associated to the passed NSD will be deleted  vnf-type  The type of the VNFDs that shall be deleted; this field can be omitted if the type is not important for the choice of VNFDs to delete      vnf-name  The name of the VNFDs that shall be deleted; this field can be omitted if the name is not important for the choice of VNFDs to delete    VirtualNetworkFunctionRecordWait  Wait for an event sent by the NFVO which is related to a VNFR  action  The event which will be waited for to happen      timeout  After this time (in seconds) the task will fail if the event did not occur yet      vnf-type  The type of the VNFR that should produce the awaited event    VNFRStatusTester  Checks if the status of a specified VNFR is as expected  status  The expected status in which the VNFR should be      vnf-type  The type of the VNFR whose status shall be checked", 
            "title": "The class-name types available"
        }, 
        {
            "location": "/integration-test-write/#using-vnfpackages", 
            "text": "Here is an example on how to use VNFPackages in your tests.   [it]\n;set the maximum time (in seconds) of the Integration test. e.g. 10 min = 600 seconds\nmax-integration-test-time = 800\n;set the maximum number of concurrent successors (max number of active child threads)\nmax-concurrent-successors = 10\n\n;vimInstance-create\n[it/vim-c-1]\nclass-name = VimInstanceCreate\nname-file = vim.json\nsuccessor-remover = vim-d-1\n\n[it/vim-c-1/vim-d-1]\nclass-name = VimInstanceDelete\n\n;package-create\n[it/vim-c-1/vnfp-c-1]\nclass-name = PackageUpload\npackage-name = iperf-server-package.tar\nsuccessor-remover = vnfp-d-1\n\n;package-delete\n[it/vim-c-1/vnfp-c-1/vnfp-d-1]\nclass-name = PackageDelete\npackage-name = iperfServerPackage\n\n;nsd-create\n[it/vim-c-1/vnfp-c-1/nsd-c-1]\nclass-name = NetworkServiceDescriptorCreateFromPackage\nname-file = NetworkServiceDescriptor.json\nsuccessor-remover = nsd-d-1\n\n;nsd-delete\n[it/vim-c-1/vnfp-c-1/nsd-c-1/nsd-d-1]\nclass-name = NetworkServiceDescriptorDelete  This example begins by storing a vim instance. Then the package iperf-server-package.tar is stored by specifying the package file name in the package-name attribute. \nThe packages have to be in the directory /etc/openbaton/integration-test/vnf-packages/. \nAfterwards a NSD is created from the VNFDs in the package and right after that deleted (to keep this example short we did not create a NSR from the NSD and so on). Be aware that you \nhave to use the class NetworkServiceDescriptorCreateFromPackage to store a NSD from a package. \nThen also the package will be deleted. You have to provide the name of the package you want to delete (not the file name this time but the name of the package defined in the Metadata.yaml). \nAt the end the vim instance is deleted.   If you create a NSD from a VNFPackage, the VNFD field of the NSD file would look something like this:   vnfd :[\n{\n       type : server \n},\n{\n       type : client \n}\n\n   ],  The integration test will search for VNFDs with these types that were previously stored by a VNFPackage and use them for creating the NSD.", 
            "title": "Using VNFPackages"
        }, 
        {
            "location": "/integration-test-write/#scaling", 
            "text": "There are three testers for Scaling already implemented. The first one is  ScaleOut . In the ini file this tester needs some additional attributes. Besides the normal  class-name  you should also specify the VNFR type on which the scale out should be performed in the field  vnf-type . Then you can also specify the virtual-link to which the new instance should be connected using  virtual-link . \nAnd you can determine a floating ip for the new instance using the field  floating-ip . \nHere is an example of a ScaleOut task in the ini file:  [it/.../sc-o-1]\nclass-name = ScaleOut\nvnf-type = client\nvirtual-link = private\nfloating-ip = random  The second tester is  ScaleIn . Here you can just specify on which VNFR type the scale in should be executed. An example:   [it/.../sc-i-1]\nclass-name = ScaleIn\nvnf-type = client  And the third tester is used to see if after the scaling operation there is the right number of instances running. \nSpecify the VNFR type you want to test by providing  vnf-type  in the ini file and specify the number of expected VNFC instances by using  vnfc-count . For example:   [it/.../sc-t-1]\nclass-name = ScalingTester\nvnf-type = client\nvnfc-count = 2  Furthermore note that the ScalingTester passes the updated NSR to the next tester. If you trigger a scaling function the NSR will change, but if you do not use ScalingTester (or NetworkServiceRecordGetLatest) the NSR used by the integration test will remain the old one before the scaling operation. \nSo the recommended proceeding after a scale out or scale in is to wait until the operation finishes and then use the  ScalingTester  or at least the  NetworkServiceRecordGetLatest  to have the updated NSR.", 
            "title": "Scaling"
        }, 
        {
            "location": "/integration-test-write/#parser", 
            "text": "The class Parser looks for a configuration file with this syntax:  old_value = new_value  In the json file, passed to the method Parser.randomize(), all the old_value will be replace with new_value.\nIMPORTANT: in the json file, the old_value must have the following sintax:  \"some_parameter\" = \" ::old_value:: \"  If we want to put random values:  old_value = new_value***  In the json file, passed to the method Parser.randomize(), all the old_value will be replace\nwith new_value plus 3 random characters (e.g. new_valuezxd).  Simple parser example  Parser properties file:  admin=admin***  Json file:  { username : ::admin:: \n}  The new json file used by the integration tests will be:  { username : adminxkz \n}  Parser configuration  If you want to apply the parser on NSDs, create the file  /etc/openbaton/integration-test/parser-properties/nsd.properties . \nIf you want to apply the parser on Vim Instances, create the file  /etc/openbaton/integration-test/parser-properties/vim.properties .", 
            "title": "Parser"
        }
    ]
}