{
    "docs": [
        {
            "location": "/", 
            "text": "Open Baton\n\n\nOpen Baton is an open source project providing a comprehensive implementation of the ETSI Management and Orchestration (MANO) specification. \n\n\nIts main components\n\n\nOpen Baton provides many different features and components: \n\n\n\n\nA Network Function Virtualisation Orchestrator (NFVO) completely designed and implemented following the ETSI MANO specification. Read more \nhere\n\n\nA generic Virtual Network Function Manager (VNFM) able to manage the lifecycle of VNFs based on their descriptors. Read more \nhere\n\n\nA Juju VNFM Adapter in order to deploy Juju Charms or Open Baton VNF Packages using the Juju VNFM. Read more \nhere\n\n\nA driver mechanism for adding and removing different type of VIMs without having to re-write anything in your orchestration logic. Read more \nhere\n\n\nA powerful event engine useful based on a pub/sub mechanism for the dispatching of lifecycle events execution. Read more \nhere\n\n\nAn autoscaling engine which can be used for automatic runtime management of the scaling operation operations of your VNFs. Read more \nhere\n\n\nA fault management system which can be used for automatic runtime management of faults which may occur at any level. Read more \nhere\n\n\nIt integrates with the Zabbix monitoring system. Read more \nhere\n\n\nA set of libraries (the openbaton-libs) which could be used for building your own VNFM. Read more \nhere\n\n\nA \nMarketplace\n useful for downloading VNFs compatible with the Open Baton NFVO and VNFMs. Read more at \nhere\n\n\n\n\n\n\nCan I plug in my Network Functions?\n\n\nYes, this is possible using (at least) two different approaches:\n\n\n\n\nIntegrating your own VNFM. In this case you can use either the REST interface, or the AMQP one for interoperating with the NFVO.\n\n\nImplementing a set of scripts which can be executed as part of the lifecycle event of your Virtual Network Function Descriptor. We provide a generic VNFM and EMS which can be used for executing them.\n\n\n\n\nLearn more \nhere\n.\n\n\nCan I use Open Baton to build my own Network Service?\n\n\nYes! Open Baton provides a NFVO which can interoperate with VNFMs implemented by third parties. We provide also a set of tools (like the vnfm-sdk) which supports developers in building their own VNFM. \n\n\nLearn more \nhere\n.\n\n\nGet started\n\n\nIn order to get started you can follow the \ninstallation guide\n.\n\n\nLearn more\n\n\nPlease refer to the \"Tutorials\" and \"Learn More\" sections for having more information about the Open Baton project. You can also learn more via our video tutorials published on the Open Baton \nYoutube Channel\n.\n\n\nWhat is NFV\n\n\nETSI NFV represents a concerted telco operator initiative fostering the development of virtual network infrastructures by porting and further adapting network functions to the specific cloud environment. \nETSI NFV has defined a large set of virtualisation use cases, spanning from the cloudification of the main core network functions such as IMS, Evolved Packet Core, and Radio Access Networks, as well as providing on demand and complete virtualised infrastructures as IaaS or PaaS to third parties, such as enterprises and professional radio. \nThat enables providing elastic deployments of cost efficient network infrastructures.\nOne of the main concerns of ETSI NFV is to prove the feasibility of the cloud deployments of the typical network functions through proof of concept trials and prototypes as well as providing indications for further standardization in the areas of underlying infrastructures, software architectures, networking and management, and orchestration to improve performance and grant security of the overall infrastructure.\nETSI NFV limits itself to this level of indications, considering that other standardization bodies and de-facto open source standards should finalize the specific implementation work. \n\n\nGet in contact\n\n\n\n\nVia twitter: \ntwitter\n\n\nSubscribing to our mailing list: \nusers-at-openbaton-dot-org\n\n\nSending us an email to: \ninfo-at-openbaton-dot-org\n\n\n\n\nSupported by\n\n\nOpen Baton is a project developed by Fraunhofer FOKUS and TU Berlin. It is supported by different European publicly funded projects: \nNUBOMEDIA\n, \nMobile Cloud Networking\n, \nCogNet\n, \nSoftFIRE\n. Open Baton is one of the main components of the \n5G Berlin\n initiative.  \n\n\n\n\n\n\n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Get Started"
        }, 
        {
            "location": "/#open-baton", 
            "text": "Open Baton is an open source project providing a comprehensive implementation of the ETSI Management and Orchestration (MANO) specification.", 
            "title": "Open Baton"
        }, 
        {
            "location": "/#its-main-components", 
            "text": "Open Baton provides many different features and components:    A Network Function Virtualisation Orchestrator (NFVO) completely designed and implemented following the ETSI MANO specification. Read more  here  A generic Virtual Network Function Manager (VNFM) able to manage the lifecycle of VNFs based on their descriptors. Read more  here  A Juju VNFM Adapter in order to deploy Juju Charms or Open Baton VNF Packages using the Juju VNFM. Read more  here  A driver mechanism for adding and removing different type of VIMs without having to re-write anything in your orchestration logic. Read more  here  A powerful event engine useful based on a pub/sub mechanism for the dispatching of lifecycle events execution. Read more  here  An autoscaling engine which can be used for automatic runtime management of the scaling operation operations of your VNFs. Read more  here  A fault management system which can be used for automatic runtime management of faults which may occur at any level. Read more  here  It integrates with the Zabbix monitoring system. Read more  here  A set of libraries (the openbaton-libs) which could be used for building your own VNFM. Read more  here  A  Marketplace  useful for downloading VNFs compatible with the Open Baton NFVO and VNFMs. Read more at  here", 
            "title": "Its main components"
        }, 
        {
            "location": "/#can-i-plug-in-my-network-functions", 
            "text": "Yes, this is possible using (at least) two different approaches:   Integrating your own VNFM. In this case you can use either the REST interface, or the AMQP one for interoperating with the NFVO.  Implementing a set of scripts which can be executed as part of the lifecycle event of your Virtual Network Function Descriptor. We provide a generic VNFM and EMS which can be used for executing them.   Learn more  here .", 
            "title": "Can I plug in my Network Functions?"
        }, 
        {
            "location": "/#can-i-use-open-baton-to-build-my-own-network-service", 
            "text": "Yes! Open Baton provides a NFVO which can interoperate with VNFMs implemented by third parties. We provide also a set of tools (like the vnfm-sdk) which supports developers in building their own VNFM.   Learn more  here .", 
            "title": "Can I use Open Baton to build my own Network Service?"
        }, 
        {
            "location": "/#get-started", 
            "text": "In order to get started you can follow the  installation guide .", 
            "title": "Get started"
        }, 
        {
            "location": "/#learn-more", 
            "text": "Please refer to the \"Tutorials\" and \"Learn More\" sections for having more information about the Open Baton project. You can also learn more via our video tutorials published on the Open Baton  Youtube Channel .", 
            "title": "Learn more"
        }, 
        {
            "location": "/#what-is-nfv", 
            "text": "ETSI NFV represents a concerted telco operator initiative fostering the development of virtual network infrastructures by porting and further adapting network functions to the specific cloud environment. \nETSI NFV has defined a large set of virtualisation use cases, spanning from the cloudification of the main core network functions such as IMS, Evolved Packet Core, and Radio Access Networks, as well as providing on demand and complete virtualised infrastructures as IaaS or PaaS to third parties, such as enterprises and professional radio. \nThat enables providing elastic deployments of cost efficient network infrastructures.\nOne of the main concerns of ETSI NFV is to prove the feasibility of the cloud deployments of the typical network functions through proof of concept trials and prototypes as well as providing indications for further standardization in the areas of underlying infrastructures, software architectures, networking and management, and orchestration to improve performance and grant security of the overall infrastructure.\nETSI NFV limits itself to this level of indications, considering that other standardization bodies and de-facto open source standards should finalize the specific implementation work.", 
            "title": "What is NFV"
        }, 
        {
            "location": "/#get-in-contact", 
            "text": "Via twitter:  twitter  Subscribing to our mailing list:  users-at-openbaton-dot-org  Sending us an email to:  info-at-openbaton-dot-org", 
            "title": "Get in contact"
        }, 
        {
            "location": "/#supported-by", 
            "text": "Open Baton is a project developed by Fraunhofer FOKUS and TU Berlin. It is supported by different European publicly funded projects:  NUBOMEDIA ,  Mobile Cloud Networking ,  CogNet ,  SoftFIRE . Open Baton is one of the main components of the  5G Berlin  initiative.     \n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Supported by"
        }, 
        {
            "location": "/nfvo-installation/", 
            "text": "Install Open Baton\n\n\nOpen Baton provides several installation mechanisms. Open Baton has two different flavors: \n\n\n\n\nstandalone\n containing only the Open Baton NFV Orchestrator, the Open Baton Generic VNF Manager and the RabbitMQ. This version is the most suitable for getting started immediately with a development environment. \n\n\ncomplete\n containing all components as listed in the get started section. Some of the components can be either installed or not using the provided installers. This version is the most suitable for a production infrastructure. \n\n\n\n\nPlease select the most suitable installation tool for your needs: \n\n\n\n\nLinux OS\n: Direct installation of a standalone or complete Open Baton environment on top of a Linux OS (ubuntu/debian) using either the \nsource-code\n or \nbinary\n version. \n\n\nMac OS\n: Install the Open Baton NFVO on MacOS using the provided brew formula. More info \nhere\n\n\nDocker\n: Launching a pre-configured docker image containing a standalone Open Baton environment. More info \nhere\n\n\nVagrant\n: Launching a vagrant box using the provided 'Vagrantfile' containing a standalone Open Baton environment. More info \nhere\n\n\n\n\nOnce you have done with the installation, you can decide either to fine tune your environment configuring the different parameters as described in the \nconfiguration guide\n or to move forward and start with your first \nhello world tutorial\n.\n\n\n\n\n\n\n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Overview"
        }, 
        {
            "location": "/nfvo-installation/#install-open-baton", 
            "text": "Open Baton provides several installation mechanisms. Open Baton has two different flavors:    standalone  containing only the Open Baton NFV Orchestrator, the Open Baton Generic VNF Manager and the RabbitMQ. This version is the most suitable for getting started immediately with a development environment.   complete  containing all components as listed in the get started section. Some of the components can be either installed or not using the provided installers. This version is the most suitable for a production infrastructure.    Please select the most suitable installation tool for your needs:    Linux OS : Direct installation of a standalone or complete Open Baton environment on top of a Linux OS (ubuntu/debian) using either the  source-code  or  binary  version.   Mac OS : Install the Open Baton NFVO on MacOS using the provided brew formula. More info  here  Docker : Launching a pre-configured docker image containing a standalone Open Baton environment. More info  here  Vagrant : Launching a vagrant box using the provided 'Vagrantfile' containing a standalone Open Baton environment. More info  here   Once you have done with the installation, you can decide either to fine tune your environment configuring the different parameters as described in the  configuration guide  or to move forward and start with your first  hello world tutorial .   \n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Install Open Baton"
        }, 
        {
            "location": "/nfvo-installation-deb/", 
            "text": "Install Open Baton on Linux\n\n\nThis tutorial will guide towards the installation of an Open Baton environment using the stable binaries version. \n\n\nNOTE\n - Please refer to \nthis tutorial\n if you are willing to install a development environment where you can easily modify, compile and commit changes to the code base directly.\n\n\nThis version is composed by the following components: \n\n\n\n\nThe NFVO implemented in java using the \nspring.io\n framework. For more details about the NFVO architecture, you can refer to the next sections\n\n\nRabbitMQ\n as messaging system\n\n\nTest VIM Driver for being able to execute the \nhello world\n tutorial without needing an OpenStack instance. \n\n\n\n\nAnd a set of optional components: \n\n\n\n\nOpenStack VIM Driver for deploying VNFs on OpenStack\n\n\nGeneric VNFM for the instantiation of VNFs part of the Open Baton ecosystem \n\n\nFault Management System for the support to detection and recovery of VNF faults\n\n\nAuto Scaling Engine for the automatic creation and termination of VNF instances due to performance requirements\n\n\nNetwork Slicing Engine for \n\n\nMySQL\n as a mean to enable the persistence when using Open Baton\n\n\n\n\nRequirements\n\n\nTo facilitate the installation procedures we provide a bootstrap script which will install the desired components and configure them for running a \nhello world\n VNF out of the box. To execute the bootstrap procedure you need to have curl installed (see http://curl.haxx.se/). This command should work on any linux system: \n\n\napt-get install curl\n\n\n\n\nNOTE\n - We assume that you are performing the installation on top of a clean installation either of Ubuntu 14.04 or Debian Jessy. In other cases we suggest to install the components one by one. You can checkout the \nbootstrap\n repository and see the installation procedures which are executed by the bootstrap script. \n\n\nInstallation guide\n\n\nTo start the bootstrap procedure of the Open Baton environment you can type the following command:\n\n\nsh \n(curl -s http://get.openbaton.org/bootstrap) release\n\n\n\n\nIn case you are interested in the latest nigthly versions of the binaries please run:\n\n\nsh \n(curl -s http://get.openbaton.org/bootstrap) nightly\n\n\n\n\nVERY IMPORTANT NOTE\n - By default RabbitMQ is installed on the host of the NFVO. Be aware of the fact that during the installation you will be prompted for entering the RabbitMQ IP and Port. Please make sure that this IP can be\n  reached by external components (VMs, or host where will run other VNFMs) otherwise you will have runtime issues. If you are installing Open Baton on a VM running in OpenStack, the best is that you put here\n  the floating IP.\n\n\nDuring the bootstrap procedure you will be prompted for inputs. For instance you can choose to install or not the Generic VNFM as well as other additional components, or enable or not SSL. \n\n\nAt the end of the bootstrap procedure, if there are no errors, the dashboard should be reachable at: \nlocalhost:8080\n. \nDepending on which additional component you decided to add to the Open Baton installation then you should have a structure similar to the following:\n\n\n/usr/lib/openbaton\n\u251c\u2500\u2500 nfvo\n\u251c\u2500\u2500 vnfm/generic\n\u251c\u2500\u2500 fms\n\u251c\u2500\u2500 ase\n\u251c\u2500\u2500 nse\n\u251c\u2500\u2500 plugins\n\u2514\u2500\u2500 systemd\n\n\n\n\nWhere:\n\n\n\n\nnfvo\n contains the jar file of the Open Baton NFV Orchestrator (NFVO)\n\n\nvnfm/generic\n contains the jar file of the Open Baton Generic VNF Manager (VNFMG)\n\n\nfms\n contains the jar file related of Open Baton Fault Management System (FMS)\n\n\nase\n contains the jar file related of Open Baton Auto Scaling Engine (ASE)\n\n\nnse\n contains the jar file related of Open Baton Network Slicing Engine (NSE)\n\n\nplugins\n contains the plugins for Open Baton. By default the Test VIM Driver plugin is installed, therefore its jar file is stored in this directory. Additionally, if during the installation procedure you decide to install the OpenStack VIM-Driver Plugins then also its jar file will be stored in this directory\n\n\nsystemd\n contains the Open Baton configuration files for the system and service manager \"systemd\"\n\n\n\n\nAdditionally, still depending on which additional component you decided to add to the Open Baton installation, then you should also have the following structure:\n\n\n/usr/bin\n\u251c\u2500\u2500 openbaton-nfvo\n\u251c\u2500\u2500 openbaton-vnfm-generic\n\u251c\u2500\u2500 openbaton-fms\n\u251c\u2500\u2500 openbaton-ase\n\u2514\u2500\u2500 openbaton-nse\n\n\n\n\nWhere:\n\n\n\n\nopenbaton-nfvo\n is the Open Baton NFVO executable\n\n\nopenbaton-vnfm-generic\n is the Open Baton Generic VNFM executable\n\n\nopenbaton-fms\n is the Open Baton FMS executable\n\n\nopenbaton-ase\n is the Open Baton ASE executable\n\n\nopenbaton-nse\n is the Open Baton NSE executable\n\n\n\n\nAt this point Open Baton is ready to be used. Please refer to the \nIntroduction\n on how to start using it or step into the \nhello world\n tutorial immediately.\n\n\nStarting and stopping the NFVO\n\n\nAfter the installation procedure the NFVO is running as a service.\nIf you want to stop it, enter one of the following commands depending on your OS.\n\n\n\n\nWith Ubuntu 14.04:\n\n\n\n\nsudo service openbaton-nfvo stop\nsudo stop openbaton-nfvo\n\n\n\n\n\n\nWith Debian Jessie:\n\n\n\n\nsudo systemctl stop openbaton-nfvo.service\n\n\n\n\n\n\nTo start the NFVO (as a service), enter one of the following commands depending on your OS.\n\n\n\n\nWith Ubuntu 14.04:\n\n\n\n\nsudo service openbaton-nfvo start\nsudo start openbaton-nfvo\n\n\n\n\n\n\nWith Debian Jessie:\n\n\n\n\nsudo systemctl start openbaton-nfvo.service\n\n\n\n\n\n\nInstead, to start and stop the NFVO as a normal process, you can use the Open Baton executables in the '/usr/bin/' folder and type the following commands:\n\n\nsudo openbaton-nfvo start\nsudo openbaton-nfvo stop\n\n\n\n\nStarting and stopping the Generic VNFM (and the other additional components)\n\n\nIf you also installed the Generic VNFM it is also already running (as a service) at the end of the installation procedure. You can stop it with one of the following commands depending on your OS.\n\n\n\n\nWith Ubuntu 14.04:\n\n\n\n\nsudo service openbaton-vnfm-generic stop\nsudo stop openbaton-vnfm-generic\n\n\n\n\n\n\nWith Debian Jessie:\n\n\n\n\nsudo systemctl stop openbaton-vnfm-generic.service\n\n\n\n\n\n\nIf you also installed the Generic VNFM, then you can start it (as a service) with one of the following commands depending on your OS.\n\n\n\n\nWith Ubuntu 14.04:\n\n\n\n\nsudo service openbaton-vnfm-generic start\nsudo start openbaton-vnfm-generic\n\n\n\n\n\n\nWith Debian Jessie:\n\n\n\n\nsudo systemctl start openbaton-vnfm-generic.service\n\n\n\n\n\n\nInstead, to start and stop the Generic VNFM as a normal process, you can use the Open Baton executables in the '/usr/bin/' folder and type the following commands:\n\n\nsudo openbaton-vnfm-generic start\nsudo openbaton-vnfm-generic stop\n\n\n\n\n\n\nNOTE\n - For all the other additional components the commands above still apply just adapted to the specific component (e.g.: for the Fault Management System you can substitute the 'openbaton-vnfm-generic' with 'openbaton-fms', etc.)\n\n\nConfigure it\n\n\nFor specific configuration refer to the \nconfiguration\n\n\n\n\n\n\n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Install on Linux"
        }, 
        {
            "location": "/nfvo-installation-deb/#install-open-baton-on-linux", 
            "text": "This tutorial will guide towards the installation of an Open Baton environment using the stable binaries version.   NOTE  - Please refer to  this tutorial  if you are willing to install a development environment where you can easily modify, compile and commit changes to the code base directly.  This version is composed by the following components:    The NFVO implemented in java using the  spring.io  framework. For more details about the NFVO architecture, you can refer to the next sections  RabbitMQ  as messaging system  Test VIM Driver for being able to execute the  hello world  tutorial without needing an OpenStack instance.    And a set of optional components:    OpenStack VIM Driver for deploying VNFs on OpenStack  Generic VNFM for the instantiation of VNFs part of the Open Baton ecosystem   Fault Management System for the support to detection and recovery of VNF faults  Auto Scaling Engine for the automatic creation and termination of VNF instances due to performance requirements  Network Slicing Engine for   MySQL  as a mean to enable the persistence when using Open Baton", 
            "title": "Install Open Baton on Linux"
        }, 
        {
            "location": "/nfvo-installation-deb/#requirements", 
            "text": "To facilitate the installation procedures we provide a bootstrap script which will install the desired components and configure them for running a  hello world  VNF out of the box. To execute the bootstrap procedure you need to have curl installed (see http://curl.haxx.se/). This command should work on any linux system:   apt-get install curl  NOTE  - We assume that you are performing the installation on top of a clean installation either of Ubuntu 14.04 or Debian Jessy. In other cases we suggest to install the components one by one. You can checkout the  bootstrap  repository and see the installation procedures which are executed by the bootstrap script.", 
            "title": "Requirements"
        }, 
        {
            "location": "/nfvo-installation-deb/#installation-guide", 
            "text": "To start the bootstrap procedure of the Open Baton environment you can type the following command:  sh  (curl -s http://get.openbaton.org/bootstrap) release  In case you are interested in the latest nigthly versions of the binaries please run:  sh  (curl -s http://get.openbaton.org/bootstrap) nightly  VERY IMPORTANT NOTE  - By default RabbitMQ is installed on the host of the NFVO. Be aware of the fact that during the installation you will be prompted for entering the RabbitMQ IP and Port. Please make sure that this IP can be\n  reached by external components (VMs, or host where will run other VNFMs) otherwise you will have runtime issues. If you are installing Open Baton on a VM running in OpenStack, the best is that you put here\n  the floating IP.  During the bootstrap procedure you will be prompted for inputs. For instance you can choose to install or not the Generic VNFM as well as other additional components, or enable or not SSL.   At the end of the bootstrap procedure, if there are no errors, the dashboard should be reachable at:  localhost:8080 . \nDepending on which additional component you decided to add to the Open Baton installation then you should have a structure similar to the following:  /usr/lib/openbaton\n\u251c\u2500\u2500 nfvo\n\u251c\u2500\u2500 vnfm/generic\n\u251c\u2500\u2500 fms\n\u251c\u2500\u2500 ase\n\u251c\u2500\u2500 nse\n\u251c\u2500\u2500 plugins\n\u2514\u2500\u2500 systemd  Where:   nfvo  contains the jar file of the Open Baton NFV Orchestrator (NFVO)  vnfm/generic  contains the jar file of the Open Baton Generic VNF Manager (VNFMG)  fms  contains the jar file related of Open Baton Fault Management System (FMS)  ase  contains the jar file related of Open Baton Auto Scaling Engine (ASE)  nse  contains the jar file related of Open Baton Network Slicing Engine (NSE)  plugins  contains the plugins for Open Baton. By default the Test VIM Driver plugin is installed, therefore its jar file is stored in this directory. Additionally, if during the installation procedure you decide to install the OpenStack VIM-Driver Plugins then also its jar file will be stored in this directory  systemd  contains the Open Baton configuration files for the system and service manager \"systemd\"   Additionally, still depending on which additional component you decided to add to the Open Baton installation, then you should also have the following structure:  /usr/bin\n\u251c\u2500\u2500 openbaton-nfvo\n\u251c\u2500\u2500 openbaton-vnfm-generic\n\u251c\u2500\u2500 openbaton-fms\n\u251c\u2500\u2500 openbaton-ase\n\u2514\u2500\u2500 openbaton-nse  Where:   openbaton-nfvo  is the Open Baton NFVO executable  openbaton-vnfm-generic  is the Open Baton Generic VNFM executable  openbaton-fms  is the Open Baton FMS executable  openbaton-ase  is the Open Baton ASE executable  openbaton-nse  is the Open Baton NSE executable   At this point Open Baton is ready to be used. Please refer to the  Introduction  on how to start using it or step into the  hello world  tutorial immediately.", 
            "title": "Installation guide"
        }, 
        {
            "location": "/nfvo-installation-deb/#starting-and-stopping-the-nfvo", 
            "text": "After the installation procedure the NFVO is running as a service.\nIf you want to stop it, enter one of the following commands depending on your OS.   With Ubuntu 14.04:   sudo service openbaton-nfvo stop\nsudo stop openbaton-nfvo   With Debian Jessie:   sudo systemctl stop openbaton-nfvo.service   To start the NFVO (as a service), enter one of the following commands depending on your OS.   With Ubuntu 14.04:   sudo service openbaton-nfvo start\nsudo start openbaton-nfvo   With Debian Jessie:   sudo systemctl start openbaton-nfvo.service   Instead, to start and stop the NFVO as a normal process, you can use the Open Baton executables in the '/usr/bin/' folder and type the following commands:  sudo openbaton-nfvo start\nsudo openbaton-nfvo stop", 
            "title": "Starting and stopping the NFVO"
        }, 
        {
            "location": "/nfvo-installation-deb/#starting-and-stopping-the-generic-vnfm-and-the-other-additional-components", 
            "text": "If you also installed the Generic VNFM it is also already running (as a service) at the end of the installation procedure. You can stop it with one of the following commands depending on your OS.   With Ubuntu 14.04:   sudo service openbaton-vnfm-generic stop\nsudo stop openbaton-vnfm-generic   With Debian Jessie:   sudo systemctl stop openbaton-vnfm-generic.service   If you also installed the Generic VNFM, then you can start it (as a service) with one of the following commands depending on your OS.   With Ubuntu 14.04:   sudo service openbaton-vnfm-generic start\nsudo start openbaton-vnfm-generic   With Debian Jessie:   sudo systemctl start openbaton-vnfm-generic.service   Instead, to start and stop the Generic VNFM as a normal process, you can use the Open Baton executables in the '/usr/bin/' folder and type the following commands:  sudo openbaton-vnfm-generic start\nsudo openbaton-vnfm-generic stop   NOTE  - For all the other additional components the commands above still apply just adapted to the specific component (e.g.: for the Fault Management System you can substitute the 'openbaton-vnfm-generic' with 'openbaton-fms', etc.)", 
            "title": "Starting and stopping the Generic VNFM (and the other additional components)"
        }, 
        {
            "location": "/nfvo-installation-deb/#configure-it", 
            "text": "For specific configuration refer to the  configuration   \n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Configure it"
        }, 
        {
            "location": "/nfvo-installation-mac/", 
            "text": "Install Open Baton on MacOS using brew\n\n\nThis tutorial will guide you through the installation of the NFVO on top of MacOS.\n\n\nRequirements\n\n\n\n\nHomebrew\n installed and updated.  \n\n\nRabbitMQ\n installed, properly configured and started. Once RabbitMQ is installed, you can configure it with the following commands:\n\n\n\n\nrabbitmqctl add_user admin openbaton\nrabbitmqctl set_user_tags admin administrator\nrabbitmqctl set_permissions -p / admin \n.*\n \n.*\n \n.*\n\n\n\n\n\nInstall the NFVO\n\n\nIn order to install the NFVO you need to execute the following instructions: \n\n\nbrew install https://raw.githubusercontent.com/openbaton/NFVO/master/gradle/gradle/scripts/osx/openbaton-nfvo.rb\n\n\n\n\nThis command will install the NFVO via brew. How to configure, start and stop the NFVO once it is installed is shown in the next section.\n\n\nStart the NFVO\n\n\nAfter the installation is completed you can launch the NFVO: \n\n\nopenbaton-nfvo start\n\n\n\n\nAfter few seconds you can open the dashboard at: http://localhost:8080. How to use the dashboard is shown \nhere\n. Additonally, you can also use the \nCLI\n.\n\n\nConfigure the NFVO\n\n\nThe configuration file (openbaton.properties) is in the folder /usr/local/Cellar/openbaton. To configure the NFVO please refer to \nnfvo configuration\n.\n\n\nUninstall the NFVO\n\n\nYou can execute the following command for uninstalling the NFVO: \n\n\nbrew remove openbaton-nfvo\n\n\n\n\n\n\n\n\n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Install on MacOS"
        }, 
        {
            "location": "/nfvo-installation-mac/#install-open-baton-on-macos-using-brew", 
            "text": "This tutorial will guide you through the installation of the NFVO on top of MacOS.", 
            "title": "Install Open Baton on MacOS using brew"
        }, 
        {
            "location": "/nfvo-installation-mac/#requirements", 
            "text": "Homebrew  installed and updated.    RabbitMQ  installed, properly configured and started. Once RabbitMQ is installed, you can configure it with the following commands:   rabbitmqctl add_user admin openbaton\nrabbitmqctl set_user_tags admin administrator\nrabbitmqctl set_permissions -p / admin  .*   .*   .*", 
            "title": "Requirements"
        }, 
        {
            "location": "/nfvo-installation-mac/#install-the-nfvo", 
            "text": "In order to install the NFVO you need to execute the following instructions:   brew install https://raw.githubusercontent.com/openbaton/NFVO/master/gradle/gradle/scripts/osx/openbaton-nfvo.rb  This command will install the NFVO via brew. How to configure, start and stop the NFVO once it is installed is shown in the next section.", 
            "title": "Install the NFVO"
        }, 
        {
            "location": "/nfvo-installation-mac/#start-the-nfvo", 
            "text": "After the installation is completed you can launch the NFVO:   openbaton-nfvo start  After few seconds you can open the dashboard at: http://localhost:8080. How to use the dashboard is shown  here . Additonally, you can also use the  CLI .", 
            "title": "Start the NFVO"
        }, 
        {
            "location": "/nfvo-installation-mac/#configure-the-nfvo", 
            "text": "The configuration file (openbaton.properties) is in the folder /usr/local/Cellar/openbaton. To configure the NFVO please refer to  nfvo configuration .", 
            "title": "Configure the NFVO"
        }, 
        {
            "location": "/nfvo-installation-mac/#uninstall-the-nfvo", 
            "text": "You can execute the following command for uninstalling the NFVO:   brew remove openbaton-nfvo   \n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Uninstall the NFVO"
        }, 
        {
            "location": "/nfvo-installation-docker/", 
            "text": "Install Open Baton using Docker\n\n\nThis tutorial will guide towards the installation of a standalone Open Baton environment composed by the following components: \n\n\n\n\nThe NFVO implemented in java using the \nspring.io\n framework. For more details about the NFVO architecture, you can refer to the next sections\n\n\nRabbitMQ\n as messaging system\n\n\nTest VIM Driver for being able to execute the \nhello world\n tutorial without needing an OpenStack instance \n\n\nOpenStack VIM Driver for deploying VNFs on OpenStack\n\n\nGeneric VNFM for the instantiation of VNFs part of the Open Baton ecosystem \n\n\n\n\nTo have a running standalone Open Baton Docker container type the following commands:\n\n\nsudo docker pull openbaton/standalone\nsudo docker run --name openbaton -d -h openbaton-rabbitmq -p 8080:8080 -p 5672:5672 -p 15672:15672 -p 8443:8443 -e RABBITMQ_BROKERIP=\nRabbitMQ IP\n openbaton/standalone\n\n\n\n\nVERY IMPORTANT NOTE\n - You should put as input for the RABBITMQ_BROKERIP the RabbitMQ IP making sure that this IP can be\n  reached by external components (VMs, or host where will run other VNFMs) otherwise you will have runtime issues. \n  In particular, you should select the external IP of your host on top of which the docker container is running\n\n\nNOTE\n - With the command above you will run the latest Open Baton version. You can see all the standalone Open Baton Docker images available from \nthis\n list.\n\n\nAfter running the container you should see as output an alphanumeric string (which represents the full ID of the Open Baton container running) similar to the following:\n\n\ncfc4a7fb23d02c47e25b447d30f6fe7c0464355a16ee1b02d84657f6fba88e07\n\n\n\n\nTo verify that the container is running you can type the following command:\n\n\nsudo docker ps -a\n\n\n\n\nwhich output should be similar to the following:\n\n\nCONTAINER ID        IMAGE                        COMMAND                  CREATED             STATUS                   PORTS                                                                                              NAMES\ncfc4a7fb23d0        openbaton/standalone:latest  \n/usr/bin/supervisord\n   49 seconds ago      Up 49 seconds            0.0.0.0:5672-\n5672/tcp, 0.0.0.0:8080-\n8080/tcp, 0.0.0.0:8443-\n8443/tcp, 0.0.0.0:15672-\n15672/tcp   admiring_lalande\n\n\n\n\nTo connect to the running container containing Open Baton you can type the following command:\n\n\nsudo docker exec -ti openbaton bash\n\n\n\n\nAfter few minutes the Open Baton NFVO should be started, then you can open a browser and go on localhost:8080.\nTo log in, the default credentials for the administrator user are:\n\n\nuser: admin\npassword: openbaton \n\n\n\n\nTo stop and delete the running Open Baton container you can type respectively the following commands:\n\n\nsudo docker stop openbaton\nsudo docker rm openbaton\n\n\n\n\n\n\n\n\n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Install with Docker"
        }, 
        {
            "location": "/nfvo-installation-docker/#install-open-baton-using-docker", 
            "text": "This tutorial will guide towards the installation of a standalone Open Baton environment composed by the following components:    The NFVO implemented in java using the  spring.io  framework. For more details about the NFVO architecture, you can refer to the next sections  RabbitMQ  as messaging system  Test VIM Driver for being able to execute the  hello world  tutorial without needing an OpenStack instance   OpenStack VIM Driver for deploying VNFs on OpenStack  Generic VNFM for the instantiation of VNFs part of the Open Baton ecosystem    To have a running standalone Open Baton Docker container type the following commands:  sudo docker pull openbaton/standalone\nsudo docker run --name openbaton -d -h openbaton-rabbitmq -p 8080:8080 -p 5672:5672 -p 15672:15672 -p 8443:8443 -e RABBITMQ_BROKERIP= RabbitMQ IP  openbaton/standalone  VERY IMPORTANT NOTE  - You should put as input for the RABBITMQ_BROKERIP the RabbitMQ IP making sure that this IP can be\n  reached by external components (VMs, or host where will run other VNFMs) otherwise you will have runtime issues. \n  In particular, you should select the external IP of your host on top of which the docker container is running  NOTE  - With the command above you will run the latest Open Baton version. You can see all the standalone Open Baton Docker images available from  this  list.  After running the container you should see as output an alphanumeric string (which represents the full ID of the Open Baton container running) similar to the following:  cfc4a7fb23d02c47e25b447d30f6fe7c0464355a16ee1b02d84657f6fba88e07  To verify that the container is running you can type the following command:  sudo docker ps -a  which output should be similar to the following:  CONTAINER ID        IMAGE                        COMMAND                  CREATED             STATUS                   PORTS                                                                                              NAMES\ncfc4a7fb23d0        openbaton/standalone:latest   /usr/bin/supervisord    49 seconds ago      Up 49 seconds            0.0.0.0:5672- 5672/tcp, 0.0.0.0:8080- 8080/tcp, 0.0.0.0:8443- 8443/tcp, 0.0.0.0:15672- 15672/tcp   admiring_lalande  To connect to the running container containing Open Baton you can type the following command:  sudo docker exec -ti openbaton bash  After few minutes the Open Baton NFVO should be started, then you can open a browser and go on localhost:8080.\nTo log in, the default credentials for the administrator user are:  user: admin\npassword: openbaton   To stop and delete the running Open Baton container you can type respectively the following commands:  sudo docker stop openbaton\nsudo docker rm openbaton   \n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Install Open Baton using Docker"
        }, 
        {
            "location": "/nfvo-installation-vagrant/", 
            "text": "Install Open Baton using Vagrant\n\n\nThis tutorial will guide towards the installation of a minimal Open Baton environment composed by the following components: \n\n\n\n\nThe NFVO implemented in java using the \nspring.io\n framework. For more details about the NFVO architecture, you can refer to the next sections\n\n\nRabbitMQ\n as messaging system\n\n\nTest VIM Driver for being able to execute the \nhello world\n tutorial without needing an OpenStack instance \n\n\nOpenStack VIM Driver for deploying VNFs on OpenStack\n\n\nGeneric VNFM for the instantiation of VNFs part of the Open Baton ecosystem\n\n\n\n\nRequirements\n\n\nYou need to have Vagrant installed. \n\n\nInstallation guide\n\n\nIf you already have Vagrant installed in your system, you can install the latest Open Baton version by using this \nVagrantfile\n and simply typing the following command:\n\n\nvagrant up\n\n\n\n\nAfter the starting of the vagrant box has finished, you can open a browser and go on \nlocalhost:8080\n. To log in, the default credentials for the administrator user are:\n\n\nuser: admin\npassword: openbaton\n\n\n\n\n\n\n\n\n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Install with Vagrant"
        }, 
        {
            "location": "/nfvo-installation-vagrant/#install-open-baton-using-vagrant", 
            "text": "This tutorial will guide towards the installation of a minimal Open Baton environment composed by the following components:    The NFVO implemented in java using the  spring.io  framework. For more details about the NFVO architecture, you can refer to the next sections  RabbitMQ  as messaging system  Test VIM Driver for being able to execute the  hello world  tutorial without needing an OpenStack instance   OpenStack VIM Driver for deploying VNFs on OpenStack  Generic VNFM for the instantiation of VNFs part of the Open Baton ecosystem", 
            "title": "Install Open Baton using Vagrant"
        }, 
        {
            "location": "/nfvo-installation-vagrant/#requirements", 
            "text": "You need to have Vagrant installed.", 
            "title": "Requirements"
        }, 
        {
            "location": "/nfvo-installation-vagrant/#installation-guide", 
            "text": "If you already have Vagrant installed in your system, you can install the latest Open Baton version by using this  Vagrantfile  and simply typing the following command:  vagrant up  After the starting of the vagrant box has finished, you can open a browser and go on  localhost:8080 . To log in, the default credentials for the administrator user are:  user: admin\npassword: openbaton   \n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Installation guide"
        }, 
        {
            "location": "/nfvo-configuration/", 
            "text": "How to configure the NFVO\n\n\nThis guide explains you how to configure the NFVO after installation is completed. In general, after using the bootsrap procedure no changes described here are required unless you want to tune up your installation. \nIn addition to this, you may need to modify also the configuration paramenters of the \nGeneric VNFM\n\n\nNFVO properties overview\n\n\nAfter the bootstrap procedure the NFVO's configuration file is located at: \n\n\n/etc/openbaton/openbaton-nfvo.properties\n\n\n\n\nThis is a property file that is used to configure the \nSpring\n environment and the \nNFVO\n. Since the component is based on the Spring framework some parameters are inherited, for a deeper explanation on all the parameters meaning, please refer to the \nSpring documentation\n. \n\n\nKeep in mind that whenever some of the parameters below referred are changed, you will need to restart the NFVO.\n\n\nModify NFVO General properties\n\n\nIMPORTANT NOTES:\n\n\nBy default RabbitMQ is installed on the host of the NFVO. Be aware of the fact that if you want any of your additional external components to be executed on a different host, you will need RabbitMQ to be reachable also from the outside.  \n\n\nIn general, also the NFVO can be executed on a different host changing the following properties of the \n/etc/openbaton/openbaton.properties\n file:\n\n\nnfvo.rabbit.brokerIp = localhost \n\n\n\n\nto:\n\n\nnfvo.rabbit.brokerIp = \nthe rabbitmq broker ip\n\n\n\n\n\nadditional rabbitMQ paramters required by the NFVO\n\n\nnfvo.rabbit.management.port=15672\n# Set the queues to be autodeleted after the shut down\nnfvo.rabbitmq.autodelete=true\nnfvo.rabbitmq.durable=true\nnfvo.rabbitmq.exclusive=false\n\n\n\n\nparameters related with NFVO behaviour runtime\n\n\nThis property allows the user to delete the Network Service Records no matter in which status they are. Please note that in any case it is possible to remove a Network Service Record in \nNULL\n state.\n\n\n# nfvo behaviour\nnfvo.delete.all-status = true\n# if true, after deleting a NSR, the nfvo will wait for \nnfvo.delete.vnfr.wait.timeout\n after that timeout the VMs and VNFR will be deleted anyway from the NFVO\nnfvo.delete.vnfr.wait.timeout=60\nnfvo.delete.vnfr.wait=false\nnfvo.delete.wait=false\n\nnfvo.history.clear=false\nnfvo.history.level=1\nnfvo.history.max-entities=250\n\n\n\n\ninitial admin password\n\n\nThe initial admin password is set via the configuration file property: \n\n\nnfvo.security.admin.password=openbaton\n#nfvo.security.guest.password=guest\n\n\n\n\nPlease bare in mind that if the property is modified via APIs/dashboard, the change won't be reflected in this file. \n\n\nparameters related with the monitoring system\n\n\nMONITORING:\n Open Baton allows the monitoring of the VMs on top of which the VNFs are executing via an external monitoring system. At the moment Zabbix is the monitoring system supported.\nIf you want to enable it, you need first to install and configure Zabbix server following the guide at this page \nZabbix server configuration\n.\nOnce the Zabbix server is correctly configured and running, you only need to add following property:\n\n\nnfvo.monitoring.ip = the Zabbix server ip\n\n\n\n\nEvery time a new Network Service is instantiated, each VNFC (VM) is automatically registered to the Zabbix server.\n\n\nparameters related with the marketplace\n\n\nThis parameter allow you to modify the marketplace IP, in case you want to use a different catalogue for providing VNF Packages. \n\n\n#nfvo.marketplace.privateip=\nnfvo.marketplace.ip=marketplace.openbaton.org\nnfvo.marketplace.port=8082\n\n\n\n\nparameters related with plugins and drivers\n\n\nThe following properties are related to the plugin mechanism used for loading VIM and Monitoring instances. \n\n\n# Setting the number of plugin active consumers\nnfvo.plugin.active.consumers=10\nnfvo.plugin.install=true\n# directory for the vim driver plugins\nnfvo.plugin.installation-dir=./plugins\nnfvo.plugin.log.path=./plugin-logs\nnfvo.plugin.wait=true\n# timeout for plugin operations\nnfvo.plugin.timeout=300000\n\n\n\n\nwhere the \nnfvo.plugin.installation-dir\n is the directory where all the jar files are, which implement the VIM interface (see the \nVIM driver documentation\n), and which will be automatically started by the NFVO after booting. \nWhile the \nnfvo.plugin.log.path\n defines the location where plugin log files will be available. \n\n\nparameters related with quota management\n\n\nModify this parameter in case you want to disable checking quota while deploying your network services. Be aware that the NFVO will request the VIM its quota, so if quota is not properly set on the NFVI, you may have some issues with this. In case of any exceptions which come with some certain scenarios, you can also avoid failing on exceptions by changing the \nnfvo.quota.check.failOnException\n to \nfalse\n.\n\n\n# Avoid doing the GRANT_OPERATION\nnfvo.quota.check=true\n# Avoid failing if unpredictable exceptions are thrown.\nnfvo.quota.check.failOnException = true\n\n\n\n\nPlease consider also the property \nnfvo.vim.drivers.allowInfiniteQuota\n explained in the next section for the quota maangement during the allocate resources mechanism\n\n\naddition parameters for the NFVO and VNFM tuning\n\n\n# Execute the start event sequentially and in order based on the VNFDependencies. This implies the NSD not to have cycling dependencies\nnfvo.start.ordered=false\n# It can be used for enabling/disabling an active check to the VIM authentication URL \nnfvo.vim.active.check=true\n# Allow infinite quotas during the GRANT_OPERATION\nnfvo.vim.drivers.allowInfiniteQuota=false\nnfvo.vim.delete.check.vnfr=true\n\n\n\n\nThose properties are needed in case you want to tune a bit the performances of the NFVO. When the VNFMs send a message to the NFVO, there is a pool of threads able to process these messages in parallel. These parameters allows you to change the pool configuration, for more details please check the \nspring documentation regarding thread pool executor\n. \n\n\n# Thread pool executor configuration\n# for info see http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/scheduling/concurrent/ThreadPoolTaskExecutor.html\nnfvo.vmanager.executor.corepoolsize = 20\nnfvo.vmanager.executor.maxpoolsize = 30\nnfvo.vmanager.executor.queuecapacity = 500\nnfvo.vmanager.executor.keepalive = 30\n# if true, deleting the nsd will remove also its vnfd\nnfvo.vnfd.cascade.delete=false\n# if true, deleting the vnfd will remove also its vnfpackage\nvnfd.vnfp.cascade.delete=true\n\n\n\n\nenable SSL\n\n\nBy default SSL is disabled. Comment out those parameters in case you want to enable it. \n\n\n#server.port=8443\n#server.ssl.enabled=true\n#server.ssl.key-store=/etc/openbaton/keystore.p12\n#server.ssl.key-store-password=password\n#server.ssl.keyAlias=tomcat\n#server.ssl.keyStoreType=PKCS12\n#nfvo.https=false\n\n\n\n\nModify logging levels\n\n\nFeel free to modify that file for adding or removing specific functionalities.  For instance, you can decide to change logging levels (TRACE, DEBUG, INFO, WARN, and ERROR) and mechanisms:\n\n\n#########################################\n########## Logging properties ###########\n#########################################\n\nlogging.level.org.springframework=WARN\n#logging.level.org.springframework.security=DEBUG\n#logging.level.org.springframework.web=DEBUG\nlogging.level.org.hibernate=WARN\nlogging.level.org.apache=WARN\n\n# Level for loggers on classes inside the root package \norg.project.openbaton\n (and its sub-packages)\nlogging.level.org.openbaton=INFO\n\n# Direct log to a log file\nlogging.file=/var/log/openbaton.log\n\n\n\n\nModidy DB properties\n\n\nDepending on the installation mode you selected, it may be that you have an in-memory database. In order to reconfigure the NFVO to use a persistent database, like MySQL, you need to change the properties as shown below:\n\n\n#########################################\n############# DB properties #############\n#########################################\n\nspring.datasource.username=admin\nspring.datasource.password=changeme\n\n# JDBC configurations' values for HSQL:\n#       jdbc:hsqldb:file:/tmp/openbaton/openbaton.hsdb\n#       org.hsqldb.jdbc.JDBCDriver\n#       org.hibernate.dialect.HSQLDialect\n# JDBC configurations' values for MYSQL:\n#       jdbc:mysql://localhost:3306/openbaton\n#       com.mysql.jdbc.Driver\n#       org.hibernate.dialect.MySQLDialect\n#\n# Active configurations by default MySQL: \nspring.datasource.url=jdbc:mysql://localhost:3306/openbaton\nspring.datasource.driver-class-name=com.mysql.jdbc.Driver\nspring.jpa.database-platform=org.hibernate.dialect.MySQLDialect\nspring.jpa.show-sql=false\n# ddl-auto available values: create-drop, update\nspring.jpa.hibernate.ddl-auto=update\n\n# MYSQL configuration (enable it in order to avoid timeout exceptions)\nspring.datasource.validationQuery=SELECT 1\nspring.datasource.testOnBorrow=true\n\n\n\n\nWhere:\n\n \nspring.datasource.username\n and \nspring.datasource.password\n need to be adapted to the mysql username and password.\n\n \nspring.jpa.hibernate.ddl-auto\n has to be set to \nupdate\n if you want the NFVO \nnot\n to drop all the tables after being shut down and to make it reuse the same tables after restarting.\n\n\nFor more details please see the \nSpring Documentation\n regarding the configuration parameters.\n\n\nModify RabbitMQ parameters\n\n\nThese are additional parameters about the configuration of Rabbit MQ:\n\n\n#########################################\n############## RabbitMQ #################\n#########################################\n\n# Comma-separated list of addresses to which the client should connect to.\n#spring.rabbitmq.addresses=${nfvo.rabbit.brokerIp}\n# Create an AmqpAdmin bean.\nspring.rabbitmq.dynamic=true\n# RabbitMQ host.\nspring.rabbitmq.host=${nfvo.rabbit.brokerIp}\n# Acknowledge mode of container.\n#spring.rabbitmq.listener.acknowledge-mode=\n# Start the container automatically on startup.\n#spring.rabbitmq.listener.auto-startup=true\n# Minimum number of consumers.\nspring.rabbitmq.listener.concurrency=5\n# Maximum number of consumers.\nspring.rabbitmq.listener.max-concurrency=30\n# Number of messages to be handled in a single request. It should be greater than or equal to the transaction size (if used).\n#spring.rabbitmq.listener.prefetch=\n# Number of messages to be processed in a transaction. For best results it should be less than or equal to the prefetch count.\n#spring.rabbitmq.listener.transaction-size=\n# Login user to authenticate to the broker.\nspring.rabbitmq.username=admin\n# Login to authenticate against the broker.\nspring.rabbitmq.password=openbaton\n# RabbitMQ managementPort.\nspring.rabbitmq.port=5672\n# Requested heartbeat timeout, in seconds; zero for none.\nspring.rabbitmq.requested-heartbeat=60\n# Enable SSL support.\n#spring.rabbitmq.ssl.enabled=false\n# Path to the key store that holds the SSL certificate.\n#spring.rabbitmq.ssl.key-store=\n# Password used to access the key store.\n#spring.rabbitmq.ssl.key-store-password=\n# Trust store that holds SSL certificates.\n#spring.rabbitmq.ssl.trust-store=\n# Password used to access the trust store.\n#spring.rabbitmq.ssl.trust-store-password=\n# Virtual host to use when connecting to the broker.\n#spring.rabbitmq.virtual-host=", 
            "title": "Configure it"
        }, 
        {
            "location": "/nfvo-configuration/#how-to-configure-the-nfvo", 
            "text": "This guide explains you how to configure the NFVO after installation is completed. In general, after using the bootsrap procedure no changes described here are required unless you want to tune up your installation. \nIn addition to this, you may need to modify also the configuration paramenters of the  Generic VNFM", 
            "title": "How to configure the NFVO"
        }, 
        {
            "location": "/nfvo-configuration/#nfvo-properties-overview", 
            "text": "After the bootstrap procedure the NFVO's configuration file is located at:   /etc/openbaton/openbaton-nfvo.properties  This is a property file that is used to configure the  Spring  environment and the  NFVO . Since the component is based on the Spring framework some parameters are inherited, for a deeper explanation on all the parameters meaning, please refer to the  Spring documentation .   Keep in mind that whenever some of the parameters below referred are changed, you will need to restart the NFVO.", 
            "title": "NFVO properties overview"
        }, 
        {
            "location": "/nfvo-configuration/#modify-nfvo-general-properties", 
            "text": "IMPORTANT NOTES:  By default RabbitMQ is installed on the host of the NFVO. Be aware of the fact that if you want any of your additional external components to be executed on a different host, you will need RabbitMQ to be reachable also from the outside.    In general, also the NFVO can be executed on a different host changing the following properties of the  /etc/openbaton/openbaton.properties  file:  nfvo.rabbit.brokerIp = localhost   to:  nfvo.rabbit.brokerIp =  the rabbitmq broker ip", 
            "title": "Modify NFVO General properties"
        }, 
        {
            "location": "/nfvo-configuration/#additional-rabbitmq-paramters-required-by-the-nfvo", 
            "text": "nfvo.rabbit.management.port=15672\n# Set the queues to be autodeleted after the shut down\nnfvo.rabbitmq.autodelete=true\nnfvo.rabbitmq.durable=true\nnfvo.rabbitmq.exclusive=false", 
            "title": "additional rabbitMQ paramters required by the NFVO"
        }, 
        {
            "location": "/nfvo-configuration/#parameters-related-with-nfvo-behaviour-runtime", 
            "text": "This property allows the user to delete the Network Service Records no matter in which status they are. Please note that in any case it is possible to remove a Network Service Record in  NULL  state.  # nfvo behaviour\nnfvo.delete.all-status = true\n# if true, after deleting a NSR, the nfvo will wait for  nfvo.delete.vnfr.wait.timeout  after that timeout the VMs and VNFR will be deleted anyway from the NFVO\nnfvo.delete.vnfr.wait.timeout=60\nnfvo.delete.vnfr.wait=false\nnfvo.delete.wait=false\n\nnfvo.history.clear=false\nnfvo.history.level=1\nnfvo.history.max-entities=250", 
            "title": "parameters related with NFVO behaviour runtime"
        }, 
        {
            "location": "/nfvo-configuration/#initial-admin-password", 
            "text": "The initial admin password is set via the configuration file property:   nfvo.security.admin.password=openbaton\n#nfvo.security.guest.password=guest  Please bare in mind that if the property is modified via APIs/dashboard, the change won't be reflected in this file.", 
            "title": "initial admin password"
        }, 
        {
            "location": "/nfvo-configuration/#parameters-related-with-the-monitoring-system", 
            "text": "MONITORING:  Open Baton allows the monitoring of the VMs on top of which the VNFs are executing via an external monitoring system. At the moment Zabbix is the monitoring system supported.\nIf you want to enable it, you need first to install and configure Zabbix server following the guide at this page  Zabbix server configuration .\nOnce the Zabbix server is correctly configured and running, you only need to add following property:  nfvo.monitoring.ip = the Zabbix server ip  Every time a new Network Service is instantiated, each VNFC (VM) is automatically registered to the Zabbix server.", 
            "title": "parameters related with the monitoring system"
        }, 
        {
            "location": "/nfvo-configuration/#parameters-related-with-the-marketplace", 
            "text": "This parameter allow you to modify the marketplace IP, in case you want to use a different catalogue for providing VNF Packages.   #nfvo.marketplace.privateip=\nnfvo.marketplace.ip=marketplace.openbaton.org\nnfvo.marketplace.port=8082", 
            "title": "parameters related with the marketplace"
        }, 
        {
            "location": "/nfvo-configuration/#parameters-related-with-plugins-and-drivers", 
            "text": "The following properties are related to the plugin mechanism used for loading VIM and Monitoring instances.   # Setting the number of plugin active consumers\nnfvo.plugin.active.consumers=10\nnfvo.plugin.install=true\n# directory for the vim driver plugins\nnfvo.plugin.installation-dir=./plugins\nnfvo.plugin.log.path=./plugin-logs\nnfvo.plugin.wait=true\n# timeout for plugin operations\nnfvo.plugin.timeout=300000  where the  nfvo.plugin.installation-dir  is the directory where all the jar files are, which implement the VIM interface (see the  VIM driver documentation ), and which will be automatically started by the NFVO after booting. \nWhile the  nfvo.plugin.log.path  defines the location where plugin log files will be available.", 
            "title": "parameters related with plugins and drivers"
        }, 
        {
            "location": "/nfvo-configuration/#parameters-related-with-quota-management", 
            "text": "Modify this parameter in case you want to disable checking quota while deploying your network services. Be aware that the NFVO will request the VIM its quota, so if quota is not properly set on the NFVI, you may have some issues with this. In case of any exceptions which come with some certain scenarios, you can also avoid failing on exceptions by changing the  nfvo.quota.check.failOnException  to  false .  # Avoid doing the GRANT_OPERATION\nnfvo.quota.check=true\n# Avoid failing if unpredictable exceptions are thrown.\nnfvo.quota.check.failOnException = true  Please consider also the property  nfvo.vim.drivers.allowInfiniteQuota  explained in the next section for the quota maangement during the allocate resources mechanism", 
            "title": "parameters related with quota management"
        }, 
        {
            "location": "/nfvo-configuration/#addition-parameters-for-the-nfvo-and-vnfm-tuning", 
            "text": "# Execute the start event sequentially and in order based on the VNFDependencies. This implies the NSD not to have cycling dependencies\nnfvo.start.ordered=false\n# It can be used for enabling/disabling an active check to the VIM authentication URL \nnfvo.vim.active.check=true\n# Allow infinite quotas during the GRANT_OPERATION\nnfvo.vim.drivers.allowInfiniteQuota=false\nnfvo.vim.delete.check.vnfr=true  Those properties are needed in case you want to tune a bit the performances of the NFVO. When the VNFMs send a message to the NFVO, there is a pool of threads able to process these messages in parallel. These parameters allows you to change the pool configuration, for more details please check the  spring documentation regarding thread pool executor .   # Thread pool executor configuration\n# for info see http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/scheduling/concurrent/ThreadPoolTaskExecutor.html\nnfvo.vmanager.executor.corepoolsize = 20\nnfvo.vmanager.executor.maxpoolsize = 30\nnfvo.vmanager.executor.queuecapacity = 500\nnfvo.vmanager.executor.keepalive = 30\n# if true, deleting the nsd will remove also its vnfd\nnfvo.vnfd.cascade.delete=false\n# if true, deleting the vnfd will remove also its vnfpackage\nvnfd.vnfp.cascade.delete=true", 
            "title": "addition parameters for the NFVO and VNFM tuning"
        }, 
        {
            "location": "/nfvo-configuration/#enable-ssl", 
            "text": "By default SSL is disabled. Comment out those parameters in case you want to enable it.   #server.port=8443\n#server.ssl.enabled=true\n#server.ssl.key-store=/etc/openbaton/keystore.p12\n#server.ssl.key-store-password=password\n#server.ssl.keyAlias=tomcat\n#server.ssl.keyStoreType=PKCS12\n#nfvo.https=false", 
            "title": "enable SSL"
        }, 
        {
            "location": "/nfvo-configuration/#modify-logging-levels", 
            "text": "Feel free to modify that file for adding or removing specific functionalities.  For instance, you can decide to change logging levels (TRACE, DEBUG, INFO, WARN, and ERROR) and mechanisms:  #########################################\n########## Logging properties ###########\n#########################################\n\nlogging.level.org.springframework=WARN\n#logging.level.org.springframework.security=DEBUG\n#logging.level.org.springframework.web=DEBUG\nlogging.level.org.hibernate=WARN\nlogging.level.org.apache=WARN\n\n# Level for loggers on classes inside the root package  org.project.openbaton  (and its sub-packages)\nlogging.level.org.openbaton=INFO\n\n# Direct log to a log file\nlogging.file=/var/log/openbaton.log", 
            "title": "Modify logging levels"
        }, 
        {
            "location": "/nfvo-configuration/#modidy-db-properties", 
            "text": "Depending on the installation mode you selected, it may be that you have an in-memory database. In order to reconfigure the NFVO to use a persistent database, like MySQL, you need to change the properties as shown below:  #########################################\n############# DB properties #############\n#########################################\n\nspring.datasource.username=admin\nspring.datasource.password=changeme\n\n# JDBC configurations' values for HSQL:\n#       jdbc:hsqldb:file:/tmp/openbaton/openbaton.hsdb\n#       org.hsqldb.jdbc.JDBCDriver\n#       org.hibernate.dialect.HSQLDialect\n# JDBC configurations' values for MYSQL:\n#       jdbc:mysql://localhost:3306/openbaton\n#       com.mysql.jdbc.Driver\n#       org.hibernate.dialect.MySQLDialect\n#\n# Active configurations by default MySQL: \nspring.datasource.url=jdbc:mysql://localhost:3306/openbaton\nspring.datasource.driver-class-name=com.mysql.jdbc.Driver\nspring.jpa.database-platform=org.hibernate.dialect.MySQLDialect\nspring.jpa.show-sql=false\n# ddl-auto available values: create-drop, update\nspring.jpa.hibernate.ddl-auto=update\n\n# MYSQL configuration (enable it in order to avoid timeout exceptions)\nspring.datasource.validationQuery=SELECT 1\nspring.datasource.testOnBorrow=true  Where:   spring.datasource.username  and  spring.datasource.password  need to be adapted to the mysql username and password.   spring.jpa.hibernate.ddl-auto  has to be set to  update  if you want the NFVO  not  to drop all the tables after being shut down and to make it reuse the same tables after restarting.  For more details please see the  Spring Documentation  regarding the configuration parameters.", 
            "title": "Modidy DB properties"
        }, 
        {
            "location": "/nfvo-configuration/#modify-rabbitmq-parameters", 
            "text": "These are additional parameters about the configuration of Rabbit MQ:  #########################################\n############## RabbitMQ #################\n#########################################\n\n# Comma-separated list of addresses to which the client should connect to.\n#spring.rabbitmq.addresses=${nfvo.rabbit.brokerIp}\n# Create an AmqpAdmin bean.\nspring.rabbitmq.dynamic=true\n# RabbitMQ host.\nspring.rabbitmq.host=${nfvo.rabbit.brokerIp}\n# Acknowledge mode of container.\n#spring.rabbitmq.listener.acknowledge-mode=\n# Start the container automatically on startup.\n#spring.rabbitmq.listener.auto-startup=true\n# Minimum number of consumers.\nspring.rabbitmq.listener.concurrency=5\n# Maximum number of consumers.\nspring.rabbitmq.listener.max-concurrency=30\n# Number of messages to be handled in a single request. It should be greater than or equal to the transaction size (if used).\n#spring.rabbitmq.listener.prefetch=\n# Number of messages to be processed in a transaction. For best results it should be less than or equal to the prefetch count.\n#spring.rabbitmq.listener.transaction-size=\n# Login user to authenticate to the broker.\nspring.rabbitmq.username=admin\n# Login to authenticate against the broker.\nspring.rabbitmq.password=openbaton\n# RabbitMQ managementPort.\nspring.rabbitmq.port=5672\n# Requested heartbeat timeout, in seconds; zero for none.\nspring.rabbitmq.requested-heartbeat=60\n# Enable SSL support.\n#spring.rabbitmq.ssl.enabled=false\n# Path to the key store that holds the SSL certificate.\n#spring.rabbitmq.ssl.key-store=\n# Password used to access the key store.\n#spring.rabbitmq.ssl.key-store-password=\n# Trust store that holds SSL certificates.\n#spring.rabbitmq.ssl.trust-store=\n# Password used to access the trust store.\n#spring.rabbitmq.ssl.trust-store-password=\n# Virtual host to use when connecting to the broker.\n#spring.rabbitmq.virtual-host=", 
            "title": "Modify RabbitMQ parameters"
        }, 
        {
            "location": "/use/", 
            "text": "How to use OpenBaton\n\n\nAfter completing the installation, you should be able to reach the dashboard of the NFVO at the following url: http://your-ip-here:8080\n\n\nWhen accessing the dashboard, you will be prompted for a username and password. The first access can only be done with the super user (\"admin\") created during the installation process. Please refer to the \nIdentity Management\n section for more information about security mechanisms. \nPlease refer to the following documentation for learning how to use the \nOpen Baton dashboard\n or the \nCommand Line Interface\n\n\nIn order to use Open Baton for launching your first Network Service, you will need to follow these steps:\n\n\n\n\nInstall a VIM driver. \nLearn more here\n\n\nRegister one or more Point of Presences (PoPs). \nLearn more here\n\n\nInstall a VNF Manager. \nLearn more here\n\n\nBuild or download one or more VNF Packages. \nLearn more here\n\n\nPrepare the Network Service Descriptor (NSD). \nLearn more here\n\n\nLaunch the NSD. \nLearn more here\n\n\n\n\nOnce these steps are completed you will be able to orchestrate your Network Service from the \ndashboard\n or via the \nREST APIs\n. \n\n\n\n\n\n\n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "NFVO intro"
        }, 
        {
            "location": "/use/#how-to-use-openbaton", 
            "text": "After completing the installation, you should be able to reach the dashboard of the NFVO at the following url: http://your-ip-here:8080  When accessing the dashboard, you will be prompted for a username and password. The first access can only be done with the super user (\"admin\") created during the installation process. Please refer to the  Identity Management  section for more information about security mechanisms. \nPlease refer to the following documentation for learning how to use the  Open Baton dashboard  or the  Command Line Interface  In order to use Open Baton for launching your first Network Service, you will need to follow these steps:   Install a VIM driver.  Learn more here  Register one or more Point of Presences (PoPs).  Learn more here  Install a VNF Manager.  Learn more here  Build or download one or more VNF Packages.  Learn more here  Prepare the Network Service Descriptor (NSD).  Learn more here  Launch the NSD.  Learn more here   Once these steps are completed you will be able to orchestrate your Network Service from the  dashboard  or via the  REST APIs .    \n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "How to use OpenBaton"
        }, 
        {
            "location": "/security/", 
            "text": "Identity management\n\n\nOpen Baton provides several mechanisms for managing users, roles and projects. When accessing the dashboard, you will be prompted for a username and password. \nThe first access can only be done with the super user created during the installation. Then it is possible to create other users and projects. The super user(admin) password is set while installing the platform.\n\n\nRoles and projects\n\n\nOpen Baton security model consists of different users, roles and projects.\n\n\nA project can be used for isolating a group of users from the others and/or VNFs. Users can be assigned to projects and adopt a different role per project. Changes made in a project's environment are not visible from another project. \nWhen the NFVO starts a default project is created. Every project has a \nunique\n name and a project-id.  \n\n\nA user can have the role \nUSER\n or \nGUEST\n in a project. Administrators with the role \nADMIN\n has control over the whole system. Admin user can add and delete users and projects, assign roles and has access to all the projects. When starting the NFVO there will be already one super user (with the role of an \nADMIN\n) defined by default with the user name \nadmin\n and the password chosen during installation (\nopenbaton\n by default)\n\n\nThe password can be changed in the top right corner of the dashboard, by clicking on the username drop down menu.\n\n\nA user with the role \nUSER\n in some specific projects, can create, delete and update PoPs, NSD, VNFD, VNFPackages, NSR and VNFR only inside his projects. He cannot access or modify other projects or users.\n\n\nA user with the role \nGUEST\n can just see the components (PoPs, NSD, NSR etc.) of the project he is assigned to but he cannot create, update or delete them. Furthermore he does not see other projects and users.\n\n\nEnabling SSL\n\n\nThe NFVO can use SSL to encrypt communication on the norhbound REST APIs. To enable this feature set\n\n\nserver.ssl.enabled = true\nserver.port: 8443\nserver.ssl.key-store = /etc/openbaton/keystore.p12\nserver.ssl.key-store-password = password\nserver.ssl.keyStoreType = PKCS12\nserver.ssl.keyAlias = tomcat\n\n\n\n\nin the \nopenbaton.properties\n file.  \n\n\nStart the NFVO and it will use SSL from now on and run on port 8443 instead of 8080, but port 8080 is redirected to 8443. To access the dashboard the use of https is required.\nIt is also possible to specify different key store file or even third part authorities. For a more documentation on this feature please refer to \nthe Spring Doc and Tutorials\n\n\n\n\n\n\n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Identity management"
        }, 
        {
            "location": "/security/#identity-management", 
            "text": "Open Baton provides several mechanisms for managing users, roles and projects. When accessing the dashboard, you will be prompted for a username and password. \nThe first access can only be done with the super user created during the installation. Then it is possible to create other users and projects. The super user(admin) password is set while installing the platform.", 
            "title": "Identity management"
        }, 
        {
            "location": "/security/#roles-and-projects", 
            "text": "Open Baton security model consists of different users, roles and projects.  A project can be used for isolating a group of users from the others and/or VNFs. Users can be assigned to projects and adopt a different role per project. Changes made in a project's environment are not visible from another project. \nWhen the NFVO starts a default project is created. Every project has a  unique  name and a project-id.    A user can have the role  USER  or  GUEST  in a project. Administrators with the role  ADMIN  has control over the whole system. Admin user can add and delete users and projects, assign roles and has access to all the projects. When starting the NFVO there will be already one super user (with the role of an  ADMIN ) defined by default with the user name  admin  and the password chosen during installation ( openbaton  by default)  The password can be changed in the top right corner of the dashboard, by clicking on the username drop down menu.  A user with the role  USER  in some specific projects, can create, delete and update PoPs, NSD, VNFD, VNFPackages, NSR and VNFR only inside his projects. He cannot access or modify other projects or users.  A user with the role  GUEST  can just see the components (PoPs, NSD, NSR etc.) of the project he is assigned to but he cannot create, update or delete them. Furthermore he does not see other projects and users.", 
            "title": "Roles and projects"
        }, 
        {
            "location": "/security/#enabling-ssl", 
            "text": "The NFVO can use SSL to encrypt communication on the norhbound REST APIs. To enable this feature set  server.ssl.enabled = true\nserver.port: 8443\nserver.ssl.key-store = /etc/openbaton/keystore.p12\nserver.ssl.key-store-password = password\nserver.ssl.keyStoreType = PKCS12\nserver.ssl.keyAlias = tomcat  in the  openbaton.properties  file.    Start the NFVO and it will use SSL from now on and run on port 8443 instead of 8080, but port 8080 is redirected to 8443. To access the dashboard the use of https is required.\nIt is also possible to specify different key store file or even third part authorities. For a more documentation on this feature please refer to  the Spring Doc and Tutorials   \n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Enabling SSL"
        }, 
        {
            "location": "/nfvo-how-to-use-gui/", 
            "text": "OpenBaton Dashboard\n\n\nThe Dashboard of OpenBaton helps you managing the lifecycle of different objects like \nVimInstaces, Network Service Descriptors/Records and Virtual Network Function Descriptors/Records in the OpenBaton environment.\n\n\nLogin\n\n\nThe first page that you will see after typing \nhttp://url-to-nfvo:8080\n or \nhttps://url-to-nfvo:8443\n (depends whether SSL is enabled or not) into your browser is the following login form.\n\n\n\n\nThe default user is called \nadmin\n and has the password \nopenbaton\n. \n\n\nOverview\n\n\nThe index page shows an overview of the state of the NFVO \n\n\n\n\nNumber of Network Service Records\n\n\nNumber of Virtual Network Functions\n\n\nNumber of Network Service Descriptors\n\n\nNumber of SSH Keys\n\n\n\n\nIt also shows the summary of the available resources, like floating ips, instances, RAM and CPU cores. The data is collected from the available PoPs if possible and then the summary is displayed. Test POPs do not grant any resources. The quota informatrion is backed up in cache to avoid unnecessary traffic. You can refresh the data by going into upper right corner drop down menu and choosing refresh quota option. You can now also see the NFVO version on the header panel. \n\n\n\n\nSecurity\n\n\nThe NFVO uses projects and users with assigned roles so that multiple selected users can work in the same project environment.\n\nThe parts of the GUI to manage users and projects are marked red in the following screenshot. \n\n\n\n\nIn the upper right corner you can see the current project in which you are working next to the folder label.\n\nClick on it to switch to other projects you have access to.\n\nNext to this you can see your user name. Click on it to extend a menu with the logout button. \nYou can also change the password by choosing the command in this menu or use the \nHelp\n button to open the documentation. \n\n\nIf you select \nIdentity\n tab, you can add and change projects and users. \nIdentity tab\n is available only to the users with admin privileges. \n\n\nThe following screenshot shows the creation of a new user named \nnew user\n who is assigned to the project \ndefault\n as a \nUSER\n. This means that he can modify the resources in this project. The role \nGUEST\n would basically grant the read-only privilege to the user. If you would like the user to have access to all the projects and resources of the NFVO, you can put a mark to on the \nMake Admin\n marker, if the marker is turned on the individual roles you choose will not matter any more and the user will be saved as an \nADMIN\n. \n\n\n\n\nThe NFVO also supports SSL. If SSL is enabled you have to use \nhttps://url-to-nfvo:8443\n to access the GUI. \n\n\nVim Driver Installation\n\n\nIf you are admin you call also use vim-drivers menu to download the drivers from marketplace and install and start them. You also have an access to the information about the drivers that are already installed. \n\n\nManage PoPs\n\n\nOn this page you can see the list of PoPs registered\n\n\n\n\nFor registering a new Point-of-Presence you can click on the button in the top-right corner \nRegister Vim\n of this page. In the new window you have two ways to register a new PoP. First is to fill out the form with all the data needed to register the PoP. You can choose the type of PoP from the drivers that you currently have installed (test, openstack, etc).\n\n\n\nYou can copy json with the data or provide a file.\n\n\n\n\nIf you want to delete a Vim Instance you can click on the button \nAction\n and then \nDelete\n in the menu\n\n\nCatalogue\n\n\nIn the menu on the left side under the template \nCatalogue\n you can manage \n\n\n\n\nNS Descriptors\n\n\nVNF Packages\n\n\nKey Pairs\n\n\nVNF Descriptors\n\n\nMarketplace\n\n\n\n\nMarketplace\n\n\nWith the opening of the Openbaton Marketplace, it became possbile to download VNFPackages and NSDs directly into the NFVO, for this, \ngo to Marketplace tab and browse the available packages. You can click download button to download and onboard it. If you download NSD, the packages will be downloaded and onboarded automatically. You can find more about marketplace  out at the pages dedicated to it. \n\n\nKey Pairs\n\n\nYou can add a key pairs to use for ssh access to the VMs via \nKey Pairs\n menu. You have two options in terms of adding the keys. \n You can promt NFVO to create a key for you with a given name:\n\n\n\nIMPORTANT\n: You will be promted to download the private key after you press \nGenerate\n. Currently there is no option to regenerate a key. If you do not download the key, you will have to generate a new one. \n\n\nYou can import key for your host user via providing your public key to the NFVO:\n\n\n\nNetwork Service Descriptors\n\n\nIn the menu on the left side under the template Catalogue you can find the \nNS Decriptors\n button.\nOn this page you can see the list of NS Descriptors stored in OpenBaton\n\n\n\n\nLaunching the NSD\n\n\nIn order to launch NSD press the \nAction\n near the NSD you want to lauch and press \nlaunch\n. You will be promted with a dialogue that will let you choose the key name for the NSR. You have 2 options in this case:\n\n\n\n\n\n\nPick key that you have added to the NFVO or created with it, you can pick multiple keys too, and press \nLaunch\n to use these keys later to access the VMs. You can also create or import key from here if you want \n\n\n\n\n\n\nYou can now also pick PoP for VNFDs that you have in your NSD. \n\n\n\n\n\n\n\n\n\n\nStoring NSD\n\n\nYou have two options for storing a NS Descriptor:\n\n\n\n\nCreate a NSD by using the VNFDs from the Packages\n\n\nCreate a NSD by using a json file\n\n\nIf you are using TOSCA NSD you can choose  \"upload CSAR NSD\" and upload it via drag and drop.\n\n\n\n\nUpload a json-file that contains the NSD\n\n\n\n\nCreate a NSD by using the VNFD from the Packages, just click on the button \"Create NSD\".\n\nThis is the form which allows you to choose the VNFDs to be used in the NSD come from the Catalogue (and contained inside the VNFPackages)\n\n\n\n\nIn the picture below you can see how to add a VNF Dependency to the NSD and possible parameters by clicking on \nDependencies +\n\n\n\n\nNetwork Service Descriptor Information\n\n\nIf you click on the id of a NSD shown in the list of NSDs you can see the information\nstored in this Network Service Descriptor.\n\n\n\n\nYou can observe the NSD in json format by clicking on the \nShow JSON\n button\n\n\n\n\nIf you click on the \nAction\n button in the list of VNFDs you can delete the VNFD from the NSD\nand the information about the \nDependencies\n stored in the Network Service Descriptor\n\n\n\n\nIf you click on the \nAction\n button in the list of VNFDependencies you can delete the VNFDependency from the NSD\n\n\nEdit a Network Service Descriptor\n\n\nIf you want to Edit the NSD just click on the \nEdit\n button under the button \nAction\n in the list of NSD\n\n\n\n\nThe same for the VNF inside the NSD\n\n\n\n\n\n\nAnd the same for the VDU inside the VNF\n\n\nVirtual Network Function Descriptor Information\n\n\nIn the list of Virtual Network Function Descriptors in NSD template you can click on the id of a Virtual Network Function Descriptor to get to this page\n\n\n\n\nAt the bottom of the page you can see the Virtual Deployment Unit (VDU) tab and if you click on the \nid\n of the \nVDU you can see the details of it. Here you can also start stop VNFC Instances with button. \n\n\n\n\nVNF Packages\n\n\nOn this page you can upload the \nVNF Package\n. For more information about the VNF Package please read the \nVNF Package documentation\n \nFor uploading a \n.tar\n you can click on the button \nUpload VNFPackage\n and this window will be shown where you can drag \n drop the file or just click on the white area and choose your file using your file manager. You can also upload csar package instead of usual tar one, for this, just click on \"Use CSAR parser\" before sending the packages. \n\n\n\n\nAfter you click on the button \nSend All\n the packages will be sent to the \nNFVO\n and once the process is finished you will see the package appearing in the list\n\n\nNetwork Service Records\n\n\nIn the menu on the left side if you click on the \nOrchestrator NS\n and then \nNS Records\n you will see the list of \nNetwork Service Records\n\nLike in this screenshot \n\n\n\n\nOn this page you can see the details of a Network Service Record by clicking on the id\n\n\n\n\nOn this page you can look at the JSON file of the NSR by clicking on the link \nShow JSON\n and also the \nGraphical view\n. \nof Network Service Record by clicking on the link \nShow Graph\n. \nIn the table of VNF Records you can delete a VNFR by clicking on \nAction\n and then \nDelete\n. \nTo look at the details of a VNFR just click on the \nid\n of it.\n\n\n\n\nEvent\n\n\nThe Events are sent by the Orchestrator to the specific \nEndPoint\n where an external component is listening to be aware when the Orchestrator \nchanges the STATE of a particular \nvirtualNetworkFunctionId\n or \nnetworkServiceId\n\n\nTo add a new Event just click the button \"Create event\" and will be shown the form as follow:\n\n\n\n\nFor getting the information click on the id link of the Event\n\n\n\n\nThis are the information of the Event selected\n\n\n\n\n\n\n\n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  &amp;&amp; (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Use via the Dashboard"
        }, 
        {
            "location": "/nfvo-how-to-use-gui/#openbaton-dashboard", 
            "text": "The Dashboard of OpenBaton helps you managing the lifecycle of different objects like \nVimInstaces, Network Service Descriptors/Records and Virtual Network Function Descriptors/Records in the OpenBaton environment.", 
            "title": "OpenBaton Dashboard"
        }, 
        {
            "location": "/nfvo-how-to-use-gui/#login", 
            "text": "The first page that you will see after typing  http://url-to-nfvo:8080  or  https://url-to-nfvo:8443  (depends whether SSL is enabled or not) into your browser is the following login form.   The default user is called  admin  and has the password  openbaton .", 
            "title": "Login"
        }, 
        {
            "location": "/nfvo-how-to-use-gui/#overview", 
            "text": "The index page shows an overview of the state of the NFVO    Number of Network Service Records  Number of Virtual Network Functions  Number of Network Service Descriptors  Number of SSH Keys   It also shows the summary of the available resources, like floating ips, instances, RAM and CPU cores. The data is collected from the available PoPs if possible and then the summary is displayed. Test POPs do not grant any resources. The quota informatrion is backed up in cache to avoid unnecessary traffic. You can refresh the data by going into upper right corner drop down menu and choosing refresh quota option. You can now also see the NFVO version on the header panel.", 
            "title": "Overview"
        }, 
        {
            "location": "/nfvo-how-to-use-gui/#security", 
            "text": "The NFVO uses projects and users with assigned roles so that multiple selected users can work in the same project environment. \nThe parts of the GUI to manage users and projects are marked red in the following screenshot.    In the upper right corner you can see the current project in which you are working next to the folder label. \nClick on it to switch to other projects you have access to. \nNext to this you can see your user name. Click on it to extend a menu with the logout button. \nYou can also change the password by choosing the command in this menu or use the  Help  button to open the documentation.   If you select  Identity  tab, you can add and change projects and users.  Identity tab  is available only to the users with admin privileges.   The following screenshot shows the creation of a new user named  new user  who is assigned to the project  default  as a  USER . This means that he can modify the resources in this project. The role  GUEST  would basically grant the read-only privilege to the user. If you would like the user to have access to all the projects and resources of the NFVO, you can put a mark to on the  Make Admin  marker, if the marker is turned on the individual roles you choose will not matter any more and the user will be saved as an  ADMIN .    The NFVO also supports SSL. If SSL is enabled you have to use  https://url-to-nfvo:8443  to access the GUI.", 
            "title": "Security"
        }, 
        {
            "location": "/nfvo-how-to-use-gui/#vim-driver-installation", 
            "text": "If you are admin you call also use vim-drivers menu to download the drivers from marketplace and install and start them. You also have an access to the information about the drivers that are already installed.", 
            "title": "Vim Driver Installation"
        }, 
        {
            "location": "/nfvo-how-to-use-gui/#manage-pops", 
            "text": "On this page you can see the list of PoPs registered   For registering a new Point-of-Presence you can click on the button in the top-right corner  Register Vim  of this page. In the new window you have two ways to register a new PoP. First is to fill out the form with all the data needed to register the PoP. You can choose the type of PoP from the drivers that you currently have installed (test, openstack, etc).  You can copy json with the data or provide a file.   If you want to delete a Vim Instance you can click on the button  Action  and then  Delete  in the menu", 
            "title": "Manage PoPs"
        }, 
        {
            "location": "/nfvo-how-to-use-gui/#catalogue", 
            "text": "In the menu on the left side under the template  Catalogue  you can manage    NS Descriptors  VNF Packages  Key Pairs  VNF Descriptors  Marketplace", 
            "title": "Catalogue"
        }, 
        {
            "location": "/nfvo-how-to-use-gui/#marketplace", 
            "text": "With the opening of the Openbaton Marketplace, it became possbile to download VNFPackages and NSDs directly into the NFVO, for this, \ngo to Marketplace tab and browse the available packages. You can click download button to download and onboard it. If you download NSD, the packages will be downloaded and onboarded automatically. You can find more about marketplace  out at the pages dedicated to it.", 
            "title": "Marketplace"
        }, 
        {
            "location": "/nfvo-how-to-use-gui/#key-pairs", 
            "text": "You can add a key pairs to use for ssh access to the VMs via  Key Pairs  menu. You have two options in terms of adding the keys. \n You can promt NFVO to create a key for you with a given name:  IMPORTANT : You will be promted to download the private key after you press  Generate . Currently there is no option to regenerate a key. If you do not download the key, you will have to generate a new one.   You can import key for your host user via providing your public key to the NFVO:", 
            "title": "Key Pairs"
        }, 
        {
            "location": "/nfvo-how-to-use-gui/#network-service-descriptors", 
            "text": "In the menu on the left side under the template Catalogue you can find the  NS Decriptors  button.\nOn this page you can see the list of NS Descriptors stored in OpenBaton", 
            "title": "Network Service Descriptors"
        }, 
        {
            "location": "/nfvo-how-to-use-gui/#launching-the-nsd", 
            "text": "In order to launch NSD press the  Action  near the NSD you want to lauch and press  launch . You will be promted with a dialogue that will let you choose the key name for the NSR. You have 2 options in this case:    Pick key that you have added to the NFVO or created with it, you can pick multiple keys too, and press  Launch  to use these keys later to access the VMs. You can also create or import key from here if you want     You can now also pick PoP for VNFDs that you have in your NSD.", 
            "title": "Launching the NSD"
        }, 
        {
            "location": "/nfvo-how-to-use-gui/#storing-nsd", 
            "text": "You have two options for storing a NS Descriptor:   Create a NSD by using the VNFDs from the Packages  Create a NSD by using a json file  If you are using TOSCA NSD you can choose  \"upload CSAR NSD\" and upload it via drag and drop.   Upload a json-file that contains the NSD   Create a NSD by using the VNFD from the Packages, just click on the button \"Create NSD\". \nThis is the form which allows you to choose the VNFDs to be used in the NSD come from the Catalogue (and contained inside the VNFPackages)   In the picture below you can see how to add a VNF Dependency to the NSD and possible parameters by clicking on  Dependencies +", 
            "title": "Storing NSD"
        }, 
        {
            "location": "/nfvo-how-to-use-gui/#network-service-descriptor-information", 
            "text": "If you click on the id of a NSD shown in the list of NSDs you can see the information\nstored in this Network Service Descriptor.   You can observe the NSD in json format by clicking on the  Show JSON  button   If you click on the  Action  button in the list of VNFDs you can delete the VNFD from the NSD\nand the information about the  Dependencies  stored in the Network Service Descriptor   If you click on the  Action  button in the list of VNFDependencies you can delete the VNFDependency from the NSD", 
            "title": "Network Service Descriptor Information"
        }, 
        {
            "location": "/nfvo-how-to-use-gui/#edit-a-network-service-descriptor", 
            "text": "If you want to Edit the NSD just click on the  Edit  button under the button  Action  in the list of NSD   The same for the VNF inside the NSD    And the same for the VDU inside the VNF", 
            "title": "Edit a Network Service Descriptor"
        }, 
        {
            "location": "/nfvo-how-to-use-gui/#virtual-network-function-descriptor-information", 
            "text": "In the list of Virtual Network Function Descriptors in NSD template you can click on the id of a Virtual Network Function Descriptor to get to this page   At the bottom of the page you can see the Virtual Deployment Unit (VDU) tab and if you click on the  id  of the \nVDU you can see the details of it. Here you can also start stop VNFC Instances with button.", 
            "title": "Virtual Network Function Descriptor Information"
        }, 
        {
            "location": "/nfvo-how-to-use-gui/#vnf-packages", 
            "text": "On this page you can upload the  VNF Package . For more information about the VNF Package please read the  VNF Package documentation  \nFor uploading a  .tar  you can click on the button  Upload VNFPackage  and this window will be shown where you can drag   drop the file or just click on the white area and choose your file using your file manager. You can also upload csar package instead of usual tar one, for this, just click on \"Use CSAR parser\" before sending the packages.    After you click on the button  Send All  the packages will be sent to the  NFVO  and once the process is finished you will see the package appearing in the list", 
            "title": "VNF Packages"
        }, 
        {
            "location": "/nfvo-how-to-use-gui/#network-service-records", 
            "text": "In the menu on the left side if you click on the  Orchestrator NS  and then  NS Records  you will see the list of  Network Service Records \nLike in this screenshot    On this page you can see the details of a Network Service Record by clicking on the id   On this page you can look at the JSON file of the NSR by clicking on the link  Show JSON  and also the  Graphical view . \nof Network Service Record by clicking on the link  Show Graph . \nIn the table of VNF Records you can delete a VNFR by clicking on  Action  and then  Delete . \nTo look at the details of a VNFR just click on the  id  of it.", 
            "title": "Network Service Records"
        }, 
        {
            "location": "/nfvo-how-to-use-gui/#event", 
            "text": "The Events are sent by the Orchestrator to the specific  EndPoint  where an external component is listening to be aware when the Orchestrator \nchanges the STATE of a particular  virtualNetworkFunctionId  or  networkServiceId  To add a new Event just click the button \"Create event\" and will be shown the form as follow:   For getting the information click on the id link of the Event   This are the information of the Event selected    \n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  &amp;&amp; (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Event"
        }, 
        {
            "location": "/nfvo-how-to-use-cli/", 
            "text": "OpenBaton Command Line Interface (CLI)\n\n\nThe \nOpenbaton Client project\n provides a command-line interface, which enables you to use the NFVO's API and send commands to it. \n\n\nInstall the Openbaton Client as binaries\n\n\nOn Linux you can install the Open Baton Command Line Iterface while installing Open Baton using the \nbootstrap script\n. It will prompt you with the question if you also want to install the Command Line Interface.\n\nIf you did not want to install the CLI at this point you can install it later on Linux using \nsudo apt-get install openbaton-cli\n.\n\nIf you use MacOS you have to install the CLI from source code. \n\n\nInstall the Openbaton Client from source code\n\n\nGit clone the \nOpenbaton Client project\n. Navigate into the root directory of the project and execute \n./gradlew build\n.\n\n\ngit clone https://github.com/openbaton/openbaton-client.git\ncd openbaton-client\n./gradlew build\n\n\n\n\nSet the required environment variables\n\n\nin case of binaries installation\n\n\nSource \n/etc/openbaton/openbaton-cli.properties\n to set the required environment variables. A dialog appears and will ask you for some properties. \n\n\nsource /etc/openbaton/openbaton-cli.properties\n\n\n\n\nThis has to be done every time before you start working with the CLI in a new terminal. \n\n\nin case of source code insallation\n\n\nNavigate into the project's root directory and execute \nsource nfvo.properties\n. A dialog appears and will ask you for some properties. \n\n\ncd openbaton-client\nsource nfvo.properties\n\n\n\n\nThis has to be done every time before you start working with the CLI in a new terminal. \n\n\nOpenbaton Client usage\n\n\nAfter environment variables have been set, you can start using the cli for sending commands to the NFVO.\n\nIf you installed the Open Baton Client while installing Open Baton with the bootstrap script or with apt-get install the command \nopenbaton\n should be available.\n\nIf you installed it from source code you have to execute the script \nopenbaton.sh\n within the directory where you cloned the Open Baton Client repository.\n\n\nRun a command:\n\n\nopenbaton.sh command_name [arg-1] [arg-2] [arg-3]\n\n\n\n\nShow the configuration:\n\n\nopenbaton.sh -c\n\n\n\n\nActivate debug mode:\n\n\nopenbaton.sh -d COMMAND [arg-1] [arg-2] [arg-3]\n\n\n\n\nPrint help:\n\n\nopenbaton.sh -h\n\n\n\n\nPrint help for a command:\n\n\nopenbaton.sh COMMAND help\n\n\n\n\nList the available commands:\n\n\nopenbaton.sh -l\n\n\n\n\nAvailable commands\n\n\nIn the following section we list all the currently avalilable commands for the cli grouped by the components they work with.\n\nTypically commands take either IDs or file paths as parameters where the files contain an object in json format. \n\n\nVim Instance Subcommands\n\n\ncreate\n\n\n\n\nCreate a Vim Instance \n\n\n\n\n $ openbaton.sh VimInstance-create \nfile.json\n\n\n\n\n\ndelete\n\n\n\n\nDelete the Vim Instance with the specified id\n\n\n\n\n $ openbaton.sh VimInstance-delete \nid-vim-instance\n\n\n\n\n\nupdate\n\n\n\n\nUpdate a Vim Instance by passing a file containing the new one and the id of the old one\n\n\n\n\n $ openbaton.sh VimInstance-update \nfile.json\n \nid-vim-instance\n\n\n\n\n\nfindAll\n\n\n\n\nFind all Vim Instances\n\n\n\n\n $ openbaton.sh VimInstance-findAll\n\n\n\n\nfindById\n\n\n\n\nFind a Vim Instance specified by the id\n\n\n\n\n $ openbaton.sh VimInstance-findById \nid-vim-instance\n\n\n\n\n\nNetwork Service Descriptor Subcommands\n\n\ncreate\n\n\n\n\nCreate a Network Service Descriptor\n\n\n\n\n $ openbaton.sh NetworkServiceDescriptor-create \nfile.json\n\n\n\n\n\ndelete\n\n\n\n\nDelete a Network Service Descriptor by passing its id\n\n\n\n\n $ openbaton.sh NetworkServiceDescriptor-delete \nid-network-service-descriptor\n\n\n\n\n\nfindAll\n\n\n\n\nFind all Network Service Descriptors\n\n\n\n\n $ openbaton.sh NetworkServiceDescriptor-findAll\n\n\n\n\nfindById\n\n\n\n\nFind a Network Service Descriptor by passing its id\n\n\n\n\n $ openbaton.sh NetworkServiceDescriptor-findById \nid-network-service-descriptor\n\n\n\n\n\ncreateVNFDependency\n\n\n\n\nCreate a Virtual Network Function Descriptor dependency for a Network Service Descriptor with a specific id\n\n\n\n\n $ openbaton.sh NetworkServiceDescriptor-createVNFDependency \nid-network-service-descriptor\n \nfile.json\n\n\n\n\n\nThe file should look similar to this:\n\n\n{\n \nparameters\n:[\ntheParameter\n], \n \nversion\n:1, \n \nsource\n:{\nid\n:\n950811b6-ebb6-4a17-bf4e-ab61974acbc8\n}, \n \ntarget\n: {\nid\n:\n9873ad54-2963-424d-ab5d-39403a5dd544\n}\n}\n\n\n\n\nThe ids belong to the particular VirtualNetworkFunctionDescriptor.\n\n\ndeleteVNFDependency\n\n\n\n\nDelete the Virtual Network Function Descriptor dependency of a Network Service Descriptor with a specific id\n\n\n\n\n   $ openbaton.sh NetworkServiceDescriptor-deleteVNFDependency \nid-network-service-descriptor\n \nid-vnfdependency\n\n\n\n\n\ngetVNFDependencies\n\n\n\n\nGet all the Virtual Network Function Descriptor Dependencies of a Network Service Descriptor with a specific id\n\n\n\n\n $ openbaton.sh NetworkServiceDescriptor-getVNFDependencies \nid-network-service-descriptor\n\n\n\n\n\ngetVNFDependency\n\n\n\n\nGet a certain Virtual Network Function Descriptor Dependency of a Network Service Descriptor with a specific id\n\n\n\n\n $ openbaton.sh NetworkServiceDescriptor-getVNFDependency \nid-network-service-descriptor\n \nid-vnfdependency\n\n\n\n\n\ngetVirtualNetworkFunctionDescriptors\n\n\n\n\nFind all Virtual Network Function Descriptors of a certain Network Service Descriptor\n\n\n\n\n $ openbaton.sh NetworkServiceDescriptor-getVirtualNetworkFunctionDescriptors \nid-network-service-descriptor\n\n\n\n\n\ngetVirtualNetworkFunctionDescriptor\n\n\n\n\nFind a Virtual Network Function Descriptor specified by its id and the id of the Network Service Descriptor containing it\n\n\n\n\n$ openbaton.sh NetworkServiceDescriptor-getVirtualNetworkFunctionDescriptor \nid-network-service-descriptor\n \nid-vnfd\n\n\n\n\n\nVirtual Network Function Descriptor Subcommands\n\n\n\n\ncreate\n\n\nCreate a Virtual Network Function Descriptor\n\n\n\n\n $ openbaton.sh VirtualNetworkFunctionDescriptor-create \nfile.json\n\n\n\n\n\n\n\ndelete\n\n\nDelete a Virtual Network Function Descriptor passing its id\n\n\n\n\n $ openbaton.sh VirtualNetworkFunctionDescriptor-delete \nid-virtual-network-function-descriptor\n\n\n\n\n\n\n\nfindAll\n\n\nFind all Virtual Network Function Descriptors\n\n\n\n\n $ openbaton.sh VirtualNetworkFunctionDescriptor-findAll\n\n\n\n\n\n\nfindById\n\n\nFind a Virtual Network Function Descriptor by passing its id\n\n\n\n\n $ openbaton.sh VirtualNetworkFunctionDescriptor-findById \nid-virtual-network-function-descriptor\n\n\n\n\n\nNetwork Service Record Subcommands\n\n\ncreate\n\n\n\n\nCreate a Network Service Record from a Network Service Descriptor stored in the orchestrator\n\n\n\n\n $ openbaton.sh NetworkServiceRecord-create \nid-network-service-descriptor\n \nvim-map-file\n \nkeypair-file\n \nconfigurations-file\n\n\n\n\n\nThe three arguments after the NSD id can be used to specify the VIM on which a VDU should be deployed, the keypairs that shall be used to deploy the NSR and configuration parameters for the VNFRs.\n\nIf you want to specify the VIM that a particular VDU shall use you can pass a file containing a map like this:\n\n\n {\nvdu1Name\n:[vim1,vim2,vim3], \nvdu2Name\n:[vim1]}\n\n\n\n\nIn this case the VDU named vdu2Name would be deployed on vim1 and the VDU named vdu1Name randomly on one of the VIMs vim1, vim2 or vim3.  \n\n\nThe second command argument specifies a file containing a list that describes which keypairs shall be used to deploy the NSR. Here is an example: \n\n\n [\nkey1\n, \nkey2\n, \nkey3\n]\n\n\n\n\nThe last command argument specifies a file containing a map of VNFR names and configuration parameters. Here is an example: \n\n\n{\n  \nconfigurations\n:{ \n    \nvnfrName1\n:{\nname\n:\nconf1\n,\nconfigurationParameters\n:[{\nconfKey\n:\nkey1\n, \nvalue\n:\nvalue1\n, \ndescription\n:\ndescription1\n}]}, \n    \nvnfrName2\n:{\nname\n:\nconf2\n,\nconfigurationParameters\n:[{\nconfKey\n:\nkey1\n, \nvalue\n:\nvalue1\n, \ndescription\n:\ndescription1\n}]} \n  }\n}\n\n\n\n\nOf course you do not have to specify VIMs, keys and configurations. If you do not want to specify them just put empty objects into the files i.e. {} and []. \n\n\ndelete\n\n\n\n\nDelete a Network Service Record passing its id\n\n\n\n\n $ openbaton.sh NetworkServiceRecord-delete \nid-network-service-record\n\n\n\n\n\nupdate\n\n\n\n\nUpdate the Network Service Record by passing a file with the new version of it and the id of the Network Service Record to update\n\n\n\n\n$ openbaton.sh NetworkServiceRecord-update \nfile.json\n \nid-network-service-record\n\n\n\n\n\nfindAll\n\n\n\n\nFind all Network Service Records\n\n\n\n\n $ openbaton.sh NetworkServiceRecord-findAll \n\n\n\n\nfindById\n\n\n\n\nFind a Network Service Record by passing its id\n\n\n\n\n $ openbaton.sh NetworkServiceRecord-findById \nid-network-service-record\n\n\n\n\n\ngetVirtualNetworkFunctionRecords\n\n\n\n\nGet all the Virtual Network Function Records of a Network Service Record with a specific id\n\n\n\n\n $ openbaton.sh NetworkServiceRecord-getVirtualNetworkFunctionRecords \nid-network-service-record\n\n\n\n\n\ngetVirtualNetworkFunctionRecord\n\n\n\n\nGet a Virtual Network Function Record of a Network Service Record by providing its id \n\n\n\n\n $ openbaton.sh NetworkServiceRecord-getVirtualNetworkFunctionRecord \nid-network-service-record\n \nid-vnfr\n\n\n\n\n\ndeleteVirtualNetworkFunctionRecord\n\n\n\n\nDelete the Virtual Network Function Record of a Network Service Record with a specific id\n\n\n\n\n $ openbaton.sh NetworkServiceRecord-deleteVirtualNetworkFunctionRecord \nid-network-service-record\n \nid-vnfr\n\n\n\n\n\ncreateVNFDependency\n\n\n\n\nCreate a Virtual Network Function Record Dependency of a NetworkServiceRecord with a specific id\n\n\n\n\n $ openbaton.sh NetworkServiceRecord-createVNFDependency \nid-network-service-record\n \nfile.json\n\n\n\n\n\ndeleteVNFDependency\n\n\n\n\nDelete the Virtual Network Function Record Dependency of a NetworkServiceRecord with a specific id\n\n\n\n\n $ openbaton.sh NetworkServiceRecord-deleteVNFDependency \nid-network-service-record\n \nid-vnfdependency\n\n\n\n\n\ngetVNFDependencies\n\n\n\n\nGet all the Virtual Network Function Record Dependencies of a Network Service Record with a specific id\n\n\n\n\n $ openbaton.sh NetworkServiceRecord-getVNFDependencies \nid-network-service-record\n\n\n\n\n\ngetVNFDependency\n\n\n\n\nGet the Virtual Network Function Record Dependency of a Network Service Record with a specific id\n\n\n\n\n $ openbaton.sh NetworkServiceRecord-getVNFDependency \nid-network-service-record\n \nid-vnfdependency\n\n\n\n\n\ncreateVNFCInstance\n\n\n\n\nPerform a SCALE_OUT operation on a Virtual Network Function by adding a VNFCInstance to its Virtual Network Function Record\n\n\n\n\n$ openbaton.sh NetworkServiceRecord-createVNFCInstance \nid-network-service-record\n \nid-virtual-network-function-record\n \nfile.json\n\n\n\n\n\ndeleteVNFCInstance\n\n\n\n\nPerform a SCALE_IN operation on a Virtual Network Function by deleting a VNFCInstance from the Virtual Network Function Record\n\n\n\n\n$ openbaton.sh NetworkServiceRecord-deleteVNFCInstance \nid-network-service-record\n \nid-virtual-network-function-record\n\n\n\n\n\nstartVNFCInstance\n\n\n\n\nStart a VNFCInstance specified by it's id\n\n\n\n\n$ openbaton.sh NetworkServiceRecord-startVNFCInstance \nid-nsr\n \nid-vnfr\n \nid-vdu\n \nid-vnfcinstance\n\n\n\n\n\nstopVNFCInstance\n\n\n\n\nStop a VNFCInstance specified by it's id\n\n\n\n\n$ openbaton.sh NetworkServiceRecord-stopVNFCInstance \nid-nsr\n \nid-vnfr\n \nid-vdu\n \nid-vnfcinstance\n\n\n\n\n\nUser Subcommands\n\n\ncreate\n\n\n\n\nCreate a new User\n\n\n\n\n$ openbaton.sh User-create \nfile.json\n\n\n\n\n\ndelete\n\n\n\n\nDelete a user passing his id\n\n\n\n\n$ openbaton.sh User-delete \nuser-id\n\n\n\n\n\nupdate\n\n\n\n\nUpdate a User\n\n\n\n\n$ openbaton.sh User-update \nfile.json\n \nuser-id\n\n\n\n\n\nfindAll\n\n\n\n\nFind all Users\n\n\n\n\n$ openbaton.sh User-findAll\n\n\n\n\nfindByName\n\n\n\n\nFind a User by his username\n\n\n\n\n$ openbaton.sh User-findByName \nusername\n\n\n\n\n\nchangePassword\n\n\n\n\nChange the password of the current user\n\n\n\n\n$ openbaton.sh User-changePassword \noldPassword\n \nnewPassword\n\n\n\n\n\nRemember to source nfvo.properties afterwards and set the new password if you want to continue working as this User. \n\n\nProject Subcommands\n\n\ncreate\n\n\n\n\nCreate a new Project\n\n\n\n\n$ openbaton.sh Project-create \nfile.json\n\n\n\n\n\ndelete\n\n\n\n\nDelete a Project passing its id\n\n\n\n\n$ openbaton.sh Project-delete \nid-project\n\n\n\n\n\nupdate\n\n\n\n\nUpdate a Project\n\n\n\n\n$ openbaton.sh Project-update \nfile.json\n \nid-project\n\n\n\n\n\nfindAll\n\n\n\n\nFind all Projects\n\n\n\n\n$ openbaton.sh Project-findAll\n\n\n\n\nfindById\n\n\n\n\nFind a Project by passing its id\n\n\n\n\n$ openbaton.sh Project-findById \nid-project\n\n\n\n\n\nKey Subcommands\n\n\ngenerateKey\n\n\n\n\nGenerate a new Key in the NFVO\n\n\n\n\n$ openbaton.sh Key-generateKey \nkeyname\n\n\n\n\n\nThis command will return the private key.\n\n\nimportKey\n\n\n\n\nImport a Key into the NFVO\n\n\n\n\n$ openbaton.sh Key-importKey \nkeyname\n \npublicKey\n\n\n\n\n\ndelete\n\n\n\n\nDelete a Key passing its id\n\n\n\n\n$ openbaton.sh Key-delete \nid-key\n\n\n\n\n\nfindAll\n\n\n\n\nFind all Keys\n\n\n\n\n$ openbaton.sh Key-findAll\n\n\n\n\nfindById\n\n\n\n\nFind a Key by passing its id\n\n\n\n\n$ openbaton.sh Key-findById \nid-key\n\n\n\n\n\nEvent Subcommands\n\n\ncreate\n\n\n\n\nCreate an Event\n\n\n\n\n $ openbaton.sh Event-create \nfile.json\n\n\n\n\n\ndelete\n\n\n\n\nDelete an Event passing its id\n\n\n\n\n$ openbaton.sh Event-delete \nid-event\n\n\n\n\n\nfindAll\n\n\n\n\nFind all Events\n\n\n\n\n$ openbaton.sh Event-findAll\n\n\n\n\nfindById\n\n\n\n\nFind an Event by passing its id\n\n\n\n\n$ openbaton.sh Event-findById \nid-event\n\n\n\n\n\nConfiguration Subcommands\n\n\ncreate\n\n\n\n\nCreate a Configuration\n\n\n\n\n$ openbaton.sh Configuration-create \nfile.json\n\n\n\n\n\ndelete\n\n\n\n\nDelete a Configuration passing its id\n\n\n\n\n$ openbaton.sh Configuration-delete \nid-configuration\n\n\n\n\n\nfindAll\n\n\n\n\nFind all Configurations\n\n\n\n\n $ openbaton.sh Configuration-findAll\n\n\n\n\nfindById\n\n\n\n\nFind a Configuration by passint its id\n\n\n\n\n $ openbaton.sh Configuration-findById \nid-configuration\n\n\n\n\n\nVirtual Link Subcommands\n\n\ncreate\n\n\n\n\nCreate a Virtual Link\n\n\n\n\n $ openbaton.sh VirtualLink-create \nfile.json\n\n\n\n\n\ndelete\n\n\n\n\nDelete a Virtual Link by passing its id\n\n\n\n\n $ openbaton.sh VirtualLink-delete \nid-virtual-link\n\n\n\n\n\nupdate\n\n\n\n\nUpdate a Virtual Link passing the new object and the id of the old Virtual Link\n\n\n\n\n $ openbaton.sh VirtualLink-update \nfile.json\n \nid-virtual-link\n\n\n\n\n\nfindAll\n\n\n\n\nFind all Virtual Links\n\n\n\n\n $ openbaton.sh VirtualLink-findAll\n\n\n\n\nfindById\n\n\n\n\nFind a Virtual Link by passing its id\n\n\n\n\n $ openbaton.sh VirtualLink-findById \nid-virtual-link\n\n\n\n\n\nVNFPackage Subcommands\n\n\ncreate\n\n\n\n\nCreate a VNFPackage by uploading a tar file to the NFVO\n\n\n\n\n $ openbaton.sh VNFPackage-upload \nfile.tar\n\n\n\n\n\ndelete\n\n\n\n\nDelete a VNFPackage by passing its id\n\n\n\n\n $ openbaton.sh VNFPackage-delete \nid-vnfPackage\n\n\n\n\n\nfindAll\n\n\n\n\nFind all VNFPackages\n\n\n\n\n $ openbaton.sh VNFPackage-findAll\n\n\n\n\nfindById\n\n\n\n\nFind a VNFPackage by passing its id\n\n\n\n\n $ openbaton.sh VNFPackage-findById \nid-vnfPackage\n\n\n\n\n\n\n\n\n\n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Use via the CLI"
        }, 
        {
            "location": "/nfvo-how-to-use-cli/#openbaton-command-line-interface-cli", 
            "text": "The  Openbaton Client project  provides a command-line interface, which enables you to use the NFVO's API and send commands to it.", 
            "title": "OpenBaton Command Line Interface (CLI)"
        }, 
        {
            "location": "/nfvo-how-to-use-cli/#install-the-openbaton-client-as-binaries", 
            "text": "On Linux you can install the Open Baton Command Line Iterface while installing Open Baton using the  bootstrap script . It will prompt you with the question if you also want to install the Command Line Interface. \nIf you did not want to install the CLI at this point you can install it later on Linux using  sudo apt-get install openbaton-cli . \nIf you use MacOS you have to install the CLI from source code.", 
            "title": "Install the Openbaton Client as binaries"
        }, 
        {
            "location": "/nfvo-how-to-use-cli/#install-the-openbaton-client-from-source-code", 
            "text": "Git clone the  Openbaton Client project . Navigate into the root directory of the project and execute  ./gradlew build .  git clone https://github.com/openbaton/openbaton-client.git\ncd openbaton-client\n./gradlew build", 
            "title": "Install the Openbaton Client from source code"
        }, 
        {
            "location": "/nfvo-how-to-use-cli/#set-the-required-environment-variables", 
            "text": "", 
            "title": "Set the required environment variables"
        }, 
        {
            "location": "/nfvo-how-to-use-cli/#in-case-of-binaries-installation", 
            "text": "Source  /etc/openbaton/openbaton-cli.properties  to set the required environment variables. A dialog appears and will ask you for some properties.   source /etc/openbaton/openbaton-cli.properties  This has to be done every time before you start working with the CLI in a new terminal.", 
            "title": "in case of binaries installation"
        }, 
        {
            "location": "/nfvo-how-to-use-cli/#in-case-of-source-code-insallation", 
            "text": "Navigate into the project's root directory and execute  source nfvo.properties . A dialog appears and will ask you for some properties.   cd openbaton-client\nsource nfvo.properties  This has to be done every time before you start working with the CLI in a new terminal.", 
            "title": "in case of source code insallation"
        }, 
        {
            "location": "/nfvo-how-to-use-cli/#openbaton-client-usage", 
            "text": "After environment variables have been set, you can start using the cli for sending commands to the NFVO. \nIf you installed the Open Baton Client while installing Open Baton with the bootstrap script or with apt-get install the command  openbaton  should be available. \nIf you installed it from source code you have to execute the script  openbaton.sh  within the directory where you cloned the Open Baton Client repository.", 
            "title": "Openbaton Client usage"
        }, 
        {
            "location": "/nfvo-how-to-use-cli/#run-a-command", 
            "text": "openbaton.sh command_name [arg-1] [arg-2] [arg-3]", 
            "title": "Run a command:"
        }, 
        {
            "location": "/nfvo-how-to-use-cli/#show-the-configuration", 
            "text": "openbaton.sh -c", 
            "title": "Show the configuration:"
        }, 
        {
            "location": "/nfvo-how-to-use-cli/#activate-debug-mode", 
            "text": "openbaton.sh -d COMMAND [arg-1] [arg-2] [arg-3]", 
            "title": "Activate debug mode:"
        }, 
        {
            "location": "/nfvo-how-to-use-cli/#print-help", 
            "text": "openbaton.sh -h", 
            "title": "Print help:"
        }, 
        {
            "location": "/nfvo-how-to-use-cli/#print-help-for-a-command", 
            "text": "openbaton.sh COMMAND help", 
            "title": "Print help for a command:"
        }, 
        {
            "location": "/nfvo-how-to-use-cli/#list-the-available-commands", 
            "text": "openbaton.sh -l", 
            "title": "List the available commands:"
        }, 
        {
            "location": "/nfvo-how-to-use-cli/#available-commands", 
            "text": "In the following section we list all the currently avalilable commands for the cli grouped by the components they work with. \nTypically commands take either IDs or file paths as parameters where the files contain an object in json format.", 
            "title": "Available commands"
        }, 
        {
            "location": "/nfvo-how-to-use-cli/#vim-instance-subcommands", 
            "text": "create   Create a Vim Instance     $ openbaton.sh VimInstance-create  file.json   delete   Delete the Vim Instance with the specified id    $ openbaton.sh VimInstance-delete  id-vim-instance   update   Update a Vim Instance by passing a file containing the new one and the id of the old one    $ openbaton.sh VimInstance-update  file.json   id-vim-instance   findAll   Find all Vim Instances    $ openbaton.sh VimInstance-findAll  findById   Find a Vim Instance specified by the id    $ openbaton.sh VimInstance-findById  id-vim-instance", 
            "title": "Vim Instance Subcommands"
        }, 
        {
            "location": "/nfvo-how-to-use-cli/#network-service-descriptor-subcommands", 
            "text": "create   Create a Network Service Descriptor    $ openbaton.sh NetworkServiceDescriptor-create  file.json   delete   Delete a Network Service Descriptor by passing its id    $ openbaton.sh NetworkServiceDescriptor-delete  id-network-service-descriptor   findAll   Find all Network Service Descriptors    $ openbaton.sh NetworkServiceDescriptor-findAll  findById   Find a Network Service Descriptor by passing its id    $ openbaton.sh NetworkServiceDescriptor-findById  id-network-service-descriptor   createVNFDependency   Create a Virtual Network Function Descriptor dependency for a Network Service Descriptor with a specific id    $ openbaton.sh NetworkServiceDescriptor-createVNFDependency  id-network-service-descriptor   file.json   The file should look similar to this:  {\n  parameters :[ theParameter ], \n  version :1, \n  source :{ id : 950811b6-ebb6-4a17-bf4e-ab61974acbc8 }, \n  target : { id : 9873ad54-2963-424d-ab5d-39403a5dd544 }\n}  The ids belong to the particular VirtualNetworkFunctionDescriptor.  deleteVNFDependency   Delete the Virtual Network Function Descriptor dependency of a Network Service Descriptor with a specific id      $ openbaton.sh NetworkServiceDescriptor-deleteVNFDependency  id-network-service-descriptor   id-vnfdependency   getVNFDependencies   Get all the Virtual Network Function Descriptor Dependencies of a Network Service Descriptor with a specific id    $ openbaton.sh NetworkServiceDescriptor-getVNFDependencies  id-network-service-descriptor   getVNFDependency   Get a certain Virtual Network Function Descriptor Dependency of a Network Service Descriptor with a specific id    $ openbaton.sh NetworkServiceDescriptor-getVNFDependency  id-network-service-descriptor   id-vnfdependency   getVirtualNetworkFunctionDescriptors   Find all Virtual Network Function Descriptors of a certain Network Service Descriptor    $ openbaton.sh NetworkServiceDescriptor-getVirtualNetworkFunctionDescriptors  id-network-service-descriptor   getVirtualNetworkFunctionDescriptor   Find a Virtual Network Function Descriptor specified by its id and the id of the Network Service Descriptor containing it   $ openbaton.sh NetworkServiceDescriptor-getVirtualNetworkFunctionDescriptor  id-network-service-descriptor   id-vnfd", 
            "title": "Network Service Descriptor Subcommands"
        }, 
        {
            "location": "/nfvo-how-to-use-cli/#virtual-network-function-descriptor-subcommands", 
            "text": "create  Create a Virtual Network Function Descriptor    $ openbaton.sh VirtualNetworkFunctionDescriptor-create  file.json    delete  Delete a Virtual Network Function Descriptor passing its id    $ openbaton.sh VirtualNetworkFunctionDescriptor-delete  id-virtual-network-function-descriptor    findAll  Find all Virtual Network Function Descriptors    $ openbaton.sh VirtualNetworkFunctionDescriptor-findAll   findById  Find a Virtual Network Function Descriptor by passing its id    $ openbaton.sh VirtualNetworkFunctionDescriptor-findById  id-virtual-network-function-descriptor", 
            "title": "Virtual Network Function Descriptor Subcommands"
        }, 
        {
            "location": "/nfvo-how-to-use-cli/#network-service-record-subcommands", 
            "text": "create   Create a Network Service Record from a Network Service Descriptor stored in the orchestrator    $ openbaton.sh NetworkServiceRecord-create  id-network-service-descriptor   vim-map-file   keypair-file   configurations-file   The three arguments after the NSD id can be used to specify the VIM on which a VDU should be deployed, the keypairs that shall be used to deploy the NSR and configuration parameters for the VNFRs. \nIf you want to specify the VIM that a particular VDU shall use you can pass a file containing a map like this:   { vdu1Name :[vim1,vim2,vim3],  vdu2Name :[vim1]}  In this case the VDU named vdu2Name would be deployed on vim1 and the VDU named vdu1Name randomly on one of the VIMs vim1, vim2 or vim3.    The second command argument specifies a file containing a list that describes which keypairs shall be used to deploy the NSR. Here is an example:    [ key1 ,  key2 ,  key3 ]  The last command argument specifies a file containing a map of VNFR names and configuration parameters. Here is an example:   {\n   configurations :{ \n     vnfrName1 :{ name : conf1 , configurationParameters :[{ confKey : key1 ,  value : value1 ,  description : description1 }]}, \n     vnfrName2 :{ name : conf2 , configurationParameters :[{ confKey : key1 ,  value : value1 ,  description : description1 }]} \n  }\n}  Of course you do not have to specify VIMs, keys and configurations. If you do not want to specify them just put empty objects into the files i.e. {} and [].   delete   Delete a Network Service Record passing its id    $ openbaton.sh NetworkServiceRecord-delete  id-network-service-record   update   Update the Network Service Record by passing a file with the new version of it and the id of the Network Service Record to update   $ openbaton.sh NetworkServiceRecord-update  file.json   id-network-service-record   findAll   Find all Network Service Records    $ openbaton.sh NetworkServiceRecord-findAll   findById   Find a Network Service Record by passing its id    $ openbaton.sh NetworkServiceRecord-findById  id-network-service-record   getVirtualNetworkFunctionRecords   Get all the Virtual Network Function Records of a Network Service Record with a specific id    $ openbaton.sh NetworkServiceRecord-getVirtualNetworkFunctionRecords  id-network-service-record   getVirtualNetworkFunctionRecord   Get a Virtual Network Function Record of a Network Service Record by providing its id     $ openbaton.sh NetworkServiceRecord-getVirtualNetworkFunctionRecord  id-network-service-record   id-vnfr   deleteVirtualNetworkFunctionRecord   Delete the Virtual Network Function Record of a Network Service Record with a specific id    $ openbaton.sh NetworkServiceRecord-deleteVirtualNetworkFunctionRecord  id-network-service-record   id-vnfr   createVNFDependency   Create a Virtual Network Function Record Dependency of a NetworkServiceRecord with a specific id    $ openbaton.sh NetworkServiceRecord-createVNFDependency  id-network-service-record   file.json   deleteVNFDependency   Delete the Virtual Network Function Record Dependency of a NetworkServiceRecord with a specific id    $ openbaton.sh NetworkServiceRecord-deleteVNFDependency  id-network-service-record   id-vnfdependency   getVNFDependencies   Get all the Virtual Network Function Record Dependencies of a Network Service Record with a specific id    $ openbaton.sh NetworkServiceRecord-getVNFDependencies  id-network-service-record   getVNFDependency   Get the Virtual Network Function Record Dependency of a Network Service Record with a specific id    $ openbaton.sh NetworkServiceRecord-getVNFDependency  id-network-service-record   id-vnfdependency   createVNFCInstance   Perform a SCALE_OUT operation on a Virtual Network Function by adding a VNFCInstance to its Virtual Network Function Record   $ openbaton.sh NetworkServiceRecord-createVNFCInstance  id-network-service-record   id-virtual-network-function-record   file.json   deleteVNFCInstance   Perform a SCALE_IN operation on a Virtual Network Function by deleting a VNFCInstance from the Virtual Network Function Record   $ openbaton.sh NetworkServiceRecord-deleteVNFCInstance  id-network-service-record   id-virtual-network-function-record   startVNFCInstance   Start a VNFCInstance specified by it's id   $ openbaton.sh NetworkServiceRecord-startVNFCInstance  id-nsr   id-vnfr   id-vdu   id-vnfcinstance   stopVNFCInstance   Stop a VNFCInstance specified by it's id   $ openbaton.sh NetworkServiceRecord-stopVNFCInstance  id-nsr   id-vnfr   id-vdu   id-vnfcinstance", 
            "title": "Network Service Record Subcommands"
        }, 
        {
            "location": "/nfvo-how-to-use-cli/#user-subcommands", 
            "text": "create   Create a new User   $ openbaton.sh User-create  file.json   delete   Delete a user passing his id   $ openbaton.sh User-delete  user-id   update   Update a User   $ openbaton.sh User-update  file.json   user-id   findAll   Find all Users   $ openbaton.sh User-findAll  findByName   Find a User by his username   $ openbaton.sh User-findByName  username   changePassword   Change the password of the current user   $ openbaton.sh User-changePassword  oldPassword   newPassword   Remember to source nfvo.properties afterwards and set the new password if you want to continue working as this User.", 
            "title": "User Subcommands"
        }, 
        {
            "location": "/nfvo-how-to-use-cli/#project-subcommands", 
            "text": "create   Create a new Project   $ openbaton.sh Project-create  file.json   delete   Delete a Project passing its id   $ openbaton.sh Project-delete  id-project   update   Update a Project   $ openbaton.sh Project-update  file.json   id-project   findAll   Find all Projects   $ openbaton.sh Project-findAll  findById   Find a Project by passing its id   $ openbaton.sh Project-findById  id-project", 
            "title": "Project Subcommands"
        }, 
        {
            "location": "/nfvo-how-to-use-cli/#key-subcommands", 
            "text": "generateKey   Generate a new Key in the NFVO   $ openbaton.sh Key-generateKey  keyname   This command will return the private key.  importKey   Import a Key into the NFVO   $ openbaton.sh Key-importKey  keyname   publicKey   delete   Delete a Key passing its id   $ openbaton.sh Key-delete  id-key   findAll   Find all Keys   $ openbaton.sh Key-findAll  findById   Find a Key by passing its id   $ openbaton.sh Key-findById  id-key", 
            "title": "Key Subcommands"
        }, 
        {
            "location": "/nfvo-how-to-use-cli/#event-subcommands", 
            "text": "create   Create an Event    $ openbaton.sh Event-create  file.json   delete   Delete an Event passing its id   $ openbaton.sh Event-delete  id-event   findAll   Find all Events   $ openbaton.sh Event-findAll  findById   Find an Event by passing its id   $ openbaton.sh Event-findById  id-event", 
            "title": "Event Subcommands"
        }, 
        {
            "location": "/nfvo-how-to-use-cli/#configuration-subcommands", 
            "text": "create   Create a Configuration   $ openbaton.sh Configuration-create  file.json   delete   Delete a Configuration passing its id   $ openbaton.sh Configuration-delete  id-configuration   findAll   Find all Configurations    $ openbaton.sh Configuration-findAll  findById   Find a Configuration by passint its id    $ openbaton.sh Configuration-findById  id-configuration", 
            "title": "Configuration Subcommands"
        }, 
        {
            "location": "/nfvo-how-to-use-cli/#virtual-link-subcommands", 
            "text": "create   Create a Virtual Link    $ openbaton.sh VirtualLink-create  file.json   delete   Delete a Virtual Link by passing its id    $ openbaton.sh VirtualLink-delete  id-virtual-link   update   Update a Virtual Link passing the new object and the id of the old Virtual Link    $ openbaton.sh VirtualLink-update  file.json   id-virtual-link   findAll   Find all Virtual Links    $ openbaton.sh VirtualLink-findAll  findById   Find a Virtual Link by passing its id    $ openbaton.sh VirtualLink-findById  id-virtual-link", 
            "title": "Virtual Link Subcommands"
        }, 
        {
            "location": "/nfvo-how-to-use-cli/#vnfpackage-subcommands", 
            "text": "create   Create a VNFPackage by uploading a tar file to the NFVO    $ openbaton.sh VNFPackage-upload  file.tar   delete   Delete a VNFPackage by passing its id    $ openbaton.sh VNFPackage-delete  id-vnfPackage   findAll   Find all VNFPackages    $ openbaton.sh VNFPackage-findAll  findById   Find a VNFPackage by passing its id    $ openbaton.sh VNFPackage-findById  id-vnfPackage    \n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "VNFPackage Subcommands"
        }, 
        {
            "location": "/vim-instance/", 
            "text": "Register a new Point of Presence (PoP)\n\n\nThe \nVirtualised Infrastructure Manager\n (Vim) is the functional block, responsible for controlling and managing the\n NFVI compute, storage and network resources within a Point of Presence (PoP).\n\n\nIn order to interoperate with a PoP it is required to register the VIM instance responsible for it to the NFVO. Assuming that you already installed the proper VIM driver, in order to connect to the selected Point of Presence (PoP), you need to register it at the NFVO. For doing that you can write a JSON file containing the details of a VIM Instance like the one described below: \n\n\n{  \n   \nname\n:\nvim-instance-name\n,\n   \nauthUrl\n:\nhttp://192.168.0.5:5000/v2.0\n,\n   \ntenant\n:\ntenantName\n,\n   \nusername\n:\nuserName\n,\n   \npassword\n:\npassword\n,\n   \nkeyPair\n:\nkeyName\n,\n   \nsecurityGroups\n:[  \n      \nsecurityName\n\n   ],\n   \ntype\n:\nopenstack\n,\n   \nlocation\n:{  \n      \nname\n:\nBerlin\n,\n      \nlatitude\n:\n52.525876\n,\n      \nlongitude\n:\n13.314400\n\n   }\n}\n\n\n\n\n\nMost of the parameters are based on the OpenStack VIM type, since OpenStack represents the standard de-facto VIM in the ETSI NFV specification.\n\n\n\n\n\n\n\n\nParams\n\n\nMeaning\n\n\nMandatory\n\n\n\n\n\n\n\n\n\n\nname\n\n\nThe name of the Point of Presence, important for later on linking it into your VNFD\n\n\nyes\n\n\n\n\n\n\nauthUrl\n\n\nThe endpoint for authentication\n\n\nyes\n\n\n\n\n\n\ntenant\n\n\nThe tenant name on which you plan to deploy your VNFs\n\n\nyes\n\n\n\n\n\n\nusername\n\n\nThe name of the user able to access your VIM via its remote APIs (usually good to have admin rights)\n\n\nyes\n\n\n\n\n\n\npassword\n\n\nThe password of the user able to access your VIM via its remote APIs\n\n\nyes\n\n\n\n\n\n\nkeyPair\n\n\nThe keyPair \nname\n to get the access to the VMs (optional - mainly applicable to OpenStack)\n\n\nyes\n\n\n\n\n\n\nsecurityGroups\n\n\nUse a Security group that provides a sets of IP filtering rules that are applied to an instance's networking (mainly applicable to OpenStack)\n\n\nno\n\n\n\n\n\n\ntype\n\n\nThe type of the VIM Instance you are using. This information will be used by the NFVO for locating the corresponding driver. Please refer to the \nMarketplace\n for checking which VIM drivers are currently available.\n\n\nyes\n\n\n\n\n\n\nlocation\n\n\nThe location of the Point of PoP.\n\n\nno\n\n\n\n\n\n\n\n\nBy default we use only one tenant on your PoP. We are currently working on supporting the instantiation of different NSDs in different tenants. But it is possible to achieve this by creating two different PoPs with different names and the different tenants. \n\n\nRegister the PoP using the GUI\n\n\nIn order to make use of your VIM described within your JSON descriptor, you need to upload the VIM json file to the NFVO. \nYou can use the dashboard available at \nlocalhost:8080\n for this purpose. \nUnder the menu \nManage PoPs\n you can see the \nPoP instances\n. Click on the Register VIM button and upload your VIM descriptor. The following picture shows the dashboard: \n\n\n\n\nOnce the VIM instance is registered, it will appear on the list of available PoPs, filled with the information regarding the available images, networks and flavors. At this point the VIM/PoP can be included in your Network Service Descriptors.\n\n\nPlease note that the name chosen must be unique inside the project and will be used to refer to the VimInstance\n.\n\n\nFor more information about the dashboard see: \nOpenBaton Dashboard\n\n\n\n\n\n\n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Register a PoP"
        }, 
        {
            "location": "/vim-instance/#register-a-new-point-of-presence-pop", 
            "text": "The  Virtualised Infrastructure Manager  (Vim) is the functional block, responsible for controlling and managing the\n NFVI compute, storage and network resources within a Point of Presence (PoP).  In order to interoperate with a PoP it is required to register the VIM instance responsible for it to the NFVO. Assuming that you already installed the proper VIM driver, in order to connect to the selected Point of Presence (PoP), you need to register it at the NFVO. For doing that you can write a JSON file containing the details of a VIM Instance like the one described below:   {  \n    name : vim-instance-name ,\n    authUrl : http://192.168.0.5:5000/v2.0 ,\n    tenant : tenantName ,\n    username : userName ,\n    password : password ,\n    keyPair : keyName ,\n    securityGroups :[  \n       securityName \n   ],\n    type : openstack ,\n    location :{  \n       name : Berlin ,\n       latitude : 52.525876 ,\n       longitude : 13.314400 \n   }\n}  Most of the parameters are based on the OpenStack VIM type, since OpenStack represents the standard de-facto VIM in the ETSI NFV specification.     Params  Meaning  Mandatory      name  The name of the Point of Presence, important for later on linking it into your VNFD  yes    authUrl  The endpoint for authentication  yes    tenant  The tenant name on which you plan to deploy your VNFs  yes    username  The name of the user able to access your VIM via its remote APIs (usually good to have admin rights)  yes    password  The password of the user able to access your VIM via its remote APIs  yes    keyPair  The keyPair  name  to get the access to the VMs (optional - mainly applicable to OpenStack)  yes    securityGroups  Use a Security group that provides a sets of IP filtering rules that are applied to an instance's networking (mainly applicable to OpenStack)  no    type  The type of the VIM Instance you are using. This information will be used by the NFVO for locating the corresponding driver. Please refer to the  Marketplace  for checking which VIM drivers are currently available.  yes    location  The location of the Point of PoP.  no     By default we use only one tenant on your PoP. We are currently working on supporting the instantiation of different NSDs in different tenants. But it is possible to achieve this by creating two different PoPs with different names and the different tenants.", 
            "title": "Register a new Point of Presence (PoP)"
        }, 
        {
            "location": "/vim-instance/#register-the-pop-using-the-gui", 
            "text": "In order to make use of your VIM described within your JSON descriptor, you need to upload the VIM json file to the NFVO. \nYou can use the dashboard available at  localhost:8080  for this purpose. \nUnder the menu  Manage PoPs  you can see the  PoP instances . Click on the Register VIM button and upload your VIM descriptor. The following picture shows the dashboard:    Once the VIM instance is registered, it will appear on the list of available PoPs, filled with the information regarding the available images, networks and flavors. At this point the VIM/PoP can be included in your Network Service Descriptors.  Please note that the name chosen must be unique inside the project and will be used to refer to the VimInstance .  For more information about the dashboard see:  OpenBaton Dashboard   \n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Register the PoP using the GUI"
        }, 
        {
            "location": "/vnf-package/", 
            "text": "VNF Package\n\n\nThis doc describes essential components of a VNF Package, how to create them and how to use them after onboarding.\nTherefore, you can find a practical tutorial at the end with all the steps starting from the creation over onboarding and finally referencing it by an NSD.\n\n\nThe NFVO can also work with CSAR as described in the \nTosca simple profile for NFV\n. More information about building and deploying compliant CSARs in this \ntutorial\n.\n\n\nA VNF Package is a tar-archive that contains all the information required for creating a VNF for the Open Baton's NFVO.\nAfter onboarding the VNF Package to the NFVO you can use the VNF directly in the NSD by referencing the VNFD by its ID.\nA VNF Package includes the VNFD, the image, scripts and a Metadata file structured as shown in the next part.\n\n\nPackage structure\n\n\nThe VNF Package has the following structure:\n\n\n- Metadata.yaml\n- vnfd.json\n- scripts/\n    - 1_script.sh\n    - 2_script.sh\n- image.img (not supported at the moment, use image-link!)\n\n\n\n\nMetadata.yaml\n\n\nThe Metadata.yaml defines essential properties for the VNF. This file is based on the YAML syntax where information are stored in simple \nkey> : \nvalue> associations.\n\n\nThe example of the Metadata file below shows a basic definition of a VNF Package.\n\n\nname: VNF_package_name\nscripts-link: scripts_link\nvim_types: list_of_vim_types\ndescription: description_of_VNF\nprovider: provider_of_package\nnfvo_version: target_NFVO_version\nimage:\n    upload: option\n    ids: list_of_ids\n    names: list_of_names\n    link: image_link\nimage-config:\n    name: image_name\n    diskFormat: disk_format\n    containerFormat: container_format\n    minCPU: min_cpu\n    minDisk: min_disk\n    minRam: min_ram\n    isPublic: is_public\n\n\n\n\nIn the following each property is explained in more detail. Please consider also the notes since some properties are optional (or even not implemented) and if they are defined, they may have more priority than other and override them therefore.\n\n\n\n\nname\n: The name defines the name of the VNF Package itself used to store it in the database.\n\n\ndescription\n: Human readable description of the VNF.\n\n\nprovider\n: The creator and maintainer of the VNF.\n\n\nvim_types\n: The list of the vim types that the VNF Package supports.\n\n\nnfvo_version\n: The version of the NFVO which supports this package. First two digits will be used for the check.\n\n\nscripts-link\n: This link points to a public git repository where scripts are stored that are needed to be executed for managing the lifecycle of the exposed VNF.\n\n\nNote\n Either you can define the scripts-link or put the scripts into the folder scripts/.\n    The scripts-link has a higher priority than the scripts located in the folder scripts/.\n    So if you set the scripts-link, the scripts in folder scripts/ are ignored completely.\n\n\nNote\n The scripts-link is processed by the Element Management System (EMS) in the meaning of fetching the files from that link.\n    So you need to take care about ensuring that the URL defined is available.\n\n\nNote\n Scripts are executed during different lifecycle-events.\n\n\n\n\n\n\nimage\n:\n\n\nupload\n: Here you can choose between different options (true, false, check).\n\n\ntrue: choosing this option means to upload the defined image on all the VimInstances. It does not matter if an image with the defined name exists or not.\n\n\nfalse: choosing this option means that you assume that the image (defined in the ids or names) is already present.\nIf the image does not exist, the VNF Package onboarding will throw an exception.\nIn this case the image (if defined) will be ignored.\n\n\ncheck: this option means that the VNF PackageManagement checks first if the image is available (defined in ids or names).\nIf the image does not exist, a new one with the image defined in the VNF Package will be created.\n\n\nNote\n Please use quotation marks for this option since the values are handled as strings internally.\nOtherwise true and false will be handled as a boolean that would lead to a faulty behavior when onboarding a new VNF Package.\n\n\n\n\n\n\nids\n: The list of image IDs is used to fetch the image from the corresponding VimInstance.\n    To do it, the manager iterates over all IDs and checks if an image with that ID exists on the VimInstance.\n    The defined IDs have a higher priority than the list of names.\n    We distinguish between the following cases:\n\n\nIf it finds no image with these IDs, it continues with the list of image names.\n\n\nIf it finds one image with these IDs, this image will be used.\n\n\nIf it finds multiple images with the same ID (should never happen) or multiple IDs matching to multiple images, an exception will be thrown because it is not clear which image to use.\n\n\n\n\n\n\nnames\n: The list of image names is used to fetch the image from the corresponding VimInstance.\n    To do it, manager iterates over all names and checks if an image with that name exists on the VimInstance.\n    The list of names have a lower priority than the list of IDs.\n    We distinguish between the following cases:\n\n\nIf it finds no image with that name, an exception will be thrown except you defined the upload option check.\nThen it will create a new image defined in the VNF Package.\n\n\nIf it finds one image, this image will be used.\n\n\nIf it finds multiple images with the same name or multiple names matching to multiple images, an exception will be thrown because it is not clear which image to use.\n\n\n\n\n\n\nlink\n: This link points to an image available at this URL used to upload the image to the cloud environment.\n\n\nNote\n Either you have to define the image link or put the image directly into the VNF Package if you want to upload a new Image to the VIM by using image upload option \ntrue\n or \ncheck\n.\n    Otherwise a NotFoundException will be thrown and the VNF Package will not be onboarded.\n    The image-link has a higher priority than the image stored in the VNF Package directly.\n\n\n*Note\n* At the moment it is only supported to upload an image by using the \nlink\n. Image uploading from an image inside the package is disabled.\n\n\n\n\n\n\n\n\n\n\nimage-config\n: All the properties explained below are required to upload the image to the cloud environment properly.\n    In case of creating a new image this configuration will be used and is obviously mandatory.\n\n\nname\n: This defines the name for the image to upload either located directly in the VNF Package or available via the URL defined in image-link.\n\n\ndiskFormat\n: The diskFormat defines the format in which disk type the image is stored.\n\n\ncontainerFormat\n: The containerFormat defines the format in which container type the image is stored .\n\n\nminCPU\n: The minCPU defines the minimum amount of CPU cores for using this image properly.\n\n\nminDisk\n: The minDisk defines the minimum amount of disk space for using this image properly.\n\n\nminRam\n: The minRam defines the minimum amount of RAM for using this image properly.\n\n\nisPublic\n: The isPublic defines whether the image is available public or not.\n\n\n\n\n\n\n\n\nVNFD>.json\n\n\nThe \nvnfd>.json contains the VirtualNetworkFunctionDescriptor (VNFD) onboarded to the Orchestrator.\nThis VNFD can later be referenced in a NSD by its ID to make use of it.\nA more detailed explanation of the VNFD can be found \nhere\n.\n\n\nNote\n The name of the file is not is up to you but the file extension .json is must be present since the VNFPackageManagement is looking for this kind of file.\n\n\nscripts\n\n\nThe scripts folder contains all the scripts required for starting, configuring or whatever you want to do on the running instance during specific lifecycles.\nThe execution order is defined by the lifecycle_events inside the VNFD.\nThis lifecycle_events are triggered by the NFVO in the meaning of: if the event \"INSTANTIATE\" contains a script in the lifecycle_events, this script is executed when the NFVO calls the instantiate method for the specific VNFR.\n\n\nNote\n The scripts in the folder \nscripts\n are fetched only if the \nscripts-link\n is not defined in the \nMetadata.yaml\n.\n    This means that the scripts in that folder have less priority than the scripts located under \nscripts-link\n.\n\n\nNote\n Scripts are executed when a specific Event is fired and this Event references to specific scripts.\n\nNote\n The \nscripts\n folder cannot contain subfolder. All scripts must be under the \nscripts\n folder.\n\nNote\n The scripts inside the \nscripts\n folder can be either shell scripts or python scripts. In both cases the parameters are passed as environment variables.\n\n\nimage>.img\n\n\nNote\n At the moment it is only supported to upload an image by using the \nlink\n defined in \nMetadata.yaml\n. Image uploading from an image inside the package is disabled.\n\n\nThis image is used for uploading it to all the cloud environments which are addressed inside the VNFD with that image.\nIt doesn't matter whether an image already exists on the considered cloud environment or not.\n\n\nNote\n This image has lower priority than the \nimage-links\n defined in \nMetadata.yaml\n.\n    This means that the image will be ignored if the \nimage-links\n is defined.\n\n\nNote\n The name of the image doesn't matter but the suffix .img since the VNFPackageManagement is looking for a file with this suffix.\n    However, the name and all the properties for storing it on the cloud environment are defined in \nMetadata.yaml\n under the key \nimage\n.\n\n\nTutorial\n\n\nThis section explains how to create, upload and make use of VNF Packages.\nThe chosen scenario is a Network Service for testing the network connectivity by using \niPerf\n.\niPerf is a tool for active measurements of the maximum achievable bandwidth on IP networks.\nTherefore, we need a server and a client installing the iPerf server/client and configuring them for communication between.\n\n\nCreation of VNF Packages\n\n\nFor doing so, we need to create two VNF Packages and reference them in the NSD.\nSo we need a VNF Package for the iperf server (called iperf-server) and for the iperf client (called iperf-client).\nFirst we will start with the creation of the iperf-server VNF Package and then we will create the iperf-client VNF Package.\n\n\nFirst of all we should create a directory for each VNF Package where we put all the files related to the VNF Package because in the end we need to pack them into a tar archive for onboarding it on the NFVO.\n\n\nVNF Package [iperf-server]\n\n\nThis iperf-server VNF Package has to install the iperf server and needs to provide its ip to the iperf client.\n\n\nMetadata [iperf-server]\n\n\nIn the Metadata.yaml we define the name of the VNF Package, the scripts location and also the properties for the image to use or upload.\nSince passing an image is not supported in the current release we will use the image link inside the \nMetadata.yaml\n.\nFinally, it looks as shown below.\n\n\nname: iperf-server\ndescription: iPerf server\nprovider: FOKUS\nscripts-link: https://script-link-to-git.git\nnfvo_version: 3.2.0\nvim_types:\n - openstack\nimage:\n    upload: \ncheck\n\n    names:\n        - iperf_server_image\n    link: \nhttp://cloud-images.ubuntu.com/trusty/current/trusty-server-cloudimg-amd64-disk1.img\n\nimage-config:\n    name: iperf_server_image\n    diskFormat: QCOW2\n    containerFormat: BARE\n    minCPU: 2\n    minDisk: 5\n    minRam: 2048\n    isPublic: false\nvim_types:\n    - openstack\n\n\n\n\nVNFD [iperf-server]\n\n\nThis is how the \nVNFD\n looks like for the iperf-server VNF Package.\nImportant to notice here is that the vm_image defined in the Metadata.yaml is filled automatically during the onboarding process of the VNF Package.\n\n\n{\n  \nname\n:\niperf-server\n,\n  \nvendor\n:\nFOKUS\n,\n  \nversion\n:\n1.0\n,\n  \nlifecycle_event\n:[\n    {\n      \nevent\n:\nINSTANTIATE\n,\n      \nlifecycle_events\n:[\n        \ninstall.sh\n,\n        \ninstall-srv.sh\n\n      ]\n    }\n  ],\n  \nvirtual_link\n:[\n    {\n      \nname\n:\nprivate\n\n    }\n  ],\n  \nvdu\n:[\n    {\n      \nvm_image\n:[\n      ],\n      \nscale_in_out\n:1,\n      \nvnfc\n:[\n        {\n          \nconnection_point\n:[\n            {\n              \nvirtual_link_reference\n:\nprivate\n\n            }\n          ]\n        }\n      ],\n      \nvimInstanceName\n:[]\n    }\n  ],\n  \ndeployment_flavour\n:[\n    {\n      \nflavour_key\n:\nm1.small\n\n    }\n  ],\n  \ntype\n:\nserver\n,\n  \nendpoint\n:\ngeneric\n,\n  \nvnfPackageLocation\n:\nhttps://github.com/openbaton/vnf-scripts.git\n\n}\n\n\n\n\nImage\n\n\nThe image we have to choose must be a debian 64bit image (e.g. ubuntu amd64) for satisfying the EMS and scripts which are designed for that kind of image.\nWe have chosen this one \ntrusty-server-cloudimg-amd64-disk1.img\n.\n\n\nVNF Package [iperf-client]\n\n\nThis iperf-client VNF Package has to install the iPerf client and needs to be configured in order to know the iPerf servers' IP.\n\n\nMetadata [iperf-client]\n\n\nIn the Metadata.yaml we define the name of the VNF Package, the scripts location and also the properties for the image to upload.\nSince passing an image is not supported in the current release we will use the image link inside the \nMetadata.yaml\n.\nFinally, it looks as shown below.\n\n\nname: iperf-client\ndescription: iPerf client\nprovider: FOKUS\nnfvo_version: 3.2.0\nvim_types:\n - openstack\nscripts-link: https://gitlab.fokus.fraunhofer.de/openbaton/scripts-test-public.git\nimage:\n    upload: \ncheck\n\n    names:\n        - iperf_client_image\n    link: \nhttp://cloud-images.ubuntu.com/trusty/current/trusty-server-cloudimg-amd64-disk1.img\n\nimage-config:\n    name: iperf_client_image\n    diskFormat: QCOW2\n    containerFormat: BARE\n    minCPU: 2\n    minDisk: 5\n    minRam: 2048\n    isPublic: false\nvim_types:\n    - openstack\n\n\n\n\nVNFD [iperf-client]\n\n\nThis is how the \nVNFD\n looks like for the iperf-client VNF Package.\nImportant to notice here is that the vm_image defined in the Metadata.yaml is filled automatically during the onboarding process of the VNF Package.\n\n\n{\n  \nname\n:\niperf-client\n,\n  \nvendor\n:\nFOKUS\n,\n  \nversion\n:\n1.0\n,\n  \nlifecycle_event\n:[\n    {\n      \nevent\n:\nCONFIGURE\n,\n      \nlifecycle_events\n:[\n        \nserver_configure.sh\n\n      ]\n    },\n    {\n      \nevent\n:\nINSTANTIATE\n,\n      \nlifecycle_events\n:[\n        \ninstall.sh\n\n      ]\n    }\n  ],\n  \nvdu\n:[\n    {\n      \nvm_image\n:[\n        \n\n      ],\n      \nscale_in_out\n:1,\n      \nvnfc\n:[\n        {\n          \nconnection_point\n:[\n            {\n              \nvirtual_link_reference\n:\nprivate\n\n            }\n          ]\n        }\n      ],\n      \nvimInstanceName\n:[]\n    }\n  ],\n  \nvirtual_link\n:[\n    {\n      \nname\n:\nprivate\n\n    }\n  ],\n  \ndeployment_flavour\n:[\n    {\n      \nflavour_key\n:\nm1.small\n\n    }\n  ],\n  \ntype\n:\nclient\n,\n  \nendpoint\n:\ngeneric\n,\n  \nvnfPackageLocation\n:\nhttps://github.com/openbaton/vnf-scripts.git\n\n}\n\n\n\n\nImage\n\n\nThe image we have to choose must be a debian 64bit image (e.g. ubuntu amd64) for satisfying the EMS and scripts which are designed for that kind of architecture.\nWe have chosen this one \ntrusty-server-cloudimg-amd64-disk1.img\n.\n\n\nOnboarding VNF Packages\n\n\nOnce we have finalized the creation of VNF Packages and packed them into a tar we can onboard them to the NFVO. Make sure that you also uploaded a VimInstance before onboarding the package. Onboarding can be done easily via the \nDashboard\n or the \nCommand Line Interface\n.\n\n\nNSD [iperf]\n\n\nIn this section we will create a \nNSD\n and reference the previously created VNF Packages by their IDs.\nFor doing that we just need to define the \nid\n for each VNFPackges' VNFD in the list of VNFDs.\nTo provide also the iperf-servers' IP to the iperf-client we need to define dependencies you can find under the key \nvnf_dependency\n setting the source to \niperf-server\n and the target to \niperf-client\n by providing the parameter \nprivate\n that indicates the private IP address of the iPerf server in the network \"private\".\n\n\nNote\n When creating the NSD the VNFD is fetched by the ID defined. Other properties we would set in the VNFD in this NSD will be ignored.\n\n\n{\n    \nname\n:\niperf\n,\n    \nvendor\n:\nfokus\n,\n    \nversion\n:\n0.1-ALPHA\n,\n    \nvnfd\n:[\n        {\n            \nid\n:\n29d918b9-6245-4dc4-abc6-b7dd6e84f2c1\n\n        },\n        {\n            \nid\n:\n87820607-4048-4fad-b02b-dbcab8bb5c1c\n\n        }\n    ],\n    \nvld\n:[\n        {\n            \nname\n:\nprivate\n\n        }\n    ],\n    \nvnf_dependency\n:[\n        {\n            \nsource\n : {\n                \nname\n: \niperf-server\n\n            },\n            \ntarget\n:{\n                \nname\n: \niperf-client\n\n            },\n            \nparameters\n:[\n                \nprivate\n\n            ]\n        }\n    ]\n}\n\n\n\n\nFinally you can onboard this NSD and deploy an NSR that bases on both VNF Packages created before.\n\n\nOnboarding and deploying NSD\n\n\nYou could also use the \nDashboard\n or the \nCommand Line Interface\n as well for onboarding and deploying the NSD.\n\n\n\n\n\n\n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "VNF Packages"
        }, 
        {
            "location": "/vnf-package/#vnf-package", 
            "text": "This doc describes essential components of a VNF Package, how to create them and how to use them after onboarding.\nTherefore, you can find a practical tutorial at the end with all the steps starting from the creation over onboarding and finally referencing it by an NSD.  The NFVO can also work with CSAR as described in the  Tosca simple profile for NFV . More information about building and deploying compliant CSARs in this  tutorial .  A VNF Package is a tar-archive that contains all the information required for creating a VNF for the Open Baton's NFVO.\nAfter onboarding the VNF Package to the NFVO you can use the VNF directly in the NSD by referencing the VNFD by its ID.\nA VNF Package includes the VNFD, the image, scripts and a Metadata file structured as shown in the next part.", 
            "title": "VNF Package"
        }, 
        {
            "location": "/vnf-package/#package-structure", 
            "text": "The VNF Package has the following structure:  - Metadata.yaml\n- vnfd.json\n- scripts/\n    - 1_script.sh\n    - 2_script.sh\n- image.img (not supported at the moment, use image-link!)", 
            "title": "Package structure"
        }, 
        {
            "location": "/vnf-package/#metadatayaml", 
            "text": "The Metadata.yaml defines essential properties for the VNF. This file is based on the YAML syntax where information are stored in simple  key> :  value> associations.  The example of the Metadata file below shows a basic definition of a VNF Package.  name: VNF_package_name\nscripts-link: scripts_link\nvim_types: list_of_vim_types\ndescription: description_of_VNF\nprovider: provider_of_package\nnfvo_version: target_NFVO_version\nimage:\n    upload: option\n    ids: list_of_ids\n    names: list_of_names\n    link: image_link\nimage-config:\n    name: image_name\n    diskFormat: disk_format\n    containerFormat: container_format\n    minCPU: min_cpu\n    minDisk: min_disk\n    minRam: min_ram\n    isPublic: is_public  In the following each property is explained in more detail. Please consider also the notes since some properties are optional (or even not implemented) and if they are defined, they may have more priority than other and override them therefore.   name : The name defines the name of the VNF Package itself used to store it in the database.  description : Human readable description of the VNF.  provider : The creator and maintainer of the VNF.  vim_types : The list of the vim types that the VNF Package supports.  nfvo_version : The version of the NFVO which supports this package. First two digits will be used for the check.  scripts-link : This link points to a public git repository where scripts are stored that are needed to be executed for managing the lifecycle of the exposed VNF.  Note  Either you can define the scripts-link or put the scripts into the folder scripts/.\n    The scripts-link has a higher priority than the scripts located in the folder scripts/.\n    So if you set the scripts-link, the scripts in folder scripts/ are ignored completely.  Note  The scripts-link is processed by the Element Management System (EMS) in the meaning of fetching the files from that link.\n    So you need to take care about ensuring that the URL defined is available.  Note  Scripts are executed during different lifecycle-events.    image :  upload : Here you can choose between different options (true, false, check).  true: choosing this option means to upload the defined image on all the VimInstances. It does not matter if an image with the defined name exists or not.  false: choosing this option means that you assume that the image (defined in the ids or names) is already present.\nIf the image does not exist, the VNF Package onboarding will throw an exception.\nIn this case the image (if defined) will be ignored.  check: this option means that the VNF PackageManagement checks first if the image is available (defined in ids or names).\nIf the image does not exist, a new one with the image defined in the VNF Package will be created.  Note  Please use quotation marks for this option since the values are handled as strings internally.\nOtherwise true and false will be handled as a boolean that would lead to a faulty behavior when onboarding a new VNF Package.    ids : The list of image IDs is used to fetch the image from the corresponding VimInstance.\n    To do it, the manager iterates over all IDs and checks if an image with that ID exists on the VimInstance.\n    The defined IDs have a higher priority than the list of names.\n    We distinguish between the following cases:  If it finds no image with these IDs, it continues with the list of image names.  If it finds one image with these IDs, this image will be used.  If it finds multiple images with the same ID (should never happen) or multiple IDs matching to multiple images, an exception will be thrown because it is not clear which image to use.    names : The list of image names is used to fetch the image from the corresponding VimInstance.\n    To do it, manager iterates over all names and checks if an image with that name exists on the VimInstance.\n    The list of names have a lower priority than the list of IDs.\n    We distinguish between the following cases:  If it finds no image with that name, an exception will be thrown except you defined the upload option check.\nThen it will create a new image defined in the VNF Package.  If it finds one image, this image will be used.  If it finds multiple images with the same name or multiple names matching to multiple images, an exception will be thrown because it is not clear which image to use.    link : This link points to an image available at this URL used to upload the image to the cloud environment.  Note  Either you have to define the image link or put the image directly into the VNF Package if you want to upload a new Image to the VIM by using image upload option  true  or  check .\n    Otherwise a NotFoundException will be thrown and the VNF Package will not be onboarded.\n    The image-link has a higher priority than the image stored in the VNF Package directly.  *Note * At the moment it is only supported to upload an image by using the  link . Image uploading from an image inside the package is disabled.      image-config : All the properties explained below are required to upload the image to the cloud environment properly.\n    In case of creating a new image this configuration will be used and is obviously mandatory.  name : This defines the name for the image to upload either located directly in the VNF Package or available via the URL defined in image-link.  diskFormat : The diskFormat defines the format in which disk type the image is stored.  containerFormat : The containerFormat defines the format in which container type the image is stored .  minCPU : The minCPU defines the minimum amount of CPU cores for using this image properly.  minDisk : The minDisk defines the minimum amount of disk space for using this image properly.  minRam : The minRam defines the minimum amount of RAM for using this image properly.  isPublic : The isPublic defines whether the image is available public or not.", 
            "title": "Metadata.yaml"
        }, 
        {
            "location": "/vnf-package/#vnfd62json", 
            "text": "The  vnfd>.json contains the VirtualNetworkFunctionDescriptor (VNFD) onboarded to the Orchestrator.\nThis VNFD can later be referenced in a NSD by its ID to make use of it.\nA more detailed explanation of the VNFD can be found  here .  Note  The name of the file is not is up to you but the file extension .json is must be present since the VNFPackageManagement is looking for this kind of file.", 
            "title": "&lt;VNFD>.json"
        }, 
        {
            "location": "/vnf-package/#scripts", 
            "text": "The scripts folder contains all the scripts required for starting, configuring or whatever you want to do on the running instance during specific lifecycles.\nThe execution order is defined by the lifecycle_events inside the VNFD.\nThis lifecycle_events are triggered by the NFVO in the meaning of: if the event \"INSTANTIATE\" contains a script in the lifecycle_events, this script is executed when the NFVO calls the instantiate method for the specific VNFR.  Note  The scripts in the folder  scripts  are fetched only if the  scripts-link  is not defined in the  Metadata.yaml .\n    This means that the scripts in that folder have less priority than the scripts located under  scripts-link .  Note  Scripts are executed when a specific Event is fired and this Event references to specific scripts. Note  The  scripts  folder cannot contain subfolder. All scripts must be under the  scripts  folder. Note  The scripts inside the  scripts  folder can be either shell scripts or python scripts. In both cases the parameters are passed as environment variables.", 
            "title": "scripts"
        }, 
        {
            "location": "/vnf-package/#image62img", 
            "text": "Note  At the moment it is only supported to upload an image by using the  link  defined in  Metadata.yaml . Image uploading from an image inside the package is disabled.  This image is used for uploading it to all the cloud environments which are addressed inside the VNFD with that image.\nIt doesn't matter whether an image already exists on the considered cloud environment or not.  Note  This image has lower priority than the  image-links  defined in  Metadata.yaml .\n    This means that the image will be ignored if the  image-links  is defined.  Note  The name of the image doesn't matter but the suffix .img since the VNFPackageManagement is looking for a file with this suffix.\n    However, the name and all the properties for storing it on the cloud environment are defined in  Metadata.yaml  under the key  image .", 
            "title": "&lt;image>.img"
        }, 
        {
            "location": "/vnf-package/#tutorial", 
            "text": "This section explains how to create, upload and make use of VNF Packages.\nThe chosen scenario is a Network Service for testing the network connectivity by using  iPerf .\niPerf is a tool for active measurements of the maximum achievable bandwidth on IP networks.\nTherefore, we need a server and a client installing the iPerf server/client and configuring them for communication between.", 
            "title": "Tutorial"
        }, 
        {
            "location": "/vnf-package/#creation-of-vnf-packages", 
            "text": "For doing so, we need to create two VNF Packages and reference them in the NSD.\nSo we need a VNF Package for the iperf server (called iperf-server) and for the iperf client (called iperf-client).\nFirst we will start with the creation of the iperf-server VNF Package and then we will create the iperf-client VNF Package.  First of all we should create a directory for each VNF Package where we put all the files related to the VNF Package because in the end we need to pack them into a tar archive for onboarding it on the NFVO.", 
            "title": "Creation of VNF Packages"
        }, 
        {
            "location": "/vnf-package/#vnf-package-iperf-server", 
            "text": "This iperf-server VNF Package has to install the iperf server and needs to provide its ip to the iperf client.", 
            "title": "VNF Package [iperf-server]"
        }, 
        {
            "location": "/vnf-package/#metadata-iperf-server", 
            "text": "In the Metadata.yaml we define the name of the VNF Package, the scripts location and also the properties for the image to use or upload.\nSince passing an image is not supported in the current release we will use the image link inside the  Metadata.yaml .\nFinally, it looks as shown below.  name: iperf-server\ndescription: iPerf server\nprovider: FOKUS\nscripts-link: https://script-link-to-git.git\nnfvo_version: 3.2.0\nvim_types:\n - openstack\nimage:\n    upload:  check \n    names:\n        - iperf_server_image\n    link:  http://cloud-images.ubuntu.com/trusty/current/trusty-server-cloudimg-amd64-disk1.img \nimage-config:\n    name: iperf_server_image\n    diskFormat: QCOW2\n    containerFormat: BARE\n    minCPU: 2\n    minDisk: 5\n    minRam: 2048\n    isPublic: false\nvim_types:\n    - openstack", 
            "title": "Metadata [iperf-server]"
        }, 
        {
            "location": "/vnf-package/#vnfd-iperf-server", 
            "text": "This is how the  VNFD  looks like for the iperf-server VNF Package.\nImportant to notice here is that the vm_image defined in the Metadata.yaml is filled automatically during the onboarding process of the VNF Package.  {\n   name : iperf-server ,\n   vendor : FOKUS ,\n   version : 1.0 ,\n   lifecycle_event :[\n    {\n       event : INSTANTIATE ,\n       lifecycle_events :[\n         install.sh ,\n         install-srv.sh \n      ]\n    }\n  ],\n   virtual_link :[\n    {\n       name : private \n    }\n  ],\n   vdu :[\n    {\n       vm_image :[\n      ],\n       scale_in_out :1,\n       vnfc :[\n        {\n           connection_point :[\n            {\n               virtual_link_reference : private \n            }\n          ]\n        }\n      ],\n       vimInstanceName :[]\n    }\n  ],\n   deployment_flavour :[\n    {\n       flavour_key : m1.small \n    }\n  ],\n   type : server ,\n   endpoint : generic ,\n   vnfPackageLocation : https://github.com/openbaton/vnf-scripts.git \n}", 
            "title": "VNFD [iperf-server]"
        }, 
        {
            "location": "/vnf-package/#image", 
            "text": "The image we have to choose must be a debian 64bit image (e.g. ubuntu amd64) for satisfying the EMS and scripts which are designed for that kind of image.\nWe have chosen this one  trusty-server-cloudimg-amd64-disk1.img .", 
            "title": "Image"
        }, 
        {
            "location": "/vnf-package/#vnf-package-iperf-client", 
            "text": "This iperf-client VNF Package has to install the iPerf client and needs to be configured in order to know the iPerf servers' IP.", 
            "title": "VNF Package [iperf-client]"
        }, 
        {
            "location": "/vnf-package/#metadata-iperf-client", 
            "text": "In the Metadata.yaml we define the name of the VNF Package, the scripts location and also the properties for the image to upload.\nSince passing an image is not supported in the current release we will use the image link inside the  Metadata.yaml .\nFinally, it looks as shown below.  name: iperf-client\ndescription: iPerf client\nprovider: FOKUS\nnfvo_version: 3.2.0\nvim_types:\n - openstack\nscripts-link: https://gitlab.fokus.fraunhofer.de/openbaton/scripts-test-public.git\nimage:\n    upload:  check \n    names:\n        - iperf_client_image\n    link:  http://cloud-images.ubuntu.com/trusty/current/trusty-server-cloudimg-amd64-disk1.img \nimage-config:\n    name: iperf_client_image\n    diskFormat: QCOW2\n    containerFormat: BARE\n    minCPU: 2\n    minDisk: 5\n    minRam: 2048\n    isPublic: false\nvim_types:\n    - openstack", 
            "title": "Metadata [iperf-client]"
        }, 
        {
            "location": "/vnf-package/#vnfd-iperf-client", 
            "text": "This is how the  VNFD  looks like for the iperf-client VNF Package.\nImportant to notice here is that the vm_image defined in the Metadata.yaml is filled automatically during the onboarding process of the VNF Package.  {\n   name : iperf-client ,\n   vendor : FOKUS ,\n   version : 1.0 ,\n   lifecycle_event :[\n    {\n       event : CONFIGURE ,\n       lifecycle_events :[\n         server_configure.sh \n      ]\n    },\n    {\n       event : INSTANTIATE ,\n       lifecycle_events :[\n         install.sh \n      ]\n    }\n  ],\n   vdu :[\n    {\n       vm_image :[\n         \n      ],\n       scale_in_out :1,\n       vnfc :[\n        {\n           connection_point :[\n            {\n               virtual_link_reference : private \n            }\n          ]\n        }\n      ],\n       vimInstanceName :[]\n    }\n  ],\n   virtual_link :[\n    {\n       name : private \n    }\n  ],\n   deployment_flavour :[\n    {\n       flavour_key : m1.small \n    }\n  ],\n   type : client ,\n   endpoint : generic ,\n   vnfPackageLocation : https://github.com/openbaton/vnf-scripts.git \n}", 
            "title": "VNFD [iperf-client]"
        }, 
        {
            "location": "/vnf-package/#image_1", 
            "text": "The image we have to choose must be a debian 64bit image (e.g. ubuntu amd64) for satisfying the EMS and scripts which are designed for that kind of architecture.\nWe have chosen this one  trusty-server-cloudimg-amd64-disk1.img .", 
            "title": "Image"
        }, 
        {
            "location": "/vnf-package/#onboarding-vnf-packages", 
            "text": "Once we have finalized the creation of VNF Packages and packed them into a tar we can onboard them to the NFVO. Make sure that you also uploaded a VimInstance before onboarding the package. Onboarding can be done easily via the  Dashboard  or the  Command Line Interface .", 
            "title": "Onboarding VNF Packages"
        }, 
        {
            "location": "/vnf-package/#nsd-iperf", 
            "text": "In this section we will create a  NSD  and reference the previously created VNF Packages by their IDs.\nFor doing that we just need to define the  id  for each VNFPackges' VNFD in the list of VNFDs.\nTo provide also the iperf-servers' IP to the iperf-client we need to define dependencies you can find under the key  vnf_dependency  setting the source to  iperf-server  and the target to  iperf-client  by providing the parameter  private  that indicates the private IP address of the iPerf server in the network \"private\".  Note  When creating the NSD the VNFD is fetched by the ID defined. Other properties we would set in the VNFD in this NSD will be ignored.  {\n     name : iperf ,\n     vendor : fokus ,\n     version : 0.1-ALPHA ,\n     vnfd :[\n        {\n             id : 29d918b9-6245-4dc4-abc6-b7dd6e84f2c1 \n        },\n        {\n             id : 87820607-4048-4fad-b02b-dbcab8bb5c1c \n        }\n    ],\n     vld :[\n        {\n             name : private \n        }\n    ],\n     vnf_dependency :[\n        {\n             source  : {\n                 name :  iperf-server \n            },\n             target :{\n                 name :  iperf-client \n            },\n             parameters :[\n                 private \n            ]\n        }\n    ]\n}  Finally you can onboard this NSD and deploy an NSR that bases on both VNF Packages created before.", 
            "title": "NSD [iperf]"
        }, 
        {
            "location": "/vnf-package/#onboarding-and-deploying-nsd", 
            "text": "You could also use the  Dashboard  or the  Command Line Interface  as well for onboarding and deploying the NSD.   \n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Onboarding and deploying NSD"
        }, 
        {
            "location": "/ns-descriptor/", 
            "text": "Network Service Descriptor\n\n\nThe Network Service Descriptor contains the values that are defined in \nETSI MANO specification\n. The NFVO is able to handle JSON file describing a Network Service Descriptor.\n\n\nThe NFVO can also handle onboarding a Network Service Template inside a CSAR compliant with the \nTOSCA Simple Profile for NFV\n. Refer to the \nNS Template tutorial\n and \nCSAR Onboarding tutorial\n.\n\n\nAn example of the most important fields follows:\n\n\n{  \n    \nname\n:\niperf-NSD\n,\n    \nvendor\n:\nfokus\n,\n    \nversion\n:\n0.1-ALPHA\n,\n    \nvnfd\n:[  ...  ],\n    \nvld\n:[  \n        {  \n            \nname\n:\nprivate\n\n        }\n    ],\n    \nvnf_dependency\n:[\n        {\n            \nsource\n : {\n                \nname\n: \niperf-server\n\n            },\n            \ntarget\n:{\n                \nname\n: \niperf-client\n\n            },\n            \nparameters\n:[\n                \nprivate\n\n            ]\n        }\n    ]\n}\n\n\n\n\nYou can see a complete NSD json \nhere\n.\n\n\n\n\n\n\n\n\nParams\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\nname\n\n\nThe name to give to the NetworkServiceDescriptor\n\n\n\n\n\n\nvendor\n\n\nThe vendor creating this NetworkServiceDescriptor\n\n\n\n\n\n\nversion\n\n\nThe version of the NetworkServiceDescriptor (can be any string)\n\n\n\n\n\n\nvnfd\n\n\nA list of VirtualNetworkFunctionDescriptors (see \nVirtualNetworkFunctionDescriptor\n)\n\n\n\n\n\n\nvld\n\n\nA list of VirtualLinkDescriptors\n\n\n\n\n\n\nvnf_dependency\n\n\nA list of VNF_Dependencies (\nNot mandatory\n, please check the \nvnfd page\n in order to understand how to get rid of it)\n\n\n\n\n\n\n\n\nVirtualLinkDescriptor\n\n\nThe Virtual Link Descriptor (VLD) describes the basic topology of the connectivity between one or more VNFs connected to this VL.\nThe VLD must contain a parameter \nname\n with the value of a network that will be used by the VirtualNetworkFunctionDescriptors.\nIf the network exists, then this network will be used, if not a new one will be created.\n\n\nVNF Dependencies\n\n\nA VNF Dependency is composed by:\n\n\n\n\n\n\n\n\nParams\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\nsource\n\n\nThe name of the VirtualNetworkFunctionDescriptor that provides one or more parameters (see \nVNFManager Generic\n and \nVNF Parameters\n)\n\n\n\n\n\n\ntarget\n\n\nThe name of the VirtualNetworkFunctionDescriptor that requires one or more parameters (see \nVNFManager Generic\n and \nVNF Parameters\n)\n\n\n\n\n\n\nparameters\n\n\nThe name of the parameters that the \ntarget\n requires\n\n\n\n\n\n\n\n\nIt is possible to let the Orchestrator to calculate dependencies automatically by providing some parameters in the VNF Descriptor part. Please check the \nVNF Descriptor page\n\n\nNetwork Service Onboarding\n\n\nAfter saving the NSD as json you could easily upload it via the \nDashboard\n or the \nCommand Line Interface\n. \n\n\n\n\n\n\n\n\n\n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Network Service Descriptor"
        }, 
        {
            "location": "/ns-descriptor/#network-service-descriptor", 
            "text": "The Network Service Descriptor contains the values that are defined in  ETSI MANO specification . The NFVO is able to handle JSON file describing a Network Service Descriptor.  The NFVO can also handle onboarding a Network Service Template inside a CSAR compliant with the  TOSCA Simple Profile for NFV . Refer to the  NS Template tutorial  and  CSAR Onboarding tutorial .  An example of the most important fields follows:  {  \n     name : iperf-NSD ,\n     vendor : fokus ,\n     version : 0.1-ALPHA ,\n     vnfd :[  ...  ],\n     vld :[  \n        {  \n             name : private \n        }\n    ],\n     vnf_dependency :[\n        {\n             source  : {\n                 name :  iperf-server \n            },\n             target :{\n                 name :  iperf-client \n            },\n             parameters :[\n                 private \n            ]\n        }\n    ]\n}  You can see a complete NSD json  here .     Params  Meaning      name  The name to give to the NetworkServiceDescriptor    vendor  The vendor creating this NetworkServiceDescriptor    version  The version of the NetworkServiceDescriptor (can be any string)    vnfd  A list of VirtualNetworkFunctionDescriptors (see  VirtualNetworkFunctionDescriptor )    vld  A list of VirtualLinkDescriptors    vnf_dependency  A list of VNF_Dependencies ( Not mandatory , please check the  vnfd page  in order to understand how to get rid of it)", 
            "title": "Network Service Descriptor"
        }, 
        {
            "location": "/ns-descriptor/#virtuallinkdescriptor", 
            "text": "The Virtual Link Descriptor (VLD) describes the basic topology of the connectivity between one or more VNFs connected to this VL.\nThe VLD must contain a parameter  name  with the value of a network that will be used by the VirtualNetworkFunctionDescriptors.\nIf the network exists, then this network will be used, if not a new one will be created.", 
            "title": "VirtualLinkDescriptor"
        }, 
        {
            "location": "/ns-descriptor/#vnf-dependencies", 
            "text": "A VNF Dependency is composed by:     Params  Meaning      source  The name of the VirtualNetworkFunctionDescriptor that provides one or more parameters (see  VNFManager Generic  and  VNF Parameters )    target  The name of the VirtualNetworkFunctionDescriptor that requires one or more parameters (see  VNFManager Generic  and  VNF Parameters )    parameters  The name of the parameters that the  target  requires     It is possible to let the Orchestrator to calculate dependencies automatically by providing some parameters in the VNF Descriptor part. Please check the  VNF Descriptor page", 
            "title": "VNF Dependencies"
        }, 
        {
            "location": "/ns-descriptor/#network-service-onboarding", 
            "text": "After saving the NSD as json you could easily upload it via the  Dashboard  or the  Command Line Interface .     \n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Network Service Onboarding"
        }, 
        {
            "location": "/vim-driver/", 
            "text": "VIM Drivers\n\n\nOpen Baton uses the Remote Procedure Call (RPC) mechanism for implementing VIM drivers. It offers an implementation of an interface that is used by the NFVO. \n\n\nWhat are the supported VIM types?\n\n\nBy default the NFVO is installed with the two following VIM drivers: \n\n\n\n\nopenstack: for interoperating with an OpenStack instance\n\n\ntest: for testing purposes implementing a VIM mockup\n\n\n\n\nFor each of those types there is a different implementation of the VIM API. The NFVO uses a driver mechanism for interacting with VIMs. Inside the NFVO folder is a folder called \nplugins\n where the binary file that implements the interface to your VIM ( i.e. \nOpenstack\n ) should be placed (you can change the folder where Open Baton searches for the plugins by changing the variable \nnfvo.plugin.installation-dir\n in the \nopenbaton.properties\n file under /etc/openbaton).\n\nThis binary file is the implementation of the interface that communicates with your VIM.\n\n\nNote\n: You can implement your own interface just follow the documentation on writing your own \nVIM driver\n.\n\n\nWhere can I find other open source VIM drivers?\n\n\nOpen Baton platform provides an openstack and a test plugin. They are automatically download by the bootstrap. During next releases there will be additional drivers available on our \nMarketplace", 
            "title": "VIM Driver Overview"
        }, 
        {
            "location": "/vim-driver/#vim-drivers", 
            "text": "Open Baton uses the Remote Procedure Call (RPC) mechanism for implementing VIM drivers. It offers an implementation of an interface that is used by the NFVO.", 
            "title": "VIM Drivers"
        }, 
        {
            "location": "/vim-driver/#what-are-the-supported-vim-types", 
            "text": "By default the NFVO is installed with the two following VIM drivers:    openstack: for interoperating with an OpenStack instance  test: for testing purposes implementing a VIM mockup   For each of those types there is a different implementation of the VIM API. The NFVO uses a driver mechanism for interacting with VIMs. Inside the NFVO folder is a folder called  plugins  where the binary file that implements the interface to your VIM ( i.e.  Openstack  ) should be placed (you can change the folder where Open Baton searches for the plugins by changing the variable  nfvo.plugin.installation-dir  in the  openbaton.properties  file under /etc/openbaton). \nThis binary file is the implementation of the interface that communicates with your VIM.  Note : You can implement your own interface just follow the documentation on writing your own  VIM driver .", 
            "title": "What are the supported VIM types?"
        }, 
        {
            "location": "/vim-driver/#where-can-i-find-other-open-source-vim-drivers", 
            "text": "Open Baton platform provides an openstack and a test plugin. They are automatically download by the bootstrap. During next releases there will be additional drivers available on our  Marketplace", 
            "title": "Where can I find other open source VIM drivers?"
        }, 
        {
            "location": "/vnfm-intro/", 
            "text": "Virtual Network Function Manager Approaches\n\n\nOpen Baton release 3 provides three different alternatives with regard to VNF Managers:  \n\n\n\n\nUse the Generic VNFM or Juju VNFM provided as part of the Open Baton project\n\n\nBuild a VNFM using the SDK in Java or Python\n\n\nUse your own VNFM connecting it to the NFVO via REST APIs or AMQP\n\n\n\n\nMain purposes of the approaches\n\n\n1. Use the Generic VNFM or Juju VNFM\n\n\nThis approach allows you to start immediately focusing mainly on the implementation of the VNF Package. Both VNF Manager supports the execution of VNF Packages CSAR based (please read more \nhere\n for more details about VNF Packaging). \n\n\nPlease refer to the following doc for more details: \nUse the generic VNFM\n or \nUse the Juju VNFM\n\n\n2. Build a VNFM using the SDK\n\n\nOpenbaton provides a Java SDK called vnfm-sdk which helps you to simply create a VNFM for your VNF.\nRegarding the type of the communication between the NFVO and the VNFM (Or-Vnfm), you can use the vnfm-sdk-amqp or vnfm-sdk-rest, depending if you prefer to communicate with AMQP or REST.\n\n\nPlease refer to the following doc for more details: \nBuild your own VNFM\n\n\n3. Use your own VNFM\n\n\nThis approach allows you to integrate your VNFM and VNF within Openbaton. In this case, the Or-Vnfm communication will be via REST interfaces.\n\n\nPlease refer to the following doc for more details: \nBring your own VNFM\n\n\nThe pages in this section describe in details these three different approaches.", 
            "title": "VNFM intro"
        }, 
        {
            "location": "/vnfm-intro/#virtual-network-function-manager-approaches", 
            "text": "Open Baton release 3 provides three different alternatives with regard to VNF Managers:     Use the Generic VNFM or Juju VNFM provided as part of the Open Baton project  Build a VNFM using the SDK in Java or Python  Use your own VNFM connecting it to the NFVO via REST APIs or AMQP", 
            "title": "Virtual Network Function Manager Approaches"
        }, 
        {
            "location": "/vnfm-intro/#main-purposes-of-the-approaches", 
            "text": "", 
            "title": "Main purposes of the approaches"
        }, 
        {
            "location": "/vnfm-intro/#1-use-the-generic-vnfm-or-juju-vnfm", 
            "text": "This approach allows you to start immediately focusing mainly on the implementation of the VNF Package. Both VNF Manager supports the execution of VNF Packages CSAR based (please read more  here  for more details about VNF Packaging).   Please refer to the following doc for more details:  Use the generic VNFM  or  Use the Juju VNFM", 
            "title": "1. Use the Generic VNFM or Juju VNFM"
        }, 
        {
            "location": "/vnfm-intro/#2-build-a-vnfm-using-the-sdk", 
            "text": "Openbaton provides a Java SDK called vnfm-sdk which helps you to simply create a VNFM for your VNF.\nRegarding the type of the communication between the NFVO and the VNFM (Or-Vnfm), you can use the vnfm-sdk-amqp or vnfm-sdk-rest, depending if you prefer to communicate with AMQP or REST.  Please refer to the following doc for more details:  Build your own VNFM", 
            "title": "2. Build a VNFM using the SDK"
        }, 
        {
            "location": "/vnfm-intro/#3-use-your-own-vnfm", 
            "text": "This approach allows you to integrate your VNFM and VNF within Openbaton. In this case, the Or-Vnfm communication will be via REST interfaces.  Please refer to the following doc for more details:  Bring your own VNFM  The pages in this section describe in details these three different approaches.", 
            "title": "3. Use your own VNFM"
        }, 
        {
            "location": "/vnfm-generic/", 
            "text": "Generic VNF Manager\n\n\nThe Generic VNF Manager is an implementation following the \nETSI MANO\n specifications. It works as intermediate component between the NFVO and the VNFs, particularly the Virtual Machines on top of which the VNF software is installed. In order to complete the lifecycle of a VNF, it interoperates with the Open Baton Element Management System (EMS) which acts as an agent inside the VMs and executing scripts contained in a VNF package or defined via the \nscripts-link\n inside the VNFD.\nThis VNFM may be assigned to the management of a single VNF instance, or the management of multiple VNF instances of the same type or of different types.\n\n\nThe Generic VNFM handles communication between the NFVO and the EMS. The communication NFVO \u2194 VNFM \u2194 EMS is done using the AMQP protocol over RabbitMQ.  \n\n\nThe communication between the NFVO and Generic VNFM:\n\n\n\n\nThe communication between the Generic VNFM and EMS:\n\n\n\n\nAs you can see, the Generic VNFM sends commands to the EMS, which is running in the VM. Then the EMS executes the commands (scripts) locally in the VNFC. \nPlease note that the EMS executes those scripts as root user\n.\nThe following sequence diagram explains the communication messages.\n\n\n\n\nThe Generic VNFManager is supposed to be used for any type of VNF that follows some conventions regarding:\n\n\n\n\nVMs deployment\n\n\nScript execution costraints\n\n\nVMs termination\n\n\n\n\nVMs deployment\n\n\nAccordingly to the \nETSI MANO B.3\n the VNF instantiation flows can be done in two ways:\n\n\n\n\nWith resource allocation done by NFVO\n\n\nWith resource allocation done by VNF Manager\n\n\n\n\nThe Generic VNFM follows the first approach. In the first approach two messages will be sent to the NFVO:\n\n\n\n\n\n\nGRANT_OPERATION message\n: check if the resources are available on the selected PoP. If the GRANT_OPERATION message is returned, then there are enough resources, otherwise an ERROR message will be sent. After the GRANT_OPERATION message it is possible to send the ALLOCATE_RESOURCE message.  \n\n\n\n\n\n\nALLOCATE_RESOURCE message\n: This message ask the NFVO to create all the resources and then, if no errors occurred, the ALLOCATE_RESOURCE message will be returned to the VNFManager. Only the VNFMs which follow the first approach need to send this message.\n\n\n\n\n\n\nAfter that point the VMs are created and \nthe VNF record is filled with values\n, such as ips, that can be found directly in the VirtualNetworkFunctionRecord\u2192VirtualDeploymentUnit\u2192VNFCInstance object.\n\n\nScript Execution Costraints\n\n\nFor each operation of the VNF Lifecycle Management interface, the VNFManager sends scripts to the EMS which executes them locally in the VMs.\n\n\nNote\n: The scripts come from the VNFPackage which you need to create (see \nVNFPackage documentation\n).\n\n\nThe ordering of this scripts is defined in the NetworkServiceDescriptor from which the NetworkServiceRecord was created, in particular into the NetworkServiceDescriptor\u2192VirtualNetworkFunctionDescriptor\u2192LifecycleEvents.\nHere an example (to make it more readable it is shown only the \nVNF lifecycle event\n part):\n\n\n{// NSD\n  ...\n  {// VNFD\n    ...\n    \nlifecycle_event\n:[\n        {\n            \nevent\n:\nINSTANTIATE\n,\n            \nlifecycle_events\n:[\n                \npre-install.sh\n,\n                \ninstall.sh\n\n            ]\n        },\n        {\n            \nevent\n:\nCONFIGURE\n,\n            \nlifecycle_events\n:[\n                \nserver_configure.sh\n\n            ]\n        },\n        {\n            \nevent\n:\nSTART\n,\n            \nlifecycle_events\n:[\n                 \nstart.sh\n\n            ]\n        },\n        {\n            \nevent\n:\nSTOP\n,\n            \nlifecycle_events\n:[\n                 \nstop.sh\n\n            ]\n        },\n        {\n            \nevent\n:\nTERMINATE\n,\n            \nlifecycle_events\n:[\n                 \nterminate.sh\n\n            ]\n        }\n    ],\n    ...\n  }\n  ...\n}\n\n\n\n\nIn the following table is described for each \nVNF lifecycle event\n when the scripts are executed.\n\n\n\n\n\n\n\n\nVNF Lifecycle event\n\n\nWhen scripts are executed\n\n\n\n\n\n\n\n\n\n\nINSTANTIATE\n\n\nDuring the instantiation of the corresponding VNF\n\n\n\n\n\n\nCONFIGURE\n\n\nAfter the instantiation. Useful if the VNF depends on other VNFs, because we can get parameters provided by them (e.g. IP). The parameters are available as environment variables (see later).\n\n\n\n\n\n\nSTART\n\n\nAfter the instantiation or configuration (It depends whether the event CONFIGURE specified).\n\n\n\n\n\n\nSTOP\n\n\nDuring the stop of the corresponding VNF\n\n\n\n\n\n\nTERMINATE\n\n\nDuring the termination of the corresponding VNF\n\n\n\n\n\n\nSCALE_IN\n\n\nWhen the VNF is target of a scaled in vnfcInstance\n\n\n\n\n\n\n\n\nThe available parameters are defined in the VirtualNetworkFunctionDescriptor fields:\n\n\n\n\n\n\n\nconfigurations\n: it contains specific parameters which you want to use in the scripts.\n\n\nout-of-the-box\n: the following parameters are automatically available into the scripts:  \n\n\nPrivate IP\n\n\nFloating IP (if requested)\n\n\nHostname  \n\n\n\n\n\n\n\n\nPlease check the example at the end of the page to understand this mechanism.\n\n\nIn the INSTANTIATE scripts, the parameters defined in these two fields are then available as environment variables into the script exactly as defined (i.e. you can get by $parameter_name).\n\n\nIn the MODIFY scripts, the INSTANTIATE parameters are still available but plus there are environment variables that come from other VNF sources, where they are specified in the provides field. \nThese kind of parameters are defined in the \nrequires\n fields (of the VNF target) and the VNFDependency\u2192parameters fields (of the NSD), and are then available as $\ntype_of_vnf_source\n_\nname_of_parameter\n (in the VNF target).\n\n\nNOTE\n: \nthe scripts in the CONFIGURE lifecycle event need to start with the type of the source VNF followed by _ (underscore) and the name of the script (i.e. server_configure.sh)\n\n\nVMs termination\n\n\nThe STOP lifecycle event is meant to just stop the VNF service and afterward be able to start it again. The TERMINATE lifecycle event delete the virtual resources from the PoP\nAs for VMs deployment, VMs termination is done by the NFVO. Specific scripts can be run before termination by putting them under the TERMINATE lifecycle event.\n\n\nLaunch the Generic VNFM\n\n\nPlease check also the \ninstallation page\n. To launch the Generic VNFM, execute the following command:\n\n\n$ cd \ngeneric directory\n\n$ ./generic-vnfm.sh start\n\n\n\n\nThe Generic VNFM can handle more than one VNF (in parallel) of the same or different type, so that you need to start only one Generic VNFM.\n\n\nEXAMPLE WITH DEPENDENCY AND SCRIPTS\n\n\nLet's see a simple example with two VNFs: vnf-server and vnf-database.\n\nThe vnf-server needs the ip of the vnf-database to be able to connect properly. The following figure shows the source (vnf-database), the target (vnf-server)\nand the dependency (IP). Such VNFs are connected in the same virtual network called \"vnet\".\n\n\n\n\nINSTANTIATE scripts\n\n\nTo start the VNFs we'll have two scripts \ninstantiate-vnf-server.sh\n and \ninstantiate-vnf-database.sh\n (more scripts are possible). Here an example of the instantiate-vnf-server.sh script:\n\n\n#!/bin/bash\n\necho \nINSTANTIATIATION of the VNF server\n\necho \nThe following parameters are available:\n\n\necho \nOut-of-the-box parameters:\n\necho \nHostname: ${hostname}\n\necho \nPrivate IP: ${vnet}\n\necho \nFloating IP (if requested otherwise it does not exist): ${vnet_floatingIp}\n\n\necho \nConfiguration parameters:\n\necho \nThe answer to everything is.. ${ANSWER_TO_EVERYTHING}\n\n\n# ... Add the code to start the vnf_server ...\n\n\n\n\nCONFIGURE script\n\n\nAfter the instantiation of the vnf-server we would configure it with the following \ndatabase_connectToDb.sh\n script:\n\n\n#!/bin/bash\n\necho \nThis is the ip of the vnf-database: ${database_vnet}\n\necho \nThis is the floating ip of the vnf-database: ${database_vnet_floatingIp}\n\necho \nThis is the hostname of the vnf-database: ${database_hostname}\n\n\n# ... Add the code to connect to the vnf-database with the ip: ${database_vnet} ...\n\n\n\n\n\nNote1\n: \ndatabase\n is the type of the vnf-database, \nvnet\n is the name of the network.\n\n\nNote2\n: All the scripts need to be in a repository or in the vnf package (see the vnf package structure \nhere\n).\n\n\nIn order to deploy the VNFs we have to create both the VNF descriptor: \nvnf-database-descriptor.json\n and \nvnf-server-descriptor.json\n. Below we'll be showed the most relevant part of them:\n\n\nvnf-database-descriptor.json\n\n\n{\n    \nname\n:\nvnf-database\n,\n    \ntype\n:\ndatabase\n,\n    \nendpoint\n:\ngeneric\n,\n    ...\n    \nlifecycle_event\n:[\n        {\n            \nevent\n:\nINSTANTIATE\n,\n            \nlifecycle_events\n:[\n                \ninstantiate-vnf-database.sh\n\n            ]\n        }\n    ],\n    ...\n}\n\n\n\n\nNote:\n to use the Generic VNFM for managing a VNF just set \"generic\" in the endpoint field.\n\n\nvnf-server-descriptor.json\n\n\n{\n    \nname\n:\nvnf-server\n,\n    \ntype\n:\nserver\n,\n    \nendpoint\n:\ngeneric\n,\n    ...\n    \nconfigurations\n:{\n            \nname\n:\nconfig_name\n,\n            \nconfigurationParameters\n:[\n            {\n                \nconfKey\n:\nANSWER_TO_EVERYTHING\n,\n                \nvalue\n:\n42\n\n            }\n            ]\n    },\n    ...\n    \nlifecycle_event\n:[\n        {\n            \nevent\n:\nINSTANTIATE\n,\n            \nlifecycle_events\n:[\n                \ninstantiate-vnf-server.sh\n\n            ]\n        },\n        {\n            \nevent\n:\nCONFIGURE\n,\n            \nlifecycle_events\n:[\n                \ndatabase_connectToDb.sh\n\n            ]\n        }\n    ],\n    ...\n}\n\n\n\n\nThe result network service descriptor shall include both the vnf descriptors above and the dependency:\n\n\n{\n    \nname\n:\nsimple-nsd\n,\n    \nvnfd\n:[\n        {\n            \nid\n:\n29d918b9-6245-4dc4-abc6-b7dd6e84f2c1\n\n        },\n        {\n            \nid\n:\n87820607-4048-4fad-b02b-dbcab8bb5c1c\n\n        }\n    ],\n    \nvld\n:[\n        {\n            \nname\n:\nvnet\n\n        }\n    ],\n    \nvnf_dependency\n:[\n        {\n            \nsource\n : {\n                \nname\n: \nvnf-database\n\n            },\n            \ntarget\n:{\n                \nname\n: \nvnf-server\n\n            },\n            \nparameters\n:[\n                \nvnet\n\n            ]\n        }\n    ]\n}\n\n\n\n\nSee the complete tutorial \u2192 \nVNFPackage tutorial\n.\n\n\n\n\n\n\n\n\n\n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Generic VNFM"
        }, 
        {
            "location": "/vnfm-generic/#generic-vnf-manager", 
            "text": "The Generic VNF Manager is an implementation following the  ETSI MANO  specifications. It works as intermediate component between the NFVO and the VNFs, particularly the Virtual Machines on top of which the VNF software is installed. In order to complete the lifecycle of a VNF, it interoperates with the Open Baton Element Management System (EMS) which acts as an agent inside the VMs and executing scripts contained in a VNF package or defined via the  scripts-link  inside the VNFD.\nThis VNFM may be assigned to the management of a single VNF instance, or the management of multiple VNF instances of the same type or of different types.  The Generic VNFM handles communication between the NFVO and the EMS. The communication NFVO \u2194 VNFM \u2194 EMS is done using the AMQP protocol over RabbitMQ.    The communication between the NFVO and Generic VNFM:   The communication between the Generic VNFM and EMS:   As you can see, the Generic VNFM sends commands to the EMS, which is running in the VM. Then the EMS executes the commands (scripts) locally in the VNFC.  Please note that the EMS executes those scripts as root user .\nThe following sequence diagram explains the communication messages.   The Generic VNFManager is supposed to be used for any type of VNF that follows some conventions regarding:   VMs deployment  Script execution costraints  VMs termination", 
            "title": "Generic VNF Manager"
        }, 
        {
            "location": "/vnfm-generic/#vms-deployment", 
            "text": "Accordingly to the  ETSI MANO B.3  the VNF instantiation flows can be done in two ways:   With resource allocation done by NFVO  With resource allocation done by VNF Manager   The Generic VNFM follows the first approach. In the first approach two messages will be sent to the NFVO:    GRANT_OPERATION message : check if the resources are available on the selected PoP. If the GRANT_OPERATION message is returned, then there are enough resources, otherwise an ERROR message will be sent. After the GRANT_OPERATION message it is possible to send the ALLOCATE_RESOURCE message.      ALLOCATE_RESOURCE message : This message ask the NFVO to create all the resources and then, if no errors occurred, the ALLOCATE_RESOURCE message will be returned to the VNFManager. Only the VNFMs which follow the first approach need to send this message.    After that point the VMs are created and  the VNF record is filled with values , such as ips, that can be found directly in the VirtualNetworkFunctionRecord\u2192VirtualDeploymentUnit\u2192VNFCInstance object.", 
            "title": "VMs deployment"
        }, 
        {
            "location": "/vnfm-generic/#script-execution-costraints", 
            "text": "For each operation of the VNF Lifecycle Management interface, the VNFManager sends scripts to the EMS which executes them locally in the VMs.  Note : The scripts come from the VNFPackage which you need to create (see  VNFPackage documentation ).  The ordering of this scripts is defined in the NetworkServiceDescriptor from which the NetworkServiceRecord was created, in particular into the NetworkServiceDescriptor\u2192VirtualNetworkFunctionDescriptor\u2192LifecycleEvents.\nHere an example (to make it more readable it is shown only the  VNF lifecycle event  part):  {// NSD\n  ...\n  {// VNFD\n    ...\n     lifecycle_event :[\n        {\n             event : INSTANTIATE ,\n             lifecycle_events :[\n                 pre-install.sh ,\n                 install.sh \n            ]\n        },\n        {\n             event : CONFIGURE ,\n             lifecycle_events :[\n                 server_configure.sh \n            ]\n        },\n        {\n             event : START ,\n             lifecycle_events :[\n                  start.sh \n            ]\n        },\n        {\n             event : STOP ,\n             lifecycle_events :[\n                  stop.sh \n            ]\n        },\n        {\n             event : TERMINATE ,\n             lifecycle_events :[\n                  terminate.sh \n            ]\n        }\n    ],\n    ...\n  }\n  ...\n}  In the following table is described for each  VNF lifecycle event  when the scripts are executed.     VNF Lifecycle event  When scripts are executed      INSTANTIATE  During the instantiation of the corresponding VNF    CONFIGURE  After the instantiation. Useful if the VNF depends on other VNFs, because we can get parameters provided by them (e.g. IP). The parameters are available as environment variables (see later).    START  After the instantiation or configuration (It depends whether the event CONFIGURE specified).    STOP  During the stop of the corresponding VNF    TERMINATE  During the termination of the corresponding VNF    SCALE_IN  When the VNF is target of a scaled in vnfcInstance     The available parameters are defined in the VirtualNetworkFunctionDescriptor fields:    configurations : it contains specific parameters which you want to use in the scripts.  out-of-the-box : the following parameters are automatically available into the scripts:    Private IP  Floating IP (if requested)  Hostname       Please check the example at the end of the page to understand this mechanism.  In the INSTANTIATE scripts, the parameters defined in these two fields are then available as environment variables into the script exactly as defined (i.e. you can get by $parameter_name).  In the MODIFY scripts, the INSTANTIATE parameters are still available but plus there are environment variables that come from other VNF sources, where they are specified in the provides field. \nThese kind of parameters are defined in the  requires  fields (of the VNF target) and the VNFDependency\u2192parameters fields (of the NSD), and are then available as $ type_of_vnf_source _ name_of_parameter  (in the VNF target).  NOTE :  the scripts in the CONFIGURE lifecycle event need to start with the type of the source VNF followed by _ (underscore) and the name of the script (i.e. server_configure.sh)", 
            "title": "Script Execution Costraints"
        }, 
        {
            "location": "/vnfm-generic/#vms-termination", 
            "text": "The STOP lifecycle event is meant to just stop the VNF service and afterward be able to start it again. The TERMINATE lifecycle event delete the virtual resources from the PoP\nAs for VMs deployment, VMs termination is done by the NFVO. Specific scripts can be run before termination by putting them under the TERMINATE lifecycle event.", 
            "title": "VMs termination"
        }, 
        {
            "location": "/vnfm-generic/#launch-the-generic-vnfm", 
            "text": "Please check also the  installation page . To launch the Generic VNFM, execute the following command:  $ cd  generic directory \n$ ./generic-vnfm.sh start  The Generic VNFM can handle more than one VNF (in parallel) of the same or different type, so that you need to start only one Generic VNFM.", 
            "title": "Launch the Generic VNFM"
        }, 
        {
            "location": "/vnfm-generic/#example-with-dependency-and-scripts", 
            "text": "Let's see a simple example with two VNFs: vnf-server and vnf-database. \nThe vnf-server needs the ip of the vnf-database to be able to connect properly. The following figure shows the source (vnf-database), the target (vnf-server)\nand the dependency (IP). Such VNFs are connected in the same virtual network called \"vnet\".   INSTANTIATE scripts  To start the VNFs we'll have two scripts  instantiate-vnf-server.sh  and  instantiate-vnf-database.sh  (more scripts are possible). Here an example of the instantiate-vnf-server.sh script:  #!/bin/bash\n\necho  INSTANTIATIATION of the VNF server \necho  The following parameters are available: \n\necho  Out-of-the-box parameters: \necho  Hostname: ${hostname} \necho  Private IP: ${vnet} \necho  Floating IP (if requested otherwise it does not exist): ${vnet_floatingIp} \n\necho  Configuration parameters: \necho  The answer to everything is.. ${ANSWER_TO_EVERYTHING} \n\n# ... Add the code to start the vnf_server ...  CONFIGURE script  After the instantiation of the vnf-server we would configure it with the following  database_connectToDb.sh  script:  #!/bin/bash\n\necho  This is the ip of the vnf-database: ${database_vnet} \necho  This is the floating ip of the vnf-database: ${database_vnet_floatingIp} \necho  This is the hostname of the vnf-database: ${database_hostname} \n\n# ... Add the code to connect to the vnf-database with the ip: ${database_vnet} ...  Note1 :  database  is the type of the vnf-database,  vnet  is the name of the network.  Note2 : All the scripts need to be in a repository or in the vnf package (see the vnf package structure  here ).  In order to deploy the VNFs we have to create both the VNF descriptor:  vnf-database-descriptor.json  and  vnf-server-descriptor.json . Below we'll be showed the most relevant part of them:  vnf-database-descriptor.json  {\n     name : vnf-database ,\n     type : database ,\n     endpoint : generic ,\n    ...\n     lifecycle_event :[\n        {\n             event : INSTANTIATE ,\n             lifecycle_events :[\n                 instantiate-vnf-database.sh \n            ]\n        }\n    ],\n    ...\n}  Note:  to use the Generic VNFM for managing a VNF just set \"generic\" in the endpoint field.  vnf-server-descriptor.json  {\n     name : vnf-server ,\n     type : server ,\n     endpoint : generic ,\n    ...\n     configurations :{\n             name : config_name ,\n             configurationParameters :[\n            {\n                 confKey : ANSWER_TO_EVERYTHING ,\n                 value : 42 \n            }\n            ]\n    },\n    ...\n     lifecycle_event :[\n        {\n             event : INSTANTIATE ,\n             lifecycle_events :[\n                 instantiate-vnf-server.sh \n            ]\n        },\n        {\n             event : CONFIGURE ,\n             lifecycle_events :[\n                 database_connectToDb.sh \n            ]\n        }\n    ],\n    ...\n}  The result network service descriptor shall include both the vnf descriptors above and the dependency:  {\n     name : simple-nsd ,\n     vnfd :[\n        {\n             id : 29d918b9-6245-4dc4-abc6-b7dd6e84f2c1 \n        },\n        {\n             id : 87820607-4048-4fad-b02b-dbcab8bb5c1c \n        }\n    ],\n     vld :[\n        {\n             name : vnet \n        }\n    ],\n     vnf_dependency :[\n        {\n             source  : {\n                 name :  vnf-database \n            },\n             target :{\n                 name :  vnf-server \n            },\n             parameters :[\n                 vnet \n            ]\n        }\n    ]\n}  See the complete tutorial \u2192  VNFPackage tutorial .    \n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "EXAMPLE WITH DEPENDENCY AND SCRIPTS"
        }, 
        {
            "location": "/vnfm-juju/", 
            "text": "Juju VNF Manager (Beta version)\n\n\nThe Juju VNF Manager enables the Open Baton NFVO to interoperate with Juju as a generic VNFM. This initial version does not provide full interoperability between this VNFM and the Generic one provided by Open Baton. However, with this VNFM you can execute the following: \n\n\n\n\ndeploy Open Baton VNF Packages \n\n\ndeploy Juju charms which are available on the \nJuju Charm Store\n\n\n\n\nPlease be careful in reading the list of unsupported functionalities in the next section. Those functionalities are part of the roadmap of this component and will be available in the next releases.  \n\n\nConstraints and future work\n\n\nHere is a list of known constraints and features that do not work at the moment. \n\n\nIn case you are planning to use the Juju VNFM to deploy Open Baton VNF Packages keep in mind that: \n\n\n\n\nLifecycle scripts have to be bash scripts\n\n\nExecution order of CONFIGURE lifecycle scripts cannot be ensured\n\n\nNo actual creation of networks (virtual links)\n\n\nVNFDs with the same name in different NSDs cause problems\n\n\n\n\nIn case you are planning to use the Juju VNFM to deploy Juju charms then keep in mind that: \n\n\n\n\nDependencies between charms from the Juju Charm Store cannot be resolved yet\n\n\n\n\nIn general, keep in mind that: \n\n\n\n\nNo accurate NSR/VNFR status feedback\n\n\nScaling is not supported\n\n\nDependencies between VNFs are only working when using the same VNFM\n\n\n\n\nThese list of issues is something we are working on for the future release.\n\n\nRequirements\n\n\n\n\nA running \nNFVO\n\n\nThe \nTest vim driver\n\n\nA running Juju 2.0 instance with a controller named \nobcontroller\n. Please refer to the juju \ninstallation guide\n\n\nThe \nJuju-VNFM\n needs to run on the same machine where Juju is installed\n\n\n\n\nHow to install the Juju VNF Manager from source code\n\n\nGit clone the project into the /opt/openbaton directory (you may need to be logged in as root user, unless you change the permissions on the /opt/openbaton folder): \n\n\nsudo apt-get install openjdk-7-jdk #in case you don't have java installed\nmkdir /opt/openbaton\ngit clone https://github.com/openbaton/juju-vnfm.git\n\n\n\n\nAnd Execute \n\n\ncd /opt/openbaton/juju-vnfm; ./juju-vnfm.sh compile\n\n\n\n\nto compile it. \n\n\nConfigure the Juju VNF Manager\n\n\nThe Juju VNF Manager uses AMQP to communicate with the NFVO, therefore it needs to reach RabbitMQ in order to properly register with the NFVO.\n\nIn order to configure the VNFM to reach the proper NFVO you need to modify the juju configuration file. First of all, copy the application.properties file into the following location\n\n\nsudo mkdir /etc/openbaton/ # in case it does not exists\nsudo cp src/main/resources/application.properties /etc/openbaton/\n\n\n\n\nThen change open it with your favourite editor and modify the properties \nspring.rabbitmq.host\n and \nspring.rabbitmq.port\n adding the ip address and port on which rabbitmq is running. Please make sure to update also the \nspring.rabbitmq.username\n and \nspring.rabbitmq.password\n with the one used also on the NFVO side. \n\n\nHow to control the Juju VNF Manager\n\n\nTo start the Juju VNF Manager execute\n\n\nbash\n cd /opt/openbaton/juju-vnfm\n ./juju-vnfm.sh start\n\n\nThis will create a new screen window which you can access using \nscreen -x openbaton\n. \n\n\nHow to use the Juju VNF Manager\n\n\nTo use the Juju VNF Manager for deploying a network service you have to store a VimInstance with type \ntest\n in the NFVO \nand the Virtual Network Function Descriptors used to describe the network service have to define their \nendpoint\n as \njuju\n. \nNow you can launch the NSD as usual. Juju uses Ubuntu series names to specify which image to use while deploying a charm.\nYou can specify this series in the application.properties, the default is trusty. \n\n\nIf you want to deploy a charm from the Juju Charm Store you have to set the VNFD's \nvnfPackageLocation\n to \njuju charm store\n \nand name the VNFD after the charm name. \nThis will cause the Juju VNFM to deploy the specified charm from the Juju Charm Store. \nThis is currently a fairly simple mechanism and does not provide further integration into the Open Baton Network Service deployment. \nSo it is not possible to include a VNFD that specifies a Juju Charm that has dependencies to other VNFDs or to pass configurations while deploying the Charm. \n\n\nHow it works\n\n\n\n\nThe Juju VNFM translates Open Baton NSD's into Juju Charms, stores them in directories in \n/tmp/openbaton/juju\n and deploys them \nusing an already running Juju controller.\n\nAfter the NFVO transmitted the last START event of a Network Service to the Juju VNFM, the charm is \ncreated and the juju deploy command called. If dependencies exist, the Juju VNFM will also add relations between the charms. \nThe charm directory will be removed afterwards. \nIn the following diagram you can see the work flow. \n\n\n\n\nThe basic lifecycle mapping between the Open Baton and the Juju model maps Open Baton's INSTANTIATE lifecycle to Juju's install hook, the START lifecycle \nto the start hook and the TERMINATE lifecycle to the stop hook. \nBut since Open Baton and Juju handle dependencies differently you cannot simply map Open Baton's CONFIGURE lifecycle to an existing Juju hook. \nThe following table shows in which VNFD dependency cases which Open Baton lifecycle is mapped to which Juju hook. \nThat means the scripts used by this lifecycle event will be executed by the corresponding Juju hook. \n\n\n\n\nIf the VNFD is a target of a dependency the START lifecycle will not be mapped to the start hook because the lifecycle's scripts \nshould be executed after the relation-changed hook which runs the CONFIGURE scripts. \nIn these cases a \nstartAfterDependency\n script will be created and the relation-changed hook will trigger its execution after it has finished.", 
            "title": "Juju VNFM"
        }, 
        {
            "location": "/vnfm-juju/#juju-vnf-manager-beta-version", 
            "text": "The Juju VNF Manager enables the Open Baton NFVO to interoperate with Juju as a generic VNFM. This initial version does not provide full interoperability between this VNFM and the Generic one provided by Open Baton. However, with this VNFM you can execute the following:    deploy Open Baton VNF Packages   deploy Juju charms which are available on the  Juju Charm Store   Please be careful in reading the list of unsupported functionalities in the next section. Those functionalities are part of the roadmap of this component and will be available in the next releases.", 
            "title": "Juju VNF Manager (Beta version)"
        }, 
        {
            "location": "/vnfm-juju/#constraints-and-future-work", 
            "text": "Here is a list of known constraints and features that do not work at the moment.   In case you are planning to use the Juju VNFM to deploy Open Baton VNF Packages keep in mind that:    Lifecycle scripts have to be bash scripts  Execution order of CONFIGURE lifecycle scripts cannot be ensured  No actual creation of networks (virtual links)  VNFDs with the same name in different NSDs cause problems   In case you are planning to use the Juju VNFM to deploy Juju charms then keep in mind that:    Dependencies between charms from the Juju Charm Store cannot be resolved yet   In general, keep in mind that:    No accurate NSR/VNFR status feedback  Scaling is not supported  Dependencies between VNFs are only working when using the same VNFM   These list of issues is something we are working on for the future release.", 
            "title": "Constraints and future work"
        }, 
        {
            "location": "/vnfm-juju/#requirements", 
            "text": "A running  NFVO  The  Test vim driver  A running Juju 2.0 instance with a controller named  obcontroller . Please refer to the juju  installation guide  The  Juju-VNFM  needs to run on the same machine where Juju is installed", 
            "title": "Requirements"
        }, 
        {
            "location": "/vnfm-juju/#how-to-install-the-juju-vnf-manager-from-source-code", 
            "text": "Git clone the project into the /opt/openbaton directory (you may need to be logged in as root user, unless you change the permissions on the /opt/openbaton folder):   sudo apt-get install openjdk-7-jdk #in case you don't have java installed\nmkdir /opt/openbaton\ngit clone https://github.com/openbaton/juju-vnfm.git  And Execute   cd /opt/openbaton/juju-vnfm; ./juju-vnfm.sh compile  to compile it.", 
            "title": "How to install the Juju VNF Manager from source code"
        }, 
        {
            "location": "/vnfm-juju/#configure-the-juju-vnf-manager", 
            "text": "The Juju VNF Manager uses AMQP to communicate with the NFVO, therefore it needs to reach RabbitMQ in order to properly register with the NFVO. \nIn order to configure the VNFM to reach the proper NFVO you need to modify the juju configuration file. First of all, copy the application.properties file into the following location  sudo mkdir /etc/openbaton/ # in case it does not exists\nsudo cp src/main/resources/application.properties /etc/openbaton/  Then change open it with your favourite editor and modify the properties  spring.rabbitmq.host  and  spring.rabbitmq.port  adding the ip address and port on which rabbitmq is running. Please make sure to update also the  spring.rabbitmq.username  and  spring.rabbitmq.password  with the one used also on the NFVO side.", 
            "title": "Configure the Juju VNF Manager"
        }, 
        {
            "location": "/vnfm-juju/#how-to-control-the-juju-vnf-manager", 
            "text": "To start the Juju VNF Manager execute  bash\n cd /opt/openbaton/juju-vnfm\n ./juju-vnfm.sh start  This will create a new screen window which you can access using  screen -x openbaton .", 
            "title": "How to control the Juju VNF Manager"
        }, 
        {
            "location": "/vnfm-juju/#how-to-use-the-juju-vnf-manager", 
            "text": "To use the Juju VNF Manager for deploying a network service you have to store a VimInstance with type  test  in the NFVO \nand the Virtual Network Function Descriptors used to describe the network service have to define their  endpoint  as  juju . \nNow you can launch the NSD as usual. Juju uses Ubuntu series names to specify which image to use while deploying a charm.\nYou can specify this series in the application.properties, the default is trusty.   If you want to deploy a charm from the Juju Charm Store you have to set the VNFD's  vnfPackageLocation  to  juju charm store  \nand name the VNFD after the charm name. \nThis will cause the Juju VNFM to deploy the specified charm from the Juju Charm Store. \nThis is currently a fairly simple mechanism and does not provide further integration into the Open Baton Network Service deployment. \nSo it is not possible to include a VNFD that specifies a Juju Charm that has dependencies to other VNFDs or to pass configurations while deploying the Charm.", 
            "title": "How to use the Juju VNF Manager"
        }, 
        {
            "location": "/vnfm-juju/#how-it-works", 
            "text": "The Juju VNFM translates Open Baton NSD's into Juju Charms, stores them in directories in  /tmp/openbaton/juju  and deploys them \nusing an already running Juju controller. \nAfter the NFVO transmitted the last START event of a Network Service to the Juju VNFM, the charm is \ncreated and the juju deploy command called. If dependencies exist, the Juju VNFM will also add relations between the charms. \nThe charm directory will be removed afterwards. \nIn the following diagram you can see the work flow.    The basic lifecycle mapping between the Open Baton and the Juju model maps Open Baton's INSTANTIATE lifecycle to Juju's install hook, the START lifecycle \nto the start hook and the TERMINATE lifecycle to the stop hook. \nBut since Open Baton and Juju handle dependencies differently you cannot simply map Open Baton's CONFIGURE lifecycle to an existing Juju hook. \nThe following table shows in which VNFD dependency cases which Open Baton lifecycle is mapped to which Juju hook. \nThat means the scripts used by this lifecycle event will be executed by the corresponding Juju hook.    If the VNFD is a target of a dependency the START lifecycle will not be mapped to the start hook because the lifecycle's scripts \nshould be executed after the relation-changed hook which runs the CONFIGURE scripts. \nIn these cases a  startAfterDependency  script will be created and the relation-changed hook will trigger its execution after it has finished.", 
            "title": "How it works"
        }, 
        {
            "location": "/vnfm-how-to-write/", 
            "text": "How to write a VNFManager\n\n\nThis section is going to describe how to write your own VNFManager by using any vnfm-sdk.\nMoreover, the vnfm-sdk contains all the things you may need for the development of the VNFManager of your choice as well.\n\n\nThe vnfm-sdk provides the following things:\n\n\n\n\nmultiple \nvnfm-sdks\n where you can choose your preferred type of communication\n\n\nCatalogue, shared with the NFVO containing all entities\n\n\nVNFMHelper\n for providing some methods out of the box\n\n\n\n\nRequirements\n\n\nBefore you can start with developing your own VNFManager you need to prepare your programming environment by installing/configuring the following requirements:\n\n\n\n\nJDK 7 (\ninstallation\n)\n\n\nGradle 1.12 or above (\ninstallation\n)\n\n\n\n\nDevelop your own VNFManager\n\n\nThis part is going to describe the steps you need to do to develop your own VNFManager with the help of any vnfm-sdk.\n\n\nThe practical parts of implementing a basic VNFManager will focus on the usage of a specific vnfm-sdk, namely the vnfm-sdk-amqp.\n\n\nPreparations\n\n\nThis section describes the initial steps for creating the project structure and configuring essential files for developing your own VNFManager.\nThis can be done in two ways.\nEither you may use your favorite IDE or you may do everything manually via the command line.\n\n\nOnce this is done, you can start implementing your VNFManager by using different communication models, the catalogue and several helpers.\n\n\nUsing your favorite IDE\n\n\nIn the following we will create the project and setup the configuration files by using your favorite IDE.\nSo first of all, start your IDE and go to the next step.\nAll the details base on the usage of \nIntelliJIdea\n.\n\n\nCreate a new project\n\n\nOnce you have started the IDE, click on File -\n New -\n Project...\n\n\nIn this dialog click on Gradle on the left and select java in the main properties window in the middle.\n\n\n\n\nThen click on next to go to the next window.\n\n\nIn the next dialog you need to define the GroupId, ArtifactId and the Version.\nMore information on the specific meaning can be found \nhere\n.\n\n\n\n\nContinue with the next dialog.\n\n\nIn this dialog you need to specify which gradle you want to use.\nIt is recommend to use the default gradle wrapper.\nAdditionally you can enable the auto-import.\n\n\n\n\nContinue with the next dialog by clicking on Next.\n\n\nIn the last dialog, you need to define the project name and the project location.\n\n\n\n\nOnce this is done you can click on Finish and continue with creating the Main Class.\n\n\nCreate the Main Class\n\n\nAfterwards, you need to create the Main Class of the VNFManager which will be started in the end.\nFor doing so, right click on the root folder my-vnfm, then click on New -\n Directory and insert what is show below.\n\n\n\n\nClick on OK to continue.\n\n\nAdditionally you need to create a new package.\nThis is done by a right-click on the previously created directory java.\nClick on New -\n Package.\nHere you can define the package name.\n\n\n\n\nFinally you can create your Main Class by clicking (right click) on the previously created package and click on New -\n Java Class.\n\n\n\n\nOnce you did all these steps, the initial project structure is created.\nWhat we miss right now is the configuration of the gradle files to define and fetch dependencies we need for implementing the VNFManager.\nThis is described in later sections.\n\n\nCreate the properties files\n\n\nThe properties files are used to define several parameters you need at runtime.\nSo just create the following file structure.\n\n\nDo a right-click on the main folder located in the src folder.\nClick on New -\n Directory and create a new folder with the name resources.\n\n\nDo again a right-click on the newly created folder resources and click on New -\n File.\nThis you need to do two times.\nThe first file is called application.properties and the second one is called conf.properties.\n\n\nWhat these files should contain is explained \nhere\n.\n\n\nUsing the command line\n\n\nThis section refers to the developers which don't like to use any IDE.\nBy not using any IDE we need to create all the folders and configuration files manually.\nSo we start with creating the project structure, the Main Class, initializing the gradle wrapper and according configuration files.\n\n\nCreate project folder\n\n\nFirst of all you need to create a new directory for your VNFManager.\nHere we call the new VNFManager my-vnfm.\nSo this can be replaced by whatever you want.\n\n\n$ mkdir my-vnfm\n\n\n\n\nCreate the Main Class\n\n\nThe Main class is the most important class you need to consider.\nHere you implement your main method and also methods you need to have for your VNFManager.\nFurther explanations are done in the according sections.\nThis is only for creating a proper file structure.\nSo execute the following commands to create the Main class in a proper folder and package structure.\n\n\nFirst, you need to create the folders and package by executing the following command in your root folder of the project.\n\n\n$ mkdir -p src/main/java/org/openbaton/vnfm\n\n\n\n\nThis creates the java folder src/main/java with the proposed package name org.openbaton.vnfm.\n\n\nIn the next step you create the Main Class called MyVNFM in this case.\n\n\n$ vim src/main/java/org/openbaton/vnfm/MyVNFM.java\n\n\n\n\nAt this point you create only the basic Java Class used later as the Main Class for implementing your VNFManager.\nThe newly created Java Class should contain the following lines for now.\n\n\npackage org.openbaton.vnfm;\n\npublic class MyVNFM {\n}\n\n\n\n\nIf you have chosen a different package name you need to replace it as well at this point.\nOnce this is done, you need to initialize the gradle wrapper and configuring according files.\n\n\nThe Build.Gradle file\n\n\nFirst you need to create the build.gradle file by executing the following command from your root project folder.\n\n\n$ vim build.gradle\n\n\n\n\nThis gradle configuration file needs to contain initially the following lines.\n\n\nbuildscript {\n    repositories {\n        mavenCentral()\n    }\n\n    dependencies {\n        classpath(\norg.springframework.boot:spring-boot-gradle-plugin:1.3.1.RELEASE\n)\n    }\n}\n\napply plugin: 'java'\napply plugin: 'spring-boot'\n\n\n\n\nThe second gradle configuration is called settings.gradle.\nThis file contains only the project name.\nSo create a new file called settings.gradle in your root folder.\n\n\n$ vim settings.gradle\n\n\n\n\nAfterwards you need to add the following line containing your project name.\nIn our case my-vnfm.\n\n\nrootProject.name = 'my-vnfm'\n\n\n\n\nAfterwards go back to the root folder and run the following command to create automatically the gradle wrapper which is used for code management and compilation.\nFor more information on how to use the gradle wrapper have a look at the gradle wrapper documentation \nhere\n.\n\n\n$ gradle wrapper\n\n\n\n\nOnce you did all these steps, the initial project structure is created.\nWhat we miss right now is the configuration of the gradle files to define and fetch dependencies we need for implementing the VNFManager.\nThis is described in later sections.\n\n\nCreate the properties files\n\n\nThe properties files are used to define several parameters you need at runtime.\nSo just create the following file structure by executing the following commands.\n\n\n$ mkdir src/main/resources\n\n\n\n\nNow you need to create two new files by running both commands you can find in the following\n\n\n$ touch src/main/resources/application.properties\n$ touch src/main/resources/conf.properties\n\n\n\n\nWhat these files should contain is explained \nhere\n.\n\n\nConfigure Gradle\n\n\nFinally you need to extend your build.gradle for announcing the Main Class, plugins to apply and repositories to use.\nSo open the build.gradle an add missing line so that the file contains the following line.\n\n\n//...\n\nbootRepackage {\n    mainClass = 'org.openbaton.vnfm.MyVNFM'\n}\n\n//...\n\n\n\n\nTake care about the configuration of the mainClass.\nIf the name or package of your mainClass is different, you need to replace it here as well.\n\n\nProperty files\n\n\nThe previously created properties files are used to define several things.\nThey are located in src/main/resources and are called application.properties and conf.properties.\n\n\nThe \napplication.properties\n contains parameters for setting up all log levels. This file is useful for configuring the springframework (see \nSpring Boot configuration file\n). This file can contain the following lines.\n\n\nlogging.level.org.springframework=INFO\nlogging.level.org.hibernate=INFO\nlogging.level.org.apache=INFO\nlogging.level.org.jclouds=WARN\n# logging.level.org.springframework.security=WARN\nlogging.level.org.springframework.web = WARN\n\n# Level for loggers on classes inside the root package \norg.project.openbaton\n (and its\n# sub-packages)\nlogging.level.org.openbaton=INFO\n\n# Direct log to a log file\nlogging.file=/var/log/openbaton.log\n\nvnfm.rabbitmq.brokerIp=localhost\nvnfm.rabbitmq.management.port=15672\nvnfm.rabbitmq.autodelete=true\nvnfm.rabbitmq.durable=false\nvnfm.rabbitmq.exclusive=false\nvnfm.rabbitmq.minConcurrency=5\nvnfm.rabbitmq.maxConcurrency=15\n\n#########################################\n############## RabbitMQ #################\n#########################################\n\n# Comma-separated list of addresses to which the client should connect to.\n# spring.rabbitmq.addresses= 192.168.145.54\n# Create an AmqpAdmin bean.\n# spring.rabbitmq.dynamic=true\n# RabbitMQ host.\nspring.rabbitmq.host=${vnfm.rabbitmq.brokerIp}\n# Acknowledge mode of container.\n# spring.rabbitmq.listener.acknowledge-mode=\n# Start the container automatically on startup.\n# spring.rabbitmq.listener.auto-startup=true\n# Minimum number of consumers.\nspring.rabbitmq.listener.concurrency=5\n# Maximum number of consumers.\nspring.rabbitmq.listener.max-concurrency=30\n# Number of messages to be handled in a single request. It should be greater than or equal to the transaction size (if used).\n# spring.rabbitmq.listener.prefetch=\n# Number of messages to be processed in a transaction. For best results it should be less than or equal to the prefetch count.\n# spring.rabbitmq.listener.transaction-size=\n# Login user to authenticate to the broker.\nspring.rabbitmq.username=admin\n# Login to authenticate against the broker.\nspring.rabbitmq.password=openbaton\n# RabbitMQ port.\nspring.rabbitmq.port=5672\n# Requested heartbeat timeout, in seconds; zero for none.\n# spring.rabbitmq.requested-heartbeat=\n# Enable SSL support.\n# spring.rabbitmq.ssl.enabled=false\n# Path to the key store that holds the SSL certificate.\n# spring.rabbitmq.ssl.key-store=\n# Password used to access the key store.\n# spring.rabbitmq.ssl.key-store-password=\n# Trust store that holds SSL certificates.\n# spring.rabbitmq.ssl.trust-store=\n# Password used to access the trust store.\n# spring.rabbitmq.ssl.trust-store-password=\n# Virtual host to use when connecting to the broker.\n# spring.rabbitmq.virtual-host=\n\n\n\n\nIf you want to change log levels you need to adapt it here.\n\n\nNOTE\n: \nIf your VNFManager is running on a different machine than the rabbitmq broker, you need to change the \nvnfm.rabbit.brokerIp\n accordingly with the ip of the rabbitmq broker.\n\n\nThe \nconf.properties\n is also a very important configuration file.\nHere you need to define the type and endpoint of your VNFManager that is later used for registering on the NFVO.\nFurthermore, you can define your own parameters which can be used at runtime for whatever you want.\nSo this file has to contain at least the type and endpoint.\nAdditionally, it is defined the folder where the vim drivers are located.\nIn this case the file should contain the following lines.\n\n\ntype=my-vnfm\nendpoint=my-vnfm-endpoint\nallocate = false\ndescription=The VNFM able to handle all the VNFs that follow specific conventions, see http://openbaton.github.io/\nenabled = true\nendpoint-type = RABBIT\nscript-max-time = 300000\nconcurrency = 15\n\n\n#### Additionally\nvim-plugin-dir = ./plugins\n\n\n\n\nWhere the parameters mean:\n\n\n\n\n\n\n\n\nParams\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\ntype\n\n\nThe type of VNF you are going to handle\n\n\n\n\n\n\nendpoint\n\n\nThe endpoint used for requesting this VNFManager\n\n\n\n\n\n\ndescription\n\n\nJust a useless description\n\n\n\n\n\n\nendpoint-type\n\n\ntype of the endpoint, either RABBIT or REST, depending on the sdk chosen. Check out next section\n\n\n\n\n\n\nenabled\n\n\ntrue if you want your vnfm to be enabled\n\n\n\n\n\n\nallocate\n\n\ntrue if the VNFM will ALLOCATE_RESOURCES, false if the NFVO will do\n\n\n\n\n\n\nconcurrency\n\n\nThe number of concurrent Receiver (only for vnfm-sdk-amqp)\n\n\n\n\n\n\n\n\nChoose a vnfm-sdk\n\n\nBefore you can start with the implementation you need to select the type of communication you want to use for the communication between the Orchestrator (NFVO) and the VNFManager.\nEither you can use the vnfm-sdk-amqp for using the \nRabbitMQ\n or the vnfm-sdk-rest for using the \nReST\n interface.\nHowever, your choice doesn't effect the upcoming implementation, because the communication itself is done automatically in the background.\nBut have in mind that both libraries depend on \nSpringBoot\n.\nSo, if you want to avoid this dependency, a third option might be: just use the simple vnfm-sdk artifact.\nBy using the simple vnfm-sdk you need to take care about all the communication between NFVO and VNFManager by yourself.\n\n\nOnce you have imported one of the vnfm-sdks you will have access to all the model classes and the vnfm-sdk classes needed to implement a VNFManager.\n\n\nThe following section shows you how to import the vnfm-sdk-amqp, representative for all the other opportunities.\n\n\nImport a vnfm-sdk\n\n\nThis section shows how to import and configure your VNFManager to make use of the vnfm-sdk-amqp.\n\n\nFor gathering the vnfm-sdk-amqp library you need to import the libraries by adding the missing lines to your build.gradle:\n\n\n//...\n\ndependencies {\n    compile 'org.hibernate:hibernate-core:4.3.10.Final'\n    compile 'org.openbaton:vnfm-sdk-amqp:3.2.0'\n}\n\n//...\n\n\n\n\nNote\n To make use of the vnfm-sdk-rest you need to change 'vnfm-sdk-amqp' to 'vnfm-sdk-rest' only.\n\n\nSo the final build.gradle file results like:\n\n\nbuildscript {\n    repositories {\n        mavenCentral()\n    }\n    dependencies {\n        classpath(\norg.springframework.boot:spring-boot-gradle-plugin:1.3.1.RELEASE\n)\n    }   \n\n}\n\napply plugin: 'java'\napply plugin: 'spring-boot'\n\nrepositories {\n    mavenCentral()\n    /**\n     * Only needed for openbaton snapshots dependencies\n     */\n    maven {\n        url 'https://oss.sonatype.org/content/repositories/snapshots/'\n    }\n}\n\ndependencies {\n    compile 'org.openbaton:vnfm-sdk-amqp:3.2.0'\n    compile 'org.hibernate:hibernate-core:4.3.10.Final'\n}\n\ngroup 'your.group'\nversion '1.0-SNAPSHOT'\n\nbootRepackage {\n    mainClass = 'org.openbaton.vnfm.MyVNFM'\n}\n\n\n\n\nOnce you did this, you need to trigger the gradle build process by running the following command via the command line in your project's root folder.\n\n\n$ ./gradlew build\n\n\n\n\nThis will fetch all the dependencies defined in the build.gradle and gives you access to all the Classes you need.\nYou can also do this by using the IDE by running the corresponding gradle task.\n\n\nImplementation of the VNFManager\n\n\nThis section is going to describe the implementation of a basic VNFManager by using the vnfm-sdk-amqp.\nIn the end, the VNFManager will be able to allocate and terminate resources by using its own openstack-plugin.\n\n\nSo first of all you need to define the main method used for starting your VNFManager.\nSo add the following to your Main Class that it looks as follows:\n\n\npackage org.openbaton.vnfm;\n\nimport org.springframework.boot.SpringApplication;\n\npublic class MyVNFM {\n\n    public static void main(String[] args){\n        SpringApplication.run(MyVNFM.class);\n    }\n}\n\n\n\n\nAfterwards you need to extend your Main Class (in this case MyVNFM) with the \nAbstractVnfmSpringAmqp\n.\n\n\nThe \nAbstractVnfmSpringAmqp\n takes care of all the configuration you need to register/unregister the VNFManager to the NFVO and handles incoming messages.\nWhereas the \nAbstractVnfm\n, extended by the \nAbstractVnfmSpringAmqp\n, is independent of the type of communication.\nThis means more in detail that the \nAbstractVnfm\n processes the incoming messages and executes the right method depending on the defined Action inside the message.\nMoreover, it is responsible for loading predefined configuration files, setting up the VNFManager itself, creating the VNFR (based on the VNFD received in the first step) and doing essential parts like requesting the NFVO for granting operations or deciding who is responsible for allocate resources.\n\n\nOnce you extended your VNFMManger, you need to implement all the methods coming from the extension of \nAbstractVnfmSpringAmqp\n as shown below:\n\n\npackage org.openbaton.vnfm;\n\nimport org.openbaton.catalogue.mano.record.VNFCInstance;\nimport org.openbaton.catalogue.mano.record.VNFRecordDependency;\nimport org.openbaton.catalogue.mano.record.VirtualNetworkFunctionRecord;\nimport org.openbaton.catalogue.nfvo.Action;\nimport org.openbaton.catalogue.nfvo.VimInstance;\nimport org.openbaton.common.vnfm_sdk.amqp.AbstractVnfmSpringAmqp;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\nimport java.util.Collection;\nimport java.util.Map;\n\n@SpringBootApplication\npublic class MyVNFM extends AbstractVnfmSpringAmqp{\n\n    public static void main(String[] args){\n        SpringApplication.run(MyVNFM.class);\n    }\n\n    /**\n     * This operation allows creating a VNF instance.\n     *\n     * @param virtualNetworkFunctionRecord\n     * @param scripts\n     * @param vimInstances\n     */\n    @Override\n    public VirtualNetworkFunctionRecord instantiate(VirtualNetworkFunctionRecord virtualNetworkFunctionRecord, Object scripts, Map\nString, Collection\nVimInstance\n vimInstances) throws Exception {\n        return virtualNetworkFunctionRecord;\n    }\n\n    /**\n     * This operation allows retrieving\n     * VNF instance state and attributes.\n     */\n    @Override\n    public void query() {\n\n    }\n\n    /**\n     * This operation allows scaling\n     * (out/in, up/down) a VNF instance.\n     */\n    @Override\n    public VirtualNetworkFunctionRecord scale(Action scaleInOrOut, VirtualNetworkFunctionRecord virtualNetworkFunctionRecord, VNFComponent component, Object scripts, VNFRecordDependency dependency) throws Exception {\n        return virtualNetworkFunctionRecord;\n    }\n\n\n    /**\n     * This operation allows verifying if\n     * the VNF instantiation is possible.\n     */\n    @Override\n    public void checkInstantiationFeasibility() {\n\n    }\n\n    /**\n     * This operation is called when one the VNFs fails\n     */\n    @Override\n    public VirtualNetworkFunctionRecord heal(VirtualNetworkFunctionRecord virtualNetworkFunctionRecord, VNFCInstance component, String cause) throws Exception {\n        return virtualNetworkFunctionRecord;\n    }\n\n    /**\n     * This operation allows applying a minor/limited\n     * software update (e.g. patch) to a VNF instance.\n     */\n    @Override\n    public VirtualNetworkFunctionRecord updateSoftware(Script script, VirtualNetworkFunctionRecord virtualNetworkFunctionRecord) throws Exception {\n        return virtualNetworkFunctionRecord;\n    }\n\n\n    /**\n     * This operation allows making structural changes\n     * (e.g. configuration, topology, behavior,\n     * redundancy model) to a VNF instance.\n     *\n     * @param virtualNetworkFunctionRecord\n     * @param dependency\n     */\n    @Override\n    public VirtualNetworkFunctionRecord modify(VirtualNetworkFunctionRecord virtualNetworkFunctionRecord, VNFRecordDependency dependency) throws Exception {\n        return virtualNetworkFunctionRecord;\n    }\n\n    /**\n     * This operation allows deploying a new\n     * software release to a VNF instance.\n     */\n    @Override\n    public void upgradeSoftware() {\n\n    }\n\n    /**\n     * This operation allows terminating gracefully\n     * or forcefully a previously created VNF instance.\n     *\n     * @param virtualNetworkFunctionRecord\n     */\n    @Override\n    public VirtualNetworkFunctionRecord terminate(VirtualNetworkFunctionRecord virtualNetworkFunctionRecord) {\n        log.info(\nTerminating vnfr with id \n + virtualNetworkFunctionRecord.getId());\n        return virtualNetworkFunctionRecord;\n    }\n\n    @Override\n    public void handleError(VirtualNetworkFunctionRecord virtualNetworkFunctionRecord) {\n\n    }\n\n    @Override\n    protected void checkEMS(String hostname) {\n        log.warn(\nEMS is not supported by this VNFM\n);\n    }\n\n    @Override\n    protected void checkEmsStarted(String hostname) throws RuntimeException {\n        log.warn(\nEMS is not supported by this VNFM\n);\n    }\n\n    @Override\n    public VirtualNetworkFunctionRecord start(VirtualNetworkFunctionRecord virtualNetworkFunctionRecord) throws Exception {\n        return virtualNetworkFunctionRecord;\n    }\n\n    @Override\n    public VirtualNetworkFunctionRecord stop(VirtualNetworkFunctionRecord virtualNetworkFunctionRecord) throws Exception {\n        return virtualNetworkFunctionRecord;\n    }\n\n    @Override\n    public VirtualNetworkFunctionRecord startVNFCInstance(VirtualNetworkFunctionRecord virtualNetworkFunctionRecord, VNFCInstance vnfcInstance) throws Exception {\n        return virtualNetworkFunctionRecord;\n    }\n\n    @Override\n    public VirtualNetworkFunctionRecord stopVNFCInstance(VirtualNetworkFunctionRecord virtualNetworkFunctionRecord, VNFCInstance vnfcInstance) throws Exception {\n        return virtualNetworkFunctionRecord;\n    }\n\n    @Override\n    public VirtualNetworkFunctionRecord configure(VirtualNetworkFunctionRecord virtualNetworkFunctionRecord) throws Exception {\n        return virtualNetworkFunctionRecord;\n    }\n\n    @Override\n    public VirtualNetworkFunctionRecord resume(VirtualNetworkFunctionRecord virtualNetworkFunctionRecord, VNFCInstance vnfcInstance, VNFRecordDependency dependency) throws Exception {\n        return virtualNetworkFunctionRecord;\n    }\n\n    /**\n     * This operation allows providing notifications on state changes\n     * of a VNF instance, related to the VNF Lifecycle.\n     */\n    @Override\n    public void NotifyChange() {\n\n    }\n}\n\n\n\n\n\n\nNow you can implement whatever you want. If the VirtualNetworkFunctionRecord is returned, it will go back directly to the NFVO.\n\n\nOne of the methods that can be overwritten is the \nfillParameters\n. This method is important when you have specified some \"provides\" in your VNFD, in facts you can fill them in this method and make them available afterwards to the scripts (see \nHow to use the parameters\n). \n\n\nAn example of allocating and terminating resource by using a plugin can be found \nhere\n and \nhere\n.\n\n\nNote\n If you use vnfm-sdk-amqp or vnfm-sdk-rest \nthe VNFManager main class needs to be stateless\n since it can (will) run each method potentially in parallel.\nFor what concerns vnfm-sdk-amqp, even setting concurrency to 1, will not ensure to have always the same instance of the class.\n\n\nUsing the VnfmHelper\n\n\nAdditionally you can autowire the VnfmHelper to make use of several helper methods that are very useful.\nIn this case your VNFManager should look like this:\n\n\npackage org.openbaton.vnfm;\n\nimport org.springframework.beans.factory.annotation.Autowired;\n\npublic class MyVNFM extends AbstractVnfmSpringAmqp {\n\n    @Autowired\n    private VnfmHelper vnfmHelper;\n\n    [...]\n}\n\n\n\n\nThe vnfmHelper helps with some methods out of the box:\n\n\npackage org.openbaton.common.vnfm_sdk;\n\nimport org.openbaton.catalogue.nfvo.messages.Interfaces.NFVMessage;\n\npublic abstract class VnfmHelper {\n\n    /**\n     * This operation sends a NFVMessage\n     * to the NFVO and doesn't wait for answer.\n     * @param nfvMessage\n     */\n    public abstract void sendToNfvo(NFVMessage nfvMessage);\n\n    /**\n     * This operation send a NFVMessage\n     * to the NFVO and waits for the answer.\n     * @param nfvMessage\n     */\n    public abstract NFVMessage sendAndReceive(NFVMessage nfvMessage) throws Exception;\n}\n\n\n\n\nAt the moment, the main purpose of the VnfmHelper is to send messages to the NFVO and wait for the answer if needed.\n\n\nNote\n This class needs to be implemented in case you want to use only the vnfm-sdk and must be provided to the AbstractVnfm.\n\n\nUsing plugins\n\n\nThis section describes the initialization and usage of plugins.\nTherefore, you need to do several things:\n\n\n\n\nStart the plugins\n\n\nConnect an according VIM to the plugin or use the plugin directly\n\n\n\n\nNote\n If you want to use the Vim with plugins, you need to fetch also the interfaces and VIM implementations by adding the following lines to your build.gradle dependencies\n\n\ncompile 'org.openbaton:vim-int:3.2.0'\ncompile 'org.openbaton:vim-impl:3.2.0'\ncompile 'org.openbaton:sdk:3.2.0'\n\n\n\n\nAfter that you need to rebuild your project for fetching the dependencies automatically.\n\n\nNow you can use the ResourceManagement interface.\nIn the end it should look like the following:\n\n\npackage org.openbaton.vnfm;\n\nimport org.openbaton.catalogue.mano.record.VNFCInstance;\nimport org.openbaton.catalogue.mano.record.VNFRecordDependency;\nimport org.openbaton.catalogue.mano.record.VirtualNetworkFunctionRecord;\nimport org.openbaton.catalogue.nfvo.Action;\nimport org.openbaton.catalogue.nfvo.VimInstance;\nimport org.openbaton.common.vnfm_sdk.amqp.AbstractVnfmSpringAmqp;\nimport org.openbaton.nfvo.vim_interfaces.resource_management.ResourceManagement;\nimport org.openbaton.plugin.utils.PluginStartup;\nimport org.openbaton.plugin.utils.RabbitPluginBroker;\nimport org.openbaton.vim.drivers.VimDriverCaller;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.context.ConfigurableApplicationContext;\n\nimport java.io.IOException;\nimport java.util.Collection;\nimport java.util.Map;\n\npublic class MyVNFM extends AbstractVnfmSpringAmqp {\n\n    @Autowired\n    private ConfigurableApplicationContext context;\n\n    private ResourceManagement resourceManagement;\n\n    private VimDriverCaller client;\n\n    [...]\n\n    @Override\n    protected void setup() {\n        super.setup();\n        try {\n            //Start all the plugins that are located in ./plugins\n            PluginStartup.startPluginRecursive(\n./plugins\n, true, \nlocalhost\n, \n5672\n, 15, \nadmin\n, \nopenbaton\n, \n15672\n);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        //Fetching the OpenstackVim using the openstack-plugin\n        resourceManagement = (ResourceManagement) context.getBean(\nopenstackVIM\n, 19345, \n15672\n);\n        //Using the openstack-plugin directly\n        client = (VimDriverCaller) ((RabbitPluginBroker) context.getBean(\nrabbitPluginBroker\n)).getVimDriverCaller(\nlocalhost\n, \nadmin\n, \nopenbaton\n, 5672, \nopenstack\n, \nopenstack\n, \n15672\n);\n    }\n}\n\n\n\n\nThis code expects that the plugins are located in ./plugins.\nSo just copy the openstack plugin of your choice to this path.\nNow you are able to use a VIM inside or the directly the plugin in your VNFManager to allocate and release resources whenever you want.\n\n\nAllocate Resources\n\n\nThe following code snippet shows how to instantiate (allocate) resources at VNFManager side with the help of the VIM.\n\n\n/**\n * This operation allows creating a VNF instance.\n *\n * @param virtualNetworkFunctionRecord\n * @param scripts\n * @param vimInstances\n */\n@Override\npublic VirtualNetworkFunctionRecord instantiate(VirtualNetworkFunctionRecord virtualNetworkFunctionRecord, Object scripts, Map\nString, Collection\nVimInstance\n vimInstances) throws Exception {\n    log.debug(\nProcessing allocation of Resources for vnfr: \n + virtualNetworkFunctionRecord);\n    /**\n     * Allocation of Resources\n     *  the grant operation is already done before this method\n     */\n    String userdata = \n;\n    Iterator\nConfigurationParameter\n configIterator = virtualNetworkFunctionRecord.getConfigurations().getConfigurationParameters().iterator();\n    while (configIterator.hasNext()) {\n        ConfigurationParameter configurationParameter = configIterator.next();\n        log.debug(\nConfiguration Parameter: \n + configurationParameter);\n        if (configurationParameter.getConfKey().equals(\nGROUP_NAME\n)) {\n            userdata = \nexport GROUP_NAME=\n + configurationParameter.getValue() + \n\\n\n;\n            userdata += \necho $GROUP_NAME \n /home/ubuntu/group_name.txt\\n\n;\n        }\n    }\n    userdata += getUserData();\n\n    log.debug(\nProcessing allocation of Recources for vnfr: \n + virtualNetworkFunctionRecord);\n    for (VirtualDeploymentUnit vdu : virtualNetworkFunctionRecord.getVdu()) {\n        VimInstance vimInstance = vimInstances.get(vdu.getParent_vdu()).iterator().next();\n        log.debug(\nCreating \n + vdu.getVnfc().size() + \n VMs\n);\n        for (VNFComponent vnfComponent : vdu.getVnfc()) {\n            Map\nString, String\n floatingIps = new HashMap\n();\n            for (VNFDConnectionPoint connectionPoint : vnfComponent.getConnection_point()) {\n                if (connectionPoint.getFloatingIp() != null \n !connectionPoint.getFloatingIp().equals(\n)) {\n                    floatingIps.put(connectionPoint.getVirtual_link_reference(), connectionPoint.getFloatingIp());\n                }\n            }\n            try {\n                VNFCInstance vnfcInstance = resourceManagement.allocate(vimInstance, vdu, virtualNetworkFunctionRecord, vnfComponent, userdata, floatingIps, new HashSet\n()).get();\n                log.debug(\nCreated VNFCInstance with id: \n + vnfcInstance);\n                vdu.getVnfc_instance().add(vnfcInstance);\n            } catch (VimException e) {\n                log.error(e.getMessage());\n                if (log.isDebugEnabled())\n                    log.error(e.getMessage(), e);\n            }\n        }\n    }\n    log.debug(\nAllocated all Resources for vnfr: \n + virtualNetworkFunctionRecord);\n    return virtualNetworkFunctionRecord;\n}\n\n\n\n\nNote\n Keep in mind that you need to set \nallocate\n to false in conf.properties, if you want to allocate resources on the VNFManager side. Otherwise the NFVO will allocate resources as well.\n\n\nRelease Resources\n\n\nThe next code snippet shows an implementation of the terminate method used for releasing resources at VNFManager side.\n\n\n/**\n * This operation allows terminating gracefully\n * or forcefully a previously created VNF instance.\n *\n * @param virtualNetworkFunctionRecord\n */\n@Override\npublic VirtualNetworkFunctionRecord terminate(VirtualNetworkFunctionRecord virtualNetworkFunctionRecord) {\n    log.info(\nTerminating vnfr with id \n + virtualNetworkFunctionRecord.getId());\n    NFVORequestor nfvoRequestor = new NFVORequestor(\nadmin\n, \nopenbaton\n, \nlocalhost\n, \n8080\n, \n1\n);\n    for (VirtualDeploymentUnit vdu : virtualNetworkFunctionRecord.getVdu()) {\n        Set\nVNFCInstance\n vnfciToRem = new HashSet\n();\n        List\nVimInstance\n vimInstances = new ArrayList\n();\n        VimInstance vimInstance = null;\n        try {\n            vimInstances = nfvoRequestor.getVimInstanceAgent().findAll();\n        } catch (SDKException e) {\n            log.error(e.getMessage(), e);\n        } catch (ClassNotFoundException e) {\n            log.error(e.getMessage(), e);\n        }\n        for (VimInstance vimInstanceFind : vimInstances) {\n            if (vdu.getVimInstanceName().contains(vimInstanceFind.getName())) {\n                vimInstance = vimInstanceFind;\n                break;\n            }\n        }\n        for (VNFCInstance vnfcInstance : vdu.getVnfc_instance()) {\n            log.debug(\nReleasing resources for vdu with id \n + vdu.getId());\n            try {\n                resourceManagement.release(vnfcInstance, vimInstance);\n            } catch (VimException e) {\n                log.error(e.getMessage(), e);\n                throw new RuntimeException(e.getMessage(), e);\n            }\n            vnfciToRem.add(vnfcInstance);\n            log.debug(\nReleased resources for vdu with id \n + vdu.getId());\n        }\n        vdu.getVnfc_instance().removeAll(vnfciToRem);\n    }\n    log.info(\nTerminated vnfr with id \n + virtualNetworkFunctionRecord.getId());\n    return virtualNetworkFunctionRecord;\n}\n\n\n\n\nStart the VNFManager\n\n\nOnce you finalized your VNFManager you can compile and start it with the following commands.\n\n\n$ ./gradlew clean build\n$ java -jar build/libs/my-vnfm-{version}.jar\n\n\n\n\nIf everything is fine, your VNFManager will register to NFVO and is able now to receive requests and process them.\n\n\n\n\n\n\n\n\n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  &amp;&amp; (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Develop a VNFM"
        }, 
        {
            "location": "/vnfm-how-to-write/#how-to-write-a-vnfmanager", 
            "text": "This section is going to describe how to write your own VNFManager by using any vnfm-sdk.\nMoreover, the vnfm-sdk contains all the things you may need for the development of the VNFManager of your choice as well.  The vnfm-sdk provides the following things:   multiple  vnfm-sdks  where you can choose your preferred type of communication  Catalogue, shared with the NFVO containing all entities  VNFMHelper  for providing some methods out of the box", 
            "title": "How to write a VNFManager"
        }, 
        {
            "location": "/vnfm-how-to-write/#requirements", 
            "text": "Before you can start with developing your own VNFManager you need to prepare your programming environment by installing/configuring the following requirements:   JDK 7 ( installation )  Gradle 1.12 or above ( installation )", 
            "title": "Requirements"
        }, 
        {
            "location": "/vnfm-how-to-write/#develop-your-own-vnfmanager", 
            "text": "This part is going to describe the steps you need to do to develop your own VNFManager with the help of any vnfm-sdk.  The practical parts of implementing a basic VNFManager will focus on the usage of a specific vnfm-sdk, namely the vnfm-sdk-amqp.", 
            "title": "Develop your own VNFManager"
        }, 
        {
            "location": "/vnfm-how-to-write/#preparations", 
            "text": "This section describes the initial steps for creating the project structure and configuring essential files for developing your own VNFManager.\nThis can be done in two ways.\nEither you may use your favorite IDE or you may do everything manually via the command line.  Once this is done, you can start implementing your VNFManager by using different communication models, the catalogue and several helpers.", 
            "title": "Preparations"
        }, 
        {
            "location": "/vnfm-how-to-write/#using-your-favorite-ide", 
            "text": "In the following we will create the project and setup the configuration files by using your favorite IDE.\nSo first of all, start your IDE and go to the next step.\nAll the details base on the usage of  IntelliJIdea .", 
            "title": "Using your favorite IDE"
        }, 
        {
            "location": "/vnfm-how-to-write/#create-a-new-project", 
            "text": "Once you have started the IDE, click on File -  New -  Project...  In this dialog click on Gradle on the left and select java in the main properties window in the middle.   Then click on next to go to the next window.  In the next dialog you need to define the GroupId, ArtifactId and the Version.\nMore information on the specific meaning can be found  here .   Continue with the next dialog.  In this dialog you need to specify which gradle you want to use.\nIt is recommend to use the default gradle wrapper.\nAdditionally you can enable the auto-import.   Continue with the next dialog by clicking on Next.  In the last dialog, you need to define the project name and the project location.   Once this is done you can click on Finish and continue with creating the Main Class.", 
            "title": "Create a new project"
        }, 
        {
            "location": "/vnfm-how-to-write/#create-the-main-class", 
            "text": "Afterwards, you need to create the Main Class of the VNFManager which will be started in the end.\nFor doing so, right click on the root folder my-vnfm, then click on New -  Directory and insert what is show below.   Click on OK to continue.  Additionally you need to create a new package.\nThis is done by a right-click on the previously created directory java.\nClick on New -  Package.\nHere you can define the package name.   Finally you can create your Main Class by clicking (right click) on the previously created package and click on New -  Java Class.   Once you did all these steps, the initial project structure is created.\nWhat we miss right now is the configuration of the gradle files to define and fetch dependencies we need for implementing the VNFManager.\nThis is described in later sections.", 
            "title": "Create the Main Class"
        }, 
        {
            "location": "/vnfm-how-to-write/#create-the-properties-files", 
            "text": "The properties files are used to define several parameters you need at runtime.\nSo just create the following file structure.  Do a right-click on the main folder located in the src folder.\nClick on New -  Directory and create a new folder with the name resources.  Do again a right-click on the newly created folder resources and click on New -  File.\nThis you need to do two times.\nThe first file is called application.properties and the second one is called conf.properties.  What these files should contain is explained  here .", 
            "title": "Create the properties files"
        }, 
        {
            "location": "/vnfm-how-to-write/#using-the-command-line", 
            "text": "This section refers to the developers which don't like to use any IDE.\nBy not using any IDE we need to create all the folders and configuration files manually.\nSo we start with creating the project structure, the Main Class, initializing the gradle wrapper and according configuration files.", 
            "title": "Using the command line"
        }, 
        {
            "location": "/vnfm-how-to-write/#create-project-folder", 
            "text": "First of all you need to create a new directory for your VNFManager.\nHere we call the new VNFManager my-vnfm.\nSo this can be replaced by whatever you want.  $ mkdir my-vnfm", 
            "title": "Create project folder"
        }, 
        {
            "location": "/vnfm-how-to-write/#create-the-main-class_1", 
            "text": "The Main class is the most important class you need to consider.\nHere you implement your main method and also methods you need to have for your VNFManager.\nFurther explanations are done in the according sections.\nThis is only for creating a proper file structure.\nSo execute the following commands to create the Main class in a proper folder and package structure.  First, you need to create the folders and package by executing the following command in your root folder of the project.  $ mkdir -p src/main/java/org/openbaton/vnfm  This creates the java folder src/main/java with the proposed package name org.openbaton.vnfm.  In the next step you create the Main Class called MyVNFM in this case.  $ vim src/main/java/org/openbaton/vnfm/MyVNFM.java  At this point you create only the basic Java Class used later as the Main Class for implementing your VNFManager.\nThe newly created Java Class should contain the following lines for now.  package org.openbaton.vnfm;\n\npublic class MyVNFM {\n}  If you have chosen a different package name you need to replace it as well at this point.\nOnce this is done, you need to initialize the gradle wrapper and configuring according files.", 
            "title": "Create the Main Class"
        }, 
        {
            "location": "/vnfm-how-to-write/#the-buildgradle-file", 
            "text": "First you need to create the build.gradle file by executing the following command from your root project folder.  $ vim build.gradle  This gradle configuration file needs to contain initially the following lines.  buildscript {\n    repositories {\n        mavenCentral()\n    }\n\n    dependencies {\n        classpath( org.springframework.boot:spring-boot-gradle-plugin:1.3.1.RELEASE )\n    }\n}\n\napply plugin: 'java'\napply plugin: 'spring-boot'  The second gradle configuration is called settings.gradle.\nThis file contains only the project name.\nSo create a new file called settings.gradle in your root folder.  $ vim settings.gradle  Afterwards you need to add the following line containing your project name.\nIn our case my-vnfm.  rootProject.name = 'my-vnfm'  Afterwards go back to the root folder and run the following command to create automatically the gradle wrapper which is used for code management and compilation.\nFor more information on how to use the gradle wrapper have a look at the gradle wrapper documentation  here .  $ gradle wrapper  Once you did all these steps, the initial project structure is created.\nWhat we miss right now is the configuration of the gradle files to define and fetch dependencies we need for implementing the VNFManager.\nThis is described in later sections.", 
            "title": "The Build.Gradle file"
        }, 
        {
            "location": "/vnfm-how-to-write/#create-the-properties-files_1", 
            "text": "The properties files are used to define several parameters you need at runtime.\nSo just create the following file structure by executing the following commands.  $ mkdir src/main/resources  Now you need to create two new files by running both commands you can find in the following  $ touch src/main/resources/application.properties\n$ touch src/main/resources/conf.properties  What these files should contain is explained  here .", 
            "title": "Create the properties files"
        }, 
        {
            "location": "/vnfm-how-to-write/#configure-gradle", 
            "text": "Finally you need to extend your build.gradle for announcing the Main Class, plugins to apply and repositories to use.\nSo open the build.gradle an add missing line so that the file contains the following line.  //...\n\nbootRepackage {\n    mainClass = 'org.openbaton.vnfm.MyVNFM'\n}\n\n//...  Take care about the configuration of the mainClass.\nIf the name or package of your mainClass is different, you need to replace it here as well.", 
            "title": "Configure Gradle"
        }, 
        {
            "location": "/vnfm-how-to-write/#property-files", 
            "text": "The previously created properties files are used to define several things.\nThey are located in src/main/resources and are called application.properties and conf.properties.  The  application.properties  contains parameters for setting up all log levels. This file is useful for configuring the springframework (see  Spring Boot configuration file ). This file can contain the following lines.  logging.level.org.springframework=INFO\nlogging.level.org.hibernate=INFO\nlogging.level.org.apache=INFO\nlogging.level.org.jclouds=WARN\n# logging.level.org.springframework.security=WARN\nlogging.level.org.springframework.web = WARN\n\n# Level for loggers on classes inside the root package  org.project.openbaton  (and its\n# sub-packages)\nlogging.level.org.openbaton=INFO\n\n# Direct log to a log file\nlogging.file=/var/log/openbaton.log\n\nvnfm.rabbitmq.brokerIp=localhost\nvnfm.rabbitmq.management.port=15672\nvnfm.rabbitmq.autodelete=true\nvnfm.rabbitmq.durable=false\nvnfm.rabbitmq.exclusive=false\nvnfm.rabbitmq.minConcurrency=5\nvnfm.rabbitmq.maxConcurrency=15\n\n#########################################\n############## RabbitMQ #################\n#########################################\n\n# Comma-separated list of addresses to which the client should connect to.\n# spring.rabbitmq.addresses= 192.168.145.54\n# Create an AmqpAdmin bean.\n# spring.rabbitmq.dynamic=true\n# RabbitMQ host.\nspring.rabbitmq.host=${vnfm.rabbitmq.brokerIp}\n# Acknowledge mode of container.\n# spring.rabbitmq.listener.acknowledge-mode=\n# Start the container automatically on startup.\n# spring.rabbitmq.listener.auto-startup=true\n# Minimum number of consumers.\nspring.rabbitmq.listener.concurrency=5\n# Maximum number of consumers.\nspring.rabbitmq.listener.max-concurrency=30\n# Number of messages to be handled in a single request. It should be greater than or equal to the transaction size (if used).\n# spring.rabbitmq.listener.prefetch=\n# Number of messages to be processed in a transaction. For best results it should be less than or equal to the prefetch count.\n# spring.rabbitmq.listener.transaction-size=\n# Login user to authenticate to the broker.\nspring.rabbitmq.username=admin\n# Login to authenticate against the broker.\nspring.rabbitmq.password=openbaton\n# RabbitMQ port.\nspring.rabbitmq.port=5672\n# Requested heartbeat timeout, in seconds; zero for none.\n# spring.rabbitmq.requested-heartbeat=\n# Enable SSL support.\n# spring.rabbitmq.ssl.enabled=false\n# Path to the key store that holds the SSL certificate.\n# spring.rabbitmq.ssl.key-store=\n# Password used to access the key store.\n# spring.rabbitmq.ssl.key-store-password=\n# Trust store that holds SSL certificates.\n# spring.rabbitmq.ssl.trust-store=\n# Password used to access the trust store.\n# spring.rabbitmq.ssl.trust-store-password=\n# Virtual host to use when connecting to the broker.\n# spring.rabbitmq.virtual-host=  If you want to change log levels you need to adapt it here.  NOTE :  If your VNFManager is running on a different machine than the rabbitmq broker, you need to change the  vnfm.rabbit.brokerIp  accordingly with the ip of the rabbitmq broker.  The  conf.properties  is also a very important configuration file.\nHere you need to define the type and endpoint of your VNFManager that is later used for registering on the NFVO.\nFurthermore, you can define your own parameters which can be used at runtime for whatever you want.\nSo this file has to contain at least the type and endpoint.\nAdditionally, it is defined the folder where the vim drivers are located.\nIn this case the file should contain the following lines.  type=my-vnfm\nendpoint=my-vnfm-endpoint\nallocate = false\ndescription=The VNFM able to handle all the VNFs that follow specific conventions, see http://openbaton.github.io/\nenabled = true\nendpoint-type = RABBIT\nscript-max-time = 300000\nconcurrency = 15\n\n\n#### Additionally\nvim-plugin-dir = ./plugins  Where the parameters mean:     Params  Meaning      type  The type of VNF you are going to handle    endpoint  The endpoint used for requesting this VNFManager    description  Just a useless description    endpoint-type  type of the endpoint, either RABBIT or REST, depending on the sdk chosen. Check out next section    enabled  true if you want your vnfm to be enabled    allocate  true if the VNFM will ALLOCATE_RESOURCES, false if the NFVO will do    concurrency  The number of concurrent Receiver (only for vnfm-sdk-amqp)", 
            "title": "Property files"
        }, 
        {
            "location": "/vnfm-how-to-write/#choose-a-vnfm-sdk", 
            "text": "Before you can start with the implementation you need to select the type of communication you want to use for the communication between the Orchestrator (NFVO) and the VNFManager.\nEither you can use the vnfm-sdk-amqp for using the  RabbitMQ  or the vnfm-sdk-rest for using the  ReST  interface.\nHowever, your choice doesn't effect the upcoming implementation, because the communication itself is done automatically in the background.\nBut have in mind that both libraries depend on  SpringBoot .\nSo, if you want to avoid this dependency, a third option might be: just use the simple vnfm-sdk artifact.\nBy using the simple vnfm-sdk you need to take care about all the communication between NFVO and VNFManager by yourself.  Once you have imported one of the vnfm-sdks you will have access to all the model classes and the vnfm-sdk classes needed to implement a VNFManager.  The following section shows you how to import the vnfm-sdk-amqp, representative for all the other opportunities.", 
            "title": "Choose a vnfm-sdk"
        }, 
        {
            "location": "/vnfm-how-to-write/#import-a-vnfm-sdk", 
            "text": "This section shows how to import and configure your VNFManager to make use of the vnfm-sdk-amqp.  For gathering the vnfm-sdk-amqp library you need to import the libraries by adding the missing lines to your build.gradle:  //...\n\ndependencies {\n    compile 'org.hibernate:hibernate-core:4.3.10.Final'\n    compile 'org.openbaton:vnfm-sdk-amqp:3.2.0'\n}\n\n//...  Note  To make use of the vnfm-sdk-rest you need to change 'vnfm-sdk-amqp' to 'vnfm-sdk-rest' only.  So the final build.gradle file results like:  buildscript {\n    repositories {\n        mavenCentral()\n    }\n    dependencies {\n        classpath( org.springframework.boot:spring-boot-gradle-plugin:1.3.1.RELEASE )\n    }   \n\n}\n\napply plugin: 'java'\napply plugin: 'spring-boot'\n\nrepositories {\n    mavenCentral()\n    /**\n     * Only needed for openbaton snapshots dependencies\n     */\n    maven {\n        url 'https://oss.sonatype.org/content/repositories/snapshots/'\n    }\n}\n\ndependencies {\n    compile 'org.openbaton:vnfm-sdk-amqp:3.2.0'\n    compile 'org.hibernate:hibernate-core:4.3.10.Final'\n}\n\ngroup 'your.group'\nversion '1.0-SNAPSHOT'\n\nbootRepackage {\n    mainClass = 'org.openbaton.vnfm.MyVNFM'\n}  Once you did this, you need to trigger the gradle build process by running the following command via the command line in your project's root folder.  $ ./gradlew build  This will fetch all the dependencies defined in the build.gradle and gives you access to all the Classes you need.\nYou can also do this by using the IDE by running the corresponding gradle task.", 
            "title": "Import a vnfm-sdk"
        }, 
        {
            "location": "/vnfm-how-to-write/#implementation-of-the-vnfmanager", 
            "text": "This section is going to describe the implementation of a basic VNFManager by using the vnfm-sdk-amqp.\nIn the end, the VNFManager will be able to allocate and terminate resources by using its own openstack-plugin.  So first of all you need to define the main method used for starting your VNFManager.\nSo add the following to your Main Class that it looks as follows:  package org.openbaton.vnfm;\n\nimport org.springframework.boot.SpringApplication;\n\npublic class MyVNFM {\n\n    public static void main(String[] args){\n        SpringApplication.run(MyVNFM.class);\n    }\n}  Afterwards you need to extend your Main Class (in this case MyVNFM) with the  AbstractVnfmSpringAmqp .  The  AbstractVnfmSpringAmqp  takes care of all the configuration you need to register/unregister the VNFManager to the NFVO and handles incoming messages.\nWhereas the  AbstractVnfm , extended by the  AbstractVnfmSpringAmqp , is independent of the type of communication.\nThis means more in detail that the  AbstractVnfm  processes the incoming messages and executes the right method depending on the defined Action inside the message.\nMoreover, it is responsible for loading predefined configuration files, setting up the VNFManager itself, creating the VNFR (based on the VNFD received in the first step) and doing essential parts like requesting the NFVO for granting operations or deciding who is responsible for allocate resources.  Once you extended your VNFMManger, you need to implement all the methods coming from the extension of  AbstractVnfmSpringAmqp  as shown below:  package org.openbaton.vnfm;\n\nimport org.openbaton.catalogue.mano.record.VNFCInstance;\nimport org.openbaton.catalogue.mano.record.VNFRecordDependency;\nimport org.openbaton.catalogue.mano.record.VirtualNetworkFunctionRecord;\nimport org.openbaton.catalogue.nfvo.Action;\nimport org.openbaton.catalogue.nfvo.VimInstance;\nimport org.openbaton.common.vnfm_sdk.amqp.AbstractVnfmSpringAmqp;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\nimport java.util.Collection;\nimport java.util.Map;\n\n@SpringBootApplication\npublic class MyVNFM extends AbstractVnfmSpringAmqp{\n\n    public static void main(String[] args){\n        SpringApplication.run(MyVNFM.class);\n    }\n\n    /**\n     * This operation allows creating a VNF instance.\n     *\n     * @param virtualNetworkFunctionRecord\n     * @param scripts\n     * @param vimInstances\n     */\n    @Override\n    public VirtualNetworkFunctionRecord instantiate(VirtualNetworkFunctionRecord virtualNetworkFunctionRecord, Object scripts, Map String, Collection VimInstance  vimInstances) throws Exception {\n        return virtualNetworkFunctionRecord;\n    }\n\n    /**\n     * This operation allows retrieving\n     * VNF instance state and attributes.\n     */\n    @Override\n    public void query() {\n\n    }\n\n    /**\n     * This operation allows scaling\n     * (out/in, up/down) a VNF instance.\n     */\n    @Override\n    public VirtualNetworkFunctionRecord scale(Action scaleInOrOut, VirtualNetworkFunctionRecord virtualNetworkFunctionRecord, VNFComponent component, Object scripts, VNFRecordDependency dependency) throws Exception {\n        return virtualNetworkFunctionRecord;\n    }\n\n\n    /**\n     * This operation allows verifying if\n     * the VNF instantiation is possible.\n     */\n    @Override\n    public void checkInstantiationFeasibility() {\n\n    }\n\n    /**\n     * This operation is called when one the VNFs fails\n     */\n    @Override\n    public VirtualNetworkFunctionRecord heal(VirtualNetworkFunctionRecord virtualNetworkFunctionRecord, VNFCInstance component, String cause) throws Exception {\n        return virtualNetworkFunctionRecord;\n    }\n\n    /**\n     * This operation allows applying a minor/limited\n     * software update (e.g. patch) to a VNF instance.\n     */\n    @Override\n    public VirtualNetworkFunctionRecord updateSoftware(Script script, VirtualNetworkFunctionRecord virtualNetworkFunctionRecord) throws Exception {\n        return virtualNetworkFunctionRecord;\n    }\n\n\n    /**\n     * This operation allows making structural changes\n     * (e.g. configuration, topology, behavior,\n     * redundancy model) to a VNF instance.\n     *\n     * @param virtualNetworkFunctionRecord\n     * @param dependency\n     */\n    @Override\n    public VirtualNetworkFunctionRecord modify(VirtualNetworkFunctionRecord virtualNetworkFunctionRecord, VNFRecordDependency dependency) throws Exception {\n        return virtualNetworkFunctionRecord;\n    }\n\n    /**\n     * This operation allows deploying a new\n     * software release to a VNF instance.\n     */\n    @Override\n    public void upgradeSoftware() {\n\n    }\n\n    /**\n     * This operation allows terminating gracefully\n     * or forcefully a previously created VNF instance.\n     *\n     * @param virtualNetworkFunctionRecord\n     */\n    @Override\n    public VirtualNetworkFunctionRecord terminate(VirtualNetworkFunctionRecord virtualNetworkFunctionRecord) {\n        log.info( Terminating vnfr with id   + virtualNetworkFunctionRecord.getId());\n        return virtualNetworkFunctionRecord;\n    }\n\n    @Override\n    public void handleError(VirtualNetworkFunctionRecord virtualNetworkFunctionRecord) {\n\n    }\n\n    @Override\n    protected void checkEMS(String hostname) {\n        log.warn( EMS is not supported by this VNFM );\n    }\n\n    @Override\n    protected void checkEmsStarted(String hostname) throws RuntimeException {\n        log.warn( EMS is not supported by this VNFM );\n    }\n\n    @Override\n    public VirtualNetworkFunctionRecord start(VirtualNetworkFunctionRecord virtualNetworkFunctionRecord) throws Exception {\n        return virtualNetworkFunctionRecord;\n    }\n\n    @Override\n    public VirtualNetworkFunctionRecord stop(VirtualNetworkFunctionRecord virtualNetworkFunctionRecord) throws Exception {\n        return virtualNetworkFunctionRecord;\n    }\n\n    @Override\n    public VirtualNetworkFunctionRecord startVNFCInstance(VirtualNetworkFunctionRecord virtualNetworkFunctionRecord, VNFCInstance vnfcInstance) throws Exception {\n        return virtualNetworkFunctionRecord;\n    }\n\n    @Override\n    public VirtualNetworkFunctionRecord stopVNFCInstance(VirtualNetworkFunctionRecord virtualNetworkFunctionRecord, VNFCInstance vnfcInstance) throws Exception {\n        return virtualNetworkFunctionRecord;\n    }\n\n    @Override\n    public VirtualNetworkFunctionRecord configure(VirtualNetworkFunctionRecord virtualNetworkFunctionRecord) throws Exception {\n        return virtualNetworkFunctionRecord;\n    }\n\n    @Override\n    public VirtualNetworkFunctionRecord resume(VirtualNetworkFunctionRecord virtualNetworkFunctionRecord, VNFCInstance vnfcInstance, VNFRecordDependency dependency) throws Exception {\n        return virtualNetworkFunctionRecord;\n    }\n\n    /**\n     * This operation allows providing notifications on state changes\n     * of a VNF instance, related to the VNF Lifecycle.\n     */\n    @Override\n    public void NotifyChange() {\n\n    }\n}  Now you can implement whatever you want. If the VirtualNetworkFunctionRecord is returned, it will go back directly to the NFVO.  One of the methods that can be overwritten is the  fillParameters . This method is important when you have specified some \"provides\" in your VNFD, in facts you can fill them in this method and make them available afterwards to the scripts (see  How to use the parameters ).   An example of allocating and terminating resource by using a plugin can be found  here  and  here .  Note  If you use vnfm-sdk-amqp or vnfm-sdk-rest  the VNFManager main class needs to be stateless  since it can (will) run each method potentially in parallel.\nFor what concerns vnfm-sdk-amqp, even setting concurrency to 1, will not ensure to have always the same instance of the class.", 
            "title": "Implementation of the VNFManager"
        }, 
        {
            "location": "/vnfm-how-to-write/#using-the-vnfmhelper", 
            "text": "Additionally you can autowire the VnfmHelper to make use of several helper methods that are very useful.\nIn this case your VNFManager should look like this:  package org.openbaton.vnfm;\n\nimport org.springframework.beans.factory.annotation.Autowired;\n\npublic class MyVNFM extends AbstractVnfmSpringAmqp {\n\n    @Autowired\n    private VnfmHelper vnfmHelper;\n\n    [...]\n}  The vnfmHelper helps with some methods out of the box:  package org.openbaton.common.vnfm_sdk;\n\nimport org.openbaton.catalogue.nfvo.messages.Interfaces.NFVMessage;\n\npublic abstract class VnfmHelper {\n\n    /**\n     * This operation sends a NFVMessage\n     * to the NFVO and doesn't wait for answer.\n     * @param nfvMessage\n     */\n    public abstract void sendToNfvo(NFVMessage nfvMessage);\n\n    /**\n     * This operation send a NFVMessage\n     * to the NFVO and waits for the answer.\n     * @param nfvMessage\n     */\n    public abstract NFVMessage sendAndReceive(NFVMessage nfvMessage) throws Exception;\n}  At the moment, the main purpose of the VnfmHelper is to send messages to the NFVO and wait for the answer if needed.  Note  This class needs to be implemented in case you want to use only the vnfm-sdk and must be provided to the AbstractVnfm.", 
            "title": "Using the VnfmHelper"
        }, 
        {
            "location": "/vnfm-how-to-write/#using-plugins", 
            "text": "This section describes the initialization and usage of plugins.\nTherefore, you need to do several things:   Start the plugins  Connect an according VIM to the plugin or use the plugin directly   Note  If you want to use the Vim with plugins, you need to fetch also the interfaces and VIM implementations by adding the following lines to your build.gradle dependencies  compile 'org.openbaton:vim-int:3.2.0'\ncompile 'org.openbaton:vim-impl:3.2.0'\ncompile 'org.openbaton:sdk:3.2.0'  After that you need to rebuild your project for fetching the dependencies automatically.  Now you can use the ResourceManagement interface.\nIn the end it should look like the following:  package org.openbaton.vnfm;\n\nimport org.openbaton.catalogue.mano.record.VNFCInstance;\nimport org.openbaton.catalogue.mano.record.VNFRecordDependency;\nimport org.openbaton.catalogue.mano.record.VirtualNetworkFunctionRecord;\nimport org.openbaton.catalogue.nfvo.Action;\nimport org.openbaton.catalogue.nfvo.VimInstance;\nimport org.openbaton.common.vnfm_sdk.amqp.AbstractVnfmSpringAmqp;\nimport org.openbaton.nfvo.vim_interfaces.resource_management.ResourceManagement;\nimport org.openbaton.plugin.utils.PluginStartup;\nimport org.openbaton.plugin.utils.RabbitPluginBroker;\nimport org.openbaton.vim.drivers.VimDriverCaller;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.context.ConfigurableApplicationContext;\n\nimport java.io.IOException;\nimport java.util.Collection;\nimport java.util.Map;\n\npublic class MyVNFM extends AbstractVnfmSpringAmqp {\n\n    @Autowired\n    private ConfigurableApplicationContext context;\n\n    private ResourceManagement resourceManagement;\n\n    private VimDriverCaller client;\n\n    [...]\n\n    @Override\n    protected void setup() {\n        super.setup();\n        try {\n            //Start all the plugins that are located in ./plugins\n            PluginStartup.startPluginRecursive( ./plugins , true,  localhost ,  5672 , 15,  admin ,  openbaton ,  15672 );\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        //Fetching the OpenstackVim using the openstack-plugin\n        resourceManagement = (ResourceManagement) context.getBean( openstackVIM , 19345,  15672 );\n        //Using the openstack-plugin directly\n        client = (VimDriverCaller) ((RabbitPluginBroker) context.getBean( rabbitPluginBroker )).getVimDriverCaller( localhost ,  admin ,  openbaton , 5672,  openstack ,  openstack ,  15672 );\n    }\n}  This code expects that the plugins are located in ./plugins.\nSo just copy the openstack plugin of your choice to this path.\nNow you are able to use a VIM inside or the directly the plugin in your VNFManager to allocate and release resources whenever you want.", 
            "title": "Using plugins"
        }, 
        {
            "location": "/vnfm-how-to-write/#allocate-resources", 
            "text": "The following code snippet shows how to instantiate (allocate) resources at VNFManager side with the help of the VIM.  /**\n * This operation allows creating a VNF instance.\n *\n * @param virtualNetworkFunctionRecord\n * @param scripts\n * @param vimInstances\n */\n@Override\npublic VirtualNetworkFunctionRecord instantiate(VirtualNetworkFunctionRecord virtualNetworkFunctionRecord, Object scripts, Map String, Collection VimInstance  vimInstances) throws Exception {\n    log.debug( Processing allocation of Resources for vnfr:   + virtualNetworkFunctionRecord);\n    /**\n     * Allocation of Resources\n     *  the grant operation is already done before this method\n     */\n    String userdata =  ;\n    Iterator ConfigurationParameter  configIterator = virtualNetworkFunctionRecord.getConfigurations().getConfigurationParameters().iterator();\n    while (configIterator.hasNext()) {\n        ConfigurationParameter configurationParameter = configIterator.next();\n        log.debug( Configuration Parameter:   + configurationParameter);\n        if (configurationParameter.getConfKey().equals( GROUP_NAME )) {\n            userdata =  export GROUP_NAME=  + configurationParameter.getValue() +  \\n ;\n            userdata +=  echo $GROUP_NAME   /home/ubuntu/group_name.txt\\n ;\n        }\n    }\n    userdata += getUserData();\n\n    log.debug( Processing allocation of Recources for vnfr:   + virtualNetworkFunctionRecord);\n    for (VirtualDeploymentUnit vdu : virtualNetworkFunctionRecord.getVdu()) {\n        VimInstance vimInstance = vimInstances.get(vdu.getParent_vdu()).iterator().next();\n        log.debug( Creating   + vdu.getVnfc().size() +   VMs );\n        for (VNFComponent vnfComponent : vdu.getVnfc()) {\n            Map String, String  floatingIps = new HashMap ();\n            for (VNFDConnectionPoint connectionPoint : vnfComponent.getConnection_point()) {\n                if (connectionPoint.getFloatingIp() != null   !connectionPoint.getFloatingIp().equals( )) {\n                    floatingIps.put(connectionPoint.getVirtual_link_reference(), connectionPoint.getFloatingIp());\n                }\n            }\n            try {\n                VNFCInstance vnfcInstance = resourceManagement.allocate(vimInstance, vdu, virtualNetworkFunctionRecord, vnfComponent, userdata, floatingIps, new HashSet ()).get();\n                log.debug( Created VNFCInstance with id:   + vnfcInstance);\n                vdu.getVnfc_instance().add(vnfcInstance);\n            } catch (VimException e) {\n                log.error(e.getMessage());\n                if (log.isDebugEnabled())\n                    log.error(e.getMessage(), e);\n            }\n        }\n    }\n    log.debug( Allocated all Resources for vnfr:   + virtualNetworkFunctionRecord);\n    return virtualNetworkFunctionRecord;\n}  Note  Keep in mind that you need to set  allocate  to false in conf.properties, if you want to allocate resources on the VNFManager side. Otherwise the NFVO will allocate resources as well.", 
            "title": "Allocate Resources"
        }, 
        {
            "location": "/vnfm-how-to-write/#release-resources", 
            "text": "The next code snippet shows an implementation of the terminate method used for releasing resources at VNFManager side.  /**\n * This operation allows terminating gracefully\n * or forcefully a previously created VNF instance.\n *\n * @param virtualNetworkFunctionRecord\n */\n@Override\npublic VirtualNetworkFunctionRecord terminate(VirtualNetworkFunctionRecord virtualNetworkFunctionRecord) {\n    log.info( Terminating vnfr with id   + virtualNetworkFunctionRecord.getId());\n    NFVORequestor nfvoRequestor = new NFVORequestor( admin ,  openbaton ,  localhost ,  8080 ,  1 );\n    for (VirtualDeploymentUnit vdu : virtualNetworkFunctionRecord.getVdu()) {\n        Set VNFCInstance  vnfciToRem = new HashSet ();\n        List VimInstance  vimInstances = new ArrayList ();\n        VimInstance vimInstance = null;\n        try {\n            vimInstances = nfvoRequestor.getVimInstanceAgent().findAll();\n        } catch (SDKException e) {\n            log.error(e.getMessage(), e);\n        } catch (ClassNotFoundException e) {\n            log.error(e.getMessage(), e);\n        }\n        for (VimInstance vimInstanceFind : vimInstances) {\n            if (vdu.getVimInstanceName().contains(vimInstanceFind.getName())) {\n                vimInstance = vimInstanceFind;\n                break;\n            }\n        }\n        for (VNFCInstance vnfcInstance : vdu.getVnfc_instance()) {\n            log.debug( Releasing resources for vdu with id   + vdu.getId());\n            try {\n                resourceManagement.release(vnfcInstance, vimInstance);\n            } catch (VimException e) {\n                log.error(e.getMessage(), e);\n                throw new RuntimeException(e.getMessage(), e);\n            }\n            vnfciToRem.add(vnfcInstance);\n            log.debug( Released resources for vdu with id   + vdu.getId());\n        }\n        vdu.getVnfc_instance().removeAll(vnfciToRem);\n    }\n    log.info( Terminated vnfr with id   + virtualNetworkFunctionRecord.getId());\n    return virtualNetworkFunctionRecord;\n}", 
            "title": "Release Resources"
        }, 
        {
            "location": "/vnfm-how-to-write/#start-the-vnfmanager", 
            "text": "Once you finalized your VNFManager you can compile and start it with the following commands.  $ ./gradlew clean build\n$ java -jar build/libs/my-vnfm-{version}.jar  If everything is fine, your VNFManager will register to NFVO and is able now to receive requests and process them.    \n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  &amp;&amp; (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Start the VNFManager"
        }, 
        {
            "location": "/vnfm-vendor-specific/", 
            "text": "Use my VNFM\n\n\nIn this section are described the REST interfaces which allow you to use your Virtual Network Function Manager (VNFM) with Openbaton's Network Function Virtualization Orchestrator (NFVO).\n\n\nNFVO - VNFM ReST interface\n\n\nNFVO exposes a REST interface for the communication with the VnfManagers. The sequence diagram regarding the instantiation of a NetworkServiceRecord is shown in the following picture.\n\n\n\n\nAs shown in the picture, the NFVO calls some ReST methods on the VNFM in a particular order. Then it expects the corresponding call back. The different types of exchanges are described in the following sections. The ALLOCATE_RESOURCES call is not needed if the VNFM will take care of creating VMs. The communication with the EMS is particular to each VNFM. In order to be able to be found, the VNFM needs to register to the NFVO. This can be done through a particular registration call.\n\n\nIn the following 'Vnfm-Or' means that the Vnfm sends to the Nfvo and 'Or-Vnfm' means that the Nfvo sends to the Vnfm.\n\n\n\n\n\n\n\n\nParams\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\nOrEndpoint\n\n\nThe endpoint of the NFVO (i.e. http://127.0.0.1:8080)\n\n\n\n\n\n\nVnfmEnpoint\n\n\nThe endpoint of the VNFM. This is given to the NFVO while registering\n\n\n\n\n\n\n\n\nRegistering a VNFM to the NFVO (Vnfm-Or)\n\n\nThis call registers a VNFM to an NFVO. \n\n\nrequest path\n\n\nPOST request on\n\n\nOrEndpoint\n/admin/v1/vnfm-register\n\n\nrequest body\n\n\n{\n    \ntype\n:\ndummy\n,\n    \nendpointType\n:\nREST\n,\n    \nendpoint\n:\nVnfmEndpoint\n,\n    \ndescription\n:\nMyVnfm\n,\n    \nenabled\n:\ntrue\n\n}\n\n\n\n\nrequest structure\n\n\n\n\n\n\n\n\nField\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\ntype\n\n\nthe VNFM type you are going to handle (specified in VirtualNetworkFunctionDescriptor \u2192 endpoint)\n\n\n\n\n\n\nendpointType\n\n\nthe VNFM type you are going to implement (REST or AMQP)\n\n\n\n\n\n\nendpoint\n\n\nthe VNFM endpoint to which the NFVO will connect (basically http://\nIP>:\nPORT>)\n\n\n\n\n\n\n\n\nINSTANTIATE (Or-Vnfm)\n\n\nThis call sends the Virtual Network Function Descriptor (VNFD) to the VNFM, which shall be used to create the Virtual Network Funtion Record (VNFR) and also sends to the VNFM all the scripts which are executed in actions like INSTANTIATE, MODIFY or START. This call triggers the creation of a Virtual Machine for the VNFCInstances specified in the sent VNFD and triggers the execution of the scripts which are associated with the INSTANTIATE lifecycle event in the VNFD. \n\n\nrequest path\n\n\nPOST request on \nVnfmEnpoint\n\n\nrequest body\n\n\n{\n    \nvnfd\n:{  ...  }, \n    \nvnfdf\n:{  ...  },\n    \nvlrs\n:[  ...  ],\n    \nextention\n:{  \n      \nnsr-id\n:\n...\n,\n      \nbrokerIp\n:\n...\n,\n      ...\n    },\n    \naction\n:\nINSTANTIATE\n,\n    \nvimInstances\n: {\n      \nvdu_id\n:[\n        { ... },\n        { ... }\n      ]\n    },\n    \nvnfPackage\n: { ... },\n    \nkeypairs\n:[\n    { ... }\n    ]  \n}\n\n\n\n\nrequest structure\n\n\n\n\n\n\n\n\nField\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\nvnfd\n\n\nthe VNFD used to create the VNFR\n\n\n\n\n\n\nvnfdf\n\n\nthe deployment flavours to be used\n\n\n\n\n\n\nvlrs\n\n\nthe list of VirtualLinkRecords of the NetworkServiceRecord\n\n\n\n\n\n\nextention\n\n\nsome info like the NetworkServiceRecord id\n\n\n\n\n\n\naction\n\n\nthe action to be executed\n\n\n\n\n\n\nvimInstances\n\n\na map containing per each VDU id the list of VimInstance objects\n\n\n\n\n\n\nvnfPackage\n\n\nthe VNFPackage of the VNFR\n\n\n\n\n\n\nkeypairs\n\n\nthe list of additional keypairs to be added to the VM\n\n\n\n\n\n\n\n\nGrantOperation (Vnfm-Or)\n\n\nThis call sends the VNFR to the NFVO in order to ask if there are enough resources\n\n\nrequest path\n\n\nPOST request on \nOrEndpoint\n/admin/v1/vnfm-core-grant\n\n\nrequest body\n\n\n{\n    \naction\n:\nGRANT_OPERATION\n,\n    \nvirtualNetworkFunctionRecord\n:{..}\n}\n\n\n\n\nrequest structure\n\n\n\n\n\n\n\n\nField\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\naction\n\n\nGRANT_OPERATION\n\n\n\n\n\n\nvirtualNetworkFunctionRecord\n\n\nthe VNFR\n\n\n\n\n\n\n\n\nGrantOperation (Or-Vnfm)\n\n\nThis call returns the NFVO's answer to the grant operation call\n\n\nrequest path\n\n\nPOST request on \nVnfmEnpoint\n\n\nrequest body\n\n\n{\n    \ngrantAllowed\n: true,\n    \nvduVim\n: {\n      \nvdu_id\n: {  }\n    },\n    \nvirtualNetworkFunctionRecord\n:{\n        ...\n    }\n}\n\n\n\n\nrequest structure\n\n\n\n\n\n\n\n\nField\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\ngrantAllowed\n\n\nif the NFVO has granted the allocate resources\n\n\n\n\n\n\nvduVim\n\n\nwhich VIM was chosen per VDU\n\n\n\n\n\n\nvirtualNetworkFunctionRecord\n\n\nthe VNFR\n\n\n\n\n\n\n\n\nAllocateResources (Vnfm-Or)\n\n\nThis call sends the VNFR to the NFVO in order to allocate resources\n\n\nrequest path\n\n\nPOST request on \nOrEndpoint\n/admin/v1/vnfm-core-allocate\n\n\nrequest body\n\n\n{\n    \nvirtualNetworkFunctionRecord\n:{..},\n    \nvimInstances\n:{\n      \nvdu_id\n:{ ... }\n    },\n    \nuserdata\n:\n,\n    \nkeypairs\n:[\n    { ... }\n    ]\n}\n\n\n\n\nrequest structure\n\n\n\n\n\n\n\n\nField\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\nvirtualNetworkFunctionRecord\n\n\nthe VNFR\n\n\n\n\n\n\nvimInstances\n\n\nthe chosen VIM per VDU\n\n\n\n\n\n\nuserdata\n\n\nthe userdata\n\n\n\n\n\n\nkeypairs\n\n\nthe keypairs to be added to the VM by the NFVO\n\n\n\n\n\n\n\n\nAllocateResources (Or-Vnfm)\n\n\nThis call returns the new VNFR to the VNFM\n\n\nrequest path\n\n\nPOST request on \nVnfmEnpoint\n\n\nrequest body\n\n\n{\n    \nvnfr\n: { ... }\n}\n\n\n\n\nrequest structure\n\n\n\n\n\n\n\n\nField\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\nvirtualNetworkFunctionRecord\n\n\nthe updated VNFR\n\n\n\n\n\n\n\n\nInstantiate (Vnfm-Or)\n\n\nThis call sends back the created Virtual Network Function Record to the NFVO. \n\n\nrequest path\n\n\nPOST request on \nOrEndpoint\n/admin/v1/vnfm-core-actions\n\n\nrequest body\n\n\n{\n    \nvirtualNetworkFunctionRecord\n:{  ...  }, \n    \naction\n:\nINSTANTIATE\n\n}\n\n\n\n\nrequest structure\n\n\n\n\n\n\n\n\nField\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\nvirtualNetworkFunctionRecord\n\n\nthe created VirtualNetworkFunctionRecord\n\n\n\n\n\n\naction\n\n\nthe action that was executed\n\n\n\n\n\n\n\n\nModify (aka AddRelations) (Or-Vnfm)\n\n\nThe Nfvo uses this request to provide dependencies of Virtual Network Functions to the VNFM. The scripts associated with the CONFIGURATION lifecycle event in the VNFR will be executed.\n\n\nrequest path\n\n\nPOST request on\n\n\nVnfmEnpoint\n\n\nrequest body\n\n\n{\n    \nvnfr\n:{ ... }, \n    \nvnfrd\n:{ ... }, \n    \naction\n:\nMODIFY\n\n}\n\n\n\n\nrequest structure\n\n\n\n\n\n\n\n\nField\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\nvnfr\n\n\nthe dependency's target VNFR\n\n\n\n\n\n\nvnfrd\n\n\nthe VNFDependency containing all the source parameters needed by the scripts\n\n\n\n\n\n\naction\n\n\nthe action to be executed\n\n\n\n\n\n\n\n\nModify (aka AddRelations) (Vnfm-Or)\n\n\nThis call sends back the modified Virtual Network Function Record to the NFVO. \n\n\nrequest path\n\n\nPOST request on\n\n\nOrEndpoint\n/admin/v1/vnfm-core-actions\n\n\nrequest body\n\n\n{\n    \nvirtualNetworkFunctionRecord\n:{ ... },\n    \naction\n:\nMODIFY\n\n}\n\n\n\n\nrequest structure\n\n\n\n\n\n\n\n\nField\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\nvirtualNetworkFunctionRecord\n\n\nthe VNFR\n\n\n\n\n\n\naction\n\n\nthe action that was executed\n\n\n\n\n\n\n\n\nStart (Or-Vnfm)\n\n\nThis call will trigger the execution of the scripts associated with the START lifecycle event in the VNFR. \n\n\nrequest path\n\n\nPOST request on\n\n\nVnfmEnpoint\n\n\nrequest body\n\n\n{\n    \nvnfr\n:{  ...  },\n    \naction\n:\nSTART\n\n}\n\n\n\n\nrequest structure\n\n\n\n\n\n\n\n\nField\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\nvnfr\n\n\nthe VNFR to start\n\n\n\n\n\n\naction\n\n\nthe action to be executed\n\n\n\n\n\n\n\n\nStart (Vnfm-Or)\n\n\nrequest path\n\n\nPOST request on\n\n\nOrEndpoint\n/admin/v1/vnfm-core-actions\n\n\nrequest body\n\n\n{\n    \nvirtualNetworkFunctionRecord\n:{  ...  },\n    \naction\n:\nSTART\n\n}\n\n\n\n\nrequest structure\n\n\n\n\n\n\n\n\nField\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\nvirtualNetworkFunctionRecord\n\n\nthe Virtual Network Function Record\n\n\n\n\n\n\naction\n\n\nthe action that was executed\n\n\n\n\n\n\n\n\nWith this last message the VNF managed by this VNFM will be set to ACTIVE. When all the VNF are set to ACTIVE also the NSR will be set to ACTIVE and the deployment succeeded.\n\n\n\n\n\n\n\n\n\n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Integrate your own VNFM"
        }, 
        {
            "location": "/vnfm-vendor-specific/#use-my-vnfm", 
            "text": "In this section are described the REST interfaces which allow you to use your Virtual Network Function Manager (VNFM) with Openbaton's Network Function Virtualization Orchestrator (NFVO).", 
            "title": "Use my VNFM"
        }, 
        {
            "location": "/vnfm-vendor-specific/#nfvo-vnfm-rest-interface", 
            "text": "NFVO exposes a REST interface for the communication with the VnfManagers. The sequence diagram regarding the instantiation of a NetworkServiceRecord is shown in the following picture.   As shown in the picture, the NFVO calls some ReST methods on the VNFM in a particular order. Then it expects the corresponding call back. The different types of exchanges are described in the following sections. The ALLOCATE_RESOURCES call is not needed if the VNFM will take care of creating VMs. The communication with the EMS is particular to each VNFM. In order to be able to be found, the VNFM needs to register to the NFVO. This can be done through a particular registration call.  In the following 'Vnfm-Or' means that the Vnfm sends to the Nfvo and 'Or-Vnfm' means that the Nfvo sends to the Vnfm.     Params  Meaning      OrEndpoint  The endpoint of the NFVO (i.e. http://127.0.0.1:8080)    VnfmEnpoint  The endpoint of the VNFM. This is given to the NFVO while registering", 
            "title": "NFVO - VNFM ReST interface"
        }, 
        {
            "location": "/vnfm-vendor-specific/#registering-a-vnfm-to-the-nfvo-vnfm-or", 
            "text": "This call registers a VNFM to an NFVO.", 
            "title": "Registering a VNFM to the NFVO (Vnfm-Or)"
        }, 
        {
            "location": "/vnfm-vendor-specific/#request-path", 
            "text": "POST request on  OrEndpoint /admin/v1/vnfm-register", 
            "title": "request path"
        }, 
        {
            "location": "/vnfm-vendor-specific/#request-body", 
            "text": "{\n     type : dummy ,\n     endpointType : REST ,\n     endpoint : VnfmEndpoint ,\n     description : MyVnfm ,\n     enabled : true \n}", 
            "title": "request body"
        }, 
        {
            "location": "/vnfm-vendor-specific/#request-structure", 
            "text": "Field  Meaning      type  the VNFM type you are going to handle (specified in VirtualNetworkFunctionDescriptor \u2192 endpoint)    endpointType  the VNFM type you are going to implement (REST or AMQP)    endpoint  the VNFM endpoint to which the NFVO will connect (basically http:// IP>: PORT>)", 
            "title": "request structure"
        }, 
        {
            "location": "/vnfm-vendor-specific/#instantiate-or-vnfm", 
            "text": "This call sends the Virtual Network Function Descriptor (VNFD) to the VNFM, which shall be used to create the Virtual Network Funtion Record (VNFR) and also sends to the VNFM all the scripts which are executed in actions like INSTANTIATE, MODIFY or START. This call triggers the creation of a Virtual Machine for the VNFCInstances specified in the sent VNFD and triggers the execution of the scripts which are associated with the INSTANTIATE lifecycle event in the VNFD.", 
            "title": "INSTANTIATE (Or-Vnfm)"
        }, 
        {
            "location": "/vnfm-vendor-specific/#request-path_1", 
            "text": "POST request on  VnfmEnpoint", 
            "title": "request path"
        }, 
        {
            "location": "/vnfm-vendor-specific/#request-body_1", 
            "text": "{\n     vnfd :{  ...  }, \n     vnfdf :{  ...  },\n     vlrs :[  ...  ],\n     extention :{  \n       nsr-id : ... ,\n       brokerIp : ... ,\n      ...\n    },\n     action : INSTANTIATE ,\n     vimInstances : {\n       vdu_id :[\n        { ... },\n        { ... }\n      ]\n    },\n     vnfPackage : { ... },\n     keypairs :[\n    { ... }\n    ]  \n}", 
            "title": "request body"
        }, 
        {
            "location": "/vnfm-vendor-specific/#request-structure_1", 
            "text": "Field  Meaning      vnfd  the VNFD used to create the VNFR    vnfdf  the deployment flavours to be used    vlrs  the list of VirtualLinkRecords of the NetworkServiceRecord    extention  some info like the NetworkServiceRecord id    action  the action to be executed    vimInstances  a map containing per each VDU id the list of VimInstance objects    vnfPackage  the VNFPackage of the VNFR    keypairs  the list of additional keypairs to be added to the VM", 
            "title": "request structure"
        }, 
        {
            "location": "/vnfm-vendor-specific/#grantoperation-vnfm-or", 
            "text": "This call sends the VNFR to the NFVO in order to ask if there are enough resources", 
            "title": "GrantOperation (Vnfm-Or)"
        }, 
        {
            "location": "/vnfm-vendor-specific/#request-path_2", 
            "text": "POST request on  OrEndpoint /admin/v1/vnfm-core-grant", 
            "title": "request path"
        }, 
        {
            "location": "/vnfm-vendor-specific/#request-body_2", 
            "text": "{\n     action : GRANT_OPERATION ,\n     virtualNetworkFunctionRecord :{..}\n}", 
            "title": "request body"
        }, 
        {
            "location": "/vnfm-vendor-specific/#request-structure_2", 
            "text": "Field  Meaning      action  GRANT_OPERATION    virtualNetworkFunctionRecord  the VNFR", 
            "title": "request structure"
        }, 
        {
            "location": "/vnfm-vendor-specific/#grantoperation-or-vnfm", 
            "text": "This call returns the NFVO's answer to the grant operation call", 
            "title": "GrantOperation (Or-Vnfm)"
        }, 
        {
            "location": "/vnfm-vendor-specific/#request-path_3", 
            "text": "POST request on  VnfmEnpoint", 
            "title": "request path"
        }, 
        {
            "location": "/vnfm-vendor-specific/#request-body_3", 
            "text": "{\n     grantAllowed : true,\n     vduVim : {\n       vdu_id : {  }\n    },\n     virtualNetworkFunctionRecord :{\n        ...\n    }\n}", 
            "title": "request body"
        }, 
        {
            "location": "/vnfm-vendor-specific/#request-structure_3", 
            "text": "Field  Meaning      grantAllowed  if the NFVO has granted the allocate resources    vduVim  which VIM was chosen per VDU    virtualNetworkFunctionRecord  the VNFR", 
            "title": "request structure"
        }, 
        {
            "location": "/vnfm-vendor-specific/#allocateresources-vnfm-or", 
            "text": "This call sends the VNFR to the NFVO in order to allocate resources", 
            "title": "AllocateResources (Vnfm-Or)"
        }, 
        {
            "location": "/vnfm-vendor-specific/#request-path_4", 
            "text": "POST request on  OrEndpoint /admin/v1/vnfm-core-allocate", 
            "title": "request path"
        }, 
        {
            "location": "/vnfm-vendor-specific/#request-body_4", 
            "text": "{\n     virtualNetworkFunctionRecord :{..},\n     vimInstances :{\n       vdu_id :{ ... }\n    },\n     userdata : ,\n     keypairs :[\n    { ... }\n    ]\n}", 
            "title": "request body"
        }, 
        {
            "location": "/vnfm-vendor-specific/#request-structure_4", 
            "text": "Field  Meaning      virtualNetworkFunctionRecord  the VNFR    vimInstances  the chosen VIM per VDU    userdata  the userdata    keypairs  the keypairs to be added to the VM by the NFVO", 
            "title": "request structure"
        }, 
        {
            "location": "/vnfm-vendor-specific/#allocateresources-or-vnfm", 
            "text": "This call returns the new VNFR to the VNFM", 
            "title": "AllocateResources (Or-Vnfm)"
        }, 
        {
            "location": "/vnfm-vendor-specific/#request-path_5", 
            "text": "POST request on  VnfmEnpoint", 
            "title": "request path"
        }, 
        {
            "location": "/vnfm-vendor-specific/#request-body_5", 
            "text": "{\n     vnfr : { ... }\n}", 
            "title": "request body"
        }, 
        {
            "location": "/vnfm-vendor-specific/#request-structure_5", 
            "text": "Field  Meaning      virtualNetworkFunctionRecord  the updated VNFR", 
            "title": "request structure"
        }, 
        {
            "location": "/vnfm-vendor-specific/#instantiate-vnfm-or", 
            "text": "This call sends back the created Virtual Network Function Record to the NFVO.", 
            "title": "Instantiate (Vnfm-Or)"
        }, 
        {
            "location": "/vnfm-vendor-specific/#request-path_6", 
            "text": "POST request on  OrEndpoint /admin/v1/vnfm-core-actions", 
            "title": "request path"
        }, 
        {
            "location": "/vnfm-vendor-specific/#request-body_6", 
            "text": "{\n     virtualNetworkFunctionRecord :{  ...  }, \n     action : INSTANTIATE \n}", 
            "title": "request body"
        }, 
        {
            "location": "/vnfm-vendor-specific/#request-structure_6", 
            "text": "Field  Meaning      virtualNetworkFunctionRecord  the created VirtualNetworkFunctionRecord    action  the action that was executed", 
            "title": "request structure"
        }, 
        {
            "location": "/vnfm-vendor-specific/#modify-aka-addrelations-or-vnfm", 
            "text": "The Nfvo uses this request to provide dependencies of Virtual Network Functions to the VNFM. The scripts associated with the CONFIGURATION lifecycle event in the VNFR will be executed.", 
            "title": "Modify (aka AddRelations) (Or-Vnfm)"
        }, 
        {
            "location": "/vnfm-vendor-specific/#request-path_7", 
            "text": "POST request on  VnfmEnpoint", 
            "title": "request path"
        }, 
        {
            "location": "/vnfm-vendor-specific/#request-body_7", 
            "text": "{\n     vnfr :{ ... }, \n     vnfrd :{ ... }, \n     action : MODIFY \n}", 
            "title": "request body"
        }, 
        {
            "location": "/vnfm-vendor-specific/#request-structure_7", 
            "text": "Field  Meaning      vnfr  the dependency's target VNFR    vnfrd  the VNFDependency containing all the source parameters needed by the scripts    action  the action to be executed", 
            "title": "request structure"
        }, 
        {
            "location": "/vnfm-vendor-specific/#modify-aka-addrelations-vnfm-or", 
            "text": "This call sends back the modified Virtual Network Function Record to the NFVO.", 
            "title": "Modify (aka AddRelations) (Vnfm-Or)"
        }, 
        {
            "location": "/vnfm-vendor-specific/#request-path_8", 
            "text": "POST request on  OrEndpoint /admin/v1/vnfm-core-actions", 
            "title": "request path"
        }, 
        {
            "location": "/vnfm-vendor-specific/#request-body_8", 
            "text": "{\n     virtualNetworkFunctionRecord :{ ... },\n     action : MODIFY \n}", 
            "title": "request body"
        }, 
        {
            "location": "/vnfm-vendor-specific/#request-structure_8", 
            "text": "Field  Meaning      virtualNetworkFunctionRecord  the VNFR    action  the action that was executed", 
            "title": "request structure"
        }, 
        {
            "location": "/vnfm-vendor-specific/#start-or-vnfm", 
            "text": "This call will trigger the execution of the scripts associated with the START lifecycle event in the VNFR.", 
            "title": "Start (Or-Vnfm)"
        }, 
        {
            "location": "/vnfm-vendor-specific/#request-path_9", 
            "text": "POST request on  VnfmEnpoint", 
            "title": "request path"
        }, 
        {
            "location": "/vnfm-vendor-specific/#request-body_9", 
            "text": "{\n     vnfr :{  ...  },\n     action : START \n}", 
            "title": "request body"
        }, 
        {
            "location": "/vnfm-vendor-specific/#request-structure_9", 
            "text": "Field  Meaning      vnfr  the VNFR to start    action  the action to be executed", 
            "title": "request structure"
        }, 
        {
            "location": "/vnfm-vendor-specific/#start-vnfm-or", 
            "text": "", 
            "title": "Start (Vnfm-Or)"
        }, 
        {
            "location": "/vnfm-vendor-specific/#request-path_10", 
            "text": "POST request on  OrEndpoint /admin/v1/vnfm-core-actions", 
            "title": "request path"
        }, 
        {
            "location": "/vnfm-vendor-specific/#request-body_10", 
            "text": "{\n     virtualNetworkFunctionRecord :{  ...  },\n     action : START \n}", 
            "title": "request body"
        }, 
        {
            "location": "/vnfm-vendor-specific/#request-structure_10", 
            "text": "Field  Meaning      virtualNetworkFunctionRecord  the Virtual Network Function Record    action  the action that was executed     With this last message the VNF managed by this VNFM will be set to ACTIVE. When all the VNF are set to ACTIVE also the NSR will be set to ACTIVE and the deployment succeeded.    \n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "request structure"
        }, 
        {
            "location": "/monitoring/", 
            "text": "Monitoring\n\n\nOpen Baton interfaces with monitoring systems using a plugin mechanism. \nThe plugin mechanism allows Open Baton to easily use multiple monitoring system. The following figure shows how the monitoring plugin communicate with the NFVO.\n\n\n\n\nAs you can see from the picture above the Monitoring Plugin (or Driver) is an intermediate between Open Baton and the specific monitoring system. \nMonitoring Plugin implements a Standard interface in order to be used by Open Baton.\nAn example of monitoring plugin is Zabbix plugin which allows Open Baton to use Zabbix Server. \nThe Zabbix Plugin is already available and you can find the documentation in the next page.", 
            "title": "Monitoring overview"
        }, 
        {
            "location": "/monitoring/#monitoring", 
            "text": "Open Baton interfaces with monitoring systems using a plugin mechanism. \nThe plugin mechanism allows Open Baton to easily use multiple monitoring system. The following figure shows how the monitoring plugin communicate with the NFVO.   As you can see from the picture above the Monitoring Plugin (or Driver) is an intermediate between Open Baton and the specific monitoring system. \nMonitoring Plugin implements a Standard interface in order to be used by Open Baton.\nAn example of monitoring plugin is Zabbix plugin which allows Open Baton to use Zabbix Server. \nThe Zabbix Plugin is already available and you can find the documentation in the next page.", 
            "title": "Monitoring"
        }, 
        {
            "location": "/zabbix-plugin/", 
            "text": "Zabbix plugin\n\n\nZabbix plugin (see it on \nGitHub\n) is an open source project providing a reference implementation of two interfaces of the VIM, based on the ETSI \nNFV MANO\n specification.\n\n\nThe two interfaces are:\n\n-   VirtualisedResourceFaultManagement\n\n-   VirtualisedResourcePerformanceManagement\n\n\nA detailed description of the interfaces is in the last ETSI Draft \nIFA005_Or-Vi_ref_point_Spec\n.\n\nIn particular with the Zabbix plugin you can create/delete items, trigger and action on-demand. \n\n\n\n\nSome of the benefits introduced by the usage of such plugin:\n\n1) Make the consumers (NFVO, VNFM) indipendent to the monitoring system.\n\n2) The communication between the consumers and zabbix-plugin is JSON based, so the consumers can be written in any languages.\n\n3) The values of the items are cached and updated periodically in order to avoid to contact the zabbix server each time a specific metric is required.\n\n4) If your consumer is written in java, we provide a simple class MonitoringPluginCaller which handle the communication via RabbitMQ.  \n\n\nPrerequisites\n\n\nThe prerequisites are:  \n\n\n\n\nZabbix server (2.2 or 3.0) installed and running. See \nhow to configure Zabbix server 2.2\n or \nZabbix server 3.0\n.\n\n\nRabbitMQ server installed and running  \n\n\nGit installed\n\n\nGradle installed\n\n\n\n\nAdditional Zabbix Server configuration required for receiving notifications\n\n\nIf you are going to use Open Baton FM system or you wish to use the createThreshold method, you need this additional configuration.\n\nCreate a script called \"send_notification.sh\" with the following content.\n\n\n#!/bin/bash\nto=$1\nbody=$3\ncurl -X POST -H \nAccept: application/json\n -H \nContent-Type: application/json\n -d \n$body\n http://$to\n\n\n\n\nThe variable 'to' is the endpoint where zabbix-plugin receives the notification (specified in \nnotification-receiver-server-context\n property). \nCopy the following script in the Zabbix Server machine. In particular, in a special directory defined in the Zabbix Server configuration file (/etc/zabbix/zabbix_server.conf) as AlertScriptsPath variable. If the value of the variable AlertScriptsPath is for example \"/usr/lib/zabbix/alertscripts\", \nthen copy the send_notification.sh script just created in that folder.\n\nOnce you are in the directory \"/usr/lib/zabbix/alertscripts\", add executable permissions to the script running the command:\n\n\nsudo chmod +x send_notification.sh\n\n\n\n\nNote\n: when you will use the method createThreshold, Zabbix Plugin will configure Zabbix Server automatically in order to use the script \"send_notification.sh\". \nWhat it will try to do is the configuration at this page \ncustom alertscripts\n. \nIf for any reason this auto-configuration won't work, you will see in the Zabbix Plugin logs, then you should execute this configuration manually as explained in the Zabbix documentation.\n\n\nNotification mechanism\n\n\nHow does Zabbix plugin receive notifications from the Zabbix Server? \n\n\nWhen using the method createThreshold provided by the plugin, it automatically creates an \naction\n executed when the specific condition is met. \nIf the threshold is crossed (the status of the trigger goes from OK to PROBLEM or viceversa) the action is performed. The action gets the informations of the threshold and sends them to a custom alertScript.\nThe custom alertscripts is executed on the Zabbix Server and its task is to send the information received from the action to the Zabbix plugin. \n\n\nZabbix plugin waits for notifications at the url: http://zabbix-plugin-ip:defaultPort/defaultContext.\n\n\nDefatult context and ports are specified in the configuration file as: \n\n \nnotification-receiver-server-context\n.\n\n \nnotification-receiver-server-port\n.\n\n\nInstallation\n\n\nOnce the prerequisites are met, you can clone the following project from git, compile it using gradle and launch it:  \n\n\ngit clone https://github.com/openbaton/zabbix-plugin.git\ncd zabbix-plugin\n./gradlew build -x test\njava -jar build/lib/openbaton-plugin-monitoring-zabbix-\nversion\n.jar\n\n\n\n\nConfiguration\n\n\nIf the prerequisites are met you should already have the folder \"/etc/openbaton\". Then copy the configuration file in src/main/resources/plugin.conf.properties to the path /etc/openbaton/ with the name openbaton-plugin-monitoring-zabbix.properties. Once you are inside the zabbix-plugin directory type this command:\n\n\ncp src/main/resources/plugin.conf.properties /etc/openbaton/openbaton-plugin-monitoring-zabbix.properties\n\n\n\n\nThe configuration parameters are explained in the following table.\n\n\n\n\n\n\n\n\nParameter\n\n\nDescription\n\n\nDefault\n\n\n\n\n\n\n\n\n\n\nzabbix-plugin-ip\n\n\nIP of the Zabbix Plugin machine\n\n\nlocalhost\n\n\n\n\n\n\nzabbix-host\n\n\nIP of the Zabbix Server\n\n\nlocalhost\n\n\n\n\n\n\nzabbix-port\n\n\nPort of the Zabbix Server\n\n\n\n\n\n\n\n\ntype\n\n\nThe type of the plugin\n\n\nzabbix-plugin\n\n\n\n\n\n\nuser-zbx\n\n\nUser of the Zabbix Server\n\n\nAdmin\n\n\n\n\n\n\npassword-zbx\n\n\nPassword of Zabbix Server\n\n\nzabbix\n\n\n\n\n\n\nzabbix-server-version\n\n\nZabbix Server version\n\n\n3.0\n\n\n\n\n\n\nclient-request-frequency\n\n\nUpdate cache period (Basically each time t, Zabbix Plugin ask to every items value for all hosts and fill the local cache). Set 0 to disable it\n\n\n10 (seconds)\n\n\n\n\n\n\nhistory-length\n\n\nHow long is the history. If the client-request-frequency is 10 seconds and history-length 100, we have available the value of the items of the previous 1000 seconds.\n\n\n250\n\n\n\n\n\n\nnotification-receiver-server-context\n\n\nContext where the zabbix-plugin receive the notifications by the zabbix server. (see the section 'How to configure Zabbix to get notifications')\n\n\n/zabbixplugin/notifications\n\n\n\n\n\n\nnotification-receiver-server-port\n\n\nPort where the zabbix-plugin receive the notifications by the zabbix server.\n\n\n8010\n\n\n\n\n\n\nexternal-properties-file\n\n\nFull path of the configuration file.\n\n\n/etc/openbaton/openbaton-plugin-monitoring-zabbix.properties\n\n\n\n\n\n\n\n\nThe configuration file should look like the one below:\n\n\n## Zabbix Plugin\n\nzabbix-plugin-ip=localhost\n# Set client-request-frequency to 0 to disable the caching\ntype=zabbix-plugin\nclient-request-frequency=10\nhistory-length=250\nnotification-receiver-server-context=/zabbixplugin/notifications\nnotification-receiver-server-port=8010\nexternal-properties-file=/etc/openbaton/openbaton-plugin-monitoring-zabbix.properties\n\n## Zabbix Server info\n\nzabbix-host=localhost\n# zabbix-port=\nuser-zbx=Admin\npassword-zbx=zabbix\n# Supported Zabbix versions: 2.2 and 3.0\nzabbix-server-version=3.0\n\n\n\n\nUsing it via MonitoringPluginCaller\n\n\nIn order to use the MonitorPluginCaller you need to import the relative plugin-sdk, coming from \nOpenbaton\n project.\nTo import the plugin-sdk, please add in your gradle file the following dependencies:\n\n\nrepositories {\n       maven { url 'https://oss.sonatype.org/content/repositories/snapshots/' }\n       maven { url 'https://oss.sonatype.org/content/repositories/releases/'  }\n}\n\ndependencies {\n    compile 'org.openbaton:monitoring:3.2.1-SNAPSHOT'\n}\n\n\n\n\nThen in your main, obtain the MonitoringPluginCaller as follow:\n\n\nMonitoringPluginCaller monitoringPluginCaller = null;\n    try {\n      monitoringPluginCaller =\n          new MonitoringPluginCaller(\n              \nbrokerIp\n, \nusername\n, \npassword\n, 5601, \nzabbix-plugin\n, \nzabbix\n, \n15672\n,120000);\n    } catch (IOException e) {\n      e.printStackTrace();\n    } catch (TimeoutException e) {\n      e.printStackTrace();\n    } catch (NotFoundException e) {\n      e.printStackTrace();\n    }\n\n\n\n\nMake sure to use the correct arguments' values. A description is provided in the following:  \n\n\n\n\n\n\n\n\nArgument value\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nbrokerIp\n\n\nIP of RabbitMQ (broker)\n\n\n\n\n\n\nusername\n\n\nUsername for RabbitMQ\n\n\n\n\n\n\npassword\n\n\nPassword for RabbitMQ\n\n\n\n\n\n\n5672\n\n\nRabbitMQ default port (change it if needed)\n\n\n\n\n\n\nzabbix-plugin\n\n\nType of the Monitoring Plugin\n\n\n\n\n\n\nzabbix\n\n\nName of the Monitoring Plugin\n\n\n\n\n\n\n15672\n\n\nRabbitMQ default management port\n\n\n\n\n\n\n120000\n\n\nTimeout of the calls on the MonitoringPluginCaller\n\n\n\n\n\n\n\n\nFunctionalities provided by the Zabbix Plugin Interface\n\n\nVirtualisedResourcePerformanceManagement interface\n\n\n\n\n\n\n\n\nMethods\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nCREATE PM JOB\n\n\nCreate one or more items to be monitored in one or more hosts.\n\n\n\n\n\n\nDELETE PM JOB\n\n\nDelete a PM job.\n\n\n\n\n\n\nQUERY PM JOB\n\n\nGet item values from one or more host. Fast method since the item values are cached.\n\n\n\n\n\n\nSUBSCRIBE\n\n\nSubscribe to a pm job or a threshold in order to be notified.\n\n\n\n\n\n\nNOTIFY\n\n\nNotification method invoked by zabbix plugin, the customer must not invoke directly this method.\n\n\n\n\n\n\nCREATE THRESHOLD\n\n\nCreate trigger on a specific item for one or more hosts\n\n\n\n\n\n\nDELETE THRESHOLD\n\n\nDelete a threshold.\n\n\n\n\n\n\nQUERY THRESHOLD\n\n\nGet information about the status of the thresholds\n\n\n\n\n\n\n\n\nVirtualisedResourceFaultManagement interface\n\n\n\n\n\n\n\n\nMethods\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nSUBSCRIBE\n\n\nSubscribe for alarm coming from an host\n\n\n\n\n\n\nNOTIFY\n\n\nNotification method invoked by zabbix plugin, the customer must not invoke directly this method.\n\n\n\n\n\n\nGET ALARM LIST\n\n\nGet alarms and relative status\n\n\n\n\n\n\n\n\nVirtualisedResourcePerformanceManagement interface\n\n\nCreate PM Job\n\n\nString createPMJob(ObjectSelection selector, List\nString\n performanceMetrics, List\nString\n performanceMetricGroup, Integer collectionPeriod,Integer reportingPeriod) throws MonitoringException;\n\n\n\n\nThis method create one or more items to be monitored in one or more hosts.\n\n\nselector\n: object to select the hosts in which we want to add the items.\n\n\nperformanceMetrics\n: List of items. We can create items which are available in the \nZabbix documentation 2.2\n or [Zabbix documentation 3.0][zabbix-doc-3.0].\n\n\nperformanceMetricGroup\n: pre-defined list of metrics. (NOT YET IMPLEMENTED, please pass an empty list of string).\n\n\ncollectionPeriod\n: Update interval of the item/s in seconds.\n\n\nreportingPeriod\n: Specifies the periodicity at which the VIM will report to the customers about performance information. (NOT YET IMPLEMENTED, please pass an integer \n= 0 ).\n\n\nIn the following example we create two items ('net.tcp.listen[8080]' and 'agent.ping') for two hosts ('host-1' and 'host-2'). As a return value we get the ID of the PMJob.\n\n\nObjectSelection objectSelection = getObjectSelector(\nhost-1\n,\nhost-2\n);\nList\nString\n performanceMetrics = getPerformanceMetrics(\nnet.tcp.listen[8080]\n,\nagent.ping\n);\nString pmJobId = monitoringPluginCaller.createPMJob(objectSelection, performanceMetrics, new ArrayList\nString\n(),60, 0);\nSystem.out.println(\nPmJobId is: \n+pmJobId);\n\n\n\n\nHere the methods getObjectSelector and getPerformanceMetrics:\n\n\nprivate List\nString\n getPerformanceMetrics(String ... performanceMetrics) {\n    List\nString\n result = new ArrayList\nString\n();\n    for(String performanceMetric : performanceMetrics){\n        result.add(performanceMetric);\n    }\n    return result;\n}\n\nprivate ObjectSelection getObjectSelector(String ... hosts) {\n    ObjectSelection objectSelection = new ObjectSelection();\n    for(String host : hosts){\n        objectSelection.addObjectInstanceId(host);\n    }\n    return objectSelection;\n}\n\n\n\n\nDelete Pm Job\n\n\nList\nString\n deletePMJob(List\nString\n pmJobIdsToDelete) throws MonitoringException;\n\n\n\n\nThis method delete an existing PmJob. We can get the id of the PmJob after the creation with createPMJob. As a return value we get the ID of the PMJobs effectively deleted.\n\n\nQuery Pm Job\n\n\nList\nItem\n queryPMJob(List\nString\n hostnames, List\nString\n performanceMetrics, String period) throws MonitoringException;\n\n\n\n\nThis method get item values from one or more host. As a return value we get the list of items.\n\n\nhostnames\n: list of hostnames which we want to know items values.\n\n\nperformanceMetrics\n: List of items. We can get items which are available in: the \nZabbix documentation 2.2\n, [Zabbix documentation 3.0][zabbix-doc-3.0], and in the \nhostnames\n.\n\n\nperiod\n: period in seconds. If period is 0 than you get the last available value of the item. If \n 0 you get the average of the values inside that period.\n    Remember than the zabbix-plugin read all value of the all hosts every \nclient-request-frequency\n (see the configuration section) and keep them in the history.\n    So if \nclient-request-frequency\n is 15 seconds and the period 30 seconds you get the average of the previous 2 values of the item.\n\n\nIn the following example we ask for the last value of two items ('net.tcp.listen[8080]' and 'agent.ping') for the hosts 'host-1'.\n\n\nArrayList\nString\n hostnames = getHostnames(\nhost-1\n);\nArrayList\nString\n performanceMetrics = getPerformanceMetrics(\nnet.tcp.listen[8080]\n,\nagent.ping\n);\nList\nItem\n items = monitoringPluginCaller.queryPMJob(hostnames,performanceMetrics,\n0\n);\n\n\n\n\nitems\n: list of items. An item is a simple object of openbaton-libs which contains properties like: metric, hostname, lastValue, value.\n\n\nSubscribe \n notifyInfo\n\n\nNOT YET IMPLEMENTED\n\n\nCreate Threshold\n\n\nString createThreshold(ObjectSelection selector, String performanceMetric, ThresholdType thresholdType, ThresholdDetails thresholdDetails) throws MonitoringException;\n\n\n\n\nThis method create a trigger on a specific item for one or more hosts. As a return value we get the id of the threshold.\n\n\nselector\n: object to select the hosts which will be part of the trigger.\n\n\nperformanceMetric\n: item to include in the trigger. The item need to be already present in the hosts specified in the \nselector\n.\n\n\nthresholdType\n: defines the type of threshold. (NOT YET IMPLEMENTED, please pass ThresholdType.SINGLE for the moment).\n\n\nthresholdDetails\n: details of the threshold. It contains:\n\n\n\n\nfunction: refer to \nZabbix trigger function 2.2\n or [Zabbix documentation 3.0][zabbix-trigger-function-3.0] \n\n\ntriggerOperator: operator\n\n\nperceiverSeverity: severity of the trigger.\n\n\nvalue: threshold value to compare with the actual value of the \nperformanceMetric\n.\n\n\nhostOperator: can be \"|\" or \"\n\", meaning that the threshold will trigger when at least one host or all the hosts cross the threshold value.\n\n\n\n\nIn the following example we create a treshold for two hosts ('host-1' and 'host-2').\n\n\nObjectSelection objectSelector = getObjectSelector(\nhost-1\n,\nhost-2\n);\nThresholdDetails thresholdDetails= new ThresholdDetails(\nlast(0)\n,\n=\n,PerceivedSeverity.CRITICAL,\n0\n,\n|\n);\nString thresholdId = zabbixMonitoringAgent.createThreshold(objectSelector,\nnet.tcp.listen[5001]\n,ThresholdType.SINGLE_VALUE,thresholdDetails);\n\n\n\n\nThe trigger that will be created has this expression: {host-1:net.tcp.listen[5001].last(0)}=0|{host-2:net.tcp.listen[5001].last(0)}=0.\nIt means that if host-1 OR host-2 have no more process listening on the port 5001 then create an alarm with severity critical.\nRefer to \nZabbix expression 2.2\n or [Zabbix expression 3.0][zabbix-trigger-expression-3.0] to understand better the expression.\n\n\nDelete Threshold\n\n\nList\nString\n deleteThreshold(List\nString\n thresholdIds) throws MonitoringException;\n\n\n\n\nThis method delete an existing threshold/s. We can get the id of the threshold after the creation with createThreshold. As a return value we get the list of the ID of the threshold effectively deleted.\n\n\nQuery Threshold\n\n\nNOT YET IMPLEMENTED\n\n\nVirtualisedResourceFaultManagement interface\n\n\nSubscribe\n\n\nString subscribeForFault(AlarmEndpoint filter) throws MonitoringException;\n\n\n\n\nSubscribe for alarm generated by thresholds. As a return value we get the id of the subscription.\n\nfilter\n: AlarmEndpoint object which contains:\n-  name: name of the alarmEndpoint.\n-  resourceId: hostname which we want to subscribe.\n-  type: REST or JMS.\n-  endpoint: endpoint where we want to be notified. It is and url for REST or a queue name for JMS. (actually only rest is supported).\n-  perceivedSeverity: define the severity of the alarm we want to get.\n    If we specify PerceivedSeverity.WARNING we will able to get notification from alarm with severity equals or higher than WARNING.\n\n\nIn the following example we subscribe for all alarms with severity higher than WARNING coming from the host 'host-1'.\n\n\nAlarmEndpoint alarmEndpoint = new AlarmEndpoint(\nfault-manager-of-host-1\n,\nhost-1\n,EndpointType.REST,\nhttp://localhost:5555/alarm\n,PerceivedSeverity.WARNING);\nString subscriptionId = monitoringPluginCaller.subscribeForFault(alarmEndpoint);\n\n\n\n\nUnsubscribe\n\n\nString unsubscribeForFault(String subscriptionId) throws MonitoringException;\n\n\n\n\nThis method detele the subscription with the ID passed as a argument. As a return value we get the id of the subscription effectively deleted.\nWe can get the id of the subscription after the creation with subscribeForFault.\n\n\nGet alarm list\n\n\nNOT YET IMPLEMENTED\n\n\nNotify\n\n\nThis method cannot be invoked by the customers as specified in the ETSI draft \nIFA005_Or-Vi_ref_point_Spec\n.\n\n\nZabbix severity mapping with ETSI severity\n\n\nIn Zabbix we can specify a severity of a trigger: not classified, information, warning, average, high, disaster.\n\n\nIn the ETSI draft there are different level of severity, called perceived severity: Indeterminate, warning, minor, major, critical.\n\n\nSo the mapping in the zabbix plugin is showed in the following table:\n\n\n\n\n\n\n\n\nZabbix severity\n\n\nETSI perceived severity\n\n\n\n\n\n\n\n\n\n\nNot classified\n\n\nIndeterminate\n\n\n\n\n\n\nInformation\n\n\nWarning\n\n\n\n\n\n\nWarning\n\n\nWarning\n\n\n\n\n\n\nAverage\n\n\nMinor\n\n\n\n\n\n\nHigh\n\n\nMajor\n\n\n\n\n\n\nDisaster\n\n\nCritical\n\n\n\n\n\n\n\n\nNotifications types\n\n\nWhen we create a new threshold, we would like to get a notification as soon as the threshold is crossed. Both interfaces send notifications with the method notify.\nAccording to ETSI specification there are 4 types of notifications. \n\n\nThe interface VirtualisedResourcePerformanceManagement sends two types of notifications:  \n\n\n\n\nPerformanceInformationAvailableNotification (NOT YET IMPLEMENTED) : this notification informs the receiver that performance information is available.     \n\n\nhresholdCrossedNotification (NOT YET IMPLEMENTED) : his notification informs the receiver that a threshold value has been crossed.  \n\n\n\n\nThe interface VirtualisedResourceFaultManagement sends the following notifications:\n\n\n\n\nAlarmNotification: This notification informs the receiver of alarms resulting from the faults related to the virtualised resources managed by the VIM. It contains the Alarm with all the information about the fault.\n\n\nAlarmStateChangedNotification: This notification informs the receiver of state change of alarm related to the virtualised resources managed by the VIM, e.g. the alarm shall be set to \u201ccleared\u201d if the corresponding fault has been solved.\n    It contains the id of the Alarm and the actual status which could be (CLEARED,FIRED,UPDATED).\n\n\n\n\nActually the zabbix-plugin when receives the notification by zabbix server, \nif the trigger has severity higher than Information\n, \nit creates an alarm (mapping zabbix notification into standard Alarm) and notify the subscribers with a AlarmNotification. If the notification is not new, then it sends an AlarmStateChangedNotification.", 
            "title": "Zabbix plugin"
        }, 
        {
            "location": "/zabbix-plugin/#zabbix-plugin", 
            "text": "Zabbix plugin (see it on  GitHub ) is an open source project providing a reference implementation of two interfaces of the VIM, based on the ETSI  NFV MANO  specification.  The two interfaces are: \n-   VirtualisedResourceFaultManagement \n-   VirtualisedResourcePerformanceManagement  A detailed description of the interfaces is in the last ETSI Draft  IFA005_Or-Vi_ref_point_Spec . \nIn particular with the Zabbix plugin you can create/delete items, trigger and action on-demand.    Some of the benefits introduced by the usage of such plugin: \n1) Make the consumers (NFVO, VNFM) indipendent to the monitoring system. \n2) The communication between the consumers and zabbix-plugin is JSON based, so the consumers can be written in any languages. \n3) The values of the items are cached and updated periodically in order to avoid to contact the zabbix server each time a specific metric is required. \n4) If your consumer is written in java, we provide a simple class MonitoringPluginCaller which handle the communication via RabbitMQ.", 
            "title": "Zabbix plugin"
        }, 
        {
            "location": "/zabbix-plugin/#prerequisites", 
            "text": "The prerequisites are:     Zabbix server (2.2 or 3.0) installed and running. See  how to configure Zabbix server 2.2  or  Zabbix server 3.0 .  RabbitMQ server installed and running    Git installed  Gradle installed", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/zabbix-plugin/#additional-zabbix-server-configuration-required-for-receiving-notifications", 
            "text": "If you are going to use Open Baton FM system or you wish to use the createThreshold method, you need this additional configuration. \nCreate a script called \"send_notification.sh\" with the following content.  #!/bin/bash\nto=$1\nbody=$3\ncurl -X POST -H  Accept: application/json  -H  Content-Type: application/json  -d  $body  http://$to  The variable 'to' is the endpoint where zabbix-plugin receives the notification (specified in  notification-receiver-server-context  property). \nCopy the following script in the Zabbix Server machine. In particular, in a special directory defined in the Zabbix Server configuration file (/etc/zabbix/zabbix_server.conf) as AlertScriptsPath variable. If the value of the variable AlertScriptsPath is for example \"/usr/lib/zabbix/alertscripts\", \nthen copy the send_notification.sh script just created in that folder. \nOnce you are in the directory \"/usr/lib/zabbix/alertscripts\", add executable permissions to the script running the command:  sudo chmod +x send_notification.sh  Note : when you will use the method createThreshold, Zabbix Plugin will configure Zabbix Server automatically in order to use the script \"send_notification.sh\". \nWhat it will try to do is the configuration at this page  custom alertscripts . \nIf for any reason this auto-configuration won't work, you will see in the Zabbix Plugin logs, then you should execute this configuration manually as explained in the Zabbix documentation.", 
            "title": "Additional Zabbix Server configuration required for receiving notifications"
        }, 
        {
            "location": "/zabbix-plugin/#notification-mechanism", 
            "text": "How does Zabbix plugin receive notifications from the Zabbix Server?   When using the method createThreshold provided by the plugin, it automatically creates an  action  executed when the specific condition is met. \nIf the threshold is crossed (the status of the trigger goes from OK to PROBLEM or viceversa) the action is performed. The action gets the informations of the threshold and sends them to a custom alertScript.\nThe custom alertscripts is executed on the Zabbix Server and its task is to send the information received from the action to the Zabbix plugin.   Zabbix plugin waits for notifications at the url: http://zabbix-plugin-ip:defaultPort/defaultContext.  Defatult context and ports are specified in the configuration file as:    notification-receiver-server-context .   notification-receiver-server-port .", 
            "title": "Notification mechanism"
        }, 
        {
            "location": "/zabbix-plugin/#installation", 
            "text": "Once the prerequisites are met, you can clone the following project from git, compile it using gradle and launch it:    git clone https://github.com/openbaton/zabbix-plugin.git\ncd zabbix-plugin\n./gradlew build -x test\njava -jar build/lib/openbaton-plugin-monitoring-zabbix- version .jar", 
            "title": "Installation"
        }, 
        {
            "location": "/zabbix-plugin/#configuration", 
            "text": "If the prerequisites are met you should already have the folder \"/etc/openbaton\". Then copy the configuration file in src/main/resources/plugin.conf.properties to the path /etc/openbaton/ with the name openbaton-plugin-monitoring-zabbix.properties. Once you are inside the zabbix-plugin directory type this command:  cp src/main/resources/plugin.conf.properties /etc/openbaton/openbaton-plugin-monitoring-zabbix.properties  The configuration parameters are explained in the following table.     Parameter  Description  Default      zabbix-plugin-ip  IP of the Zabbix Plugin machine  localhost    zabbix-host  IP of the Zabbix Server  localhost    zabbix-port  Port of the Zabbix Server     type  The type of the plugin  zabbix-plugin    user-zbx  User of the Zabbix Server  Admin    password-zbx  Password of Zabbix Server  zabbix    zabbix-server-version  Zabbix Server version  3.0    client-request-frequency  Update cache period (Basically each time t, Zabbix Plugin ask to every items value for all hosts and fill the local cache). Set 0 to disable it  10 (seconds)    history-length  How long is the history. If the client-request-frequency is 10 seconds and history-length 100, we have available the value of the items of the previous 1000 seconds.  250    notification-receiver-server-context  Context where the zabbix-plugin receive the notifications by the zabbix server. (see the section 'How to configure Zabbix to get notifications')  /zabbixplugin/notifications    notification-receiver-server-port  Port where the zabbix-plugin receive the notifications by the zabbix server.  8010    external-properties-file  Full path of the configuration file.  /etc/openbaton/openbaton-plugin-monitoring-zabbix.properties     The configuration file should look like the one below:  ## Zabbix Plugin\n\nzabbix-plugin-ip=localhost\n# Set client-request-frequency to 0 to disable the caching\ntype=zabbix-plugin\nclient-request-frequency=10\nhistory-length=250\nnotification-receiver-server-context=/zabbixplugin/notifications\nnotification-receiver-server-port=8010\nexternal-properties-file=/etc/openbaton/openbaton-plugin-monitoring-zabbix.properties\n\n## Zabbix Server info\n\nzabbix-host=localhost\n# zabbix-port=\nuser-zbx=Admin\npassword-zbx=zabbix\n# Supported Zabbix versions: 2.2 and 3.0\nzabbix-server-version=3.0", 
            "title": "Configuration"
        }, 
        {
            "location": "/zabbix-plugin/#using-it-via-monitoringplugincaller", 
            "text": "In order to use the MonitorPluginCaller you need to import the relative plugin-sdk, coming from  Openbaton  project.\nTo import the plugin-sdk, please add in your gradle file the following dependencies:  repositories {\n       maven { url 'https://oss.sonatype.org/content/repositories/snapshots/' }\n       maven { url 'https://oss.sonatype.org/content/repositories/releases/'  }\n}\n\ndependencies {\n    compile 'org.openbaton:monitoring:3.2.1-SNAPSHOT'\n}  Then in your main, obtain the MonitoringPluginCaller as follow:  MonitoringPluginCaller monitoringPluginCaller = null;\n    try {\n      monitoringPluginCaller =\n          new MonitoringPluginCaller(\n               brokerIp ,  username ,  password , 5601,  zabbix-plugin ,  zabbix ,  15672 ,120000);\n    } catch (IOException e) {\n      e.printStackTrace();\n    } catch (TimeoutException e) {\n      e.printStackTrace();\n    } catch (NotFoundException e) {\n      e.printStackTrace();\n    }  Make sure to use the correct arguments' values. A description is provided in the following:       Argument value  Description      brokerIp  IP of RabbitMQ (broker)    username  Username for RabbitMQ    password  Password for RabbitMQ    5672  RabbitMQ default port (change it if needed)    zabbix-plugin  Type of the Monitoring Plugin    zabbix  Name of the Monitoring Plugin    15672  RabbitMQ default management port    120000  Timeout of the calls on the MonitoringPluginCaller", 
            "title": "Using it via MonitoringPluginCaller"
        }, 
        {
            "location": "/zabbix-plugin/#functionalities-provided-by-the-zabbix-plugin-interface", 
            "text": "", 
            "title": "Functionalities provided by the Zabbix Plugin Interface"
        }, 
        {
            "location": "/zabbix-plugin/#virtualisedresourceperformancemanagement-interface", 
            "text": "Methods  Description      CREATE PM JOB  Create one or more items to be monitored in one or more hosts.    DELETE PM JOB  Delete a PM job.    QUERY PM JOB  Get item values from one or more host. Fast method since the item values are cached.    SUBSCRIBE  Subscribe to a pm job or a threshold in order to be notified.    NOTIFY  Notification method invoked by zabbix plugin, the customer must not invoke directly this method.    CREATE THRESHOLD  Create trigger on a specific item for one or more hosts    DELETE THRESHOLD  Delete a threshold.    QUERY THRESHOLD  Get information about the status of the thresholds", 
            "title": "VirtualisedResourcePerformanceManagement interface"
        }, 
        {
            "location": "/zabbix-plugin/#virtualisedresourcefaultmanagement-interface", 
            "text": "Methods  Description      SUBSCRIBE  Subscribe for alarm coming from an host    NOTIFY  Notification method invoked by zabbix plugin, the customer must not invoke directly this method.    GET ALARM LIST  Get alarms and relative status", 
            "title": "VirtualisedResourceFaultManagement interface"
        }, 
        {
            "location": "/zabbix-plugin/#virtualisedresourceperformancemanagement-interface_1", 
            "text": "", 
            "title": "VirtualisedResourcePerformanceManagement interface"
        }, 
        {
            "location": "/zabbix-plugin/#create-pm-job", 
            "text": "String createPMJob(ObjectSelection selector, List String  performanceMetrics, List String  performanceMetricGroup, Integer collectionPeriod,Integer reportingPeriod) throws MonitoringException;  This method create one or more items to be monitored in one or more hosts.  selector : object to select the hosts in which we want to add the items.  performanceMetrics : List of items. We can create items which are available in the  Zabbix documentation 2.2  or [Zabbix documentation 3.0][zabbix-doc-3.0].  performanceMetricGroup : pre-defined list of metrics. (NOT YET IMPLEMENTED, please pass an empty list of string).  collectionPeriod : Update interval of the item/s in seconds.  reportingPeriod : Specifies the periodicity at which the VIM will report to the customers about performance information. (NOT YET IMPLEMENTED, please pass an integer  = 0 ).  In the following example we create two items ('net.tcp.listen[8080]' and 'agent.ping') for two hosts ('host-1' and 'host-2'). As a return value we get the ID of the PMJob.  ObjectSelection objectSelection = getObjectSelector( host-1 , host-2 );\nList String  performanceMetrics = getPerformanceMetrics( net.tcp.listen[8080] , agent.ping );\nString pmJobId = monitoringPluginCaller.createPMJob(objectSelection, performanceMetrics, new ArrayList String (),60, 0);\nSystem.out.println( PmJobId is:  +pmJobId);  Here the methods getObjectSelector and getPerformanceMetrics:  private List String  getPerformanceMetrics(String ... performanceMetrics) {\n    List String  result = new ArrayList String ();\n    for(String performanceMetric : performanceMetrics){\n        result.add(performanceMetric);\n    }\n    return result;\n}\n\nprivate ObjectSelection getObjectSelector(String ... hosts) {\n    ObjectSelection objectSelection = new ObjectSelection();\n    for(String host : hosts){\n        objectSelection.addObjectInstanceId(host);\n    }\n    return objectSelection;\n}", 
            "title": "Create PM Job"
        }, 
        {
            "location": "/zabbix-plugin/#delete-pm-job", 
            "text": "List String  deletePMJob(List String  pmJobIdsToDelete) throws MonitoringException;  This method delete an existing PmJob. We can get the id of the PmJob after the creation with createPMJob. As a return value we get the ID of the PMJobs effectively deleted.", 
            "title": "Delete Pm Job"
        }, 
        {
            "location": "/zabbix-plugin/#query-pm-job", 
            "text": "List Item  queryPMJob(List String  hostnames, List String  performanceMetrics, String period) throws MonitoringException;  This method get item values from one or more host. As a return value we get the list of items.  hostnames : list of hostnames which we want to know items values.  performanceMetrics : List of items. We can get items which are available in: the  Zabbix documentation 2.2 , [Zabbix documentation 3.0][zabbix-doc-3.0], and in the  hostnames .  period : period in seconds. If period is 0 than you get the last available value of the item. If   0 you get the average of the values inside that period.\n    Remember than the zabbix-plugin read all value of the all hosts every  client-request-frequency  (see the configuration section) and keep them in the history.\n    So if  client-request-frequency  is 15 seconds and the period 30 seconds you get the average of the previous 2 values of the item.  In the following example we ask for the last value of two items ('net.tcp.listen[8080]' and 'agent.ping') for the hosts 'host-1'.  ArrayList String  hostnames = getHostnames( host-1 );\nArrayList String  performanceMetrics = getPerformanceMetrics( net.tcp.listen[8080] , agent.ping );\nList Item  items = monitoringPluginCaller.queryPMJob(hostnames,performanceMetrics, 0 );  items : list of items. An item is a simple object of openbaton-libs which contains properties like: metric, hostname, lastValue, value.", 
            "title": "Query Pm Job"
        }, 
        {
            "location": "/zabbix-plugin/#subscribe-notifyinfo", 
            "text": "NOT YET IMPLEMENTED", 
            "title": "Subscribe &amp; notifyInfo"
        }, 
        {
            "location": "/zabbix-plugin/#create-threshold", 
            "text": "String createThreshold(ObjectSelection selector, String performanceMetric, ThresholdType thresholdType, ThresholdDetails thresholdDetails) throws MonitoringException;  This method create a trigger on a specific item for one or more hosts. As a return value we get the id of the threshold.  selector : object to select the hosts which will be part of the trigger.  performanceMetric : item to include in the trigger. The item need to be already present in the hosts specified in the  selector .  thresholdType : defines the type of threshold. (NOT YET IMPLEMENTED, please pass ThresholdType.SINGLE for the moment).  thresholdDetails : details of the threshold. It contains:   function: refer to  Zabbix trigger function 2.2  or [Zabbix documentation 3.0][zabbix-trigger-function-3.0]   triggerOperator: operator  perceiverSeverity: severity of the trigger.  value: threshold value to compare with the actual value of the  performanceMetric .  hostOperator: can be \"|\" or \" \", meaning that the threshold will trigger when at least one host or all the hosts cross the threshold value.   In the following example we create a treshold for two hosts ('host-1' and 'host-2').  ObjectSelection objectSelector = getObjectSelector( host-1 , host-2 );\nThresholdDetails thresholdDetails= new ThresholdDetails( last(0) , = ,PerceivedSeverity.CRITICAL, 0 , | );\nString thresholdId = zabbixMonitoringAgent.createThreshold(objectSelector, net.tcp.listen[5001] ,ThresholdType.SINGLE_VALUE,thresholdDetails);  The trigger that will be created has this expression: {host-1:net.tcp.listen[5001].last(0)}=0|{host-2:net.tcp.listen[5001].last(0)}=0.\nIt means that if host-1 OR host-2 have no more process listening on the port 5001 then create an alarm with severity critical.\nRefer to  Zabbix expression 2.2  or [Zabbix expression 3.0][zabbix-trigger-expression-3.0] to understand better the expression.", 
            "title": "Create Threshold"
        }, 
        {
            "location": "/zabbix-plugin/#delete-threshold", 
            "text": "List String  deleteThreshold(List String  thresholdIds) throws MonitoringException;  This method delete an existing threshold/s. We can get the id of the threshold after the creation with createThreshold. As a return value we get the list of the ID of the threshold effectively deleted.", 
            "title": "Delete Threshold"
        }, 
        {
            "location": "/zabbix-plugin/#query-threshold", 
            "text": "NOT YET IMPLEMENTED", 
            "title": "Query Threshold"
        }, 
        {
            "location": "/zabbix-plugin/#virtualisedresourcefaultmanagement-interface_1", 
            "text": "", 
            "title": "VirtualisedResourceFaultManagement interface"
        }, 
        {
            "location": "/zabbix-plugin/#subscribe", 
            "text": "String subscribeForFault(AlarmEndpoint filter) throws MonitoringException;  Subscribe for alarm generated by thresholds. As a return value we get the id of the subscription. filter : AlarmEndpoint object which contains:\n-  name: name of the alarmEndpoint.\n-  resourceId: hostname which we want to subscribe.\n-  type: REST or JMS.\n-  endpoint: endpoint where we want to be notified. It is and url for REST or a queue name for JMS. (actually only rest is supported).\n-  perceivedSeverity: define the severity of the alarm we want to get.\n    If we specify PerceivedSeverity.WARNING we will able to get notification from alarm with severity equals or higher than WARNING.  In the following example we subscribe for all alarms with severity higher than WARNING coming from the host 'host-1'.  AlarmEndpoint alarmEndpoint = new AlarmEndpoint( fault-manager-of-host-1 , host-1 ,EndpointType.REST, http://localhost:5555/alarm ,PerceivedSeverity.WARNING);\nString subscriptionId = monitoringPluginCaller.subscribeForFault(alarmEndpoint);", 
            "title": "Subscribe"
        }, 
        {
            "location": "/zabbix-plugin/#unsubscribe", 
            "text": "String unsubscribeForFault(String subscriptionId) throws MonitoringException;  This method detele the subscription with the ID passed as a argument. As a return value we get the id of the subscription effectively deleted.\nWe can get the id of the subscription after the creation with subscribeForFault.", 
            "title": "Unsubscribe"
        }, 
        {
            "location": "/zabbix-plugin/#get-alarm-list", 
            "text": "NOT YET IMPLEMENTED", 
            "title": "Get alarm list"
        }, 
        {
            "location": "/zabbix-plugin/#notify", 
            "text": "This method cannot be invoked by the customers as specified in the ETSI draft  IFA005_Or-Vi_ref_point_Spec .", 
            "title": "Notify"
        }, 
        {
            "location": "/zabbix-plugin/#zabbix-severity-mapping-with-etsi-severity", 
            "text": "In Zabbix we can specify a severity of a trigger: not classified, information, warning, average, high, disaster.  In the ETSI draft there are different level of severity, called perceived severity: Indeterminate, warning, minor, major, critical.  So the mapping in the zabbix plugin is showed in the following table:     Zabbix severity  ETSI perceived severity      Not classified  Indeterminate    Information  Warning    Warning  Warning    Average  Minor    High  Major    Disaster  Critical", 
            "title": "Zabbix severity mapping with ETSI severity"
        }, 
        {
            "location": "/zabbix-plugin/#notifications-types", 
            "text": "When we create a new threshold, we would like to get a notification as soon as the threshold is crossed. Both interfaces send notifications with the method notify.\nAccording to ETSI specification there are 4 types of notifications.   The interface VirtualisedResourcePerformanceManagement sends two types of notifications:     PerformanceInformationAvailableNotification (NOT YET IMPLEMENTED) : this notification informs the receiver that performance information is available.       hresholdCrossedNotification (NOT YET IMPLEMENTED) : his notification informs the receiver that a threshold value has been crossed.     The interface VirtualisedResourceFaultManagement sends the following notifications:   AlarmNotification: This notification informs the receiver of alarms resulting from the faults related to the virtualised resources managed by the VIM. It contains the Alarm with all the information about the fault.  AlarmStateChangedNotification: This notification informs the receiver of state change of alarm related to the virtualised resources managed by the VIM, e.g. the alarm shall be set to \u201ccleared\u201d if the corresponding fault has been solved.\n    It contains the id of the Alarm and the actual status which could be (CLEARED,FIRED,UPDATED).   Actually the zabbix-plugin when receives the notification by zabbix server,  if the trigger has severity higher than Information , \nit creates an alarm (mapping zabbix notification into standard Alarm) and notify the subscribers with a AlarmNotification. If the notification is not new, then it sends an AlarmStateChangedNotification.", 
            "title": "Notifications types"
        }, 
        {
            "location": "/autoscaling/", 
            "text": "AutoScaling Engine\n\n\nThis external component provides an NFV-compliant AutoScaling Engine (ASE). In the following fundamentals are described such as installing the ASE, configuring it and how to use it such as creating AutoScaling policies.\n\n\nThe \nautoscaling-engine\n is implemented in java using the \nspring.io\n framework. It runs as an external component and communicates with the NFVO via Open Baton's SDK.\n\n\nAdditionally, the AutoScaling Engine uses the plugin mechanism to allow whatever Monitoring System you prefer. We use \nZabbix\n as the monitoring system in the following that must be preinstalled and configured. Additional information about \nzabbix-plugin\n can be found \nhere\n.\n\n\nBefore starting this component you have to do the configuration of the AutoScaling Engine that is described in the \nnext chapter\n followed by the guide of \nhow to start\n and \nhow to use\n it.\n\n\nTechnical Requirements\n\n\n\n\nPreconfigured Open Baton environment (NFVO, VNFMs, VIM drivers)\n\n\nRunning Zabbix server (if Zabbix is the monitoring system of choice) \n\n\nPreconfgiured and running zabbix plugin either located in the folder \nNFVO/plugins\n or \nautoscaling/plugins\n to let it start automatically; or started manually. (if Zabbix is the monitoring system of choice)\n\n\n\n\nHow to install AutoScaling Engine\n\n\nIf you installed this component already with the general bootstrap of Open Baton, the ASE is already installed, configured and running. In this case you can jump directly to this section \nHow to use AutoScaling Engine\n. If the NSE is not yet installed please continue with this section.\n\n\nDifferent options are available for the installation of the AutoScaling Engine. Either you use the fully automated bootstrap where all configurations are done automatically where you can choose between the installation based on the debian package or on the source code which is suggested for development. Apart from the bootstrap you can also use the debian or the source code installation where you need to configure the AutoScaling Engine manually. \n\n\nInstallation via bootstrap\n\n\nUsing the bootstrap gives a fully automated installation of this component including installation and configuration. If you use the bootstrap you should place your monitoring plugin of choice directly in the \nNFVO/plugins\n folder before starting the orchestrator to have it already available when starting the AutoScaling Engine.\n\n\nThe only thing to do is to execute the following command and follow the configuration process: \n\n\nbash \n(curl -fsSkl https://raw.githubusercontent.com/openbaton/autoscaling-engine/master/bootstrap)\n\n\n\n\nOnce you started the bootstrap you can choose between different options, such as installing this component via debian packages or via the source code (mainly for development)\n\n\nInstallation via debian package\n\n\nWhen using the debian package you need to add the apt-repository of Open Baton to your local environment with the following command if not yet done:\n\n\nwget -O - http://get.openbaton.org/keys/public.gpg.key | apt-key add -\necho \ndeb http://get.openbaton.org/repos/apt/debian/ stable main\n \n /etc/apt/sources.list\n\n\n\n\nOnce you added the repo to your environment you should update the list of repos by executing:\n\n\napt-get update\n\n\n\n\nNow you can install the NSE by executing:\n\n\napt-get install openbaton-ase\n\n\n\n\nInstallation from the source code\n\n\nThe latest stable version AutoScaling Engine can be cloned from this \nrepository\n by executing the following command:\n\n\ngit clone https://github.com/openbaton/autoscaling.git\n\n\n\n\nOnce this is done, go inside the cloned folder and make use of the provided script to compile the project and start as done below:\n\n\n./autoscaling-engine.sh compile start\n\n\n\n\nManual configuration of the AutoScaling Engine\n\n\nThis chapter describes what needs to be done before starting the AutoScaling Engine. This includes the configuration file and properties, and also how to make use of monitoring plugin.\n\n\nConfiguration file\n\n\nThe configuration file must be copied to \netc/openbaton/openbaton-ase.properties\n by executing the following command from inside the repository folder:\n\n\ncp etc/ase.properties /etc/openbaton/autoscaling.properties\n\n\n\n\nIf done, check out the following chapter in order to understand the configuration parameters.\n\n\nConfiguration properties\n\n\nThis chapter describes the parameters that must be considered for configuring the AutoScaling Engine.\n\n\n\n\n\n\n\n\nParams\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\nlogging.file\n\n\nlocation of the logging file\n\n\n\n\n\n\nlogging.level.*\n\n\nlogging levels of the defined modules\n\n\n\n\n\n\nautoscaling.server.ip\n\n\nIP where the AutoScaling Engine is running. localhost might fit for most in the case when the System is running locally. If the System is running on another machine than the NFVO, you have to set the external IP here in order to subscribe for events towards the NFVO properly.\n\n\n\n\n\n\nautoscaling.server.port\n\n\nPort where the System is reachable\n\n\n\n\n\n\nautoscaling.rabbitmq.brokerIp\n\n\nIP of the machine where RabbitMQ is running. This is needed for communicating with the monitoring plugin.\n\n\n\n\n\n\nspring.rabbitmq.username\n\n\nusername for authorizing towards RabbitMQ\n\n\n\n\n\n\nspring.rabbitmq.password\n\n\npassword for authorizing towards RabbitMQ\n\n\n\n\n\n\nnfvo.ip\n\n\nIP of the NFVO\n\n\n\n\n\n\nnfvo.port\n\n\nPort of the NFVO\n\n\n\n\n\n\nnfvo.username\n\n\nusername for authorizing towards NFVO\n\n\n\n\n\n\nnfvo.password\n\n\npassword for authorizing towards NFVO\n\n\n\n\n\n\n\n\nMonitoring plugin\n\n\nThe montoring plugin must be placed in the folder \nplugins\n. The zabbix plugin can be found \nhere\n with additional information about how to use and how to compile it.\nIf the plugin is placed in the folder mentioned before, it will be started automatically when starting the AutoScaling Engine. Additionally, you can place the plugin also in the \nNFVO/plugins\n folder to let it start automatically. \n\n\nNote\n If the NFVO is already in charge of starting the plugin, you should avoid to start it a second time from the AutoScaling Engine. Once started it can be used by all components.\n\n\nStarting the AutoScaling Engine\n\n\nHow to start the ASE depends of the way you installed this component.\n\n\nDebian packages\n\n\nIf you installed the ASE with the debian packages you can start it with the following command:\n\n\nopenbaton-ase start\n\n\n\n\nFor stopping it you can just type:\n\n\nopenbaton-ase stop\n\n\n\n\nSource code\n\n\nIf you are using the source code you can start the ASE easily by using the provided script with the following command:\n\n\n./autoscaling-engine.sh start\n\n\n\n\nOnce the AutoScaling Engine is started, you can access the screen session by executing:\n\n\nscreen -r openbaton\n\n\n\n\nFor stopping you can use:\n\n\n./autoscaling-engine.sh kill\n\n\n\n\nNote\n Since the AutoScaling Engine subscribes to specific events towards the NFVO, you should take care about that the NFVO is already running when starting the AutoScaling Engine. Otherwise the AutoScaling Engine will wait for 600 seconds for the availability of the NFVO before terminating automatically.\n\n\nHow to use the AutoScaling Engine\n\n\nThis guide shows you how to make use of the AutoScaling Engine. In particular, it describes how to define AutoScaling Policies.\n\n\nCreating AutoScaling Policies\n\n\nA AutoScaling Policy defines conditions and actions in order to allow automatic scaling at runtime. The list of AutoScalePolicies are defined at the level of the VNFD/VNFR.\nAn example of an AutoScalePolicy can be found below followed by descriptions for each parameter.\n\n\nauto_scale_policy\n:[\n  {\n    \nname\n:\nscale-out\n,\n    \nthreshold\n:100,\n    \ncomparisonOperator\n:\n=\n,\n    \nperiod\n:30,\n    \ncooldown\n:60,\n    \nmode\n:\nREACTIVE\n,\n    \ntype\n:\nWEIGHTED\n,\n    \nalarms\n: [\n      {\n        \nmetric\n:\nsystem.cpu.load[percpu,avg1]\n,\n        \nstatistic\n:\navg\n,\n        \ncomparisonOperator\n:\n,\n        \nthreshold\n:0.70,\n        \nweight\n:1\n      }\n    ],\n    \nactions\n: [\n      {\n        \ntype\n:\nSCALE_OUT\n,\n        \nvalue\n:\n2\n,\n        \ntarget\n:\ntarget\n\n      }\n    ]\n  }\n]\n\n\n\n\nAn example using the \nTOSCA YAML descriptors\n can be found \nhere\n.\n\n\nThis AutoScalePolicy indicates an scaling-out operation of two new VNFC Instances if the averaged value of all measurement results of the metric \ncpu load\n is greater than the threshold of 0.7 (70%).\nThis condition is checked every 30 seconds as defined via the period. Once the scaling-out is finished it starts a cooldown of 60 seconds. For this cooldown time further scaling requests are rejected by the AutoScaling Engine.\n\n\nThe following table describes the meanings of the parameters more in detail.\n\n\n\n\n\n\n\n\nParams\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\nname\n\n\nThis is the human-readable name of the AutoScalePolicy used for identification.\n\n\n\n\n\n\nthreshold\n\n\nIs a value in percentage that indicates how many sub alarms have to be fired before firing the high-alarm of the AutoScalePolicy. For example, a value of 100 indicates that all sub alarms have to be fired in order to execute the actions of this AutoScalePolicy.\n\n\n\n\n\n\ncomparisonOperator\n\n\nThis comparison operator is used to check the percentages of thrown alarms. 100% means that all weighted alarms must be thrown. 50% would mean that only half of the weighted alarms must be thrown in oder to trigger the scaling action.\n\n\n\n\n\n\nperiod\n\n\nThis is the period of checking conditions of AutoScalePolicies. For example, a value of 30 indicates, that every 30 seconds all the conditions of the defined AutoScalePolicy are checked.\n\n\n\n\n\n\ncooldown\n\n\nThis is the amount of time the VNF needs to wait between two scaling operations to ensure that the executed scaling action takes effect. Further scaling actions that are requested during the cooldown period are rejected.\n\n\n\n\n\n\nmode\n\n\nThis defines the mode of the AutoScalePolicy. This is mainly about the way of recognizing alarms and conditions, like: \nREACTIVE\n, \nPROACTIVE\n, \nPREDICTIVE\n. At this moment \nREACTIVE\n is provided only.\n\n\n\n\n\n\ntype\n\n\nThe type defines the meaning and the way of processing alarms. Here we distinguish between \nVOTED\n, \nWEIGHTED\n, \nSIMPLE\n. Currently supported is \nWEIGHTED\n\n\n\n\n\n\nalarms\n\n\nThe list of alarms defines all the alarms and conditions that belongs to the same AutoScalePolicy. The list of alarms is affected by the mode and the type of the AutoScalePolicy and influences the final check towards the threshold that decides about the triggering of the AutoScalePolicy. Each alarm is composed as defined \nhere\n.\n\n\n\n\n\n\nactions\n\n\nThe list of actions defines the actions that shall be executed once the conditions (alarms) of the AutoScalePolicy are met and the corresponding actions of the AutoScalePolicy are triggered. Actions are defined as show \nhere\n.\n\n\n\n\n\n\n\n\nAlarms\n\n\nAn alarm defines the conditions in order to trigger the the automatic scaling.\n\n\n\n\n\n\n\n\nParams\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\nmetric\n\n\nThis is the name of the metric that is considered when checking the conditions, e.g., cpu idle time, memory consumption, network traffic, etc. This metric must be available through the Monitoring System.\n\n\n\n\n\n\nstatistic\n\n\nThis defines the way of calculating the final measurement result over the group of instances. Possible values are: avg, min, max, sum, count.\n\n\n\n\n\n\ncomparisonOperator\n\n\nThe comparisonOperator defines how to compare the final measurement result with the threshold. Possible values are: \n=\n, \n, \n=\n, \n, \n=\n, \n!=\n.\n\n\n\n\n\n\nthreshold\n\n\nThe threshold defines the value that is compared with the final measurement of a specific metric.\n\n\n\n\n\n\nweight\n\n\nThe weight defines the weight of the alarm and is used when combining all the alarms of an AutoScalePolicy to a final indicator that defines how many alarms must be fired. In this way prioritized alarms can be handled with different weights. For example, there is an alarm with the weight of three and another alarm with the weight of one. If the Alarm with weight three is fired and the second one is not fired, the final result would be 75\\% in the meaning of three quarters of the conditions are met.\n\n\n\n\n\n\n\n\nActions\n\n\nAn Action defines the operation that will be executed (if possible) when the scaling conditions are met that are defined in the Alarms.\n\n\n\n\n\n\n\n\nParams\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\ntype\n\n\nThe type defines the type of the action to be executed. For example, \nSCALE_OUT\n indicates that resources shall be added and \nSCALE_IN\n means that resources shall be released. Currently provided types of actions are listed \nhere\n.\n\n\n\n\n\n\nvalue\n\n\nThe value is related to the type of action. \nSCALE_OUT\n and \nSCALE_IN\n expects a value that defines how many instances should be scaled-out or scaled-in, \nSCALE_OUT_TO\n and \nSCALE_IN_TO\n expects a number to what the number of instances shall be scaled in or out. Supported types of actions are shown \nhere\n\n\n\n\n\n\ntarget\n\n\n[OPTIONAL] The target allows scaling of other VNFs when conditions are met of the considered VNF that includes the policy. The target points to the type of the VNF that should be scaled. If multiple VNFs has the same type, it will be chosen one of them to execute the scaling action. If the target is not defined, it will be executed scaling actions on the same VNF that includes the policy.\n\n\n\n\n\n\n\n\nAction types\n\n\nActions types are the operations that can be executed when defined conditions are met. The following list shows which actions are supported at the moment and what they will do.\n\n\n\n\n\n\n\n\nParams\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\nSCALE_OUT\n\n\nscaling-out a specific number of instances\n\n\n\n\n\n\nSCALE_IN\n\n\nscaling-in a specific number of instances\n\n\n\n\n\n\nSCALE_OUT_TO\n\n\nscaling-out to a specific number of instances\n\n\n\n\n\n\nSCALE_IN_TO\n\n\nscaling-in to a specific number of instances", 
            "title": "Autoscaling overview"
        }, 
        {
            "location": "/autoscaling/#autoscaling-engine", 
            "text": "This external component provides an NFV-compliant AutoScaling Engine (ASE). In the following fundamentals are described such as installing the ASE, configuring it and how to use it such as creating AutoScaling policies.  The  autoscaling-engine  is implemented in java using the  spring.io  framework. It runs as an external component and communicates with the NFVO via Open Baton's SDK.  Additionally, the AutoScaling Engine uses the plugin mechanism to allow whatever Monitoring System you prefer. We use  Zabbix  as the monitoring system in the following that must be preinstalled and configured. Additional information about  zabbix-plugin  can be found  here .  Before starting this component you have to do the configuration of the AutoScaling Engine that is described in the  next chapter  followed by the guide of  how to start  and  how to use  it.", 
            "title": "AutoScaling Engine"
        }, 
        {
            "location": "/autoscaling/#technical-requirements", 
            "text": "Preconfigured Open Baton environment (NFVO, VNFMs, VIM drivers)  Running Zabbix server (if Zabbix is the monitoring system of choice)   Preconfgiured and running zabbix plugin either located in the folder  NFVO/plugins  or  autoscaling/plugins  to let it start automatically; or started manually. (if Zabbix is the monitoring system of choice)", 
            "title": "Technical Requirements"
        }, 
        {
            "location": "/autoscaling/#how-to-install-autoscaling-engine", 
            "text": "If you installed this component already with the general bootstrap of Open Baton, the ASE is already installed, configured and running. In this case you can jump directly to this section  How to use AutoScaling Engine . If the NSE is not yet installed please continue with this section.  Different options are available for the installation of the AutoScaling Engine. Either you use the fully automated bootstrap where all configurations are done automatically where you can choose between the installation based on the debian package or on the source code which is suggested for development. Apart from the bootstrap you can also use the debian or the source code installation where you need to configure the AutoScaling Engine manually.", 
            "title": "How to install AutoScaling Engine"
        }, 
        {
            "location": "/autoscaling/#installation-via-bootstrap", 
            "text": "Using the bootstrap gives a fully automated installation of this component including installation and configuration. If you use the bootstrap you should place your monitoring plugin of choice directly in the  NFVO/plugins  folder before starting the orchestrator to have it already available when starting the AutoScaling Engine.  The only thing to do is to execute the following command and follow the configuration process:   bash  (curl -fsSkl https://raw.githubusercontent.com/openbaton/autoscaling-engine/master/bootstrap)  Once you started the bootstrap you can choose between different options, such as installing this component via debian packages or via the source code (mainly for development)", 
            "title": "Installation via bootstrap"
        }, 
        {
            "location": "/autoscaling/#installation-via-debian-package", 
            "text": "When using the debian package you need to add the apt-repository of Open Baton to your local environment with the following command if not yet done:  wget -O - http://get.openbaton.org/keys/public.gpg.key | apt-key add -\necho  deb http://get.openbaton.org/repos/apt/debian/ stable main    /etc/apt/sources.list  Once you added the repo to your environment you should update the list of repos by executing:  apt-get update  Now you can install the NSE by executing:  apt-get install openbaton-ase", 
            "title": "Installation via debian package"
        }, 
        {
            "location": "/autoscaling/#installation-from-the-source-code", 
            "text": "The latest stable version AutoScaling Engine can be cloned from this  repository  by executing the following command:  git clone https://github.com/openbaton/autoscaling.git  Once this is done, go inside the cloned folder and make use of the provided script to compile the project and start as done below:  ./autoscaling-engine.sh compile start", 
            "title": "Installation from the source code"
        }, 
        {
            "location": "/autoscaling/#manual-configuration-of-the-autoscaling-engine", 
            "text": "This chapter describes what needs to be done before starting the AutoScaling Engine. This includes the configuration file and properties, and also how to make use of monitoring plugin.", 
            "title": "Manual configuration of the AutoScaling Engine"
        }, 
        {
            "location": "/autoscaling/#configuration-file", 
            "text": "The configuration file must be copied to  etc/openbaton/openbaton-ase.properties  by executing the following command from inside the repository folder:  cp etc/ase.properties /etc/openbaton/autoscaling.properties  If done, check out the following chapter in order to understand the configuration parameters.", 
            "title": "Configuration file"
        }, 
        {
            "location": "/autoscaling/#configuration-properties", 
            "text": "This chapter describes the parameters that must be considered for configuring the AutoScaling Engine.     Params  Meaning      logging.file  location of the logging file    logging.level.*  logging levels of the defined modules    autoscaling.server.ip  IP where the AutoScaling Engine is running. localhost might fit for most in the case when the System is running locally. If the System is running on another machine than the NFVO, you have to set the external IP here in order to subscribe for events towards the NFVO properly.    autoscaling.server.port  Port where the System is reachable    autoscaling.rabbitmq.brokerIp  IP of the machine where RabbitMQ is running. This is needed for communicating with the monitoring plugin.    spring.rabbitmq.username  username for authorizing towards RabbitMQ    spring.rabbitmq.password  password for authorizing towards RabbitMQ    nfvo.ip  IP of the NFVO    nfvo.port  Port of the NFVO    nfvo.username  username for authorizing towards NFVO    nfvo.password  password for authorizing towards NFVO", 
            "title": "Configuration properties"
        }, 
        {
            "location": "/autoscaling/#monitoring-plugin", 
            "text": "The montoring plugin must be placed in the folder  plugins . The zabbix plugin can be found  here  with additional information about how to use and how to compile it.\nIf the plugin is placed in the folder mentioned before, it will be started automatically when starting the AutoScaling Engine. Additionally, you can place the plugin also in the  NFVO/plugins  folder to let it start automatically.   Note  If the NFVO is already in charge of starting the plugin, you should avoid to start it a second time from the AutoScaling Engine. Once started it can be used by all components.", 
            "title": "Monitoring plugin"
        }, 
        {
            "location": "/autoscaling/#starting-the-autoscaling-engine", 
            "text": "How to start the ASE depends of the way you installed this component.", 
            "title": "Starting the AutoScaling Engine"
        }, 
        {
            "location": "/autoscaling/#debian-packages", 
            "text": "If you installed the ASE with the debian packages you can start it with the following command:  openbaton-ase start  For stopping it you can just type:  openbaton-ase stop", 
            "title": "Debian packages"
        }, 
        {
            "location": "/autoscaling/#source-code", 
            "text": "If you are using the source code you can start the ASE easily by using the provided script with the following command:  ./autoscaling-engine.sh start  Once the AutoScaling Engine is started, you can access the screen session by executing:  screen -r openbaton  For stopping you can use:  ./autoscaling-engine.sh kill  Note  Since the AutoScaling Engine subscribes to specific events towards the NFVO, you should take care about that the NFVO is already running when starting the AutoScaling Engine. Otherwise the AutoScaling Engine will wait for 600 seconds for the availability of the NFVO before terminating automatically.", 
            "title": "Source code"
        }, 
        {
            "location": "/autoscaling/#how-to-use-the-autoscaling-engine", 
            "text": "This guide shows you how to make use of the AutoScaling Engine. In particular, it describes how to define AutoScaling Policies.", 
            "title": "How to use the AutoScaling Engine"
        }, 
        {
            "location": "/autoscaling/#creating-autoscaling-policies", 
            "text": "A AutoScaling Policy defines conditions and actions in order to allow automatic scaling at runtime. The list of AutoScalePolicies are defined at the level of the VNFD/VNFR.\nAn example of an AutoScalePolicy can be found below followed by descriptions for each parameter.  auto_scale_policy :[\n  {\n     name : scale-out ,\n     threshold :100,\n     comparisonOperator : = ,\n     period :30,\n     cooldown :60,\n     mode : REACTIVE ,\n     type : WEIGHTED ,\n     alarms : [\n      {\n         metric : system.cpu.load[percpu,avg1] ,\n         statistic : avg ,\n         comparisonOperator : ,\n         threshold :0.70,\n         weight :1\n      }\n    ],\n     actions : [\n      {\n         type : SCALE_OUT ,\n         value : 2 ,\n         target : target \n      }\n    ]\n  }\n]  An example using the  TOSCA YAML descriptors  can be found  here .  This AutoScalePolicy indicates an scaling-out operation of two new VNFC Instances if the averaged value of all measurement results of the metric  cpu load  is greater than the threshold of 0.7 (70%).\nThis condition is checked every 30 seconds as defined via the period. Once the scaling-out is finished it starts a cooldown of 60 seconds. For this cooldown time further scaling requests are rejected by the AutoScaling Engine.  The following table describes the meanings of the parameters more in detail.     Params  Meaning      name  This is the human-readable name of the AutoScalePolicy used for identification.    threshold  Is a value in percentage that indicates how many sub alarms have to be fired before firing the high-alarm of the AutoScalePolicy. For example, a value of 100 indicates that all sub alarms have to be fired in order to execute the actions of this AutoScalePolicy.    comparisonOperator  This comparison operator is used to check the percentages of thrown alarms. 100% means that all weighted alarms must be thrown. 50% would mean that only half of the weighted alarms must be thrown in oder to trigger the scaling action.    period  This is the period of checking conditions of AutoScalePolicies. For example, a value of 30 indicates, that every 30 seconds all the conditions of the defined AutoScalePolicy are checked.    cooldown  This is the amount of time the VNF needs to wait between two scaling operations to ensure that the executed scaling action takes effect. Further scaling actions that are requested during the cooldown period are rejected.    mode  This defines the mode of the AutoScalePolicy. This is mainly about the way of recognizing alarms and conditions, like:  REACTIVE ,  PROACTIVE ,  PREDICTIVE . At this moment  REACTIVE  is provided only.    type  The type defines the meaning and the way of processing alarms. Here we distinguish between  VOTED ,  WEIGHTED ,  SIMPLE . Currently supported is  WEIGHTED    alarms  The list of alarms defines all the alarms and conditions that belongs to the same AutoScalePolicy. The list of alarms is affected by the mode and the type of the AutoScalePolicy and influences the final check towards the threshold that decides about the triggering of the AutoScalePolicy. Each alarm is composed as defined  here .    actions  The list of actions defines the actions that shall be executed once the conditions (alarms) of the AutoScalePolicy are met and the corresponding actions of the AutoScalePolicy are triggered. Actions are defined as show  here .", 
            "title": "Creating AutoScaling Policies"
        }, 
        {
            "location": "/autoscaling/#alarms", 
            "text": "An alarm defines the conditions in order to trigger the the automatic scaling.     Params  Meaning      metric  This is the name of the metric that is considered when checking the conditions, e.g., cpu idle time, memory consumption, network traffic, etc. This metric must be available through the Monitoring System.    statistic  This defines the way of calculating the final measurement result over the group of instances. Possible values are: avg, min, max, sum, count.    comparisonOperator  The comparisonOperator defines how to compare the final measurement result with the threshold. Possible values are:  = ,  ,  = ,  ,  = ,  != .    threshold  The threshold defines the value that is compared with the final measurement of a specific metric.    weight  The weight defines the weight of the alarm and is used when combining all the alarms of an AutoScalePolicy to a final indicator that defines how many alarms must be fired. In this way prioritized alarms can be handled with different weights. For example, there is an alarm with the weight of three and another alarm with the weight of one. If the Alarm with weight three is fired and the second one is not fired, the final result would be 75\\% in the meaning of three quarters of the conditions are met.", 
            "title": "Alarms"
        }, 
        {
            "location": "/autoscaling/#actions", 
            "text": "An Action defines the operation that will be executed (if possible) when the scaling conditions are met that are defined in the Alarms.     Params  Meaning      type  The type defines the type of the action to be executed. For example,  SCALE_OUT  indicates that resources shall be added and  SCALE_IN  means that resources shall be released. Currently provided types of actions are listed  here .    value  The value is related to the type of action.  SCALE_OUT  and  SCALE_IN  expects a value that defines how many instances should be scaled-out or scaled-in,  SCALE_OUT_TO  and  SCALE_IN_TO  expects a number to what the number of instances shall be scaled in or out. Supported types of actions are shown  here    target  [OPTIONAL] The target allows scaling of other VNFs when conditions are met of the considered VNF that includes the policy. The target points to the type of the VNF that should be scaled. If multiple VNFs has the same type, it will be chosen one of them to execute the scaling action. If the target is not defined, it will be executed scaling actions on the same VNF that includes the policy.", 
            "title": "Actions"
        }, 
        {
            "location": "/autoscaling/#action-types", 
            "text": "Actions types are the operations that can be executed when defined conditions are met. The following list shows which actions are supported at the moment and what they will do.     Params  Meaning      SCALE_OUT  scaling-out a specific number of instances    SCALE_IN  scaling-in a specific number of instances    SCALE_OUT_TO  scaling-out to a specific number of instances    SCALE_IN_TO  scaling-in to a specific number of instances", 
            "title": "Action types"
        }, 
        {
            "location": "/fault-management/", 
            "text": "Open Baton Fault Management System (FMS)\n\n\nThe Open Baton FMS project is a module of the Open Baton Orchestrator. \nIt provides an extensive Fault Management System that is based on alarms coming from the VIM and executes actions through the NFVO.\n\n\nNote\n: if you followed the installation guide using the bootstrap, you can jump to the section \"How to use Open Baton FM\"\n\n\nTechnical Requirements\n\n\nThe technical requirements are:  \n\n\n\n\nZabbix plugin running (see the \ndoc of Zabbix plugin\n)\n\n\nMysql server installed and running\n\n\nOpen Baton 3.2.x running\n\n\nGeneric VNFM 3.2.x running\n\n\n\n\nHow to install Open Baton FM\n\n\nOnce the prerequisites are met, you need to execute the following steps.\n\n\nCreate the database\n\n\nIn order to create the database be sure you have installed \nmysql server\n as already mentioned in the requirements section. \nYou need root access to mysql-server in order to create a new database called faultmanagement. Once you access into mysql, execute the following operation: \n\n\ncreate database faultmanagement;\n\n\n\n\nOnce the database has been created, you should create a user which will be used by the FM system to access and store data on the database. If you decide to use the \nroot\n user you can skip this step, but you need to modify the fms.properties file accordingly as defined in the next section. \nBy default username and password are set with the following values in the fms.properties properties file (see next section if you plan to use a different user and password): \n\n\n\n\nusername=fmsuser\n\n\npassword=changeme\n\n\n\n\nGrant the access to the database \"faultmanagement\", to the user, running the following command:\n\n\nGRANT ALL PRIVILEGES ON faultmanagement.* TO fmsuser@'%' IDENTIFIED BY 'changeme';\n\n\n\n\nModify fms.properties file in order to use different credentials for the database\n\n\nIn the folder \"etc\" of this project, there is a file called fms.properties containing all the default properties values used by the FM system. \n\n\nIn order to use different credentials, you need to modify the following DB properties: \n\n\n# DB properties\nspring.datasource.username=fmsuser\nspring.datasource.password=changeme\n\n\n\n\nIn case your DB is running remotely, you can specifcy a different host, instead of localhost, in the following property (be careful to have port 3306 open and accessible from remote): \n\n\nspring.datasource.url=jdbc:mysql://localhost:3306/faultmanagement\n\n\n\n\nAdditional configuration options\n\n\nAs already mentioned in the previous section, in the folder \"etc\" of this project, there is a file called fms.properties containing all the default properties values used by the FM system.\nYou should update this file in order to make it work with your NFVO instance. Change the Open Baton related properties section: \n\n\n################################################\n####### Open Baton Related properties ##########\n################################################\nnfvo.ip=localhost\nnfvo.port=8080\nnfvo-usr=admin\nnfvo-pwd=openbaton\n\n\n\n\nCheckout the source code of the project, compile and run it\n\n\nYou can clone this repository with this command:\n\n\ngit clone https://github.com/openbaton/fm-system.git\n\n\n\n\nThe configuration file is etc/fms.properties, you have to copy it in the Open Baton etc folder ( /etc/openbaton ). You can do it typing the following command \n\n\ncd fm-system\ncp etc/fms.properties /etc/openbaton/fms.properties\n\n\n\n\nNow, you can finally compile and start the FM System. \n\n\n./fm-system.sh compile start\n\n\n\n\nHow to use Open Baton FM\n\n\nOpen Baton FM is a rule-driven tool. The rules define when to generate an alarm and how to react. The rule for generating the alarm is called fault management policy (see the next section). \nThe rule for defining how to react upon alarms is a Drools Rule. Once such rules are in place, Open Baton FM follows the following workflow.\n\n\n\n\nThe actions are listed below:\n\n\n\n\n\n\n\n\nACTION\n\n\nDESCRIPTION\n\n\n\n\n\n\n\n\n\n\nHeal\n\n\nThe VNFM executes the scripts in the Heal lifecycle event (in the VNFD). The message contains the cause of the fault, which can be used in the scripts.\n\n\n\n\n\n\nSwitch to stanby VNFC (Stateless)\n\n\nIf the VDU requires redoundancy active-passive, there will be a component VNFC\n in standby mode. This action consists in: activate the VNFC\n, route all signalling and data flow(s) for VNFC to VNFC*, deactivate VNFC.\n\n\n\n\n\n\nSwitch to stanby VNFC (Stateful)\n\n\nTo investigate. Refer on ETSI GS NFV-REL 001 v1.1.1 (2015-01) Chapter 11.2.1.\n\n\n\n\n\n\n\n\nWrite a fault management policy\n\n\nThe fault management policy needs to be present in the VNFD, in particular in the VDU. This is an example of fault management policy:\n\n\nfault_management_policy\n:[\n    {\n      \nname\n:\nweb server not available\n,\n      \nisVNFAlarm\n: true,\n      \ncriteria\n:[\n      {\n        \nparameter_ref\n:\nnet.tcp.listen[80]\n,\n        \nfunction\n:\nlast()\n,\n        \nvnfc_selector\n:\nat_least_one\n,\n        \ncomparison_operator\n:\n=\n,\n        \nthreshold\n:\n0\n\n      }\n      ],\n      \nperiod\n:5,\n      \nseverity\n:\nCRITICAL\n\n    }\n]\n\n\n\n\nYou can find an example of the fault management policy for the \nTOSCA YAML descriptors\n \nhere\n.\n\n\nDescription of the fault management policy:  \n\n\n\n\n\n\n\n\nProperty\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nname\n\n\nThis is the name of the fault management policy.\n\n\n\n\n\n\nisVNFAlarm\n\n\nTrue, if the alarm is of type VNF.\n\n\n\n\n\n\ncriteria\n\n\nThe criteria defines a threshold on a monitoring parameter. When the threshold is crossed an alarm is fired.\n\n\n\n\n\n\nperiod\n\n\nThe criteria is checked every \"period\" seconds.\n\n\n\n\n\n\nseverity\n\n\nDefines the severity of the alarm.\n\n\n\n\n\n\n\n\nDescription of the criteria:  \n\n\n\n\n\n\n\n\nProperty\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nparameter_ref\n\n\nThis is the reference to a monitoring parameter in the VDU. (see below how to define monitoring parameters).\n\n\n\n\n\n\nfunction\n\n\nThe function to apply to the parameter ( last(0) means the last value available of the parameter). Since currently only Zabbix is supported, look at the \nZabbix documentation\n for the all available functions.\n\n\n\n\n\n\nvnfc_selector\n\n\nselect if the criteria is met when all VNFC components cross the threshold (all) or at least one (at_least_one)\n\n\n\n\n\n\ncomparison_operator\n\n\nThis defines the comparison operator used for the threshold.\n\n\n\n\n\n\nthreshold\n\n\nThe value of the threshold to compare against the parameter_ref value.\n\n\n\n\n\n\n\n\nIn order to refer to a monitoring parameter with the property \nparameter_ref\n, it needs to be present in the vdu:\n\n\nmonitoring_parameter\n:[\n   \nagent.ping\n,\n\n   \nnet.tcp.listen[5001]\n,\n\n   \nsystem.cpu.load[all,avg5]\n,\n\n   \nvfs.file.regmatch[/var/log/app.log,Exception]\n\n]\n\n\n\n\nYou can specify every parameter available in the \nZabbix Agent\n.\n\n\nHow the HEAL method works\n\n\nThe Heal VNF operation is a method of the VNF lifecycle management interface described in the ETSI \nNFV MANO\n specifications. Here is reported the description and the notes about this method:\n\n\nDescription: this operation is used to request appropriate correction actions in reaction to a failure.\nNotes: This assumes operational behaviour for healing actions by VNFM has been described in the VNFD. An example might be switching between active and standby mode.\n\n\n\n\nIn the ETSI draft \"NFV-IFA007v040\" at \nthis\n page, the Heal VNF message is defined as:\n\n\nvnfInstanceId\u0000 : Identifies the VNF instance requiring a healing action.\u0000\ncause : Indicates the reason why a healing procedure is required.\u0000\n\n\n\n\nOnce the fault management system received an alarm from the VIM, \nit checks, if the alarm is referred to a VNF and sends the Heal VNF message to the NFVO which forwards it to the respective VNFM.\nThe VNFM executes in the failed VNFC the scripts in the HEAL lifecycle event.\nHere an example of the heal script you can use:\n\n\n#!/bin/bash\n\ncase \n$cause\n in\n\n(\nserviceDown\n) \n    echo \nApache is down, let's try to restart it...\n\n    service apache2 restart\n    if [ $? -ne 0 ]; then\n        echo \nERROR: the Apache service is not started\n\n        exit 1\n        fi\n    echo \nThe Apache service is running again!\n\n    ;;\n*) echo \nThe cause $cause is unknown\n\n    exit 2\n    ;;\nesac\n\n\n\n\nThe variable $cause is specified in the Drools rule. In our case it is \"serviceDown\" and we try to restart the Apache server.\n\n\nDrools Rules\n\n\nThe Open Baton FMS is a rule-based system. Such rules are specified in Drools language and processed by the Drools engine in the Open Baton FMS.\nAn example rule looks like the following:\n\n\nrule \nSave a VNFAlarm\n\n    when\n        vnfAlarm : VNFAlarm()\n    then\n    VNFAlarm alarm = vnfAlarmRepository.save(vnfAlarm);\n    logger.debug(\nSaved VnfAlarm: \n+alarm);\nend\n\n\n\n\nThis rule saves a VNF Alarm in the database.\nThe following rule executes the HEAL action once a VNF Alarm is received:\n\n\nrule \nGot a critical VNF Alarm and execute the HEAL action\n\n\n    when\n       vnfAlarm : VNFAlarm(  alarmState == AlarmState.FIRED, perceivedSeverity == PerceivedSeverity.CRITICAL)\n    then\n\n    //Get the vnfr\n    VirtualNetworkFunctionRecord vnfr = nfvoRequestorWrapper.getVirtualNetworkFunctionRecord(vnfAlarm.getVnfrId());\n\n    //Get the vnfc failed (assuming only one vnfc is failed)\n    VNFCInstance vnfcInstance = nsrManager.getVNFCInstanceFromVnfr(vnfr,vnfAlarm.getVnfcIds().iterator().next());\n\n    logger.info(\n(VNF LAYER) A CRITICAL alarm is received by the vnfc: \n+vnfcInstance.getHostname());\n\n    //Get the vdu of the failed VNFC\n    VirtualDeploymentUnit vdu = nfvoRequestorWrapper.getVDU(vnfr,vnfcInstance.getId());\n\n    logger.info(\nHeal fired!\n);\n    highAvailabilityManager.executeHeal(\nserviceDown\n,vnfr.getParent_ns_id(),vnfr.getId(),vdu.getId(),vnfcInstance.getId());\n\n    //Insert a new recovery action\n\n    RecoveryAction recoveryAction= new RecoveryAction(RecoveryActionType.HEAL,vnfr.getEndpoint(),\n);\n    recoveryAction.setStatus(RecoveryActionStatus.IN_PROGRESS);\n    insert(recoveryAction);\nend\n\n\n\n\nHow the Switch to Standby works\n\n\nThe Switch to Standby action can be performed by the Open Baton FMS once a VNFC in standby is present in the VNF. Its main action is switch the service from a VNFC to the VNFC in standby automatically.\nIn order to have a VNFC in standby, such information must be included in the VNFD, in particular in the VDU, as the following:\n\n\nhigh_availability\n:{\n    \nresiliencyLevel\n:\nACTIVE_STANDBY_STATELESS\n,\n    \nredundancyScheme\n:\n1:N\n\n}\n\n\n\n\nThis information will be processed by the Open Baton FMS which will create a VNFC instance in standby.\nThen in a Drools rule this action can be called as following:\n\n\nhighAvailabilityManager.switchToRedundantVNFC(failedVnfcInstance,vnfr,vdu);\n\n\n\n\nTutorial\n\n\nThe tutorial is available at this \npage\n.", 
            "title": "FM overview"
        }, 
        {
            "location": "/fault-management/#open-baton-fault-management-system-fms", 
            "text": "The Open Baton FMS project is a module of the Open Baton Orchestrator. \nIt provides an extensive Fault Management System that is based on alarms coming from the VIM and executes actions through the NFVO.  Note : if you followed the installation guide using the bootstrap, you can jump to the section \"How to use Open Baton FM\"", 
            "title": "Open Baton Fault Management System (FMS)"
        }, 
        {
            "location": "/fault-management/#technical-requirements", 
            "text": "The technical requirements are:     Zabbix plugin running (see the  doc of Zabbix plugin )  Mysql server installed and running  Open Baton 3.2.x running  Generic VNFM 3.2.x running", 
            "title": "Technical Requirements"
        }, 
        {
            "location": "/fault-management/#how-to-install-open-baton-fm", 
            "text": "Once the prerequisites are met, you need to execute the following steps.", 
            "title": "How to install Open Baton FM"
        }, 
        {
            "location": "/fault-management/#create-the-database", 
            "text": "In order to create the database be sure you have installed  mysql server  as already mentioned in the requirements section. \nYou need root access to mysql-server in order to create a new database called faultmanagement. Once you access into mysql, execute the following operation:   create database faultmanagement;  Once the database has been created, you should create a user which will be used by the FM system to access and store data on the database. If you decide to use the  root  user you can skip this step, but you need to modify the fms.properties file accordingly as defined in the next section. \nBy default username and password are set with the following values in the fms.properties properties file (see next section if you plan to use a different user and password):    username=fmsuser  password=changeme   Grant the access to the database \"faultmanagement\", to the user, running the following command:  GRANT ALL PRIVILEGES ON faultmanagement.* TO fmsuser@'%' IDENTIFIED BY 'changeme';", 
            "title": "Create the database"
        }, 
        {
            "location": "/fault-management/#modify-fmsproperties-file-in-order-to-use-different-credentials-for-the-database", 
            "text": "In the folder \"etc\" of this project, there is a file called fms.properties containing all the default properties values used by the FM system.   In order to use different credentials, you need to modify the following DB properties:   # DB properties\nspring.datasource.username=fmsuser\nspring.datasource.password=changeme  In case your DB is running remotely, you can specifcy a different host, instead of localhost, in the following property (be careful to have port 3306 open and accessible from remote):   spring.datasource.url=jdbc:mysql://localhost:3306/faultmanagement", 
            "title": "Modify fms.properties file in order to use different credentials for the database"
        }, 
        {
            "location": "/fault-management/#additional-configuration-options", 
            "text": "As already mentioned in the previous section, in the folder \"etc\" of this project, there is a file called fms.properties containing all the default properties values used by the FM system.\nYou should update this file in order to make it work with your NFVO instance. Change the Open Baton related properties section:   ################################################\n####### Open Baton Related properties ##########\n################################################\nnfvo.ip=localhost\nnfvo.port=8080\nnfvo-usr=admin\nnfvo-pwd=openbaton", 
            "title": "Additional configuration options"
        }, 
        {
            "location": "/fault-management/#checkout-the-source-code-of-the-project-compile-and-run-it", 
            "text": "You can clone this repository with this command:  git clone https://github.com/openbaton/fm-system.git  The configuration file is etc/fms.properties, you have to copy it in the Open Baton etc folder ( /etc/openbaton ). You can do it typing the following command   cd fm-system\ncp etc/fms.properties /etc/openbaton/fms.properties  Now, you can finally compile and start the FM System.   ./fm-system.sh compile start", 
            "title": "Checkout the source code of the project, compile and run it"
        }, 
        {
            "location": "/fault-management/#how-to-use-open-baton-fm", 
            "text": "Open Baton FM is a rule-driven tool. The rules define when to generate an alarm and how to react. The rule for generating the alarm is called fault management policy (see the next section). \nThe rule for defining how to react upon alarms is a Drools Rule. Once such rules are in place, Open Baton FM follows the following workflow.   The actions are listed below:     ACTION  DESCRIPTION      Heal  The VNFM executes the scripts in the Heal lifecycle event (in the VNFD). The message contains the cause of the fault, which can be used in the scripts.    Switch to stanby VNFC (Stateless)  If the VDU requires redoundancy active-passive, there will be a component VNFC  in standby mode. This action consists in: activate the VNFC , route all signalling and data flow(s) for VNFC to VNFC*, deactivate VNFC.    Switch to stanby VNFC (Stateful)  To investigate. Refer on ETSI GS NFV-REL 001 v1.1.1 (2015-01) Chapter 11.2.1.", 
            "title": "How to use Open Baton FM"
        }, 
        {
            "location": "/fault-management/#write-a-fault-management-policy", 
            "text": "The fault management policy needs to be present in the VNFD, in particular in the VDU. This is an example of fault management policy:  fault_management_policy :[\n    {\n       name : web server not available ,\n       isVNFAlarm : true,\n       criteria :[\n      {\n         parameter_ref : net.tcp.listen[80] ,\n         function : last() ,\n         vnfc_selector : at_least_one ,\n         comparison_operator : = ,\n         threshold : 0 \n      }\n      ],\n       period :5,\n       severity : CRITICAL \n    }\n]  You can find an example of the fault management policy for the  TOSCA YAML descriptors   here .  Description of the fault management policy:       Property  Description      name  This is the name of the fault management policy.    isVNFAlarm  True, if the alarm is of type VNF.    criteria  The criteria defines a threshold on a monitoring parameter. When the threshold is crossed an alarm is fired.    period  The criteria is checked every \"period\" seconds.    severity  Defines the severity of the alarm.     Description of the criteria:       Property  Description      parameter_ref  This is the reference to a monitoring parameter in the VDU. (see below how to define monitoring parameters).    function  The function to apply to the parameter ( last(0) means the last value available of the parameter). Since currently only Zabbix is supported, look at the  Zabbix documentation  for the all available functions.    vnfc_selector  select if the criteria is met when all VNFC components cross the threshold (all) or at least one (at_least_one)    comparison_operator  This defines the comparison operator used for the threshold.    threshold  The value of the threshold to compare against the parameter_ref value.     In order to refer to a monitoring parameter with the property  parameter_ref , it needs to be present in the vdu:  monitoring_parameter :[\n    agent.ping ,\n\n    net.tcp.listen[5001] ,\n\n    system.cpu.load[all,avg5] ,\n\n    vfs.file.regmatch[/var/log/app.log,Exception] \n]  You can specify every parameter available in the  Zabbix Agent .", 
            "title": "Write a fault management policy"
        }, 
        {
            "location": "/fault-management/#how-the-heal-method-works", 
            "text": "The Heal VNF operation is a method of the VNF lifecycle management interface described in the ETSI  NFV MANO  specifications. Here is reported the description and the notes about this method:  Description: this operation is used to request appropriate correction actions in reaction to a failure.\nNotes: This assumes operational behaviour for healing actions by VNFM has been described in the VNFD. An example might be switching between active and standby mode.  In the ETSI draft \"NFV-IFA007v040\" at  this  page, the Heal VNF message is defined as:  vnfInstanceId\u0000 : Identifies the VNF instance requiring a healing action.\u0000\ncause : Indicates the reason why a healing procedure is required.\u0000  Once the fault management system received an alarm from the VIM, \nit checks, if the alarm is referred to a VNF and sends the Heal VNF message to the NFVO which forwards it to the respective VNFM.\nThe VNFM executes in the failed VNFC the scripts in the HEAL lifecycle event.\nHere an example of the heal script you can use:  #!/bin/bash\n\ncase  $cause  in\n\n( serviceDown ) \n    echo  Apache is down, let's try to restart it... \n    service apache2 restart\n    if [ $? -ne 0 ]; then\n        echo  ERROR: the Apache service is not started \n        exit 1\n        fi\n    echo  The Apache service is running again! \n    ;;\n*) echo  The cause $cause is unknown \n    exit 2\n    ;;\nesac  The variable $cause is specified in the Drools rule. In our case it is \"serviceDown\" and we try to restart the Apache server.", 
            "title": "How the HEAL method works"
        }, 
        {
            "location": "/fault-management/#drools-rules", 
            "text": "The Open Baton FMS is a rule-based system. Such rules are specified in Drools language and processed by the Drools engine in the Open Baton FMS.\nAn example rule looks like the following:  rule  Save a VNFAlarm \n    when\n        vnfAlarm : VNFAlarm()\n    then\n    VNFAlarm alarm = vnfAlarmRepository.save(vnfAlarm);\n    logger.debug( Saved VnfAlarm:  +alarm);\nend  This rule saves a VNF Alarm in the database.\nThe following rule executes the HEAL action once a VNF Alarm is received:  rule  Got a critical VNF Alarm and execute the HEAL action \n\n    when\n       vnfAlarm : VNFAlarm(  alarmState == AlarmState.FIRED, perceivedSeverity == PerceivedSeverity.CRITICAL)\n    then\n\n    //Get the vnfr\n    VirtualNetworkFunctionRecord vnfr = nfvoRequestorWrapper.getVirtualNetworkFunctionRecord(vnfAlarm.getVnfrId());\n\n    //Get the vnfc failed (assuming only one vnfc is failed)\n    VNFCInstance vnfcInstance = nsrManager.getVNFCInstanceFromVnfr(vnfr,vnfAlarm.getVnfcIds().iterator().next());\n\n    logger.info( (VNF LAYER) A CRITICAL alarm is received by the vnfc:  +vnfcInstance.getHostname());\n\n    //Get the vdu of the failed VNFC\n    VirtualDeploymentUnit vdu = nfvoRequestorWrapper.getVDU(vnfr,vnfcInstance.getId());\n\n    logger.info( Heal fired! );\n    highAvailabilityManager.executeHeal( serviceDown ,vnfr.getParent_ns_id(),vnfr.getId(),vdu.getId(),vnfcInstance.getId());\n\n    //Insert a new recovery action\n\n    RecoveryAction recoveryAction= new RecoveryAction(RecoveryActionType.HEAL,vnfr.getEndpoint(), );\n    recoveryAction.setStatus(RecoveryActionStatus.IN_PROGRESS);\n    insert(recoveryAction);\nend", 
            "title": "Drools Rules"
        }, 
        {
            "location": "/fault-management/#how-the-switch-to-standby-works", 
            "text": "The Switch to Standby action can be performed by the Open Baton FMS once a VNFC in standby is present in the VNF. Its main action is switch the service from a VNFC to the VNFC in standby automatically.\nIn order to have a VNFC in standby, such information must be included in the VNFD, in particular in the VDU, as the following:  high_availability :{\n     resiliencyLevel : ACTIVE_STANDBY_STATELESS ,\n     redundancyScheme : 1:N \n}  This information will be processed by the Open Baton FMS which will create a VNFC instance in standby.\nThen in a Drools rule this action can be called as following:  highAvailabilityManager.switchToRedundantVNFC(failedVnfcInstance,vnfr,vdu);", 
            "title": "How the Switch to Standby works"
        }, 
        {
            "location": "/fault-management/#tutorial", 
            "text": "The tutorial is available at this  page .", 
            "title": "Tutorial"
        }, 
        {
            "location": "/network-slicing/", 
            "text": "Network Slicing Engine\n\n\nThis external component provides a Network Slicing Engine (NSE). In the following fundamentals are described such as installing the NSE, configuring it and how to configure Network Slicing requirements.\n\n\nIn a nutshell this component ensures QoS configuration defined in the Descriptors provided by the NFVO.\n\n\nThe \nnetwork-slicing-engine\n is implemented in java using the \nspring.io\n framework. It runs as an external component and communicates with the NFVO via Open Baton's SDK.\n\n\nAdditionally, the NSE uses the a plugin mechanism to allow whatever driver is needed to setup QoS. Currently, it supports only the neutron driver which allows to configure QoS in OpenStack directly. Hence, the NSE requires at least version Mitaka of OpenStack since it was recently introduced.\n\n\nBefore starting this component you have to do the configuration of the NSE that is described in the \nnext chapter\n followed by the guide of \nhow to start\n and \nhow to use\n it.\n\n\nTechnical Requirements\n\n\nThis section covers the requirements that must be met by the environment in order to satisfy the demands of the NSE:\n\n\n\n\nInstalled and configured Open Baton NFVO/gVNFM (\n=3.0.0)\n\n\nInstalled and configured Openstack (\n=Mitaka) (for Mitaka check \nhere\n or Newton \nhere\n) \n\n\n\n\nHow to install Network Slicing Engine\n\n\nIf you installed this component already with the general bootstrap of Open Baton, the NSE is already installed, configured and running. In this case you can jump directly to this section \nHow to use Network Slicing Engine\n. If the NSE is not yet installed please continue with this section.\n\n\nDifferent options are available for the installation of the NSE. Either you use the fully automated bootstrap where all configurations are done automatically where you can choose between the installation based on the debian package or on the source code which is suggested for development. Apart from the bootstrap you can also use the debian or the source code installation where you need to configure the NSE manually. \n\n\nInstallation via bootstrap\n\n\nUsing the bootstrap gives a fully automated standalone installation of the NS including installation and configuration.\n\n\nThe only thing to do is to execute the following command and follow the configuration process: \n\n\nbash \n(curl -fsSkl https://raw.githubusercontent.com/openbaton/network-slicing-engine/master/bootstrap)\n\n\n\n\nOnce you started the bootstrap you can choose between different options, such as installing this component via debian packages or from the source code (mainly for development)\n\n\nInstallation via debian package\n\n\nWhen using the debian package you need to add the apt-repository of Open Baton to your local environment with the following command if not yet done:\n\n\nwget -O - http://get.openbaton.org/keys/public.gpg.key | apt-key add -\necho \ndeb http://get.openbaton.org/repos/apt/debian/ stable main\n \n /etc/apt/sources.list\n\n\n\n\nOnce you added the repo to your environment you should update the list of repos by executing:\n\n\napt-get update\n\n\n\n\nNow you can install the NSE by executing:\n\n\napt-get install openbaton-nse\n\n\n\n\nInstallation from the source code\n\n\nThe latest stable version NSE can be cloned from this \nrepository\n by executing the following command:\n\n\ngit clone https://github.com/openbaton/network-slicing-engine.git\n\n\n\n\nOnce this is done, go inside the cloned folder and make use of the provided script to compile the project as done below:\n\n\n./network-slicing-engine.sh compile\n\n\n\n\nManual configuration of the Network Slicing Engine\n\n\nThis chapter describes what needs to be done before starting the Network Slicing Engine. This includes the configuration file and properties, and also how to define QoS requirements in the descriptor.\n\n\nConfiguration file\n\n\nThe configuration file must be copied to \netc/openbaton/network-slicing-engine.properties\n by executing the following command from inside the repository folder:\n\n\ncp etc/network-slicing-engine.properties /etc/openbaton/network-slicing-engine.properties\n\n\n\n\nIf done, check out the following chapter in order to understand the configuration parameters.\n\n\nConfiguration properties\n\n\nThis chapter describes the parameters that must be considered for configuring the Network Slicing Engine.\n\n\n\n\n\n\n\n\nParams\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\nlogging.file\n\n\nlocation of the logging file\n\n\n\n\n\n\nlogging.level.*\n\n\nlogging levels of the defined modules\n\n\n\n\n\n\nrabbitmq.host\n\n\nhost of RabbitMQ\n\n\n\n\n\n\nrabbitmq.username\n\n\nusername for authorizing towards RabbitMQ\n\n\n\n\n\n\nrabbitmq.password\n\n\npassword for authorizing towards RabbitMQ\n\n\n\n\n\n\nnfvo.ip\n\n\nIP of the NFVO\n\n\n\n\n\n\nnfvo.port\n\n\nPort of the NFVO\n\n\n\n\n\n\nnfvo.username\n\n\nusername for authorizing towards NFVO\n\n\n\n\n\n\nnfvo.password\n\n\npassword for authorizing towards NFVO\n\n\n\n\n\n\nnfvo.project.name\n\n\nproject used for registering for the events\n\n\n\n\n\n\n\n\nStarting the Network Slicing Engine\n\n\nHow to start the NSE depends of the way you installed this component.\n\n\nDebian packages\n\n\nIf you installed the NSE with the debian packages you can start it with the following command:\n\n\nopenbaton-nse start\n\n\n\n\nFor stopping it you can just type:\n\n\nopenbaton-nse stop\n\n\n\n\nSource code\n\n\nIf you are using the source code you can start the NSE  easily by using the provided script with the following command:\n\n\n./network-slicing-engine.sh start\n\n\n\n\nOnce the NSE is started, you can access the screen session by executing:\n\n\nscreen -r openbaton\n\n\n\n\nFor stopping you can use:\n\n\n./network-slicing-engine.sh kill\n\n\n\n\nNote\n Since the NSE subscribes to specific events towards the NFVO, you should take care about that the NFVO is already running when starting the NSE.\n\n\nHow to use Network Slicing Engine\n\n\nThe currently only supported driver is neutron, which will use the native QoS capabilities of Openstack Mitaka. To use it simply set \nnse.driver=neutron\n in the configuration file. To set QoS policies in your NSD specify the following QoS parameter in the virtual_link of your vnfd configuration. \n\n\nIn JSON:\n\n\n  \nvirtual_link\n:[\n    {\n      \nname\n:\nNAME_OF_THE_NETWORK\n,\n      \nqos\n:[\n        \nminimum_bandwith:BRONZE\n\n      ]\n    }\n  ]\n\n\n\n\nIn YAML:\n\n\nmgmt:\n  type: tosca.nodes.nfv.VL\n  properties:\n    vendor: Fokus\n    qos:\n      - minimum_bandwith:BRONZE", 
            "title": "NS overview"
        }, 
        {
            "location": "/network-slicing/#network-slicing-engine", 
            "text": "This external component provides a Network Slicing Engine (NSE). In the following fundamentals are described such as installing the NSE, configuring it and how to configure Network Slicing requirements.  In a nutshell this component ensures QoS configuration defined in the Descriptors provided by the NFVO.  The  network-slicing-engine  is implemented in java using the  spring.io  framework. It runs as an external component and communicates with the NFVO via Open Baton's SDK.  Additionally, the NSE uses the a plugin mechanism to allow whatever driver is needed to setup QoS. Currently, it supports only the neutron driver which allows to configure QoS in OpenStack directly. Hence, the NSE requires at least version Mitaka of OpenStack since it was recently introduced.  Before starting this component you have to do the configuration of the NSE that is described in the  next chapter  followed by the guide of  how to start  and  how to use  it.", 
            "title": "Network Slicing Engine"
        }, 
        {
            "location": "/network-slicing/#technical-requirements", 
            "text": "This section covers the requirements that must be met by the environment in order to satisfy the demands of the NSE:   Installed and configured Open Baton NFVO/gVNFM ( =3.0.0)  Installed and configured Openstack ( =Mitaka) (for Mitaka check  here  or Newton  here )", 
            "title": "Technical Requirements"
        }, 
        {
            "location": "/network-slicing/#how-to-install-network-slicing-engine", 
            "text": "If you installed this component already with the general bootstrap of Open Baton, the NSE is already installed, configured and running. In this case you can jump directly to this section  How to use Network Slicing Engine . If the NSE is not yet installed please continue with this section.  Different options are available for the installation of the NSE. Either you use the fully automated bootstrap where all configurations are done automatically where you can choose between the installation based on the debian package or on the source code which is suggested for development. Apart from the bootstrap you can also use the debian or the source code installation where you need to configure the NSE manually.", 
            "title": "How to install Network Slicing Engine"
        }, 
        {
            "location": "/network-slicing/#installation-via-bootstrap", 
            "text": "Using the bootstrap gives a fully automated standalone installation of the NS including installation and configuration.  The only thing to do is to execute the following command and follow the configuration process:   bash  (curl -fsSkl https://raw.githubusercontent.com/openbaton/network-slicing-engine/master/bootstrap)  Once you started the bootstrap you can choose between different options, such as installing this component via debian packages or from the source code (mainly for development)", 
            "title": "Installation via bootstrap"
        }, 
        {
            "location": "/network-slicing/#installation-via-debian-package", 
            "text": "When using the debian package you need to add the apt-repository of Open Baton to your local environment with the following command if not yet done:  wget -O - http://get.openbaton.org/keys/public.gpg.key | apt-key add -\necho  deb http://get.openbaton.org/repos/apt/debian/ stable main    /etc/apt/sources.list  Once you added the repo to your environment you should update the list of repos by executing:  apt-get update  Now you can install the NSE by executing:  apt-get install openbaton-nse", 
            "title": "Installation via debian package"
        }, 
        {
            "location": "/network-slicing/#installation-from-the-source-code", 
            "text": "The latest stable version NSE can be cloned from this  repository  by executing the following command:  git clone https://github.com/openbaton/network-slicing-engine.git  Once this is done, go inside the cloned folder and make use of the provided script to compile the project as done below:  ./network-slicing-engine.sh compile", 
            "title": "Installation from the source code"
        }, 
        {
            "location": "/network-slicing/#manual-configuration-of-the-network-slicing-engine", 
            "text": "This chapter describes what needs to be done before starting the Network Slicing Engine. This includes the configuration file and properties, and also how to define QoS requirements in the descriptor.", 
            "title": "Manual configuration of the Network Slicing Engine"
        }, 
        {
            "location": "/network-slicing/#configuration-file", 
            "text": "The configuration file must be copied to  etc/openbaton/network-slicing-engine.properties  by executing the following command from inside the repository folder:  cp etc/network-slicing-engine.properties /etc/openbaton/network-slicing-engine.properties  If done, check out the following chapter in order to understand the configuration parameters.", 
            "title": "Configuration file"
        }, 
        {
            "location": "/network-slicing/#configuration-properties", 
            "text": "This chapter describes the parameters that must be considered for configuring the Network Slicing Engine.     Params  Meaning      logging.file  location of the logging file    logging.level.*  logging levels of the defined modules    rabbitmq.host  host of RabbitMQ    rabbitmq.username  username for authorizing towards RabbitMQ    rabbitmq.password  password for authorizing towards RabbitMQ    nfvo.ip  IP of the NFVO    nfvo.port  Port of the NFVO    nfvo.username  username for authorizing towards NFVO    nfvo.password  password for authorizing towards NFVO    nfvo.project.name  project used for registering for the events", 
            "title": "Configuration properties"
        }, 
        {
            "location": "/network-slicing/#starting-the-network-slicing-engine", 
            "text": "How to start the NSE depends of the way you installed this component.", 
            "title": "Starting the Network Slicing Engine"
        }, 
        {
            "location": "/network-slicing/#debian-packages", 
            "text": "If you installed the NSE with the debian packages you can start it with the following command:  openbaton-nse start  For stopping it you can just type:  openbaton-nse stop", 
            "title": "Debian packages"
        }, 
        {
            "location": "/network-slicing/#source-code", 
            "text": "If you are using the source code you can start the NSE  easily by using the provided script with the following command:  ./network-slicing-engine.sh start  Once the NSE is started, you can access the screen session by executing:  screen -r openbaton  For stopping you can use:  ./network-slicing-engine.sh kill  Note  Since the NSE subscribes to specific events towards the NFVO, you should take care about that the NFVO is already running when starting the NSE.", 
            "title": "Source code"
        }, 
        {
            "location": "/network-slicing/#how-to-use-network-slicing-engine", 
            "text": "The currently only supported driver is neutron, which will use the native QoS capabilities of Openstack Mitaka. To use it simply set  nse.driver=neutron  in the configuration file. To set QoS policies in your NSD specify the following QoS parameter in the virtual_link of your vnfd configuration.   In JSON:     virtual_link :[\n    {\n       name : NAME_OF_THE_NETWORK ,\n       qos :[\n         minimum_bandwith:BRONZE \n      ]\n    }\n  ]  In YAML:  mgmt:\n  type: tosca.nodes.nfv.VL\n  properties:\n    vendor: Fokus\n    qos:\n      - minimum_bandwith:BRONZE", 
            "title": "How to use Network Slicing Engine"
        }, 
        {
            "location": "/marketplace/", 
            "text": "Marketplace\n\n\nOpen Baton relase 3 comes with a new public component: the \nMarketplace\n. From this page you can browse all the free and open source VNF. You can also download NSDs, images and drivers. In the near future it will be possible for a registered user to upload his own VNF Package, making it in this way public and available to everyone. \n\n\n\n\nA VNF Package can be downloaded from this page and it can be helpfull as an example when you are writing your own VNF Package. If you want to import VNF Packages and/or NSDs in your own NFVO, you can do it directly via the integrated marketplace page in the NFVO Dashboard. \n\n\n\n\nYou can onboard the packages simply by clicking on the button, \u0435hey will be automatically downloaded and onboarded, ready to be used for deployment.\n\n\nIMPORTANT NOTE\n: The NSDs/VNFDs do not specify the PoP where they will be deployed (\nvimInstanceName\n) since of course the Marketplace is not aware of the PoP currently onboarded on the NFVO. Please remeber to specify during the deployement message where you want to deploy each single VNF. You can also avoid choosing the PoP in the deployment form, but the NFVO will choose randomly between the available onboarded PoPs.", 
            "title": "Marketplace overview"
        }, 
        {
            "location": "/marketplace/#marketplace", 
            "text": "Open Baton relase 3 comes with a new public component: the  Marketplace . From this page you can browse all the free and open source VNF. You can also download NSDs, images and drivers. In the near future it will be possible for a registered user to upload his own VNF Package, making it in this way public and available to everyone.    A VNF Package can be downloaded from this page and it can be helpfull as an example when you are writing your own VNF Package. If you want to import VNF Packages and/or NSDs in your own NFVO, you can do it directly via the integrated marketplace page in the NFVO Dashboard.    You can onboard the packages simply by clicking on the button, \u0435hey will be automatically downloaded and onboarded, ready to be used for deployment.  IMPORTANT NOTE : The NSDs/VNFDs do not specify the PoP where they will be deployed ( vimInstanceName ) since of course the Marketplace is not aware of the PoP currently onboarded on the NFVO. Please remeber to specify during the deployement message where you want to deploy each single VNF. You can also avoid choosing the PoP in the deployment form, but the NFVO will choose randomly between the available onboarded PoPs.", 
            "title": "Marketplace"
        }, 
        {
            "location": "/tutorial/", 
            "text": "Open Baton Tutorials\n\n\nThis section provides you a set of tutorials for facilitating your first contact with Open Baton. Those tutorials makes use of VNF Packages and Network Service Descriptors that could also be downloaded directly from the Open Baton \nMarketplace\n\n\nEach tutorial is organised in the following way: \n\n\n\n\nA description of the tutorial is provided. It describes the scenario that is going to be deployed\n\n\nIt provides a list of required components. Considering the specific scenario which will be deployed following the tutorial, it will specify what are the Open Baton components which are required for executing this specific tutorial\n\n\nIt specifies the list of steps which needs to be executed in order to run the tutorial", 
            "title": "Tutorials overview"
        }, 
        {
            "location": "/tutorial/#open-baton-tutorials", 
            "text": "This section provides you a set of tutorials for facilitating your first contact with Open Baton. Those tutorials makes use of VNF Packages and Network Service Descriptors that could also be downloaded directly from the Open Baton  Marketplace  Each tutorial is organised in the following way:    A description of the tutorial is provided. It describes the scenario that is going to be deployed  It provides a list of required components. Considering the specific scenario which will be deployed following the tutorial, it will specify what are the Open Baton components which are required for executing this specific tutorial  It specifies the list of steps which needs to be executed in order to run the tutorial", 
            "title": "Open Baton Tutorials"
        }, 
        {
            "location": "/dummy-NSR/", 
            "text": "Tutorial: Dummy Network Service Record\n\n\n\n\nThis tutorial explains how to deploy a Network Service Record composed of Dummy VNFs. It is typically used for testing that the installation of the NFVO went fine. \nIt will not launch any Virtual Machines nor actually deploy a real Network Service.\n\n\nYou can execute also the same tutorial using the \nTOSCA\n definitions. \n\n\nRequirements\n\n\nIn order to execute this scenario, you need to have the following components up and running: \n\n\n\n\nNFVO\n\n\nTest vim driver\n\n\nDummy-VNFM\n \n\n\n\n\nPreparation\n\n\nIf not yet running start the NFVO and the Dummy-VNFM (refer to it's \nreadme\n file on how to start it).\n\nIf you installed the NFVO using the bootstrap script, the Test vim driver will be installed already.\n\nOtherwise you have to provide it manually by cloning the \ngit repository\n and building the jar file with \n./gradlew build\n.\nNow move the built jar into \n{path-to-nfvo-source-code}/nfvo/plugins/vim-drivers\n and restart the NFVO. \n\n\nStore the VimInstance\n\n\nUpload a VimInstance with the type \ntest\n to the NFVO (e.g. this \nVimInstance\n). \nThe type \ntest\n will make sure that the NFVO uses the Test vim driver for deploying network services.  \n\n\nFor registering the Point of Presence of type \ntest\n to the NFVO you have to upload a Vim Instance. You can use this \nVimInstance\n. \n\n\nUsing the dashboard\n\n\nIf you want to use the Dashboard (checkout the \ndashboard documentation\n for more information on how to use it), open it at the URL http://ip-where-nfvo-runs:8080 (change port and protocol if you use SSL) and log in (default username and password are \nadmin\n and \nopenbaton\n).\n\nGo to \nManage PoPs -\n PoP Instances\n and choose the Vim Instance of your choice by clicking on \nRegister Vim\n and selecting the Vim Instance's json file.\n\n\n\n\nUsing the CLI\n\n\nIf you want to use the CLI (checkout the [Open Baton Client documentation][cli] for more information on how to install and use it), you need to execute the following command in order to onboard the Vim Instance where \nvim-instance.json\n is the path to the Vim Instance file:\n\n\n$./openbaton.sh VimInstance-create vim-instance.json\n\n\n\n\nStore the Network Service Descriptor\n\n\nDownload this \nNSD\n and upload it to the NFVO either using the dashboard or the cli. \n\n\nUsing the dashboard\n\n\nIf you want to use the Dashboard go to \nCatalogue -\n NS Descriptors\n and choose the NSD of your choice by clicking on \nUpload NSD\n and selecting the Descriptor's json file.\n\n\n\n\nUsing the CLI\n\n\nIf you want to use the CLI you need to execute the following command in order to onboard the NSD:\n\n\n$./openbaton.sh NetworkServiceDescriptor-create tutorial-iperf-NSD.json\n\n\n\n\nOnce this request is processed successfully, it returns the following:\n\n\n+------------------ +------------------------------------------------------------------ + \n| PROPERTY          | VALUE                                                             | \n+------------------ +------------------------------------------------------------------ + \n| VNFD              |                                                                   | \n|                   | id: 50c89b6a-2c3e-40b0-8f85-a4ee00f93ea6 - name:  dummy-client    | \n|                   | id: 55c1bdc8-af49-48e1-a438-4f4758edb5c2 - name:  dummy-server    | \n|                   |                                                                   | \n| VNF_DEPENDENCY    |                                                                   | \n|                   | id: 863177bd-4c68-42b3-a982-fa350ace94b1                          | \n|                   |                                                                   | \n| id                | bef3c744-b02a-48f1-9d14-9ede7847bc57                              | \n|                   |                                                                   | \n| hb_version        | 1                                                                 | \n|                   |                                                                   | \n| name              | dummy-NS                                                          | \n|                   |                                                                   | \n| projectId         | 2feadcfd-87cd-404c-9f52-7d5e621d1f0c                              | \n|                   |                                                                   | \n| vendor            | Fokus                                                             | \n|                   |                                                                   | \n| version           | 0.1                                                               | \n|                   |                                                                   | \n| VLD               |                                                                   | \n|                   | id: 2cb51390-48e0-4dc6-bbd4-1fe10655a087 - name:  private         | \n|                   |                                                                   | \n+------------------ +------------------------------------------------------------------ + \n\n\n\n\nDeploy the Network Service Descriptor\n\n\nAs soon as you onboarded the NSD in the NFVO you can deploy this NSD either by using the dashboard or the CLI.\n\nThis will create a Network Service Record (NSR) but because it is a Dummy-VNFM no Virtual Machines will be launched. \n\n\nUsing the dashboard\n\n\nThis part shows you how to deploy an onboarded NSD via the dashboard. You need to go to the GUI again and navigate to \nCatalogue -\n NS Descriptors\n. Open the drop down menu by clicking on \nAction\n. Afterwards you need to press the \nLaunch\n button and a window with launching options will appear. Just click on \nLaunch\n again in order to start the deployment of this NSD.\n\n\n\n\nIf you go to \nOrchestrate NS -\n NS Records\n in the menu on the left side, you can follow the deployment process and check the current status of the created NSR.\n\n\nUsing the CLI\n\n\nYou can also use the CLI for deploying existing NSDs. The command needs the ID of the NSD to deploy as an argument. It can be found either by using the dashboard or getting it from the output when onboarding a new NSD as done in the previous step. The command to deploy the previously onboarded NSD looks like shown below:\n\n\n$./openbaton.sh NetworkServiceRecord-create bef3c744-b02a-48f1-9d14-9ede7847bc57 vimmap.json keypair.json conf.json\n\n\n\n\nThe first argument is the ID of the NSD from which the NSR will be created. The following arguments are files that can contain additional configuration while deploying. \nYou have to pass these files even if you do not want to pass any configuration like in our case. So just create the three files and fill them with empty json objects/arrays (i.e. \n{}\n and \n[]\n).\n\nThe \nvimmap.json\n and the \nconf.json\n files should contain this:\n\n\n{}\n\n\n\n\nAnd the \nkeypair.json\n file this:\n\n\n[]\n\n\n\n\nThe execution of this command produces the following output:\n\n\n+------------------------ +------------------------------------------------------------- + \n| PROPERTY                | VALUE                                                        | \n+------------------------ +------------------------------------------------------------- + \n| id                      | 50388d15-237c-40c0-9e71-357a0d9475db                         | \n|                         |                                                              | \n| vendor                  | Fokus                                                        | \n|                         |                                                              | \n| projectId               | 2feadcfd-87cd-404c-9f52-7d5e621d1f0c                         | \n|                         |                                                              | \n| task                    | Onboarding                                                   | \n|                         |                                                              | \n| version                 | 0.1                                                          | \n|                         |                                                              | \n| VLR                     |                                                              | \n|                         | id: 6fe543f9-da83-46f6-948a-10f55ad6dec1 - name:  private    | \n|                         |                                                              | \n| VNF_DEPENDENCY          |                                                              | \n|                         | id: 222ff41f-33b9-4f49-af56-a34d9265d510                     | \n|                         |                                                              | \n| descriptor_reference    | bef3c744-b02a-48f1-9d14-9ede7847bc57                         | \n|                         |                                                              | \n| status                  | NULL                                                         | \n|                         |                                                              | \n| createdAt               | 2016.10.26 at 12:30:30 CEST                                  | \n|                         |                                                              | \n| name                    | dummy-NS                                                     | \n|                         |                                                              | \n+------------------------ +------------------------------------------------------------- +  \n\n\n\n\nIn order to follow the deployment process you can retrieve information by passing the ID of the deploying NSR to this command:\n\n\n$./openbaton.sh NetworkServiceRecord-findById 50388d15-237c-40c0-9e71-357a0d9475db\n\n\n+------------------------ +------------------------------------------------------------------ + \n| PROPERTY                | VALUE                                                             | \n+------------------------ +------------------------------------------------------------------ + \n| id                      | 50388d15-237c-40c0-9e71-357a0d9475db                              | \n|                         |                                                                   | \n| vendor                  | Fokus                                                             | \n|                         |                                                                   | \n| projectId               | 2feadcfd-87cd-404c-9f52-7d5e621d1f0c                              | \n|                         |                                                                   | \n| task                    | Onboarded                                                         | \n|                         |                                                                   | \n| version                 | 0.1                                                               | \n|                         |                                                                   | \n| VLR                     |                                                                   | \n|                         | id: 6fe543f9-da83-46f6-948a-10f55ad6dec1 - name:  private         | \n|                         |                                                                   | \n| VNFR                    |                                                                   | \n|                         | id: bc75a14d-53b3-46b3-9f2d-ad061a843cbd - name:  dummy-client    | \n|                         | id: 59a12259-b229-4e81-89d4-e0bc3a02415c - name:  dummy-server    | \n|                         |                                                                   | \n| VNF_DEPENDENCY          |                                                                   | \n|                         | id: 222ff41f-33b9-4f49-af56-a34d9265d510                          | \n|                         |                                                                   | \n| descriptor_reference    | bef3c744-b02a-48f1-9d14-9ede7847bc57                              | \n|                         |                                                                   | \n| status                  | ACTIVE                                                            | \n|                         |                                                                   | \n| createdAt               | 2016.10.26 at 12:30:30 CEST                                       | \n|                         |                                                                   | \n| name                    | dummy-NS                                                          | \n|                         |                                                                   | \n+------------------------ +------------------------------------------------------------------ +\n\n\n\n\nConclusions\n\n\nAfter the Dummy-Vnfm and the NFVO finished their work the deployed NSR will change to \nACTIVE\n state.\n\nNo virtual machines were created and no real network service was deployed.\n\nThe Test vim driver ensured that the NFVO thought that all the required resources were allocated and the Vim Instance created. \nThe Dummy-VNFM lead the NFVO to believe that it created virtual machines and executed the lifecycle event scripts on them. \n\n\n\n\n\n\n\n\n\n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Dummy NSR"
        }, 
        {
            "location": "/dummy-NSR/#tutorial-dummy-network-service-record", 
            "text": "This tutorial explains how to deploy a Network Service Record composed of Dummy VNFs. It is typically used for testing that the installation of the NFVO went fine. \nIt will not launch any Virtual Machines nor actually deploy a real Network Service.  You can execute also the same tutorial using the  TOSCA  definitions.", 
            "title": "Tutorial: Dummy Network Service Record"
        }, 
        {
            "location": "/dummy-NSR/#requirements", 
            "text": "In order to execute this scenario, you need to have the following components up and running:    NFVO  Test vim driver  Dummy-VNFM", 
            "title": "Requirements"
        }, 
        {
            "location": "/dummy-NSR/#preparation", 
            "text": "If not yet running start the NFVO and the Dummy-VNFM (refer to it's  readme  file on how to start it). \nIf you installed the NFVO using the bootstrap script, the Test vim driver will be installed already. \nOtherwise you have to provide it manually by cloning the  git repository  and building the jar file with  ./gradlew build .\nNow move the built jar into  {path-to-nfvo-source-code}/nfvo/plugins/vim-drivers  and restart the NFVO.", 
            "title": "Preparation"
        }, 
        {
            "location": "/dummy-NSR/#store-the-viminstance", 
            "text": "Upload a VimInstance with the type  test  to the NFVO (e.g. this  VimInstance ). \nThe type  test  will make sure that the NFVO uses the Test vim driver for deploying network services.    For registering the Point of Presence of type  test  to the NFVO you have to upload a Vim Instance. You can use this  VimInstance .", 
            "title": "Store the VimInstance"
        }, 
        {
            "location": "/dummy-NSR/#using-the-dashboard", 
            "text": "If you want to use the Dashboard (checkout the  dashboard documentation  for more information on how to use it), open it at the URL http://ip-where-nfvo-runs:8080 (change port and protocol if you use SSL) and log in (default username and password are  admin  and  openbaton ). \nGo to  Manage PoPs -  PoP Instances  and choose the Vim Instance of your choice by clicking on  Register Vim  and selecting the Vim Instance's json file.", 
            "title": "Using the dashboard"
        }, 
        {
            "location": "/dummy-NSR/#using-the-cli", 
            "text": "If you want to use the CLI (checkout the [Open Baton Client documentation][cli] for more information on how to install and use it), you need to execute the following command in order to onboard the Vim Instance where  vim-instance.json  is the path to the Vim Instance file:  $./openbaton.sh VimInstance-create vim-instance.json", 
            "title": "Using the CLI"
        }, 
        {
            "location": "/dummy-NSR/#store-the-network-service-descriptor", 
            "text": "Download this  NSD  and upload it to the NFVO either using the dashboard or the cli.", 
            "title": "Store the Network Service Descriptor"
        }, 
        {
            "location": "/dummy-NSR/#using-the-dashboard_1", 
            "text": "If you want to use the Dashboard go to  Catalogue -  NS Descriptors  and choose the NSD of your choice by clicking on  Upload NSD  and selecting the Descriptor's json file.", 
            "title": "Using the dashboard"
        }, 
        {
            "location": "/dummy-NSR/#using-the-cli_1", 
            "text": "If you want to use the CLI you need to execute the following command in order to onboard the NSD:  $./openbaton.sh NetworkServiceDescriptor-create tutorial-iperf-NSD.json  Once this request is processed successfully, it returns the following:  +------------------ +------------------------------------------------------------------ + \n| PROPERTY          | VALUE                                                             | \n+------------------ +------------------------------------------------------------------ + \n| VNFD              |                                                                   | \n|                   | id: 50c89b6a-2c3e-40b0-8f85-a4ee00f93ea6 - name:  dummy-client    | \n|                   | id: 55c1bdc8-af49-48e1-a438-4f4758edb5c2 - name:  dummy-server    | \n|                   |                                                                   | \n| VNF_DEPENDENCY    |                                                                   | \n|                   | id: 863177bd-4c68-42b3-a982-fa350ace94b1                          | \n|                   |                                                                   | \n| id                | bef3c744-b02a-48f1-9d14-9ede7847bc57                              | \n|                   |                                                                   | \n| hb_version        | 1                                                                 | \n|                   |                                                                   | \n| name              | dummy-NS                                                          | \n|                   |                                                                   | \n| projectId         | 2feadcfd-87cd-404c-9f52-7d5e621d1f0c                              | \n|                   |                                                                   | \n| vendor            | Fokus                                                             | \n|                   |                                                                   | \n| version           | 0.1                                                               | \n|                   |                                                                   | \n| VLD               |                                                                   | \n|                   | id: 2cb51390-48e0-4dc6-bbd4-1fe10655a087 - name:  private         | \n|                   |                                                                   | \n+------------------ +------------------------------------------------------------------ +", 
            "title": "Using the CLI"
        }, 
        {
            "location": "/dummy-NSR/#deploy-the-network-service-descriptor", 
            "text": "As soon as you onboarded the NSD in the NFVO you can deploy this NSD either by using the dashboard or the CLI. \nThis will create a Network Service Record (NSR) but because it is a Dummy-VNFM no Virtual Machines will be launched.", 
            "title": "Deploy the Network Service Descriptor"
        }, 
        {
            "location": "/dummy-NSR/#using-the-dashboard_2", 
            "text": "This part shows you how to deploy an onboarded NSD via the dashboard. You need to go to the GUI again and navigate to  Catalogue -  NS Descriptors . Open the drop down menu by clicking on  Action . Afterwards you need to press the  Launch  button and a window with launching options will appear. Just click on  Launch  again in order to start the deployment of this NSD.   If you go to  Orchestrate NS -  NS Records  in the menu on the left side, you can follow the deployment process and check the current status of the created NSR.", 
            "title": "Using the dashboard"
        }, 
        {
            "location": "/dummy-NSR/#using-the-cli_2", 
            "text": "You can also use the CLI for deploying existing NSDs. The command needs the ID of the NSD to deploy as an argument. It can be found either by using the dashboard or getting it from the output when onboarding a new NSD as done in the previous step. The command to deploy the previously onboarded NSD looks like shown below:  $./openbaton.sh NetworkServiceRecord-create bef3c744-b02a-48f1-9d14-9ede7847bc57 vimmap.json keypair.json conf.json  The first argument is the ID of the NSD from which the NSR will be created. The following arguments are files that can contain additional configuration while deploying. \nYou have to pass these files even if you do not want to pass any configuration like in our case. So just create the three files and fill them with empty json objects/arrays (i.e.  {}  and  [] ). \nThe  vimmap.json  and the  conf.json  files should contain this:  {}  And the  keypair.json  file this:  []  The execution of this command produces the following output:  +------------------------ +------------------------------------------------------------- + \n| PROPERTY                | VALUE                                                        | \n+------------------------ +------------------------------------------------------------- + \n| id                      | 50388d15-237c-40c0-9e71-357a0d9475db                         | \n|                         |                                                              | \n| vendor                  | Fokus                                                        | \n|                         |                                                              | \n| projectId               | 2feadcfd-87cd-404c-9f52-7d5e621d1f0c                         | \n|                         |                                                              | \n| task                    | Onboarding                                                   | \n|                         |                                                              | \n| version                 | 0.1                                                          | \n|                         |                                                              | \n| VLR                     |                                                              | \n|                         | id: 6fe543f9-da83-46f6-948a-10f55ad6dec1 - name:  private    | \n|                         |                                                              | \n| VNF_DEPENDENCY          |                                                              | \n|                         | id: 222ff41f-33b9-4f49-af56-a34d9265d510                     | \n|                         |                                                              | \n| descriptor_reference    | bef3c744-b02a-48f1-9d14-9ede7847bc57                         | \n|                         |                                                              | \n| status                  | NULL                                                         | \n|                         |                                                              | \n| createdAt               | 2016.10.26 at 12:30:30 CEST                                  | \n|                         |                                                              | \n| name                    | dummy-NS                                                     | \n|                         |                                                              | \n+------------------------ +------------------------------------------------------------- +    In order to follow the deployment process you can retrieve information by passing the ID of the deploying NSR to this command:  $./openbaton.sh NetworkServiceRecord-findById 50388d15-237c-40c0-9e71-357a0d9475db\n\n\n+------------------------ +------------------------------------------------------------------ + \n| PROPERTY                | VALUE                                                             | \n+------------------------ +------------------------------------------------------------------ + \n| id                      | 50388d15-237c-40c0-9e71-357a0d9475db                              | \n|                         |                                                                   | \n| vendor                  | Fokus                                                             | \n|                         |                                                                   | \n| projectId               | 2feadcfd-87cd-404c-9f52-7d5e621d1f0c                              | \n|                         |                                                                   | \n| task                    | Onboarded                                                         | \n|                         |                                                                   | \n| version                 | 0.1                                                               | \n|                         |                                                                   | \n| VLR                     |                                                                   | \n|                         | id: 6fe543f9-da83-46f6-948a-10f55ad6dec1 - name:  private         | \n|                         |                                                                   | \n| VNFR                    |                                                                   | \n|                         | id: bc75a14d-53b3-46b3-9f2d-ad061a843cbd - name:  dummy-client    | \n|                         | id: 59a12259-b229-4e81-89d4-e0bc3a02415c - name:  dummy-server    | \n|                         |                                                                   | \n| VNF_DEPENDENCY          |                                                                   | \n|                         | id: 222ff41f-33b9-4f49-af56-a34d9265d510                          | \n|                         |                                                                   | \n| descriptor_reference    | bef3c744-b02a-48f1-9d14-9ede7847bc57                              | \n|                         |                                                                   | \n| status                  | ACTIVE                                                            | \n|                         |                                                                   | \n| createdAt               | 2016.10.26 at 12:30:30 CEST                                       | \n|                         |                                                                   | \n| name                    | dummy-NS                                                          | \n|                         |                                                                   | \n+------------------------ +------------------------------------------------------------------ +", 
            "title": "Using the CLI"
        }, 
        {
            "location": "/dummy-NSR/#conclusions", 
            "text": "After the Dummy-Vnfm and the NFVO finished their work the deployed NSR will change to  ACTIVE  state. \nNo virtual machines were created and no real network service was deployed. \nThe Test vim driver ensured that the NFVO thought that all the required resources were allocated and the Vim Instance created. \nThe Dummy-VNFM lead the NFVO to believe that it created virtual machines and executed the lifecycle event scripts on them.     \n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Conclusions"
        }, 
        {
            "location": "/iperf-NSR/", 
            "text": "Tutorial: iPerf Network Service\n\n\nThis tutorial explains how to deploy a network service that uses iPerf.\n\n\niPerf\n is a tool for active measurements of the maximum achievable bandwidth between two or more machines where an iPerf client connects to an iPerf server.\n\n\nYou can execute also the same tutorial using the \nTOSCA\n definitions. \n\n\nThis tutorial makes use of:\n\n\n\n\nNFVO\n\n\nGeneric VNFM\n\n\nGeneric \nEMS\n\n\nOpenStack vim driver\n\n\n\n\nRequirements\n\n\nIn order to execute this scenario, you need to have the following components up and running:\n\n\n\n\nThe \nNFVO\n\n\nthe \nOpenStack vim driver\n\n\nthe \nGeneric VNFM\n\n\nOpenStack\n\n\n\n\nStart the NFVO and Generic VNFM depending on how you \ninstalled\n it.\n\nIf you used the bootstrap script for installing you do not have to care about the OpenStack vim driver as it will be installed already. \n\n\nStore the Vim Instance\n\n\nFor registering the Point of Presence of type OpenStack to the NFVO you have to upload a Vim Instance. You can use the following \njson descriptor\n by changing the values to your needs. \n\n\nUsing the dashboard\n\n\nIf you want to use the Dashboard (checkout the \ndashboard documentation\n for more information on how to use it), open it at the URL http://ip-where-nfvo-runs:8080 (change port and protocol if you use SSL) and log in (default username and password are \nadmin\n and \nopenbaton\n).\n\nGo to \nManage PoPs -\n PoP Instances\n and choose the Vim Instance of your choice by clicking on \nRegister Vim\n and selecting the Vim Instance's json file.\n\n\n\n\nUsing the CLI\n\n\nIf you want to use the CLI (checkout the \nOpen Baton Client documentation\n for more information on how to install and use it), you need to execute the following command in order to onboard the Vim Instance where \nvim-instance.json\n is the path to the Vim Instance file:\n\n\n$./openbaton.sh VimInstance-create vim-instance.json\n\n\n\n\nStore the Network Service Descriptor\n\n\nDownload the \niPerf NSD using private IPs\n or \niPerf NSD using floating IPs\n, and upload it in the catalogue either using the dashboard or the CLI.\n\nThe difference is that the first NSD will deploy Virtual Machines without floating IPs on OpenStack whereas the second one will use floating IPs. \n\n\nUsing the dashboard\n\n\nIf you want to use the Dashboard go to \nCatalogue -\n NS Descriptors\n and choose the NSD of your choice by clicking on \nUpload NSD\n and selecting the Descriptor's json file.\n\n\n\n\nUsing the CLI\n\n\nIf you want to use the CLI you need to execute the following command in order to onboard the NSD:\n\n\n$./openbaton.sh NetworkServiceDescriptor-create tutorial-iperf-NSD.json\n\n\n\n\nOnce this request is processed successfully, it returns the following:\n\n\n+------------------ +------------------------------------------------------------------ + \n| PROPERTY          | VALUE                                                             | \n+------------------ +------------------------------------------------------------------ + \n| VNFD              |                                                                   | \n|                   | id: 2dd6a30d-0eee-4f88-aa45-9f3a420f341b - name:  iperf-server    | \n|                   | id: 55ac1b21-fdf0-4fe3-861e-5b1f6b5079e3 - name:  iperf-client    | \n|                   |                                                                   | \n| VNF_DEPENDENCY    |                                                                   | \n|                   | id: 123b3dc1-4310-405c-8c50-17dbb1becd2d                          | \n|                   |                                                                   | \n| id                | f2086f71-4ecf-4ed8-a692-36775ebdfc68                              | \n|                   |                                                                   | \n| hb_version        | 1                                                                 | \n|                   |                                                                   | \n| name              | NSD iperf + privateIPs                                            | \n|                   |                                                                   | \n| projectId         | 7bc76eb0-c48c-4328-a234-c779ab54cd2a                              | \n|                   |                                                                   | \n| vendor            | FOKUS                                                             | \n|                   |                                                                   | \n| version           | 1.0                                                               | \n|                   |                                                                   | \n| VLD               |                                                                   | \n|                   | id: bd65ee00-ce56-42f4-9d31-5cd220ee64a6 - name:  private         | \n|                   |                                                                   | \n+------------------ +------------------------------------------------------------------ + \n\n\n\n\nDeploy the Network Service Descriptor\n\n\nAs soon as you onboarded the NSD in the NFVO you can deploy this NSD either by using the dashboard or the CLI.\n\nThis will create a Network Service Record (NSR) and actually launch the Virtual Machines on OpenStack. \n\n\nUsing the dashboard\n\n\nThis part shows you how to deploy an onboarded NSD via the dashboard. You need to go to the GUI again and navigate to \nCatalogue -\n NS Descriptors\n. Open the drop down menu by clicking on \nAction\n. Afterwards you need to press the \nLaunch\n button and a window with launching options will appear. Just click on \nLaunch\n again in order to start the deployment of this NSD.\n\n\n\n\nIf you go to \nOrchestrate NS -\n NS Records\n in the menu on the left side, you can follow the deployment process and check the current status of the created NSR.\n\n\nUsing the CLI\n\n\nYou can also use the CLI for deploying existing NSDs. The command needs the ID of the NSD to deploy as an argument. It can be found either by using the dashboard or getting it from the output when onboarding a new NSD as done in the previous step. The command to deploy the previously onboarded NSD looks like shown below:\n\n\n$./openbaton.sh NetworkServiceRecord-create f2086f71-4ecf-4ed8-a692-36775ebdfc68 vimmap.json keypair.json conf.json\n\n\n\n\nThe first argument is the ID of the NSD from which the NSR will be created. The following arguments are files that can contain additional configuration while deploying. \nYou have to pass these files even if you do not want to pass any configuration like in our case. So just create the three files and fill them with empty json objects/arrays (i.e. \n{}\n and \n[]\n).\n\nThe \nvimmap.json\n and the \nconf.json\n files should contain this:\n\n\n{}\n\n\n\n\nAnd the \nkeypair.json\n file this:\n\n\n[]\n\n\n\n\nThe execution of this command produces the following output:\n\n\n+------------------------ +------------------------------------------------------------- + \n| PROPERTY                | VALUE                                                        | \n+------------------------ +------------------------------------------------------------- + \n| id                      | af12b18b-9aa2-4fed-9b07-bbe1dcad9c98                         | \n|                         |                                                              | \n| vendor                  | FOKUS                                                        | \n|                         |                                                              | \n| projectId               | 7bc76eb0-c48c-4328-a234-c779ab54cd2a                         | \n|                         |                                                              | \n| task                    | Onboarding                                                   | \n|                         |                                                              | \n| version                 | 1.0                                                          | \n|                         |                                                              | \n| VLR                     |                                                              | \n|                         | id: 7c9996a4-eac8-4862-872b-dfccc4ab1790 - name:  private    | \n|                         |                                                              | \n| VNF_DEPENDENCY          |                                                              | \n|                         | id: 4b0d291e-883b-40e0-b64e-faeb196d2aaf                     | \n|                         |                                                              | \n| descriptor_reference    | f2086f71-4ecf-4ed8-a692-36775ebdfc68                         | \n|                         |                                                              | \n| status                  | NULL                                                         | \n|                         |                                                              | \n| createdAt               | 2016.10.25 at 11:52:04 CEST                                  | \n|                         |                                                              | \n| name                    | NSD iperf + privateIPs                                       | \n|                         |                                                              | \n+------------------------ +------------------------------------------------------------- + \n\n\n\n\nIn order to follow the deployment process you can retrieve information by passing the ID of the deploying NSR to this command:\n\n\n$./openbaton.sh NetworkServiceRecord-findById af12b18b-9aa2-4fed-9b07-bbe1dcad9c98\n\n\n+------------------------ +------------------------------------------------------------------ + \n| PROPERTY                | VALUE                                                             | \n+------------------------ +------------------------------------------------------------------ + \n| id                      | af12b18b-9aa2-4fed-9b07-bbe1dcad9c98                              | \n|                         |                                                                   | \n| vendor                  | FOKUS                                                             | \n|                         |                                                                   | \n| projectId               | 7bc76eb0-c48c-4328-a234-c779ab54cd2a                              | \n|                         |                                                                   | \n| task                    | Onboarded                                                         | \n|                         |                                                                   | \n| version                 | 1.0                                                               | \n|                         |                                                                   | \n| VLR                     |                                                                   | \n|                         | id: 7c9996a4-eac8-4862-872b-dfccc4ab1790 - name:  private         | \n|                         |                                                                   | \n| VNFR                    |                                                                   | \n|                         | id: ecd372b4-b170-46de-93a4-06b8f03a6436 - name:  iperf-server    | \n|                         | id: 20011a5c-73a5-46d6-a7c8-19bfa47de0e6 - name:  iperf-client    | \n|                         |                                                                   | \n| VNF_DEPENDENCY          |                                                                   | \n|                         | id: 4b0d291e-883b-40e0-b64e-faeb196d2aaf                          | \n|                         |                                                                   | \n| descriptor_reference    | f2086f71-4ecf-4ed8-a692-36775ebdfc68                              | \n|                         |                                                                   | \n| status                  | ACTIVE                                                            | \n|                         |                                                                   | \n| createdAt               | 2016.10.25 at 11:52:04 CEST                                       | \n|                         |                                                                   | \n| name                    | NSD iperf + privateIPs                                            | \n|                         |                                                                   | \n+------------------------ +------------------------------------------------------------------ + \n\n\n\n\nConclusions\n\n\nWhen all the VNF Records are done with all of the scripts defined in the lifecycle events, the NFVO will put the state of the VNF Record to ACTIVE and when all the VNF Records are in state ACTIVE, also the Network Service Record will be in state ACTIVE. This means that the service is deployed correctly. For learning more about the states of a VNF Record please refer to the \nVNF Record state documentation\n.\n\n\nAddtional information about this scenario\n\n\nWhen you access your OpenStack dashboard you should be able to see the deployed Virtual Machines. One of them will act as an iPerf server and the other one as an iPerf client that connects to the server. \n\n\nThe following pictures shows the deployment.\n\n\n\n\nAs indicated by the blue arrow the iperf server is the source of a dependency and the client is the target. In this case the client needs the IP of the server in order to connect.\nLet's have a look at the NSD we used to deploy this scenario in order to see how the dependencies are described.\n\nYou will see that the NSD contains a field called \nvnf_dependency\n. \n\n\nvnf_dependency\n:[\n    {\n      \nsource\n:{\n        \nname\n:\niperf-server\n\n      },\n      \ntarget\n:{\n        \nname\n:\niperf-client\n\n      },\n      \nparameters\n:[\n        \nprivate_floatingIp\n\n      ]\n    }\n  ]\n\n\n\n\nThe json array \nvnf_dependency\n may contain multiple dependencies. In our case it is just one, which describes that the VNFD named \niperf-client\n needs a parameter called \nprivate_floaingIp\n from the VNFD \niperf-server\n. This parameter can be used by the iperf-client as a variable in its lifecycle scripts. \n\n\nAlso the lifecycle scripts are specified in the NSD. For example the VNFD \niperf-client\n has the following lifecycle events: \n\n\nlifecycle_event\n:[\n        {\n          \nevent\n:\nCONFIGURE\n,\n          \nlifecycle_events\n:[\n            \nserver_configure_floatingIp.sh\n\n          ]\n        },\n        {\n          \nevent\n:\nINSTANTIATE\n,\n          \nlifecycle_events\n:[\n            \ninstall.sh\n\n          ]\n        }\n      ]\n\n\n\n\nYou can see that there is one lifecycle event called \nINSTANTIATE\n and one called \nCONFIGURE\n. Actually there exist also other lifecycle events, read about them \nhere\n.\n\nEach one will be executed at a different point in time. By execution we mean that the scripts that are listed in the \nlifecycle_events\n field will run with root permissions on the Virtual Machine.\n\nThe scripts are located in a public git repository. The url is specified in the \nvnfPackageLocation\n field in the VNFDs.\n\nIn our example the \nINSTANTIATE\n event will run first after the Virtual Machine was initialized. It will run the \ninstall.sh\n script which installs iPerf and screen on the Virtual Machine.\n\nThe \nCONFIGURE\n lifecycle event starts after the \nINSTANTIATE\n lifecycle event. The \nCONFIGURE\n lifecycle event has a special role. In the lifecycle scripts of this event the dependency parameters are available.\n\nThat is why we use this event to tell iPerf to connect to the server ip. In the example NSD that uses floating IPs the dependency parameter is called \nprivate_floatingIp\n. \nIn the \nCONFIGURE\n lifecycle script we will therefore run \n\n\nscreen -d -m -S client iperf -c $server_private_floatingIp -t 300\n\n\n\n\nYou wonder why the variable in the script has another name than the dependency parameter? Well, you have to prepend the type of the source VNFD and an underscore to the variable. This is why \nprivate_floatingIp\n becomes \nserver_private_floatingIp\n.\n\nAnd there is another restriction. In order to use the dependency parameter in the \nCONFIGURE\n script its name has to start with the source VNFD type followed by an underscore.\n\nIf you want to learn more about dependencies, lifecycle events and variables read \nthis\n section. \n\n\nThe process in details\n\n\nLet's again have a look at the sequence diagram of a create Network Service Record operation.\n\n\n\n\nWhen the Network Service Record create is called with the Iperf Network Service Descriptor's id, the steps defined in the sequence diagram above happen.\n\n\nINSTANTIATE Method\n\n\nThe first message sent to the Generic VNFM is the INSTANTIATE message \n(1)\n. This message contains the VNF Descriptor and some other parameters needed to create the VNF Record, for instance the list of Virtual Link Records. The Generic VNFM  is called and then the create Virtual Network Function Record and the Virtual Network Function Record is created \n(2)\n and sent back to the NFVO into a GrantOperation message \n(3)\n. This message will trigger the NFVO to check if there are enough resources to create that VNF Record. If so, then a GrantOperation message with the updated VNF Record is sent back to the Generic VNFManager. Then the Generic VNFManager creates an AllocateResources message with the received VNF Record and sends it to the NFVO \n(4)\n. After creating the resources (VMs) the NFVO sends back the AllocateResources message to the VNFManager. Here the instantiate method is called \n(5)\n. Inside this method, the scripts contained in the VNF Package (or the git repository containing the scripts) is sent to the EMS, the scripts are saved locally to the VM and then the Generic VNFManager will call the execution of each script defined in the VNF Descriptor \n(6)\n. Once all of the scripts are executed and there wasn't any error, the VNFManager sends the Instantiate message back to the NFVO \n(7)\n. \n\n\nMODIFY Method\n\n\nIf the VNF is target for some dependencies, like the iperf client, the MODIFY message is sent to the VNFManager by the NFVO \n(8)\n. Then the VNFManager executes the scripts contained in the CONFIGURE lifecycle event defined in the VNF Descriptor \n(9)\n, and sends back the modify message to the NFVO \n(10)\n, if no errors occurred. In this case, the scripts environment will contain the variables defined in the related VNF dependency.\n\n\nSTART Method\n\n\nHere exactly as before, the NFVO sends the START message to the Generic VNFManager \n(11)\n, and the VNFManager calls the EMS for execution of the scripts defined in the START lifecycle (none for this example) \n(12)\n. And the start message is then sent back to the NFVO meaning that no errors occurred \n(13)\n.\n\n\n\n\n\n\n\n\n\n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Iperf Scenario"
        }, 
        {
            "location": "/iperf-NSR/#tutorial-iperf-network-service", 
            "text": "This tutorial explains how to deploy a network service that uses iPerf.  iPerf  is a tool for active measurements of the maximum achievable bandwidth between two or more machines where an iPerf client connects to an iPerf server.  You can execute also the same tutorial using the  TOSCA  definitions.   This tutorial makes use of:   NFVO  Generic VNFM  Generic  EMS  OpenStack vim driver", 
            "title": "Tutorial: iPerf Network Service"
        }, 
        {
            "location": "/iperf-NSR/#requirements", 
            "text": "In order to execute this scenario, you need to have the following components up and running:   The  NFVO  the  OpenStack vim driver  the  Generic VNFM  OpenStack   Start the NFVO and Generic VNFM depending on how you  installed  it. \nIf you used the bootstrap script for installing you do not have to care about the OpenStack vim driver as it will be installed already.", 
            "title": "Requirements"
        }, 
        {
            "location": "/iperf-NSR/#store-the-vim-instance", 
            "text": "For registering the Point of Presence of type OpenStack to the NFVO you have to upload a Vim Instance. You can use the following  json descriptor  by changing the values to your needs.", 
            "title": "Store the Vim Instance"
        }, 
        {
            "location": "/iperf-NSR/#using-the-dashboard", 
            "text": "If you want to use the Dashboard (checkout the  dashboard documentation  for more information on how to use it), open it at the URL http://ip-where-nfvo-runs:8080 (change port and protocol if you use SSL) and log in (default username and password are  admin  and  openbaton ). \nGo to  Manage PoPs -  PoP Instances  and choose the Vim Instance of your choice by clicking on  Register Vim  and selecting the Vim Instance's json file.", 
            "title": "Using the dashboard"
        }, 
        {
            "location": "/iperf-NSR/#using-the-cli", 
            "text": "If you want to use the CLI (checkout the  Open Baton Client documentation  for more information on how to install and use it), you need to execute the following command in order to onboard the Vim Instance where  vim-instance.json  is the path to the Vim Instance file:  $./openbaton.sh VimInstance-create vim-instance.json", 
            "title": "Using the CLI"
        }, 
        {
            "location": "/iperf-NSR/#store-the-network-service-descriptor", 
            "text": "Download the  iPerf NSD using private IPs  or  iPerf NSD using floating IPs , and upload it in the catalogue either using the dashboard or the CLI. \nThe difference is that the first NSD will deploy Virtual Machines without floating IPs on OpenStack whereas the second one will use floating IPs.", 
            "title": "Store the Network Service Descriptor"
        }, 
        {
            "location": "/iperf-NSR/#using-the-dashboard_1", 
            "text": "If you want to use the Dashboard go to  Catalogue -  NS Descriptors  and choose the NSD of your choice by clicking on  Upload NSD  and selecting the Descriptor's json file.", 
            "title": "Using the dashboard"
        }, 
        {
            "location": "/iperf-NSR/#using-the-cli_1", 
            "text": "If you want to use the CLI you need to execute the following command in order to onboard the NSD:  $./openbaton.sh NetworkServiceDescriptor-create tutorial-iperf-NSD.json  Once this request is processed successfully, it returns the following:  +------------------ +------------------------------------------------------------------ + \n| PROPERTY          | VALUE                                                             | \n+------------------ +------------------------------------------------------------------ + \n| VNFD              |                                                                   | \n|                   | id: 2dd6a30d-0eee-4f88-aa45-9f3a420f341b - name:  iperf-server    | \n|                   | id: 55ac1b21-fdf0-4fe3-861e-5b1f6b5079e3 - name:  iperf-client    | \n|                   |                                                                   | \n| VNF_DEPENDENCY    |                                                                   | \n|                   | id: 123b3dc1-4310-405c-8c50-17dbb1becd2d                          | \n|                   |                                                                   | \n| id                | f2086f71-4ecf-4ed8-a692-36775ebdfc68                              | \n|                   |                                                                   | \n| hb_version        | 1                                                                 | \n|                   |                                                                   | \n| name              | NSD iperf + privateIPs                                            | \n|                   |                                                                   | \n| projectId         | 7bc76eb0-c48c-4328-a234-c779ab54cd2a                              | \n|                   |                                                                   | \n| vendor            | FOKUS                                                             | \n|                   |                                                                   | \n| version           | 1.0                                                               | \n|                   |                                                                   | \n| VLD               |                                                                   | \n|                   | id: bd65ee00-ce56-42f4-9d31-5cd220ee64a6 - name:  private         | \n|                   |                                                                   | \n+------------------ +------------------------------------------------------------------ +", 
            "title": "Using the CLI"
        }, 
        {
            "location": "/iperf-NSR/#deploy-the-network-service-descriptor", 
            "text": "As soon as you onboarded the NSD in the NFVO you can deploy this NSD either by using the dashboard or the CLI. \nThis will create a Network Service Record (NSR) and actually launch the Virtual Machines on OpenStack.", 
            "title": "Deploy the Network Service Descriptor"
        }, 
        {
            "location": "/iperf-NSR/#using-the-dashboard_2", 
            "text": "This part shows you how to deploy an onboarded NSD via the dashboard. You need to go to the GUI again and navigate to  Catalogue -  NS Descriptors . Open the drop down menu by clicking on  Action . Afterwards you need to press the  Launch  button and a window with launching options will appear. Just click on  Launch  again in order to start the deployment of this NSD.   If you go to  Orchestrate NS -  NS Records  in the menu on the left side, you can follow the deployment process and check the current status of the created NSR.", 
            "title": "Using the dashboard"
        }, 
        {
            "location": "/iperf-NSR/#using-the-cli_2", 
            "text": "You can also use the CLI for deploying existing NSDs. The command needs the ID of the NSD to deploy as an argument. It can be found either by using the dashboard or getting it from the output when onboarding a new NSD as done in the previous step. The command to deploy the previously onboarded NSD looks like shown below:  $./openbaton.sh NetworkServiceRecord-create f2086f71-4ecf-4ed8-a692-36775ebdfc68 vimmap.json keypair.json conf.json  The first argument is the ID of the NSD from which the NSR will be created. The following arguments are files that can contain additional configuration while deploying. \nYou have to pass these files even if you do not want to pass any configuration like in our case. So just create the three files and fill them with empty json objects/arrays (i.e.  {}  and  [] ). \nThe  vimmap.json  and the  conf.json  files should contain this:  {}  And the  keypair.json  file this:  []  The execution of this command produces the following output:  +------------------------ +------------------------------------------------------------- + \n| PROPERTY                | VALUE                                                        | \n+------------------------ +------------------------------------------------------------- + \n| id                      | af12b18b-9aa2-4fed-9b07-bbe1dcad9c98                         | \n|                         |                                                              | \n| vendor                  | FOKUS                                                        | \n|                         |                                                              | \n| projectId               | 7bc76eb0-c48c-4328-a234-c779ab54cd2a                         | \n|                         |                                                              | \n| task                    | Onboarding                                                   | \n|                         |                                                              | \n| version                 | 1.0                                                          | \n|                         |                                                              | \n| VLR                     |                                                              | \n|                         | id: 7c9996a4-eac8-4862-872b-dfccc4ab1790 - name:  private    | \n|                         |                                                              | \n| VNF_DEPENDENCY          |                                                              | \n|                         | id: 4b0d291e-883b-40e0-b64e-faeb196d2aaf                     | \n|                         |                                                              | \n| descriptor_reference    | f2086f71-4ecf-4ed8-a692-36775ebdfc68                         | \n|                         |                                                              | \n| status                  | NULL                                                         | \n|                         |                                                              | \n| createdAt               | 2016.10.25 at 11:52:04 CEST                                  | \n|                         |                                                              | \n| name                    | NSD iperf + privateIPs                                       | \n|                         |                                                              | \n+------------------------ +------------------------------------------------------------- +   In order to follow the deployment process you can retrieve information by passing the ID of the deploying NSR to this command:  $./openbaton.sh NetworkServiceRecord-findById af12b18b-9aa2-4fed-9b07-bbe1dcad9c98\n\n\n+------------------------ +------------------------------------------------------------------ + \n| PROPERTY                | VALUE                                                             | \n+------------------------ +------------------------------------------------------------------ + \n| id                      | af12b18b-9aa2-4fed-9b07-bbe1dcad9c98                              | \n|                         |                                                                   | \n| vendor                  | FOKUS                                                             | \n|                         |                                                                   | \n| projectId               | 7bc76eb0-c48c-4328-a234-c779ab54cd2a                              | \n|                         |                                                                   | \n| task                    | Onboarded                                                         | \n|                         |                                                                   | \n| version                 | 1.0                                                               | \n|                         |                                                                   | \n| VLR                     |                                                                   | \n|                         | id: 7c9996a4-eac8-4862-872b-dfccc4ab1790 - name:  private         | \n|                         |                                                                   | \n| VNFR                    |                                                                   | \n|                         | id: ecd372b4-b170-46de-93a4-06b8f03a6436 - name:  iperf-server    | \n|                         | id: 20011a5c-73a5-46d6-a7c8-19bfa47de0e6 - name:  iperf-client    | \n|                         |                                                                   | \n| VNF_DEPENDENCY          |                                                                   | \n|                         | id: 4b0d291e-883b-40e0-b64e-faeb196d2aaf                          | \n|                         |                                                                   | \n| descriptor_reference    | f2086f71-4ecf-4ed8-a692-36775ebdfc68                              | \n|                         |                                                                   | \n| status                  | ACTIVE                                                            | \n|                         |                                                                   | \n| createdAt               | 2016.10.25 at 11:52:04 CEST                                       | \n|                         |                                                                   | \n| name                    | NSD iperf + privateIPs                                            | \n|                         |                                                                   | \n+------------------------ +------------------------------------------------------------------ +", 
            "title": "Using the CLI"
        }, 
        {
            "location": "/iperf-NSR/#conclusions", 
            "text": "When all the VNF Records are done with all of the scripts defined in the lifecycle events, the NFVO will put the state of the VNF Record to ACTIVE and when all the VNF Records are in state ACTIVE, also the Network Service Record will be in state ACTIVE. This means that the service is deployed correctly. For learning more about the states of a VNF Record please refer to the  VNF Record state documentation .", 
            "title": "Conclusions"
        }, 
        {
            "location": "/iperf-NSR/#addtional-information-about-this-scenario", 
            "text": "When you access your OpenStack dashboard you should be able to see the deployed Virtual Machines. One of them will act as an iPerf server and the other one as an iPerf client that connects to the server.   The following pictures shows the deployment.   As indicated by the blue arrow the iperf server is the source of a dependency and the client is the target. In this case the client needs the IP of the server in order to connect.\nLet's have a look at the NSD we used to deploy this scenario in order to see how the dependencies are described. \nYou will see that the NSD contains a field called  vnf_dependency .   vnf_dependency :[\n    {\n       source :{\n         name : iperf-server \n      },\n       target :{\n         name : iperf-client \n      },\n       parameters :[\n         private_floatingIp \n      ]\n    }\n  ]  The json array  vnf_dependency  may contain multiple dependencies. In our case it is just one, which describes that the VNFD named  iperf-client  needs a parameter called  private_floaingIp  from the VNFD  iperf-server . This parameter can be used by the iperf-client as a variable in its lifecycle scripts.   Also the lifecycle scripts are specified in the NSD. For example the VNFD  iperf-client  has the following lifecycle events:   lifecycle_event :[\n        {\n           event : CONFIGURE ,\n           lifecycle_events :[\n             server_configure_floatingIp.sh \n          ]\n        },\n        {\n           event : INSTANTIATE ,\n           lifecycle_events :[\n             install.sh \n          ]\n        }\n      ]  You can see that there is one lifecycle event called  INSTANTIATE  and one called  CONFIGURE . Actually there exist also other lifecycle events, read about them  here . \nEach one will be executed at a different point in time. By execution we mean that the scripts that are listed in the  lifecycle_events  field will run with root permissions on the Virtual Machine. \nThe scripts are located in a public git repository. The url is specified in the  vnfPackageLocation  field in the VNFDs. \nIn our example the  INSTANTIATE  event will run first after the Virtual Machine was initialized. It will run the  install.sh  script which installs iPerf and screen on the Virtual Machine. \nThe  CONFIGURE  lifecycle event starts after the  INSTANTIATE  lifecycle event. The  CONFIGURE  lifecycle event has a special role. In the lifecycle scripts of this event the dependency parameters are available. \nThat is why we use this event to tell iPerf to connect to the server ip. In the example NSD that uses floating IPs the dependency parameter is called  private_floatingIp . \nIn the  CONFIGURE  lifecycle script we will therefore run   screen -d -m -S client iperf -c $server_private_floatingIp -t 300  You wonder why the variable in the script has another name than the dependency parameter? Well, you have to prepend the type of the source VNFD and an underscore to the variable. This is why  private_floatingIp  becomes  server_private_floatingIp . \nAnd there is another restriction. In order to use the dependency parameter in the  CONFIGURE  script its name has to start with the source VNFD type followed by an underscore. \nIf you want to learn more about dependencies, lifecycle events and variables read  this  section.", 
            "title": "Addtional information about this scenario"
        }, 
        {
            "location": "/iperf-NSR/#the-process-in-details", 
            "text": "Let's again have a look at the sequence diagram of a create Network Service Record operation.   When the Network Service Record create is called with the Iperf Network Service Descriptor's id, the steps defined in the sequence diagram above happen.", 
            "title": "The process in details"
        }, 
        {
            "location": "/iperf-NSR/#instantiate-method", 
            "text": "The first message sent to the Generic VNFM is the INSTANTIATE message  (1) . This message contains the VNF Descriptor and some other parameters needed to create the VNF Record, for instance the list of Virtual Link Records. The Generic VNFM  is called and then the create Virtual Network Function Record and the Virtual Network Function Record is created  (2)  and sent back to the NFVO into a GrantOperation message  (3) . This message will trigger the NFVO to check if there are enough resources to create that VNF Record. If so, then a GrantOperation message with the updated VNF Record is sent back to the Generic VNFManager. Then the Generic VNFManager creates an AllocateResources message with the received VNF Record and sends it to the NFVO  (4) . After creating the resources (VMs) the NFVO sends back the AllocateResources message to the VNFManager. Here the instantiate method is called  (5) . Inside this method, the scripts contained in the VNF Package (or the git repository containing the scripts) is sent to the EMS, the scripts are saved locally to the VM and then the Generic VNFManager will call the execution of each script defined in the VNF Descriptor  (6) . Once all of the scripts are executed and there wasn't any error, the VNFManager sends the Instantiate message back to the NFVO  (7) .", 
            "title": "INSTANTIATE Method"
        }, 
        {
            "location": "/iperf-NSR/#modify-method", 
            "text": "If the VNF is target for some dependencies, like the iperf client, the MODIFY message is sent to the VNFManager by the NFVO  (8) . Then the VNFManager executes the scripts contained in the CONFIGURE lifecycle event defined in the VNF Descriptor  (9) , and sends back the modify message to the NFVO  (10) , if no errors occurred. In this case, the scripts environment will contain the variables defined in the related VNF dependency.", 
            "title": "MODIFY Method"
        }, 
        {
            "location": "/iperf-NSR/#start-method", 
            "text": "Here exactly as before, the NFVO sends the START message to the Generic VNFManager  (11) , and the VNFManager calls the EMS for execution of the scripts defined in the START lifecycle (none for this example)  (12) . And the start message is then sent back to the NFVO meaning that no errors occurred  (13) .    \n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "START Method"
        }, 
        {
            "location": "/tutorial-sipp/", 
            "text": "Tutorial: SIPp Network Service\n\n\nThis tutorial explains how to deploy a network service that uses SIPp.\n\n\nSIPp\n is a free Open Source test tool / traffic generator for the SIP protocol which follows a client/server approach. In the following you will see how to create the NSD which defines the allocations of virtual resources, the installation and configuration of the the SIPp server and client. Furthermore, you can see how to create dependencies.\n\n\nThis tutorial makes use of:\n\n\n\n\nNFVO\n\n\nGeneric VNFM\n\n\nGeneric EMS\n\n\nOpenStack vim driver\n\n\n\n\nRequirements\n\n\nIn order to execute this scenario, you need to have the following components up and running:\n\n\n\n\nConfigured and running \nNFVO\n\n\nRunning \nOpenStack vim driver\n\n\nRunning \nGeneric VNFM\n\n\nConfigured and running OpenStack environment\n\n\n\n\nStore the Vim Instance\n\n\nFor registering the Point of Presence of type OpenStack to the NFVO you have to upload a Vim Instance. You can use the following \njson descriptor\n by changing the values to your needs. \n\n\nUsing the dashboard\n\n\nIf you want to use the Dashboard (checkout the \ndashboard documentation\n for more information on how to use it), open it at the URL http://ip-where-nfvo-runs:8080 (change port and protocol if you use SSL) and log in (default username and password are \nadmin\n and \nopenbaton\n).\n\nGo to \nManage PoPs -\n PoP Instances\n and choose the Vim Instance of your choice by clicking on \nRegister Vim\n and selecting the Vim Instance's json file.\n\n\n\n\nUsing the CLI\n\n\nIf you want to use the CLI (checkout the \nOpen Baton Client documentation\n for more information on how to install and use it), you need to execute the following command in order to onboard the Vim Instance where \nvim-instance.json\n is the path to the Vim Instance file:\n\n\n$./openbaton.sh VimInstance-create vim-instance.json\n\n\n\n\nStore the Network Service Descriptor\n\n\nDownload the \nSIPp NSD using private IPs\n or \nSIPp NSD using floating IPs\n, and upload it in the catalogue either using the dashboard or the CLI.\n\nThe difference is that the first NSD will deploy Virtual Machines without floating IPs on OpenStack whereas the second one will use floating IPs. \n\n\nUsing the dashboard\n\n\nIf you want to use the Dashboard go to \nCatalogue -\n NS Descriptors\n and choose the NSD of your choice by clicking on \nUpload NSD\n and selecting the Descriptor's json file.\n\n\n\n\nUsing the CLI\n\n\nIf you want to use the CLI you need to execute the following command in order to onboard the NSD:\n\n\n$./openbaton.sh NetworkServiceDescriptor-create NetworkServiceDescriptor-SIPp-FloatingIPs.json\n\n\n\n\nOnce this request is processed successfully, it returns the following:\n\n\n+------------------ +----------------------------------------------------------------- +\n| PROPERTY          | VALUE                                                            |\n+------------------ +----------------------------------------------------------------- +\n| VNFD              |                                                                  |\n|                   | id: b9e7fb33-d777-43e2-9120-8d5ab5478c3f - name:  sipp-server    |\n|                   | id: 1f35a049-b3fc-4905-b495-d0c30e8560e1 - name:  sipp-client    |\n|                   |                                                                  |\n| VNF_DEPENDENCY    |                                                                  |\n|                   | id: 46a85018-221e-4f6e-9b58-8f2b4143a4ab                         |\n|                   |                                                                  |\n| id                | a4882ae8-8f43-4646-8a36-475b6b0560b3                             |\n|                   |                                                                  |\n| hb_version        | 1                                                                |\n|                   |                                                                  |\n| name              | NSD SIPp Floating IPs                                            |\n|                   |                                                                  |\n| projectId         | 0c60579d-a2aa-486a-b2a4-dc93f9c64fa7                             |\n|                   |                                                                  |\n| vendor            | FOKUS                                                            |\n|                   |                                                                  |\n| version           | 1.0                                                              |\n|                   |                                                                  |\n| VLD               |                                                                  |\n|                   | id: d296dbb8-b966-4d01-b8ed-01e5faf88a67 - name:  private        |\n|                   |                                                                  |\n+------------------ +----------------------------------------------------------------- +\n\n\n\n\nDeploy the Network Service Descriptor\n\n\nAs soon as you onboarded the NSD in the NFVO you can deploy this NSD either by using the dashboard or the CLI.\n\nThis will create a Network Service Record (NSR) and actually launch the Virtual Machines on OpenStack. \n\n\nUsing the dashboard\n\n\nThis part shows you how to deploy an onboarded NSD via the dashboard. You need to go to the GUI again and navigate to \nCatalogue -\n NS Descriptors\n. Open the drop down menu by clicking on \nAction\n. Afterwards you need to press the \nLaunch\n button and a window with launching options will appear. Just click on \nLaunch\n again in order to start the deployment of this NSD.\n\n\n\n\nIf you go to \nOrchestrate NS -\n NS Records\n in the menu on the left side, you can follow the deployment process and check the current status of the created NSR.\n\n\nUsing the CLI\n\n\nYou can also use the CLI for deploying existing NSDs. The command needs the ID of the NSD to deploy as an argument. It can be found either by using the dashboard or getting it from the output when onboarding a new NSD as done in the previous step. The command to deploy the previously onboarded NSD looks like shown below:\n\n\n$./openbaton.sh NetworkServiceRecord-create 82ac4b14-a014-4185-b1b2-c4b0f9b1712e vimmap.json keypair.json conf.json\n\n\n\n\nThe first argument is the ID of the NSD from which the NSR will be created. The following arguments are files that can contain additional configuration while deploying. \nYou have to pass these files even if you do not want to pass any configuration like in our case. So just create the three files and fill them with empty json objects/arrays (i.e. \n{}\n and \n[]\n).\n\nThe \nvimmap.json\n and the \nconf.json\n files should contain this:\n\n\n{}\n\n\n\n\nAnd the \nkeypair.json\n file this:\n\n\n[]\n\n\n\n\nThe execution of this command produces the following output:\n\n\n+------------------------ +------------------------------------------------------------- +\n| PROPERTY                | VALUE                                                        |\n+------------------------ +------------------------------------------------------------- +\n| id                      | a648c1fa-621e-4cc3-9f27-8e950e695d17                         |\n|                         |                                                              |\n| vendor                  | FOKUS                                                        |\n|                         |                                                              |\n| projectId               | 0c60579d-a2aa-486a-b2a4-dc93f9c64fa7                         |\n|                         |                                                              |\n| task                    | Onboarding                                                   |\n|                         |                                                              |\n| version                 | 1.0                                                          |\n|                         |                                                              |\n| VLR                     |                                                              |\n|                         | id: 492af81d-42dc-43c2-af7b-a5149451edc7 - name:  private    |\n|                         |                                                              |\n| VNF_DEPENDENCY          |                                                              |\n|                         | id: 46d28db8-d80e-4c3d-b2e6-a6dfbad80e1c                     |\n|                         |                                                              |\n| descriptor_reference    | 82ac4b14-a014-4185-b1b2-c4b0f9b1712e                         |\n|                         |                                                              |\n| status                  | NULL                                                         |\n|                         |                                                              |\n| createdAt               | 2016.10.27 at 17:35:01 MESZ                                  |\n|                         |                                                              |\n| name                    | NSD SIPp Floating IPs                                        |\n|                         |                                                              |\n+------------------------ +------------------------------------------------------------- +\n\n\n\n\nIn order to follow the deployment process you can retrieve information by passing the ID of the deploying NSR to this command:\n\n\n$./openbaton.sh NetworkServiceRecord-findById a648c1fa-621e-4cc3-9f27-8e950e695d17\n\n\n+------------------------ +----------------------------------------------------------------- +\n| PROPERTY                | VALUE                                                            |\n+------------------------ +----------------------------------------------------------------- +\n| id                      | a648c1fa-621e-4cc3-9f27-8e950e695d17                             |\n|                         |                                                                  |\n| vendor                  | FOKUS                                                            |\n|                         |                                                                  |\n| projectId               | 0c60579d-a2aa-486a-b2a4-dc93f9c64fa7                             |\n|                         |                                                                  |\n| task                    | Onboarded                                                        |\n|                         |                                                                  |\n| version                 | 1.0                                                              |\n|                         |                                                                  |\n| VLR                     |                                                                  |\n|                         | id: 492af81d-42dc-43c2-af7b-a5149451edc7 - name:  private        |\n|                         |                                                                  |\n| VNFR                    |                                                                  |\n|                         | id: bda67156-49ec-40c9-a58d-e00623e8e2ef - name:  sipp-server    |\n|                         | id: ec95ff3b-9013-4f57-a782-e51f40c7cb8a - name:  sipp-client    |\n|                         |                                                                  |\n| VNF_DEPENDENCY          |                                                                  |\n|                         | id: 46d28db8-d80e-4c3d-b2e6-a6dfbad80e1c                         |\n|                         |                                                                  |\n| descriptor_reference    | 82ac4b14-a014-4185-b1b2-c4b0f9b1712e                             |\n|                         |                                                                  |\n| status                  | ACTIVE                                                           |\n|                         |                                                                  |\n| createdAt               | 2016.10.27 at 17:35:01 MESZ                                      |\n|                         |                                                                  |\n| name                    | NSD SIPp Floating IPs                                            |\n|                         |                                                                  |\n+------------------------ +----------------------------------------------------------------- +\n\n\n\n\nConclusions\n\n\nWhen all the VNF Records are done with all of the scripts defined in the lifecycle events, the NFVO will put the state of the VNF Record to ACTIVE and when all the VNF Records are in state ACTIVE, also the Network Service Record will be in state ACTIVE. This means that the service is deployed correctly. For learning more about the states of a VNF Record please refer to the \nVNF Record state documentation\n.\n\n\nConfiguration Parameters\n\n\nAdditionally, there are a bundge of parameters which can configure the SIP client to simulate several scenarios such as increasing number of calls, changing the call rates or changing the transport mode. These parameters can be changed inside the NSD directly or provided during the launch of the NSD. Below you can find the configuration parameters as put in the SIPp NSD, in particular in the SIPp client VNFD. Checkout the following overview of all available paramters and the meanings.\n\n\nconfigurations\n: {\n    \nconfigurationParameters\n: [\n        {\n            \nconfKey\n: \nSIPP_LENGTH\n,\n            \nvalue\n: \n0\n,\n            \ndescription\n: \nControls the length (in milliseconds) of calls. More precisely, this controls the duration of 'pause' instructions in the scenario, if they do not have a 'milliseconds' section. Default value is 0.\n\n        },\n        {\n            \nconfKey\n: \nSIPP_RATE\n,\n            \nvalue\n: \n10\n,\n            \ndescription\n: \nSet the call rate (in calls per seconds). Default is 10. If the -rp option is used, the call rate is calculated with the period in ms given by the user.\n\n        },\n        {\n            \nconfKey\n: \nSIPP_RATE_PERIOD\n,\n            \nvalue\n: \n1000\n,\n            \ndescription\n: \nSpecify the rate period in milliseconds for the call rate.  Default is 1 second.  This allows you to have n calls every m milliseconds (by using -r n -rp m). Example: -r 7 -rp 2000 ==\n 7 calls every 2 seconds.\n\n        },\n        {\n            \nconfKey\n: \nSIPP_RATE_MAX\n,\n            \nvalue\n: \n10\n,\n            \ndescription\n: \nIf -rate_increase is set, then quit after the rate reaches this value. Example: -rate_increase 10 -max_rate 100 ==\n increase calls by 10 until 100 cps is hit.\n\n        },\n        {\n            \nconfKey\n: \nSIPP_RATE_INCREASE\n,\n            \nvalue\n: \n0\n,\n            \ndescription\n: \nSpecify the rate increase every -fd seconds.  This allows you to increase the load for each independent logging period. Example: -rate_increase 10 -fd 10 ==\n increase calls by 10 every 10 seconds.\n\n        },\n        {\n            \nconfKey\n: \nSIPP_RTP_ECHO\n,\n            \nvalue\n: \n10\n,\n            \ndescription\n: \nEnable RTP echo. RTP/UDP packets received on port defined by -mp are echoed to their sender. RTP/UDP packets coming on this port + 2 are also echoed to their sender (used for sound and video echo).\n\n        },\n        {\n            \nconfKey\n: \nSIPP_TRANSPORT_MODE\n,\n            \nvalue\n: \nu1\n,\n            \ndescription\n: \nSet the transport mode: - u1: UDP with one socket (default), - un: UDP with one socket per call, - ui: UDP with one socket per IP address The IP addresses must be defined in the injection file. - t1: TCP with one socket, - tn: TCP with one socket per call, - l1: TLS with one socket, - ln: TLS with one socket per call, - c1: u1 + compression (only if compression plugin loaded), - cn: un + compression (only if compression plugin loaded).\n\n        }\n    ],\n    \nname\n: \nsipp-configuration\n\n}\n\n\n\n\nDependencies between VNFs\n\n\nWhen you access your OpenStack dashboard you should be able to see the deployed Virtual Machines. One of them will act as a SIPp server and the other one as a SIPp client that connects to the server. \n\n\nIn this scenario the SIPp server is the source of a dependency and the client is the target. This mean the client needs the IP of the server in order to connect.\nLet's have a look at the NSD we used to deploy this scenario in order to see how the dependencies are described.\n\nYou will see that the NSD contains a field called \nvnf_dependency\n. \n\n\nvnf_dependency\n:[\n    {\n      \nsource\n:{\n        \nname\n:\nsipp-server\n\n      },\n      \ntarget\n:{\n        \nname\n:\nsipp-client\n\n      },\n      \nparameters\n:[\n        \nprivate\n\n      ]\n    }\n  ]\n\n\n\n\nThe json array \nvnf_dependency\n may contain multiple dependencies. In our case it is just one, which describes that the VNFD named \nsipp-client\n needs a parameter called \nprivate\n from the VNFD \nsipp-server\n. This parameter can be used by the sipp-client as a variable in its lifecycle scripts. \n\n\nAlso the lifecycle scripts are specified in the NSD. For example the VNFD \nsipp-client\n has the following lifecycle events: \n\n\nlifecycle_event\n:[\n                {\n                    \nevent\n:\nCONFIGURE\n,\n                    \nlifecycle_events\n:[\n                        \nserver_sipp_start.sh\n\n                    ]\n                },\n                {\n                    \nevent\n:\nINSTANTIATE\n,\n                    \nlifecycle_events\n:[\n                        \nsipp_install.sh\n\n                    ]\n                }\n            ]\n\n\n\n\nYou can see that there is one lifecycle event called \nINSTANTIATE\n and one called \nCONFIGURE\n. Actually there exist also other lifecycle events, read about them \nhere\n.\n\nEach one will be executed at a different point in time. By execution we mean that the scripts that are listed in the \nlifecycle_events\n field will run with root permissions on the Virtual Machine.\n\nThe scripts are located in a public git repository. The url is specified in the \nvnfPackageLocation\n field in the VNFDs.\n\nIn our example the \nINSTANTIATE\n event will run first after the Virtual Machine was initialized. It will run the \nsipp_install.sh\n script which installs SIP and screen on the Virtual Machine.\n\nThe \nCONFIGURE\n lifecycle event starts after the \nINSTANTIATE\n lifecycle event. The \nCONFIGURE\n lifecycle event has a special role. In the lifecycle scripts of this event the dependency parameters are available.\n\nThat is why we use this event to tell SIP to connect to the server ip. In the example NSD that uses floating IPs the dependency parameter is called \nprivate\n. \nIn the \nCONFIGURE\n lifecycle script we will therefore run \n\n\nscreen -d -m -S client sipp -sn uac $server_private -d $SIPP_LENGTH -r $SIPP_RATE -rp $SIPP_RATE_PERIOD -rate_increase $SIPP_RATE_INCREASE -fd $SIPP_RATE_INCREASE -rate_max $SIPP_RATE_MAX -rtp_echo -t $SIPP_TRANSPORT_MODE -trace_msg -trace_screen -trace_err -trace_rtt -trace_logs -trace_rtt -trace_logs\n\n\n\n\nYou wonder why the variable in the script has another name than the dependency parameter? Well, you have to prepend the type of the source VNFD and an underscore to the variable. This is why \nprivate\n becomes \nserver_private\n.\n\nAnd there is another restriction. In order to use the dependency parameter in the \nCONFIGURE\n script its name has to start with the source VNFD type followed by an underscore.\n\nIf you want to learn more about dependencies, lifecycle events and variables read \nthis\n section. \n\n\nThe process in details\n\n\nLet's again have a look at the sequence diagram of a create Network Service Record operation.\n\n\n\n\nWhen the Network Service Record create is called with the SIP Network Service Descriptor's id, the steps defined in the sequence diagram above happen.\n\n\nINSTANTIATE Method\n\n\nThe first message sent to the Generic VNFM is the INSTANTIATE message \n(1)\n. This message contains the VNF Descriptor and some other parameters needed to create the VNF Record, for instance the list of Virtual Link Records. The Generic VNFM  is called and then the create Virtual Network Function Record and the Virtual Network Function Record is created \n(2)\n and sent back to the NFVO into a GrantOperation message \n(3)\n. This message will trigger the NFVO to check if there are enough resources to create that VNF Record. If so, then a GrantOperation message with the updated VNF Record is sent back to the Generic VNFManager. Then the Generic VNFManager creates an AllocateResources message with the received VNF Record and sends it to the NFVO \n(4)\n. After creating the resources (VMs) the NFVO sends back the AllocateResources message to the VNFManager. Here the instantiate method is called \n(5)\n. Inside this method, the scripts contained in the VNF Package (or the git repository containing the scripts) is sent to the EMS, the scripts are saved locally to the VM and then the Generic VNFManager will call the execution of each script defined in the VNF Descriptor \n(6)\n. Once all of the scripts are executed and there wasn't any error, the VNFManager sends the Instantiate message back to the NFVO \n(7)\n. \n\n\nMODIFY Method\n\n\nIf the VNF is target for some dependencies, like the SIP client, the MODIFY message is sent to the VNFManager by the NFVO \n(8)\n. Then the VNFManager executes the scripts contained in the CONFIGURE lifecycle event defined in the VNF Descriptor \n(9)\n, and sends back the modify message to the NFVO \n(10)\n, if no errors occurred. In this case, the scripts environment will contain the variables defined in the related VNF dependency.\n\n\nSTART Method\n\n\nHere exactly as before, the NFVO sends the START message to the Generic VNFManager \n(11)\n, and the VNFManager calls the EMS for execution of the scripts defined in the START lifecycle (none for this example) \n(12)\n. And the start message is then sent back to the NFVO meaning that no errors occurred \n(13)\n.\n\n\n\n\n\n\n\n\n\n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "SIPp example"
        }, 
        {
            "location": "/tutorial-sipp/#tutorial-sipp-network-service", 
            "text": "This tutorial explains how to deploy a network service that uses SIPp.  SIPp  is a free Open Source test tool / traffic generator for the SIP protocol which follows a client/server approach. In the following you will see how to create the NSD which defines the allocations of virtual resources, the installation and configuration of the the SIPp server and client. Furthermore, you can see how to create dependencies.  This tutorial makes use of:   NFVO  Generic VNFM  Generic EMS  OpenStack vim driver", 
            "title": "Tutorial: SIPp Network Service"
        }, 
        {
            "location": "/tutorial-sipp/#requirements", 
            "text": "In order to execute this scenario, you need to have the following components up and running:   Configured and running  NFVO  Running  OpenStack vim driver  Running  Generic VNFM  Configured and running OpenStack environment", 
            "title": "Requirements"
        }, 
        {
            "location": "/tutorial-sipp/#store-the-vim-instance", 
            "text": "For registering the Point of Presence of type OpenStack to the NFVO you have to upload a Vim Instance. You can use the following  json descriptor  by changing the values to your needs.", 
            "title": "Store the Vim Instance"
        }, 
        {
            "location": "/tutorial-sipp/#using-the-dashboard", 
            "text": "If you want to use the Dashboard (checkout the  dashboard documentation  for more information on how to use it), open it at the URL http://ip-where-nfvo-runs:8080 (change port and protocol if you use SSL) and log in (default username and password are  admin  and  openbaton ). \nGo to  Manage PoPs -  PoP Instances  and choose the Vim Instance of your choice by clicking on  Register Vim  and selecting the Vim Instance's json file.", 
            "title": "Using the dashboard"
        }, 
        {
            "location": "/tutorial-sipp/#using-the-cli", 
            "text": "If you want to use the CLI (checkout the  Open Baton Client documentation  for more information on how to install and use it), you need to execute the following command in order to onboard the Vim Instance where  vim-instance.json  is the path to the Vim Instance file:  $./openbaton.sh VimInstance-create vim-instance.json", 
            "title": "Using the CLI"
        }, 
        {
            "location": "/tutorial-sipp/#store-the-network-service-descriptor", 
            "text": "Download the  SIPp NSD using private IPs  or  SIPp NSD using floating IPs , and upload it in the catalogue either using the dashboard or the CLI. \nThe difference is that the first NSD will deploy Virtual Machines without floating IPs on OpenStack whereas the second one will use floating IPs.", 
            "title": "Store the Network Service Descriptor"
        }, 
        {
            "location": "/tutorial-sipp/#using-the-dashboard_1", 
            "text": "If you want to use the Dashboard go to  Catalogue -  NS Descriptors  and choose the NSD of your choice by clicking on  Upload NSD  and selecting the Descriptor's json file.", 
            "title": "Using the dashboard"
        }, 
        {
            "location": "/tutorial-sipp/#using-the-cli_1", 
            "text": "If you want to use the CLI you need to execute the following command in order to onboard the NSD:  $./openbaton.sh NetworkServiceDescriptor-create NetworkServiceDescriptor-SIPp-FloatingIPs.json  Once this request is processed successfully, it returns the following:  +------------------ +----------------------------------------------------------------- +\n| PROPERTY          | VALUE                                                            |\n+------------------ +----------------------------------------------------------------- +\n| VNFD              |                                                                  |\n|                   | id: b9e7fb33-d777-43e2-9120-8d5ab5478c3f - name:  sipp-server    |\n|                   | id: 1f35a049-b3fc-4905-b495-d0c30e8560e1 - name:  sipp-client    |\n|                   |                                                                  |\n| VNF_DEPENDENCY    |                                                                  |\n|                   | id: 46a85018-221e-4f6e-9b58-8f2b4143a4ab                         |\n|                   |                                                                  |\n| id                | a4882ae8-8f43-4646-8a36-475b6b0560b3                             |\n|                   |                                                                  |\n| hb_version        | 1                                                                |\n|                   |                                                                  |\n| name              | NSD SIPp Floating IPs                                            |\n|                   |                                                                  |\n| projectId         | 0c60579d-a2aa-486a-b2a4-dc93f9c64fa7                             |\n|                   |                                                                  |\n| vendor            | FOKUS                                                            |\n|                   |                                                                  |\n| version           | 1.0                                                              |\n|                   |                                                                  |\n| VLD               |                                                                  |\n|                   | id: d296dbb8-b966-4d01-b8ed-01e5faf88a67 - name:  private        |\n|                   |                                                                  |\n+------------------ +----------------------------------------------------------------- +", 
            "title": "Using the CLI"
        }, 
        {
            "location": "/tutorial-sipp/#deploy-the-network-service-descriptor", 
            "text": "As soon as you onboarded the NSD in the NFVO you can deploy this NSD either by using the dashboard or the CLI. \nThis will create a Network Service Record (NSR) and actually launch the Virtual Machines on OpenStack.", 
            "title": "Deploy the Network Service Descriptor"
        }, 
        {
            "location": "/tutorial-sipp/#using-the-dashboard_2", 
            "text": "This part shows you how to deploy an onboarded NSD via the dashboard. You need to go to the GUI again and navigate to  Catalogue -  NS Descriptors . Open the drop down menu by clicking on  Action . Afterwards you need to press the  Launch  button and a window with launching options will appear. Just click on  Launch  again in order to start the deployment of this NSD.   If you go to  Orchestrate NS -  NS Records  in the menu on the left side, you can follow the deployment process and check the current status of the created NSR.", 
            "title": "Using the dashboard"
        }, 
        {
            "location": "/tutorial-sipp/#using-the-cli_2", 
            "text": "You can also use the CLI for deploying existing NSDs. The command needs the ID of the NSD to deploy as an argument. It can be found either by using the dashboard or getting it from the output when onboarding a new NSD as done in the previous step. The command to deploy the previously onboarded NSD looks like shown below:  $./openbaton.sh NetworkServiceRecord-create 82ac4b14-a014-4185-b1b2-c4b0f9b1712e vimmap.json keypair.json conf.json  The first argument is the ID of the NSD from which the NSR will be created. The following arguments are files that can contain additional configuration while deploying. \nYou have to pass these files even if you do not want to pass any configuration like in our case. So just create the three files and fill them with empty json objects/arrays (i.e.  {}  and  [] ). \nThe  vimmap.json  and the  conf.json  files should contain this:  {}  And the  keypair.json  file this:  []  The execution of this command produces the following output:  +------------------------ +------------------------------------------------------------- +\n| PROPERTY                | VALUE                                                        |\n+------------------------ +------------------------------------------------------------- +\n| id                      | a648c1fa-621e-4cc3-9f27-8e950e695d17                         |\n|                         |                                                              |\n| vendor                  | FOKUS                                                        |\n|                         |                                                              |\n| projectId               | 0c60579d-a2aa-486a-b2a4-dc93f9c64fa7                         |\n|                         |                                                              |\n| task                    | Onboarding                                                   |\n|                         |                                                              |\n| version                 | 1.0                                                          |\n|                         |                                                              |\n| VLR                     |                                                              |\n|                         | id: 492af81d-42dc-43c2-af7b-a5149451edc7 - name:  private    |\n|                         |                                                              |\n| VNF_DEPENDENCY          |                                                              |\n|                         | id: 46d28db8-d80e-4c3d-b2e6-a6dfbad80e1c                     |\n|                         |                                                              |\n| descriptor_reference    | 82ac4b14-a014-4185-b1b2-c4b0f9b1712e                         |\n|                         |                                                              |\n| status                  | NULL                                                         |\n|                         |                                                              |\n| createdAt               | 2016.10.27 at 17:35:01 MESZ                                  |\n|                         |                                                              |\n| name                    | NSD SIPp Floating IPs                                        |\n|                         |                                                              |\n+------------------------ +------------------------------------------------------------- +  In order to follow the deployment process you can retrieve information by passing the ID of the deploying NSR to this command:  $./openbaton.sh NetworkServiceRecord-findById a648c1fa-621e-4cc3-9f27-8e950e695d17\n\n\n+------------------------ +----------------------------------------------------------------- +\n| PROPERTY                | VALUE                                                            |\n+------------------------ +----------------------------------------------------------------- +\n| id                      | a648c1fa-621e-4cc3-9f27-8e950e695d17                             |\n|                         |                                                                  |\n| vendor                  | FOKUS                                                            |\n|                         |                                                                  |\n| projectId               | 0c60579d-a2aa-486a-b2a4-dc93f9c64fa7                             |\n|                         |                                                                  |\n| task                    | Onboarded                                                        |\n|                         |                                                                  |\n| version                 | 1.0                                                              |\n|                         |                                                                  |\n| VLR                     |                                                                  |\n|                         | id: 492af81d-42dc-43c2-af7b-a5149451edc7 - name:  private        |\n|                         |                                                                  |\n| VNFR                    |                                                                  |\n|                         | id: bda67156-49ec-40c9-a58d-e00623e8e2ef - name:  sipp-server    |\n|                         | id: ec95ff3b-9013-4f57-a782-e51f40c7cb8a - name:  sipp-client    |\n|                         |                                                                  |\n| VNF_DEPENDENCY          |                                                                  |\n|                         | id: 46d28db8-d80e-4c3d-b2e6-a6dfbad80e1c                         |\n|                         |                                                                  |\n| descriptor_reference    | 82ac4b14-a014-4185-b1b2-c4b0f9b1712e                             |\n|                         |                                                                  |\n| status                  | ACTIVE                                                           |\n|                         |                                                                  |\n| createdAt               | 2016.10.27 at 17:35:01 MESZ                                      |\n|                         |                                                                  |\n| name                    | NSD SIPp Floating IPs                                            |\n|                         |                                                                  |\n+------------------------ +----------------------------------------------------------------- +", 
            "title": "Using the CLI"
        }, 
        {
            "location": "/tutorial-sipp/#conclusions", 
            "text": "When all the VNF Records are done with all of the scripts defined in the lifecycle events, the NFVO will put the state of the VNF Record to ACTIVE and when all the VNF Records are in state ACTIVE, also the Network Service Record will be in state ACTIVE. This means that the service is deployed correctly. For learning more about the states of a VNF Record please refer to the  VNF Record state documentation .", 
            "title": "Conclusions"
        }, 
        {
            "location": "/tutorial-sipp/#configuration-parameters", 
            "text": "Additionally, there are a bundge of parameters which can configure the SIP client to simulate several scenarios such as increasing number of calls, changing the call rates or changing the transport mode. These parameters can be changed inside the NSD directly or provided during the launch of the NSD. Below you can find the configuration parameters as put in the SIPp NSD, in particular in the SIPp client VNFD. Checkout the following overview of all available paramters and the meanings.  configurations : {\n     configurationParameters : [\n        {\n             confKey :  SIPP_LENGTH ,\n             value :  0 ,\n             description :  Controls the length (in milliseconds) of calls. More precisely, this controls the duration of 'pause' instructions in the scenario, if they do not have a 'milliseconds' section. Default value is 0. \n        },\n        {\n             confKey :  SIPP_RATE ,\n             value :  10 ,\n             description :  Set the call rate (in calls per seconds). Default is 10. If the -rp option is used, the call rate is calculated with the period in ms given by the user. \n        },\n        {\n             confKey :  SIPP_RATE_PERIOD ,\n             value :  1000 ,\n             description :  Specify the rate period in milliseconds for the call rate.  Default is 1 second.  This allows you to have n calls every m milliseconds (by using -r n -rp m). Example: -r 7 -rp 2000 ==  7 calls every 2 seconds. \n        },\n        {\n             confKey :  SIPP_RATE_MAX ,\n             value :  10 ,\n             description :  If -rate_increase is set, then quit after the rate reaches this value. Example: -rate_increase 10 -max_rate 100 ==  increase calls by 10 until 100 cps is hit. \n        },\n        {\n             confKey :  SIPP_RATE_INCREASE ,\n             value :  0 ,\n             description :  Specify the rate increase every -fd seconds.  This allows you to increase the load for each independent logging period. Example: -rate_increase 10 -fd 10 ==  increase calls by 10 every 10 seconds. \n        },\n        {\n             confKey :  SIPP_RTP_ECHO ,\n             value :  10 ,\n             description :  Enable RTP echo. RTP/UDP packets received on port defined by -mp are echoed to their sender. RTP/UDP packets coming on this port + 2 are also echoed to their sender (used for sound and video echo). \n        },\n        {\n             confKey :  SIPP_TRANSPORT_MODE ,\n             value :  u1 ,\n             description :  Set the transport mode: - u1: UDP with one socket (default), - un: UDP with one socket per call, - ui: UDP with one socket per IP address The IP addresses must be defined in the injection file. - t1: TCP with one socket, - tn: TCP with one socket per call, - l1: TLS with one socket, - ln: TLS with one socket per call, - c1: u1 + compression (only if compression plugin loaded), - cn: un + compression (only if compression plugin loaded). \n        }\n    ],\n     name :  sipp-configuration \n}", 
            "title": "Configuration Parameters"
        }, 
        {
            "location": "/tutorial-sipp/#dependencies-between-vnfs", 
            "text": "When you access your OpenStack dashboard you should be able to see the deployed Virtual Machines. One of them will act as a SIPp server and the other one as a SIPp client that connects to the server.   In this scenario the SIPp server is the source of a dependency and the client is the target. This mean the client needs the IP of the server in order to connect.\nLet's have a look at the NSD we used to deploy this scenario in order to see how the dependencies are described. \nYou will see that the NSD contains a field called  vnf_dependency .   vnf_dependency :[\n    {\n       source :{\n         name : sipp-server \n      },\n       target :{\n         name : sipp-client \n      },\n       parameters :[\n         private \n      ]\n    }\n  ]  The json array  vnf_dependency  may contain multiple dependencies. In our case it is just one, which describes that the VNFD named  sipp-client  needs a parameter called  private  from the VNFD  sipp-server . This parameter can be used by the sipp-client as a variable in its lifecycle scripts.   Also the lifecycle scripts are specified in the NSD. For example the VNFD  sipp-client  has the following lifecycle events:   lifecycle_event :[\n                {\n                     event : CONFIGURE ,\n                     lifecycle_events :[\n                         server_sipp_start.sh \n                    ]\n                },\n                {\n                     event : INSTANTIATE ,\n                     lifecycle_events :[\n                         sipp_install.sh \n                    ]\n                }\n            ]  You can see that there is one lifecycle event called  INSTANTIATE  and one called  CONFIGURE . Actually there exist also other lifecycle events, read about them  here . \nEach one will be executed at a different point in time. By execution we mean that the scripts that are listed in the  lifecycle_events  field will run with root permissions on the Virtual Machine. \nThe scripts are located in a public git repository. The url is specified in the  vnfPackageLocation  field in the VNFDs. \nIn our example the  INSTANTIATE  event will run first after the Virtual Machine was initialized. It will run the  sipp_install.sh  script which installs SIP and screen on the Virtual Machine. \nThe  CONFIGURE  lifecycle event starts after the  INSTANTIATE  lifecycle event. The  CONFIGURE  lifecycle event has a special role. In the lifecycle scripts of this event the dependency parameters are available. \nThat is why we use this event to tell SIP to connect to the server ip. In the example NSD that uses floating IPs the dependency parameter is called  private . \nIn the  CONFIGURE  lifecycle script we will therefore run   screen -d -m -S client sipp -sn uac $server_private -d $SIPP_LENGTH -r $SIPP_RATE -rp $SIPP_RATE_PERIOD -rate_increase $SIPP_RATE_INCREASE -fd $SIPP_RATE_INCREASE -rate_max $SIPP_RATE_MAX -rtp_echo -t $SIPP_TRANSPORT_MODE -trace_msg -trace_screen -trace_err -trace_rtt -trace_logs -trace_rtt -trace_logs  You wonder why the variable in the script has another name than the dependency parameter? Well, you have to prepend the type of the source VNFD and an underscore to the variable. This is why  private  becomes  server_private . \nAnd there is another restriction. In order to use the dependency parameter in the  CONFIGURE  script its name has to start with the source VNFD type followed by an underscore. \nIf you want to learn more about dependencies, lifecycle events and variables read  this  section.", 
            "title": "Dependencies between VNFs"
        }, 
        {
            "location": "/tutorial-sipp/#the-process-in-details", 
            "text": "Let's again have a look at the sequence diagram of a create Network Service Record operation.   When the Network Service Record create is called with the SIP Network Service Descriptor's id, the steps defined in the sequence diagram above happen.", 
            "title": "The process in details"
        }, 
        {
            "location": "/tutorial-sipp/#instantiate-method", 
            "text": "The first message sent to the Generic VNFM is the INSTANTIATE message  (1) . This message contains the VNF Descriptor and some other parameters needed to create the VNF Record, for instance the list of Virtual Link Records. The Generic VNFM  is called and then the create Virtual Network Function Record and the Virtual Network Function Record is created  (2)  and sent back to the NFVO into a GrantOperation message  (3) . This message will trigger the NFVO to check if there are enough resources to create that VNF Record. If so, then a GrantOperation message with the updated VNF Record is sent back to the Generic VNFManager. Then the Generic VNFManager creates an AllocateResources message with the received VNF Record and sends it to the NFVO  (4) . After creating the resources (VMs) the NFVO sends back the AllocateResources message to the VNFManager. Here the instantiate method is called  (5) . Inside this method, the scripts contained in the VNF Package (or the git repository containing the scripts) is sent to the EMS, the scripts are saved locally to the VM and then the Generic VNFManager will call the execution of each script defined in the VNF Descriptor  (6) . Once all of the scripts are executed and there wasn't any error, the VNFManager sends the Instantiate message back to the NFVO  (7) .", 
            "title": "INSTANTIATE Method"
        }, 
        {
            "location": "/tutorial-sipp/#modify-method", 
            "text": "If the VNF is target for some dependencies, like the SIP client, the MODIFY message is sent to the VNFManager by the NFVO  (8) . Then the VNFManager executes the scripts contained in the CONFIGURE lifecycle event defined in the VNF Descriptor  (9) , and sends back the modify message to the NFVO  (10) , if no errors occurred. In this case, the scripts environment will contain the variables defined in the related VNF dependency.", 
            "title": "MODIFY Method"
        }, 
        {
            "location": "/tutorial-sipp/#start-method", 
            "text": "Here exactly as before, the NFVO sends the START message to the Generic VNFManager  (11) , and the VNFManager calls the EMS for execution of the scripts defined in the START lifecycle (none for this example)  (12) . And the start message is then sent back to the NFVO meaning that no errors occurred  (13) .    \n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "START Method"
        }, 
        {
            "location": "/ims-NSR/", 
            "text": "Tutorial: OpenIMSCore Network Service Record\n\n\n\n\nThis tutorial shows how to deploy a Network Service Record composed by 5 VNFs, a basic \nOpenIMSCore\n.\nYou can execute also the same tutorial using the \nTOSCA\n definitions. \n\n\nCompared to the \nIperf-Server - Iperf-Client\n the example provided here is far more complex. So we assume you are fimiliar with the architecture.\n\n\nRequirements\n\n\nIn order to execute this scenario, you need to have the following components up and running: \n\n\n\n\nNFVO\n\n\nGeneric VNFM\n\n\nOpenstack-Plugin\n\n\n\n\nStore the VimInstance\n\n\nUpload a VimInstance to the NFVO (e.g. this \nVimInstance\n). \n\n\nPrepare the VNF Packages\n\n\nDownload the necessary files from the \ngithub repository\n and pack the \nVNF Packages\n for all 5 components ( scscf, icscf, pcscf, bind9, fhoss ).\n\n\nExample for creating the Icscf Virtual Network Function Package\n\n\n# Where to save the scripts\nGIT_REPO_LOC=/opt/vnf_packages_example_openimscore_openbaton\n# Clone the repository\ngit clone https://github.com/openbaton/opemimscore_example $GIT_REPO_LOC\n# Create the .tar file which needs to be uploaded\ncd $GIT_REPO_LOC/icscf\ntar -cf icscf.tar *\n\n\n\n\nFor this example we assume the network used to interconnect the components is called \"mgmt\", if you want to modify this example ensure you are naming the network accordingly, the scripts from the github do not handle different network names yet. Also the vimInstanceName may be different to you, depending on your setup. The deployment_flavor is optional but should containg enough RAM for the default configuration of the components to be able to run, else some components may crash on start. This example setup has been successfuly tested on clean \nUbuntu14.04 images\n with 2048 Mb RAM deployed on an \nOpenstack Kilo (2015.1.3)\n. Ensure that the image name defined in the Metadata.yaml of each package is existing.\n\n\nFinally onboard the packages.\n\n\nStore the Network Service Descriptor\n\n\nDownload the following \nNSD\n and upload it to the NFVO either using the dashboard or the cli. \nTake care to replace the vnfd ids with the ones you deployed.\n\n\nOpen the Dashboard (checkout the \ndashboard documentation\n) for more information on how to use it), open it at the URL http://your-ip-here:8080 and log in (default username and password are \nadmin\n and \nopenbaton\n). Go to \nCatalogue -\n NS Descriptors\n and choose the NSD of your choice by clicking on \nUpload NSD\n and selecting the Descriptor's json file.\n\n\nDeploy the Network Service Descriptor\n\n\nDeploy the stored NSD either using the dashboard.\n\n\nYou need to go again to the GUI, go to \nCatalogue -\n NS Descriptors\n, and open the drop down menu by clicking on \nAction\n. Afterwards you need to press the \nLaunch\n button in order to start the deployment of this NSD.\n\n\nIf you go to \nOrchestrate NS -\n NS Records\n in the menu on the left side, you can follow the deployment process and check the current status of the deploying NSD.\n\n\nConclusions\n\n\nOnce the Network Service Record went to \"ACTIVE\" your \nOpenIMSCore\n - \nBind9\n - \nFHoSS\n deployment is finished.\n\n\n\n\nTo test your \nOpenIMSCore\n you may use a Sip client of your choice. Be sure to use the realm defined in your \nBind9 Virtual Network Function Descriptor\n while testing registration and call. By default the \nFHoSS\n conaints 2 users : alice and bob. The user is the same as the password, but you may also alter it to your needs modifying the \nFHoSS Virtual Network Function Descriptor\n ( You will find the users in \"var_user_data.sql\" file under the fhoss folder)\n\n\nFor Benchmarking we can use \nIMS Bench SIPp\n but then you should add more users to the \nFHoSS\n database since by default it only contains 2 users.\n\n\n\n\n\n\n\n\n\n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "OpenIMSCore example"
        }, 
        {
            "location": "/ims-NSR/#tutorial-openimscore-network-service-record", 
            "text": "This tutorial shows how to deploy a Network Service Record composed by 5 VNFs, a basic  OpenIMSCore .\nYou can execute also the same tutorial using the  TOSCA  definitions.   Compared to the  Iperf-Server - Iperf-Client  the example provided here is far more complex. So we assume you are fimiliar with the architecture.", 
            "title": "Tutorial: OpenIMSCore Network Service Record"
        }, 
        {
            "location": "/ims-NSR/#requirements", 
            "text": "In order to execute this scenario, you need to have the following components up and running:    NFVO  Generic VNFM  Openstack-Plugin", 
            "title": "Requirements"
        }, 
        {
            "location": "/ims-NSR/#store-the-viminstance", 
            "text": "Upload a VimInstance to the NFVO (e.g. this  VimInstance ).", 
            "title": "Store the VimInstance"
        }, 
        {
            "location": "/ims-NSR/#prepare-the-vnf-packages", 
            "text": "Download the necessary files from the  github repository  and pack the  VNF Packages  for all 5 components ( scscf, icscf, pcscf, bind9, fhoss ).", 
            "title": "Prepare the VNF Packages"
        }, 
        {
            "location": "/ims-NSR/#example-for-creating-the-icscf-virtual-network-function-package", 
            "text": "# Where to save the scripts\nGIT_REPO_LOC=/opt/vnf_packages_example_openimscore_openbaton\n# Clone the repository\ngit clone https://github.com/openbaton/opemimscore_example $GIT_REPO_LOC\n# Create the .tar file which needs to be uploaded\ncd $GIT_REPO_LOC/icscf\ntar -cf icscf.tar *  For this example we assume the network used to interconnect the components is called \"mgmt\", if you want to modify this example ensure you are naming the network accordingly, the scripts from the github do not handle different network names yet. Also the vimInstanceName may be different to you, depending on your setup. The deployment_flavor is optional but should containg enough RAM for the default configuration of the components to be able to run, else some components may crash on start. This example setup has been successfuly tested on clean  Ubuntu14.04 images  with 2048 Mb RAM deployed on an  Openstack Kilo (2015.1.3) . Ensure that the image name defined in the Metadata.yaml of each package is existing.  Finally onboard the packages.", 
            "title": "Example for creating the Icscf Virtual Network Function Package"
        }, 
        {
            "location": "/ims-NSR/#store-the-network-service-descriptor", 
            "text": "Download the following  NSD  and upload it to the NFVO either using the dashboard or the cli. \nTake care to replace the vnfd ids with the ones you deployed.  Open the Dashboard (checkout the  dashboard documentation ) for more information on how to use it), open it at the URL http://your-ip-here:8080 and log in (default username and password are  admin  and  openbaton ). Go to  Catalogue -  NS Descriptors  and choose the NSD of your choice by clicking on  Upload NSD  and selecting the Descriptor's json file.", 
            "title": "Store the Network Service Descriptor"
        }, 
        {
            "location": "/ims-NSR/#deploy-the-network-service-descriptor", 
            "text": "Deploy the stored NSD either using the dashboard.  You need to go again to the GUI, go to  Catalogue -  NS Descriptors , and open the drop down menu by clicking on  Action . Afterwards you need to press the  Launch  button in order to start the deployment of this NSD.  If you go to  Orchestrate NS -  NS Records  in the menu on the left side, you can follow the deployment process and check the current status of the deploying NSD.", 
            "title": "Deploy the Network Service Descriptor"
        }, 
        {
            "location": "/ims-NSR/#conclusions", 
            "text": "Once the Network Service Record went to \"ACTIVE\" your  OpenIMSCore  -  Bind9  -  FHoSS  deployment is finished.   To test your  OpenIMSCore  you may use a Sip client of your choice. Be sure to use the realm defined in your  Bind9 Virtual Network Function Descriptor  while testing registration and call. By default the  FHoSS  conaints 2 users : alice and bob. The user is the same as the password, but you may also alter it to your needs modifying the  FHoSS Virtual Network Function Descriptor  ( You will find the users in \"var_user_data.sql\" file under the fhoss folder)  For Benchmarking we can use  IMS Bench SIPp  but then you should add more users to the  FHoSS  database since by default it only contains 2 users.    \n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Conclusions"
        }, 
        {
            "location": "/tutorial-juju/", 
            "text": "OpenIMS Tutorial with Juju-VNFM and Openstack\n\n\nThis Tutorial will demonstrate how to deploy the OpenIMSCore implementation on Openstack using Open Baton and the Juju-VNFM. \n\n\nRequirements\n\n\n\n\nNFVO (\n 3.0.0) \n\n\nJuju and Juju VNFM installed and configured following the \ninstallation-guide\n  \n\n\nAn OpenStack instance configured and available as PoP\n\n\nOpenIMSCore packages\n\n\n\n\nConfigure Juju to work with OpenStack\n\n\nCreate a document called \nmystack.yaml\n. \nHere you will provide the necessary information for Juju to connect to Openstack. \nThe content of the file could look something like this:\n\n\n  clouds:\n    mystack:\n      type: openstack\n      auth-types: [userpass]\n      use-floating-ip: true\n      use-default-secgroup: true\n      regions:\n        RegionOne:\n          endpoint: http://auth-url:5000/v2.0\n\n\n\n\nValues for \nauth-type\n, \nregion\n or \nendpoint\n may vary according to your Openstack setup, but \nuse-floating-ip\n and \nuse-default-secgroup\n \nhave to be set to true. \n\n\nNow we will add the cloud to Juju with the following command: \n\n\njuju add-cloud mystack {pathToMystackFile}/mystack.yaml\n\n\n\n\nThe next step is to set credentials for the mystack cloud configuration. Execute the following command and enter the required values. \n\n\njuju add-credential mystack\n\n\n\n\nConfigure OpenStack to work with Juju\n\n\nThen we also have to configure OpenStack to provide an image usable by Juju. \nFor this please refer to \nthis\n guide. \n\n\nBootstrap the environment\n\n\nFinally we can bootstrap the OpenStack environment using this command:\n\n\njuju bootstrap obcontroller mystack --config image-metadata-url=$METADATA_URL --config network=$NETWORK_ID --config use-floating-ip=true --config use-default-secgroup=true --bootstrap-series=$SERIES\n\n\n\n\nwhere the $METADATA_URL has to be replaced by the endpoint you created in the previously mentioned guide to configure Openstack. \nIf you followed it you should be able to obtain the url by executing \n\n\nopenstack endpoint show product-streams\n\n\n\n\nand copying the printed public url. \nIt will look something like this: \nhttp:/\\/openstack-url:8080/v1/AUTH_e4f353a5d2184b1fa3f359aaf02abbee/simplestreams/images\n\n\nThe $NETWORK_ID has to be the network's id from Openstack that shall be used. \n\n\nAnd the $SERIES should be set to an Ubuntu series according to the image you want to use. \nBy default the Juju-VNFM uses trusty while deploying. \n\n\nDeploy the OpenIMSCore\n\n\nNow that the setup is ready we can start looking at the actual deployment of the OpenIMSCore. \n\n\nClone the git repository containing the packages from \nhere\n. \nBut before we create tar archives for uploading to the NFVO we have to configure them to work with the Juju-VNFM. \nIn every component's directory (bind9, fhoss, scscf, pcscf, icscf) you will find a file containing the VNFD. \nIn these VNFDs you have to change the \nendpoint\n value from generic to juju. \nFurthermore you (currently) have to edit a file in the script folders of icscf, pccs and scscf. \nThat are the files \nicscf.conf\n, \nscscf.conf\n and \npcscf.conf\n. \nIn those scripts please comment the lines starting from \npre-start script\n until the next \nend script\n. \n\n\nLike this for example: \n\n\n# pre-start script\n#   exec /opt/OpenIMSCore/bin/icscf.kill.sh\n#   exit 0\n# end script\n\n\n\n\nAfterwards you can create the packages for each IMS component. \nFor icscf for example change into the icscf directory and execute \n\n\ntar -cf icscf.tar *\n\n\n\n\nStart the NFVO and the Juju-VNFM and upload a VimInstance named \nvim-instance\n with type \ntest\n to the NFVO. \nThen upload the VNFPackages to the NFVO using the Gui or Cli. \nThis will also create VNFDs in the NFVO. Download this \nNSD\n and replace the VNFD ids with the ones of the stored VNFDs. \nUpload the NSD to the NFVO and launch it. This will create an NSR and deploy the OpenIMSCore on OpenStack. \nSince the correct reporting of the deployment's status from the Juju-VNFM to the NFVO is still a future task \nyou should not rely on the NSR status shown by the Gui, but check using the \njuju status\n command.", 
            "title": "OpenIMSCore with Juju VNFM"
        }, 
        {
            "location": "/tutorial-juju/#openims-tutorial-with-juju-vnfm-and-openstack", 
            "text": "This Tutorial will demonstrate how to deploy the OpenIMSCore implementation on Openstack using Open Baton and the Juju-VNFM.", 
            "title": "OpenIMS Tutorial with Juju-VNFM and Openstack"
        }, 
        {
            "location": "/tutorial-juju/#requirements", 
            "text": "NFVO (  3.0.0)   Juju and Juju VNFM installed and configured following the  installation-guide     An OpenStack instance configured and available as PoP  OpenIMSCore packages", 
            "title": "Requirements"
        }, 
        {
            "location": "/tutorial-juju/#configure-juju-to-work-with-openstack", 
            "text": "Create a document called  mystack.yaml . \nHere you will provide the necessary information for Juju to connect to Openstack. \nThe content of the file could look something like this:    clouds:\n    mystack:\n      type: openstack\n      auth-types: [userpass]\n      use-floating-ip: true\n      use-default-secgroup: true\n      regions:\n        RegionOne:\n          endpoint: http://auth-url:5000/v2.0  Values for  auth-type ,  region  or  endpoint  may vary according to your Openstack setup, but  use-floating-ip  and  use-default-secgroup  \nhave to be set to true.   Now we will add the cloud to Juju with the following command:   juju add-cloud mystack {pathToMystackFile}/mystack.yaml  The next step is to set credentials for the mystack cloud configuration. Execute the following command and enter the required values.   juju add-credential mystack", 
            "title": "Configure Juju to work with OpenStack"
        }, 
        {
            "location": "/tutorial-juju/#configure-openstack-to-work-with-juju", 
            "text": "Then we also have to configure OpenStack to provide an image usable by Juju. \nFor this please refer to  this  guide.", 
            "title": "Configure OpenStack to work with Juju"
        }, 
        {
            "location": "/tutorial-juju/#bootstrap-the-environment", 
            "text": "Finally we can bootstrap the OpenStack environment using this command:  juju bootstrap obcontroller mystack --config image-metadata-url=$METADATA_URL --config network=$NETWORK_ID --config use-floating-ip=true --config use-default-secgroup=true --bootstrap-series=$SERIES  where the $METADATA_URL has to be replaced by the endpoint you created in the previously mentioned guide to configure Openstack. \nIf you followed it you should be able to obtain the url by executing   openstack endpoint show product-streams  and copying the printed public url. \nIt will look something like this: \nhttp:/\\/openstack-url:8080/v1/AUTH_e4f353a5d2184b1fa3f359aaf02abbee/simplestreams/images  The $NETWORK_ID has to be the network's id from Openstack that shall be used.   And the $SERIES should be set to an Ubuntu series according to the image you want to use. \nBy default the Juju-VNFM uses trusty while deploying.", 
            "title": "Bootstrap the environment"
        }, 
        {
            "location": "/tutorial-juju/#deploy-the-openimscore", 
            "text": "Now that the setup is ready we can start looking at the actual deployment of the OpenIMSCore.   Clone the git repository containing the packages from  here . \nBut before we create tar archives for uploading to the NFVO we have to configure them to work with the Juju-VNFM. \nIn every component's directory (bind9, fhoss, scscf, pcscf, icscf) you will find a file containing the VNFD. \nIn these VNFDs you have to change the  endpoint  value from generic to juju. \nFurthermore you (currently) have to edit a file in the script folders of icscf, pccs and scscf. \nThat are the files  icscf.conf ,  scscf.conf  and  pcscf.conf . \nIn those scripts please comment the lines starting from  pre-start script  until the next  end script .   Like this for example:   # pre-start script\n#   exec /opt/OpenIMSCore/bin/icscf.kill.sh\n#   exit 0\n# end script  Afterwards you can create the packages for each IMS component. \nFor icscf for example change into the icscf directory and execute   tar -cf icscf.tar *  Start the NFVO and the Juju-VNFM and upload a VimInstance named  vim-instance  with type  test  to the NFVO. \nThen upload the VNFPackages to the NFVO using the Gui or Cli. \nThis will also create VNFDs in the NFVO. Download this  NSD  and replace the VNFD ids with the ones of the stored VNFDs. \nUpload the NSD to the NFVO and launch it. This will create an NSR and deploy the OpenIMSCore on OpenStack. \nSince the correct reporting of the deployment's status from the Juju-VNFM to the NFVO is still a future task \nyou should not rely on the NSR status shown by the Gui, but check using the  juju status  command.", 
            "title": "Deploy the OpenIMSCore"
        }, 
        {
            "location": "/fms-sipp-tutorial/", 
            "text": "Tutorial: Fault Management System\n\n\nThis tutorial explain how to use the Fault Management System in a simple network service. The network service is composed by a SIPp client and a SIPp server. \nThe Fault Management System will create a standby SIPp server in order to protect the active SIPp server from failures.\n\n\nRequirements\n\n\nIn order to execute this scenario, you need to have the following components up and running:\n\n\n\n\nNFVO\n\n\nOpenStack vim driver\n\n\nZabbix plugin\n + Zabbix Server (2.2 or 3.0 version)\n\n\nGeneric VNFM\n\n\nFault Management System\n\n\nOpenStack\n\n\n\n\nStart the NFVO and Generic VNFM depending on how you \ninstalled\n it.\n\nIf you used the bootstrap script for installing you do not have to care about the OpenStack vim driver as it will be installed already, as well as Zabbix Plugin. \n\n\nStore the Vim Instance\n\n\nFor registering the Point of Presence of type OpenStack to the NFVO you have to upload a Vim Instance. You can use the following \njson descriptor\n by changing the values to your needs. \n\n\nUsing the dashboard\n\n\nIf you want to use the Dashboard (checkout the \ndashboard documentation\n for more information on how to use it), open it at the URL http://ip-where-nfvo-runs:8080 (change port and protocol if you use SSL) and log in (default username and password are \nadmin\n and \nopenbaton\n).\n\nGo to \nManage PoPs -\n PoP Instances\n and choose the Vim Instance of your choice by clicking on \nRegister Vim\n and selecting the Vim Instance's json file.\n\n\n\n\nUsing the CLI\n\n\nIf you want to use the CLI (checkout the \nOpen Baton Client documentation\n for more information on how to install and use it), you need to execute the following command in order to onboard the Vim Instance where \nvim-instance.json\n is the path to the Vim Instance file:\n\n\n$./openbaton.sh VimInstance-create vim-instance.json\n\n\n\n\nStore the Network Service Descriptor\n\n\nDownload the \nsipp-fms-nsd.json\n file, make sure that all the parameters fit with your environment and then upload it in the catalogue either using the dashboard or the CLI.\n\nThe main parameters you should check before uploading the NSD are: vm_image (make sure you have and Ubuntu image in OpenStack and its name matches the one in this parameter), vimInstanceName (if you only have one vim instance you can leave it empty otherwise you must specify the vim instance name in this parameter or when you will launch the NSD) and flavour_key (make sure you have a flavour in OpenStack matching the one in this parameter).\n\n\nUsing the dashboard\n\n\nIf you want to use the Dashboard go to \nCatalogue -\n NS Descriptors\n, copy the text of NSD \"sipp-fms-nsd.json\", click \nAdd NSD -\n Upload NSD\n, paste the NSD and click \nStore NSD\n.\n\n\nUsing the CLI\n\n\nIf you want to use the CLI you need to execute the following command in order to onboard the NSD:\n\n\n$./openbaton.sh NetworkServiceDescriptor-create sipp-fms-nsd.json\n\n\n\n\nOnce this request is processed successfully, it returns the following:\n\n\n+------------------ +------------------------------------------------------------------ + \n| PROPERTY          | VALUE                                                             | \n+------------------ +------------------------------------------------------------------ + \n| VNFD              |                                                                   | \n|                   | id: 2dd6a30d-0eee-4f88-aa45-9f3a420f341b - name:  sipp-server     | \n|                   | id: 55ac1b21-fdf0-4fe3-861e-5b1f6b5079e3 - name:  sipp-client     | \n|                   |                                                                   | \n| VNF_DEPENDENCY    |                                                                   | \n|                   | id: 123b3dc1-4310-405c-8c50-17dbb1becd2d                          | \n|                   |                                                                   | \n| id                | f2086f71-4ecf-4ed8-a692-36775ebdfc68                              | \n|                   |                                                                   | \n| hb_version        | 1                                                                 | \n|                   |                                                                   | \n| name              | SIPp with fms                                            | \n|                   |                                                                   | \n| projectId         | 7bc76eb0-c48c-4328-a234-c779ab54cd2a                              | \n|                   |                                                                   | \n| vendor            | FOKUS                                                             | \n|                   |                                                                   | \n| version           | 1.0                                                               | \n|                   |                                                                   | \n| VLD               |                                                                   | \n|                   | id: bd65ee00-ce56-42f4-9d31-5cd220ee64a6 - name:  private         | \n|                   |                                                                   | \n+------------------ +------------------------------------------------------------------ + \n\n\n\n\nDeploy the Network Service Descriptor\n\n\nAs soon as you uploaded the NSD in the NFVO you can deploy this NSD either by using the dashboard or the CLI.\n\nThis will create a Network Service Record (NSR) and actually launch the Virtual Machines on OpenStack. The network service is composed by two VNFC instances (virtual machines), however the Fault Management System creates a third virtual machine, which consists in the SIPp server in standby.\n\n\nUsing the dashboard\n\n\nThis part shows you how to deploy an onboarded NSD via the dashboard. You need to go to the GUI again and navigate to \nCatalogue -\n NS Descriptors\n. Open the drop down menu by clicking on \nAction\n. Afterwards you need to press the \nLaunch\n button and a window with launching options will appear. Just click on \nLaunch\n again in order to start the deployment of this NSD.\n\n\n\n\nIf you go to \nOrchestrate NS -\n NS Records\n in the menu on the left side, you can follow the deployment process and check the current status of the created NSR.\n\nOnce the network service goes to ACTIVE there should be two SIPp server (one ACTIVE and one in STANDBY) and one SIPp client.\nRegarding the SIPp server VNF you should see the following:\n\n\n\n\nTrigger the switch to standby\n\n\nNow you can trigger the switch to standby simulating a failure.\n\nGo to Openstack dashboard and terminate the virtual machine which correspond to the ACTIVE SIPp server. As you can expect the SIPp client will loose the connection with the server.\n\nHowever after 1/2 minutes the FMS will execute the switch to standby. After this action, the standby SIPp server will be activated and the client will connect to the new one, so that the network service recovers from the failure.", 
            "title": "Fault Management System"
        }, 
        {
            "location": "/fms-sipp-tutorial/#tutorial-fault-management-system", 
            "text": "This tutorial explain how to use the Fault Management System in a simple network service. The network service is composed by a SIPp client and a SIPp server. \nThe Fault Management System will create a standby SIPp server in order to protect the active SIPp server from failures.", 
            "title": "Tutorial: Fault Management System"
        }, 
        {
            "location": "/fms-sipp-tutorial/#requirements", 
            "text": "In order to execute this scenario, you need to have the following components up and running:   NFVO  OpenStack vim driver  Zabbix plugin  + Zabbix Server (2.2 or 3.0 version)  Generic VNFM  Fault Management System  OpenStack   Start the NFVO and Generic VNFM depending on how you  installed  it. \nIf you used the bootstrap script for installing you do not have to care about the OpenStack vim driver as it will be installed already, as well as Zabbix Plugin.", 
            "title": "Requirements"
        }, 
        {
            "location": "/fms-sipp-tutorial/#store-the-vim-instance", 
            "text": "For registering the Point of Presence of type OpenStack to the NFVO you have to upload a Vim Instance. You can use the following  json descriptor  by changing the values to your needs.", 
            "title": "Store the Vim Instance"
        }, 
        {
            "location": "/fms-sipp-tutorial/#using-the-dashboard", 
            "text": "If you want to use the Dashboard (checkout the  dashboard documentation  for more information on how to use it), open it at the URL http://ip-where-nfvo-runs:8080 (change port and protocol if you use SSL) and log in (default username and password are  admin  and  openbaton ). \nGo to  Manage PoPs -  PoP Instances  and choose the Vim Instance of your choice by clicking on  Register Vim  and selecting the Vim Instance's json file.", 
            "title": "Using the dashboard"
        }, 
        {
            "location": "/fms-sipp-tutorial/#using-the-cli", 
            "text": "If you want to use the CLI (checkout the  Open Baton Client documentation  for more information on how to install and use it), you need to execute the following command in order to onboard the Vim Instance where  vim-instance.json  is the path to the Vim Instance file:  $./openbaton.sh VimInstance-create vim-instance.json", 
            "title": "Using the CLI"
        }, 
        {
            "location": "/fms-sipp-tutorial/#store-the-network-service-descriptor", 
            "text": "Download the  sipp-fms-nsd.json  file, make sure that all the parameters fit with your environment and then upload it in the catalogue either using the dashboard or the CLI. \nThe main parameters you should check before uploading the NSD are: vm_image (make sure you have and Ubuntu image in OpenStack and its name matches the one in this parameter), vimInstanceName (if you only have one vim instance you can leave it empty otherwise you must specify the vim instance name in this parameter or when you will launch the NSD) and flavour_key (make sure you have a flavour in OpenStack matching the one in this parameter).", 
            "title": "Store the Network Service Descriptor"
        }, 
        {
            "location": "/fms-sipp-tutorial/#using-the-dashboard_1", 
            "text": "If you want to use the Dashboard go to  Catalogue -  NS Descriptors , copy the text of NSD \"sipp-fms-nsd.json\", click  Add NSD -  Upload NSD , paste the NSD and click  Store NSD .", 
            "title": "Using the dashboard"
        }, 
        {
            "location": "/fms-sipp-tutorial/#using-the-cli_1", 
            "text": "If you want to use the CLI you need to execute the following command in order to onboard the NSD:  $./openbaton.sh NetworkServiceDescriptor-create sipp-fms-nsd.json  Once this request is processed successfully, it returns the following:  +------------------ +------------------------------------------------------------------ + \n| PROPERTY          | VALUE                                                             | \n+------------------ +------------------------------------------------------------------ + \n| VNFD              |                                                                   | \n|                   | id: 2dd6a30d-0eee-4f88-aa45-9f3a420f341b - name:  sipp-server     | \n|                   | id: 55ac1b21-fdf0-4fe3-861e-5b1f6b5079e3 - name:  sipp-client     | \n|                   |                                                                   | \n| VNF_DEPENDENCY    |                                                                   | \n|                   | id: 123b3dc1-4310-405c-8c50-17dbb1becd2d                          | \n|                   |                                                                   | \n| id                | f2086f71-4ecf-4ed8-a692-36775ebdfc68                              | \n|                   |                                                                   | \n| hb_version        | 1                                                                 | \n|                   |                                                                   | \n| name              | SIPp with fms                                            | \n|                   |                                                                   | \n| projectId         | 7bc76eb0-c48c-4328-a234-c779ab54cd2a                              | \n|                   |                                                                   | \n| vendor            | FOKUS                                                             | \n|                   |                                                                   | \n| version           | 1.0                                                               | \n|                   |                                                                   | \n| VLD               |                                                                   | \n|                   | id: bd65ee00-ce56-42f4-9d31-5cd220ee64a6 - name:  private         | \n|                   |                                                                   | \n+------------------ +------------------------------------------------------------------ +", 
            "title": "Using the CLI"
        }, 
        {
            "location": "/fms-sipp-tutorial/#deploy-the-network-service-descriptor", 
            "text": "As soon as you uploaded the NSD in the NFVO you can deploy this NSD either by using the dashboard or the CLI. \nThis will create a Network Service Record (NSR) and actually launch the Virtual Machines on OpenStack. The network service is composed by two VNFC instances (virtual machines), however the Fault Management System creates a third virtual machine, which consists in the SIPp server in standby.", 
            "title": "Deploy the Network Service Descriptor"
        }, 
        {
            "location": "/fms-sipp-tutorial/#using-the-dashboard_2", 
            "text": "This part shows you how to deploy an onboarded NSD via the dashboard. You need to go to the GUI again and navigate to  Catalogue -  NS Descriptors . Open the drop down menu by clicking on  Action . Afterwards you need to press the  Launch  button and a window with launching options will appear. Just click on  Launch  again in order to start the deployment of this NSD.   If you go to  Orchestrate NS -  NS Records  in the menu on the left side, you can follow the deployment process and check the current status of the created NSR. \nOnce the network service goes to ACTIVE there should be two SIPp server (one ACTIVE and one in STANDBY) and one SIPp client.\nRegarding the SIPp server VNF you should see the following:", 
            "title": "Using the dashboard"
        }, 
        {
            "location": "/fms-sipp-tutorial/#trigger-the-switch-to-standby", 
            "text": "Now you can trigger the switch to standby simulating a failure. \nGo to Openstack dashboard and terminate the virtual machine which correspond to the ACTIVE SIPp server. As you can expect the SIPp client will loose the connection with the server. \nHowever after 1/2 minutes the FMS will execute the switch to standby. After this action, the standby SIPp server will be activated and the client will connect to the new one, so that the network service recovers from the failure.", 
            "title": "Trigger the switch to standby"
        }, 
        {
            "location": "/integration-test-use/", 
            "text": "How to use the Integration Tests\n\n\nOverview\n\n\nThis project provides integration tests for OpenBaton. \nEleven tests are run.\n\n\nTest descriptions\n\n\n\n\nscenario-dummy-iperf\n\n\nscenario-many-dependencies\n\n\nscenario-real-iperf\n\n\nscenario-complex-ncat\n\n\nscenario-scaling\n\n\nerror-in-configure\n\n\nerror-in-instantiate\n\n\nerror-in-start\n\n\nerror-in-terminate\n\n\nwrong-lifecycle-event\n\n\nuser-project-test\n\n\nstress-test\n\n\n\n\nscenario-dummy-iperf\n uses the [Dummy VNFM][vnfm-dummy] to simulate a VNFM and therefore tests the communication between NFVO and VNFM. \nIt does not actually deploy a network service. The fake network service is a simple iperf scenario with one server and one client. \n\n\nscenario-many-dependencies\n also uses the Dummy VNFM but its fake network service is a little bit more complex in the sense that it has many VNFD with many dependencies between them. \n\n\nThe test \nscenario-real-iperf\n actually deploys a network service on openstack. \nIt consists of two VNFD and deploys one iperf server and two iperf clients. The clients contact the server. \n\n\nThe test \nscenario-complex-ncat\n deploys a more complex network service on openstack. \nFive virtual machines will be running and acting as peers. \nThe following picture shows the architecture in which the peers connect to each other using ncat and send their ip address. \nA peer at the beginning of an arrow acts as an ncat client and connects to the peer at the end of the arrow. \nThe receiving peer stores the ip address of the sender so that it is possible to verify which peer connected to which. \nThe two colours represent the two different networks on which the peers are running and connecting. \nBlue is the network \nprivate\n and black \nprivate2\n.\n\n\n\n\nThe test \nscenario-scaling\n tests the scaling function of Openbaton. \nIt starts by deploying two VMs one acting as an ncat server and one as an ncat client which sends his ip address to the server so that it is possible to check if the client actually connected to the server. \nThen it executes some scaling functions like scale out and scale in and checks if new instances of the server and the client are deployed. Cases like scale in on just one instance and scale out on the maximum number of instances are included. \nIt also examines if the client instances are provided with the ip addresses of the new server instances, so that they are able to connect to them. \nTo see detailed information about which scaling functions are executed exactly please refer to the \nscenario-scaling.ini\n file in the project.\n\n\nThe tests \nerror-in-configure\n, \nerror-in-instantiate\n, \nerror-in-start\n, \nerror-in-terminate\n each deploy a network service from a NSD which contains a failing script in the particular lifecycle event and tests if the NFVO handles it correctly. \n\n\nThe test \nwrong-lifecycle-event\n tries to onboard a NSD to the NFVO which contains an undefined lifecycle event. The test will pass if the onboarding is not successful. \n\n\nThe \nuser-project-test\n checks if the NFVO handles user and project management correctly. It adds and deletes users, projects and a vim instance from different \nuser perspectives. This test can be executed without a VNFManager. \n\n\nThe \nstress-test\n checks if the NFVO can handle a large number of NSR deployments from the same or different NSDs at the same time. This test uses the Dummy-VNFM. For this test you should set the property \nnfvo.vmanager.executor.maxpoolsize\n to a large number (e.g. 200) in the /etc/openbaton/openbaton.properties file.\n\n\nIn most of the tests a vim instance and a network service descriptor are stored on the orchestrator and the network service launched. \nIf that is successful, the network service is stopped and the network service record, network service descriptor and the vim instance are removed. \nIn the cases of the \nscenario-real-iperf\n, \nscenario-complex-ncat\n and \nscenario-scaling\n test also the service itself is tested, i.e. if iperf is running and the clients can connect to the server. Therefore the integration tests will execute some scripts for testing on the virtual machines. \n\n\nRequirements\n\n\n\n\nA running \nNFVO\n with the OpenStack vim driver and Test vim driver\n\n\nA running \nGeneric VNFM\n\n\nA running \nDummy VNFM\n\n\nOpenStack\n\n\n\n\nInstallation and configuration\n\n\nUse git to clone the integration-test project to your machine. \nIn \nintegration-tests/src/main/resources\n is a file named integration-tests.properties. \nOpen it and set the property values according to your needs. \n\n\n\n\n\n\n\n\nField\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nnfvo-ip\n\n\nThe ip of the machine on which the NFVO you want to use is running\n\n\n\n\n\n\nnfvo-port\n\n\nThe port on which the NFVO is running\n\n\n\n\n\n\nnfvo-usr\n\n\nThe username required for logging in the NFVO\n\n\n\n\n\n\nnfvo-pwd\n\n\nThe password required for logging in the NFVO\n\n\n\n\n\n\nnfvo-project-id\n\n\nThe id of the project that the integration tests shall use\n\n\n\n\n\n\nnfvo-ssl-enabled\n\n\nSet this to \ntrue\n if the NFVO uses SSL\n\n\n\n\n\n\nlocal-ip\n\n\nThe ip of the machine on which the integration test is running\n\n\n\n\n\n\nclear-after-test\n\n\nIf set to \ntrue\n, the NFVO will be cleared of all the remaining NSRs, NSD, VNFPackages and Vim-Instances left from previous test\n\n\n\n\n\n\nintegration-test-scenarios\n\n\nHere you can specify a folder in which you can put integration test scenarios. If \n.ini\n files exist in this folder, the integration test will use just those files. If there are no files it will use the ones in the projects resource folder\n\n\n\n\n\n\nexternal-properties-file\n\n\nIf you want to use another file for fetching the properties. It is already preset to \n/etc/openbaton/integration-tests/integration-tests.properties\n. If it does not exist it will not be used.\n\n\n\n\n\n\n\n\nAfter that you will also need a keypair for OpenStack. Create one and download the private key as a .pem file. \nRename it to \nintegration-test.pem\n and provide it with the needed permissions by executing \nchmod 400 integration-test.pem\n.\nIf it does not exist already create the directory \n/etc/openbaton/integration-tests\n on your machine and move the pem file into it. \nThe next step is to create a vim file. \nHere is an example where you just have to change some fields. \n\n\n{\n  \nname\n:\nvim-instance\n,\n  \nauthUrl\n:\nhttp://your-openstack-url\n,\n  \ntenant\n:\nthe tenant you use\n,\n  \nusername\n:\nopenstack username\n,\n  \npassword\n:\nopenstack password\n,\n  \nkeyPair\n:\nin here the one you created\n,\n  \nsecurityGroups\n: [\n    \ndefault\n\n  ],\n  \ntype\n:\nopenstack\n,\n  \nlocation\n:{\n    \nname\n:\nyour location\n,\n    \nlatitude\n:\nthe latitude\n,\n    \nlongitude\n:\nthe longitude\n\n  }\n}\n\n\n\n\nName the vim file \nreal-vim.json\n and add it to the folder \nintegration-tests/src/main/resources/etc/json_file/vim_instances/\n in the project.\nIn the folder \nintegration-tests/src/main/resources/etc/json_file/network_service_descriptors\n of the project you will find a file named NetworkServiceDescriptor-iperf-real.json and one named NetworkServiceDescriptor-complex-iperf.json. \nDownload the \nubuntu-14.04-server-cloudimg-amd64-disk1\n image and store it in OpenStack. \n\n\nThe scenario \nerror-in-terminate.ini\n needs some special configuration in the NFVO if you want to run it. Change \nnfvo.delete.vnfr.wait\n to \ntrue\n in \n/etc/openbaton/openbaton.properties\n before starting the NFVO.\n\n\nThen use a shell to navigate into the project's root directory. \nExecute the command \n./integration-tests.sh compile\n.\n\n\nStart the integration test\n\n\nBefore starting the integration tests be sure that the NFVO, Generic VNFM and Dummy VNFM you want to use are already running. \nThen start the test by executing \n./integration-tests.sh start\n.\nIt is possible to specify the test scenarios you want to run so that not every test in the \n/src/main/resources/integration-test-scenarios\n folder is executed. \nTherefore use additional command line arguments while starting the integration tests. Every scenario occuring as an argument will be executed. For example \n./integration-tests.sh start scenario-real-iperf.ini scenario-scaling.ini\n will just execute the tests described in the files \nscenario-real-iperf.ini\n and \nscenario-scaling.ini\n located in the folder \n/src/main/resources/integration-test-scenarios\n.\nIf you do not pass any command line arguments, every available scenario will be executed. To see which scenarios are available execute \n./integration-tests.sh list\n.\n\n\nTest results\n\n\nWhile the tests are running they will produce output to the console. This output will be logged in the file integration-test.log which is in the project's root directory. \nIf a test finished it will either tell you that it passed successfully or not. \nIf it did not pass correctly you will find the reason in the log output. \n\n\nWrite your own integration tests\n\n\nPlease refer to \nthis page\n.\n\n\n\n\n\n\n\n\n\n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Integration Tests"
        }, 
        {
            "location": "/integration-test-use/#how-to-use-the-integration-tests", 
            "text": "", 
            "title": "How to use the Integration Tests"
        }, 
        {
            "location": "/integration-test-use/#overview", 
            "text": "This project provides integration tests for OpenBaton. \nEleven tests are run.", 
            "title": "Overview"
        }, 
        {
            "location": "/integration-test-use/#test-descriptions", 
            "text": "scenario-dummy-iperf  scenario-many-dependencies  scenario-real-iperf  scenario-complex-ncat  scenario-scaling  error-in-configure  error-in-instantiate  error-in-start  error-in-terminate  wrong-lifecycle-event  user-project-test  stress-test   scenario-dummy-iperf  uses the [Dummy VNFM][vnfm-dummy] to simulate a VNFM and therefore tests the communication between NFVO and VNFM. \nIt does not actually deploy a network service. The fake network service is a simple iperf scenario with one server and one client.   scenario-many-dependencies  also uses the Dummy VNFM but its fake network service is a little bit more complex in the sense that it has many VNFD with many dependencies between them.   The test  scenario-real-iperf  actually deploys a network service on openstack. \nIt consists of two VNFD and deploys one iperf server and two iperf clients. The clients contact the server.   The test  scenario-complex-ncat  deploys a more complex network service on openstack. \nFive virtual machines will be running and acting as peers. \nThe following picture shows the architecture in which the peers connect to each other using ncat and send their ip address. \nA peer at the beginning of an arrow acts as an ncat client and connects to the peer at the end of the arrow. \nThe receiving peer stores the ip address of the sender so that it is possible to verify which peer connected to which. \nThe two colours represent the two different networks on which the peers are running and connecting. \nBlue is the network  private  and black  private2 .   The test  scenario-scaling  tests the scaling function of Openbaton. \nIt starts by deploying two VMs one acting as an ncat server and one as an ncat client which sends his ip address to the server so that it is possible to check if the client actually connected to the server. \nThen it executes some scaling functions like scale out and scale in and checks if new instances of the server and the client are deployed. Cases like scale in on just one instance and scale out on the maximum number of instances are included. \nIt also examines if the client instances are provided with the ip addresses of the new server instances, so that they are able to connect to them. \nTo see detailed information about which scaling functions are executed exactly please refer to the  scenario-scaling.ini  file in the project.  The tests  error-in-configure ,  error-in-instantiate ,  error-in-start ,  error-in-terminate  each deploy a network service from a NSD which contains a failing script in the particular lifecycle event and tests if the NFVO handles it correctly.   The test  wrong-lifecycle-event  tries to onboard a NSD to the NFVO which contains an undefined lifecycle event. The test will pass if the onboarding is not successful.   The  user-project-test  checks if the NFVO handles user and project management correctly. It adds and deletes users, projects and a vim instance from different \nuser perspectives. This test can be executed without a VNFManager.   The  stress-test  checks if the NFVO can handle a large number of NSR deployments from the same or different NSDs at the same time. This test uses the Dummy-VNFM. For this test you should set the property  nfvo.vmanager.executor.maxpoolsize  to a large number (e.g. 200) in the /etc/openbaton/openbaton.properties file.  In most of the tests a vim instance and a network service descriptor are stored on the orchestrator and the network service launched. \nIf that is successful, the network service is stopped and the network service record, network service descriptor and the vim instance are removed. \nIn the cases of the  scenario-real-iperf ,  scenario-complex-ncat  and  scenario-scaling  test also the service itself is tested, i.e. if iperf is running and the clients can connect to the server. Therefore the integration tests will execute some scripts for testing on the virtual machines.", 
            "title": "Test descriptions"
        }, 
        {
            "location": "/integration-test-use/#requirements", 
            "text": "A running  NFVO  with the OpenStack vim driver and Test vim driver  A running  Generic VNFM  A running  Dummy VNFM  OpenStack", 
            "title": "Requirements"
        }, 
        {
            "location": "/integration-test-use/#installation-and-configuration", 
            "text": "Use git to clone the integration-test project to your machine. \nIn  integration-tests/src/main/resources  is a file named integration-tests.properties. \nOpen it and set the property values according to your needs.      Field  Value      nfvo-ip  The ip of the machine on which the NFVO you want to use is running    nfvo-port  The port on which the NFVO is running    nfvo-usr  The username required for logging in the NFVO    nfvo-pwd  The password required for logging in the NFVO    nfvo-project-id  The id of the project that the integration tests shall use    nfvo-ssl-enabled  Set this to  true  if the NFVO uses SSL    local-ip  The ip of the machine on which the integration test is running    clear-after-test  If set to  true , the NFVO will be cleared of all the remaining NSRs, NSD, VNFPackages and Vim-Instances left from previous test    integration-test-scenarios  Here you can specify a folder in which you can put integration test scenarios. If  .ini  files exist in this folder, the integration test will use just those files. If there are no files it will use the ones in the projects resource folder    external-properties-file  If you want to use another file for fetching the properties. It is already preset to  /etc/openbaton/integration-tests/integration-tests.properties . If it does not exist it will not be used.     After that you will also need a keypair for OpenStack. Create one and download the private key as a .pem file. \nRename it to  integration-test.pem  and provide it with the needed permissions by executing  chmod 400 integration-test.pem .\nIf it does not exist already create the directory  /etc/openbaton/integration-tests  on your machine and move the pem file into it. \nThe next step is to create a vim file. \nHere is an example where you just have to change some fields.   {\n   name : vim-instance ,\n   authUrl : http://your-openstack-url ,\n   tenant : the tenant you use ,\n   username : openstack username ,\n   password : openstack password ,\n   keyPair : in here the one you created ,\n   securityGroups : [\n     default \n  ],\n   type : openstack ,\n   location :{\n     name : your location ,\n     latitude : the latitude ,\n     longitude : the longitude \n  }\n}  Name the vim file  real-vim.json  and add it to the folder  integration-tests/src/main/resources/etc/json_file/vim_instances/  in the project.\nIn the folder  integration-tests/src/main/resources/etc/json_file/network_service_descriptors  of the project you will find a file named NetworkServiceDescriptor-iperf-real.json and one named NetworkServiceDescriptor-complex-iperf.json. \nDownload the  ubuntu-14.04-server-cloudimg-amd64-disk1  image and store it in OpenStack.   The scenario  error-in-terminate.ini  needs some special configuration in the NFVO if you want to run it. Change  nfvo.delete.vnfr.wait  to  true  in  /etc/openbaton/openbaton.properties  before starting the NFVO.  Then use a shell to navigate into the project's root directory. \nExecute the command  ./integration-tests.sh compile .", 
            "title": "Installation and configuration"
        }, 
        {
            "location": "/integration-test-use/#start-the-integration-test", 
            "text": "Before starting the integration tests be sure that the NFVO, Generic VNFM and Dummy VNFM you want to use are already running. \nThen start the test by executing  ./integration-tests.sh start .\nIt is possible to specify the test scenarios you want to run so that not every test in the  /src/main/resources/integration-test-scenarios  folder is executed. \nTherefore use additional command line arguments while starting the integration tests. Every scenario occuring as an argument will be executed. For example  ./integration-tests.sh start scenario-real-iperf.ini scenario-scaling.ini  will just execute the tests described in the files  scenario-real-iperf.ini  and  scenario-scaling.ini  located in the folder  /src/main/resources/integration-test-scenarios .\nIf you do not pass any command line arguments, every available scenario will be executed. To see which scenarios are available execute  ./integration-tests.sh list .", 
            "title": "Start the integration test"
        }, 
        {
            "location": "/integration-test-use/#test-results", 
            "text": "While the tests are running they will produce output to the console. This output will be logged in the file integration-test.log which is in the project's root directory. \nIf a test finished it will either tell you that it passed successfully or not. \nIf it did not pass correctly you will find the reason in the log output.", 
            "title": "Test results"
        }, 
        {
            "location": "/integration-test-use/#write-your-own-integration-tests", 
            "text": "Please refer to  this page .    \n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Write your own integration tests"
        }, 
        {
            "location": "/nfvo-architecture/", 
            "text": "NFVO Architecture\n\n\nNFVO\n is a modular software composed by the modules illustrated in the following picture:\n\n\n\n\nAPI\n\n\nThis module contains the necessary classes exposing APIs as ReST server. For more details please see \nthe api documentation\n\n\nMAIN\n\n\nThis module contains the classes in charge of the startup of the whole system and gathering configuratons for instance.\n\n\nCOMMON\n\n\nThis module contains the classes that are common to the NFVO\n\n\nCLI\n\n\nThis module contains the NFVO console.\n\n\nDASHBOARD\n\n\nThis module contains the web dashboard available at localhost:8080\n\n\nCORE-INT\n\n\nThis module contains the interfaces of the core functionalities regarding only the internal NFVO interfaces. Most of them are definend in \nETSI MANO specification\n in NFV-MANO interfaces section.\n\n\nCORE-IMPL\n\n\nThis module contains the beans implementing the \ncore-int\n interfaces.\n\n\nVNFM-INT\n\n\nThis module contains the interfaces of the core functionalities regarding only the NFVO interfaces to the VnfManagers. Most of them are definend in \nETSI MANO specification\n in NFV-MANO interfaces section.\n\n\nVNFM-IMPL\n\n\nThis module contains the beans implementing the \nvnfm-int\n interfaces.\n\n\nREPOSITORY\n\n\nThis module contains specific repositories interfacing the database in a generic way using Spring CrudRepository.\n\n\nCATALOGUE\n\n\nThis module contains the complete model of NFVO that is sharde in the openbaton libraries. The model is definend in \nETSI MANO specification\n.\n\n\nVIM-INT\n\n\nThis module contains the interfaces of the core functionalities regarding only the NFVO interfaces to the VIM. Most of them are definend in \nETSI MANO specification\n in NFV-MANO interfaces section.\n\n\nVIM-IMPL\n\n\nThis module contains the beans implementing the \nvim-int\n interfaces.\n\n\nPLUGIN\n\n\nThis module contains the utility classes used to interface to the openbaton plugins.\n\n\nVIM-DRIVERS\n\n\nThis module contains the interface for the VIM openbaton plugins.\n\n\nEXCEPTION\n\n\nThis module contains all the exception classes common to every project containing openbaton libraries.\n\n\nMONITORING\n\n\nThis module contains the interface for the monitoring of the openbaton plugins.\n\n\nTOSCA-PARSER\n\n\nThis module contains all the classes of the parser in charge of managing the TOSCA packages\n\n\nSECURITY\n\n\nThis module configures the security mechanisms used in the NFVO\n\n\nAll the platform modules are based on the \nSpring Framework\n and the comunication between NFVO and other external modules are mostly based on RabbitMQ messaging system.  \n\n\n\n\n\n\n\n\n\n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "NFVO Architecture"
        }, 
        {
            "location": "/nfvo-architecture/#nfvo-architecture", 
            "text": "NFVO  is a modular software composed by the modules illustrated in the following picture:", 
            "title": "NFVO Architecture"
        }, 
        {
            "location": "/nfvo-architecture/#api", 
            "text": "This module contains the necessary classes exposing APIs as ReST server. For more details please see  the api documentation", 
            "title": "API"
        }, 
        {
            "location": "/nfvo-architecture/#main", 
            "text": "This module contains the classes in charge of the startup of the whole system and gathering configuratons for instance.", 
            "title": "MAIN"
        }, 
        {
            "location": "/nfvo-architecture/#common", 
            "text": "This module contains the classes that are common to the NFVO", 
            "title": "COMMON"
        }, 
        {
            "location": "/nfvo-architecture/#cli", 
            "text": "This module contains the NFVO console.", 
            "title": "CLI"
        }, 
        {
            "location": "/nfvo-architecture/#dashboard", 
            "text": "This module contains the web dashboard available at localhost:8080", 
            "title": "DASHBOARD"
        }, 
        {
            "location": "/nfvo-architecture/#core-int", 
            "text": "This module contains the interfaces of the core functionalities regarding only the internal NFVO interfaces. Most of them are definend in  ETSI MANO specification  in NFV-MANO interfaces section.", 
            "title": "CORE-INT"
        }, 
        {
            "location": "/nfvo-architecture/#core-impl", 
            "text": "This module contains the beans implementing the  core-int  interfaces.", 
            "title": "CORE-IMPL"
        }, 
        {
            "location": "/nfvo-architecture/#vnfm-int", 
            "text": "This module contains the interfaces of the core functionalities regarding only the NFVO interfaces to the VnfManagers. Most of them are definend in  ETSI MANO specification  in NFV-MANO interfaces section.", 
            "title": "VNFM-INT"
        }, 
        {
            "location": "/nfvo-architecture/#vnfm-impl", 
            "text": "This module contains the beans implementing the  vnfm-int  interfaces.", 
            "title": "VNFM-IMPL"
        }, 
        {
            "location": "/nfvo-architecture/#repository", 
            "text": "This module contains specific repositories interfacing the database in a generic way using Spring CrudRepository.", 
            "title": "REPOSITORY"
        }, 
        {
            "location": "/nfvo-architecture/#catalogue", 
            "text": "This module contains the complete model of NFVO that is sharde in the openbaton libraries. The model is definend in  ETSI MANO specification .", 
            "title": "CATALOGUE"
        }, 
        {
            "location": "/nfvo-architecture/#vim-int", 
            "text": "This module contains the interfaces of the core functionalities regarding only the NFVO interfaces to the VIM. Most of them are definend in  ETSI MANO specification  in NFV-MANO interfaces section.", 
            "title": "VIM-INT"
        }, 
        {
            "location": "/nfvo-architecture/#vim-impl", 
            "text": "This module contains the beans implementing the  vim-int  interfaces.", 
            "title": "VIM-IMPL"
        }, 
        {
            "location": "/nfvo-architecture/#plugin", 
            "text": "This module contains the utility classes used to interface to the openbaton plugins.", 
            "title": "PLUGIN"
        }, 
        {
            "location": "/nfvo-architecture/#vim-drivers", 
            "text": "This module contains the interface for the VIM openbaton plugins.", 
            "title": "VIM-DRIVERS"
        }, 
        {
            "location": "/nfvo-architecture/#exception", 
            "text": "This module contains all the exception classes common to every project containing openbaton libraries.", 
            "title": "EXCEPTION"
        }, 
        {
            "location": "/nfvo-architecture/#monitoring", 
            "text": "This module contains the interface for the monitoring of the openbaton plugins.", 
            "title": "MONITORING"
        }, 
        {
            "location": "/nfvo-architecture/#tosca-parser", 
            "text": "This module contains all the classes of the parser in charge of managing the TOSCA packages", 
            "title": "TOSCA-PARSER"
        }, 
        {
            "location": "/nfvo-architecture/#security", 
            "text": "This module configures the security mechanisms used in the NFVO  All the platform modules are based on the  Spring Framework  and the comunication between NFVO and other external modules are mostly based on RabbitMQ messaging system.      \n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "SECURITY"
        }, 
        {
            "location": "/vim-driver-create/", 
            "text": "Create Vim Driver\n\n\nThis tutorial will give This project plugin-sdk contains modules that are needed to implement a plugin for OpenBaton system.\n\n\nHow does this work?\n\n\nOpenBaton use the Remote Procedure Call (RPC) mechanism for implementing the Plugins. It offers an implementation of an interface that is used by the NFVO. \n\n\nRequirements\n\n\nBefore you can start with developing your own Vim Driver you need to prepare your programming environment by installing/configuring the following requirements:\n\n\n\n\nJDK 7 (\ninstallation\n)\n\n\nGradle (\ninstallation\n)\n\n\n\n\nCreate a new project\n\n\nOnce you have started the IDE, click on File -\n New -\n Project...\n\n\nIn this dialog click on Gradle on the left and select java in the main properties window in the middle.\n\n\n\n\nThen click on next to go to the next window.\n\n\nIn the next dialog you need to define the GroupId, ArtifactId and the Version.\nMore information on the specific meaning can be found \nhere\n.\n\n\n\n\nContinue with the next dialog.\n\n\nIn this dialog you need to specify which gradle you want to use.\nIt is recommend to use the default gradle wrapper.\nAdditionally you can enable the auto-import.\n\n\n\n\nContinue with the next dialog by clicking on Next.\n\n\nIn the last dialog, you need to define the project name and the project location.\n\n\n\n\nOnce this is done you can click on Finish and continue with creating the Main Class.\n\n\nCreate the Main Class\n\n\nAfterwards, you need to create the Main Class of the VIM driver which will be started in the end.\nFor doing so, right click on the root folder my-vim, then click on New -\n Directory and insert what is show below.\n\n\n\n\nClick on OK to continue.\n\n\nAdditionally you need to create a new package.\nThis is done by a right-click on the previously created directory java.\nClick on New -\n Package.\nHere you can define the package name.\n\n\n\n\nFinally you can create your MyVim Class by clicking (right click) on the previously created package and click on New -\n Java Class.\n\n\n\n\nOnce you did all these steps, the initial project structure is created.\nWhat we miss right now is the configuration of the gradle files to define and fetch dependencies we need for implementing the Vim driver.\nThis is described in later sections.\n\n\nIn order to create a VIM driver for OpenBaton system you need to add to your \nbuild.gradle\n file:\n\n\n\ngroup 'org.myplugin.example'\nversion '1.0-SNAPSHOT'\n\nbuildscript {\n    repositories {\n        mavenLocal()\n        mavenCentral()\n    }\n    dependencies {\n        classpath(\norg.springframework.boot:spring-boot-gradle-plugin:1.2.6.RELEASE\n)\n    }\n}\n\nrepositories {\n    mavenCentral()\n    /**\n     * Only needed for openbaton snapshots dependencies\n     */\n    maven {\n        url 'https://oss.sonatype.org/content/repositories/snapshots/'\n    }\n}\n\napply plugin: 'java'\napply plugin: 'maven'\napply plugin: 'spring-boot'\n\n\nmainClassName = 'org.myplugin.example.Starter'\n\n\ndependencies {\n    compile 'org.openbaton:plugin-sdk:3.2.0'\n    compile'org.springframework:spring-context:4.2.1.RELEASE'\n}\n\n\n\n\n\nWrite your Vim driver\n\n\nThe Vim driver is a simple class extending one abstract class and using a Starter utility \n\n\nType of Vim Instance\n\n\nOpenBaton provides a specific class for handling the \nopenstack\n type or the \ntest\n type thus these two types are supported. For all the other types a generic class will handle the communication between the NFVO and your plugin.\n\n\nImplement VimDriver\n\n\nThe \nVimDriver\n is an abastract class that contains tha basic functionalities that a Vim Instance has to provide. \n\n\nNOTE\n: If you want to implement a Monitoring plugin, then you need to implement the Abstract Class \nMonitoringPlugin\n\n\nYour \nMyVim\n class will implement the methods inherited from \nVimDriver\n that manages your Vim Instance:\n\n\n\n\n\n\n\n\nFunction\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nList\\\nNFVImage> listImages\n\n\nReturns the list of Images\n\n\n\n\n\n\nList\\\nServer> listServer\n\n\nReturns the list of Servers\n\n\n\n\n\n\nList\\\nNetwork> listNetworks\n\n\nReturns the list of Network\n\n\n\n\n\n\nList\\\nDeploymentFlavour> listFlavors\n\n\nReturns the list of DeploymentFlavour\n\n\n\n\n\n\nServer launchInstanceAndWait\n\n\nCreates a new Server\n\n\n\n\n\n\nvoid deleteServerByIdAndWait\n\n\nRemoves the Server with id\n\n\n\n\n\n\nNetwork createNetwork\n\n\nCreates a new Network\n\n\n\n\n\n\nNetwork getNetworkById\n\n\nReturns the Network with id\n\n\n\n\n\n\nNetwork updateNetwork\n\n\nUpdates a new Network\n\n\n\n\n\n\nboolean deleteNetwork\n\n\nDeletes the Network\n\n\n\n\n\n\nSubnet createSubnet\n\n\nCreates a new Subnet\n\n\n\n\n\n\nSubnet updateSubnet\n\n\nUpdates the Subnet\n\n\n\n\n\n\nboolean deleteSubnet\n\n\nDeletes the Subnet\n\n\n\n\n\n\nList\\\nString> getSubnetsExtIds\n\n\nReturns the list of SubnetsExtId\n\n\n\n\n\n\nDeploymentFlavour addFlavor\n\n\nAdds a new DeploymentFlavour\n\n\n\n\n\n\nDeploymentFlavour updateFlavor\n\n\nUpdates the DeploymentFlavour\n\n\n\n\n\n\nboolean deleteFlavor\n\n\nDeletes the DeploymentFlavour\n\n\n\n\n\n\nNFVImage addImage\n\n\nAdds a new NFVImage\n\n\n\n\n\n\nNFVImage updateImage\n\n\nUpdates the NFVImage\n\n\n\n\n\n\nNFVImage copyImage\n\n\nCopies the NFVImage\n\n\n\n\n\n\nboolean deleteImage\n\n\nDeletes the NFVImage\n\n\n\n\n\n\nQuota getQuota\n\n\nReturns the Quota\n\n\n\n\n\n\nString getType\n\n\nReturns the type\n\n\n\n\n\n\n\n\nAn example of the class:\n\n\npackage org.myplugin.example;\n\nimport org.openbaton.catalogue.mano.common.DeploymentFlavour;\nimport org.openbaton.catalogue.nfvo.*;\nimport org.openbaton.exceptions.VimDriverException;\nimport org.openbaton.vim.drivers.interfaces.VimDriver;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.context.annotation.Scope;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Set;\n\npublic class MyVim extends VimDriver{\n\n\n    private Logger log = LoggerFactory.getLogger(this.getClass());\n\n    @Override\n    public Server launchInstance(VimInstance vimInstance, String name, String image, String flavor, String keypair, Set\nString\n network, Set\nString\n secGroup, String userData) throws RemoteException {\n        // ...\n    }\n\n    @Override\n    public String getType(VimInstance vimInstance) {\n        // ...\n    }\n\n    @Override\n    public List\nNFVImage\n listImages(VimInstance vimInstance) {\n        // ...\n    }\n\n    public static void main(String[] args) {\n        PluginStarter.registerPlugin(MyVim.class, \nmy-type\n, \nbroker-ip\n, 5672, 10);\n    }\n}\n\n\n\n\nAs you can notice, there is the need of a \nmain\n method to start multiple instances of the plugin (in this example are 10, the last parameter).\n\n\nRun your Vim driver in OpenBaton environment\n\n\nUnder the folder of your project \nsrc/main/resources\n you should create a file \nplugin.conf.properties\n and write the variable \ntype = \nthe-vim-type\n.\n\n\nThe structure of your project should be like:\n\n\n\n\nNow you can run \n./gradlew build\n and Gradle will create the jar that you can find in the folder \nbuild/libs/myPlugin-1.0-SNAPSHOT.jar\n.\n\n\nOnce all these steps are done, you can copy and paste the \nmyPlugin-1.0-SNAPSHOT.jar\n under the folder specified in the \nopenbaton.properties\n (under \n/etc/openbaton\n folder) \nplugin-installation-dir\n property, as default path_to_NFVO/plugins.\nThe plugin sends the log messages to NFVO, the NFVO writes them into a log file. The path to this file can be set with nfvo.plugin.log.path properties in the /etc/openbaton/openbaton.properties. \nCongratulations you have your version of the interface for your Vim Instance that will be used by NFVO\n\n\nUse my plugin\n\n\nOnce you copied the jar file into the right folder, either you need to (re)start the NFVO or you type \ninstallPlugin\n in the NFVO console passing the needed arguments. In case you restart the NFVO, the plugin will automatically register and you can see that there will be a log file in the NFVO folder called \nplugin-myPlugin.log\n containing the logs of the plugin. The myPlugin now acts as a normal plugin so for using it check out the \nVim instance documentation\n in order to point out to the new plugin.\n\n\nNOTE\n: you can also launch your plugin from your command line just typing\n\n\n$ java -jar myPlugin-1.0-SNAPSHOT.jar\n\n\n\n\n\n\n\n\n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Create a VIM Driver"
        }, 
        {
            "location": "/vim-driver-create/#create-vim-driver", 
            "text": "This tutorial will give This project plugin-sdk contains modules that are needed to implement a plugin for OpenBaton system.", 
            "title": "Create Vim Driver"
        }, 
        {
            "location": "/vim-driver-create/#how-does-this-work", 
            "text": "OpenBaton use the Remote Procedure Call (RPC) mechanism for implementing the Plugins. It offers an implementation of an interface that is used by the NFVO.", 
            "title": "How does this work?"
        }, 
        {
            "location": "/vim-driver-create/#requirements", 
            "text": "Before you can start with developing your own Vim Driver you need to prepare your programming environment by installing/configuring the following requirements:   JDK 7 ( installation )  Gradle ( installation )", 
            "title": "Requirements"
        }, 
        {
            "location": "/vim-driver-create/#create-a-new-project", 
            "text": "Once you have started the IDE, click on File -  New -  Project...  In this dialog click on Gradle on the left and select java in the main properties window in the middle.   Then click on next to go to the next window.  In the next dialog you need to define the GroupId, ArtifactId and the Version.\nMore information on the specific meaning can be found  here .   Continue with the next dialog.  In this dialog you need to specify which gradle you want to use.\nIt is recommend to use the default gradle wrapper.\nAdditionally you can enable the auto-import.   Continue with the next dialog by clicking on Next.  In the last dialog, you need to define the project name and the project location.   Once this is done you can click on Finish and continue with creating the Main Class.", 
            "title": "Create a new project"
        }, 
        {
            "location": "/vim-driver-create/#create-the-main-class", 
            "text": "Afterwards, you need to create the Main Class of the VIM driver which will be started in the end.\nFor doing so, right click on the root folder my-vim, then click on New -  Directory and insert what is show below.   Click on OK to continue.  Additionally you need to create a new package.\nThis is done by a right-click on the previously created directory java.\nClick on New -  Package.\nHere you can define the package name.   Finally you can create your MyVim Class by clicking (right click) on the previously created package and click on New -  Java Class.   Once you did all these steps, the initial project structure is created.\nWhat we miss right now is the configuration of the gradle files to define and fetch dependencies we need for implementing the Vim driver.\nThis is described in later sections.  In order to create a VIM driver for OpenBaton system you need to add to your  build.gradle  file:  \ngroup 'org.myplugin.example'\nversion '1.0-SNAPSHOT'\n\nbuildscript {\n    repositories {\n        mavenLocal()\n        mavenCentral()\n    }\n    dependencies {\n        classpath( org.springframework.boot:spring-boot-gradle-plugin:1.2.6.RELEASE )\n    }\n}\n\nrepositories {\n    mavenCentral()\n    /**\n     * Only needed for openbaton snapshots dependencies\n     */\n    maven {\n        url 'https://oss.sonatype.org/content/repositories/snapshots/'\n    }\n}\n\napply plugin: 'java'\napply plugin: 'maven'\napply plugin: 'spring-boot'\n\n\nmainClassName = 'org.myplugin.example.Starter'\n\n\ndependencies {\n    compile 'org.openbaton:plugin-sdk:3.2.0'\n    compile'org.springframework:spring-context:4.2.1.RELEASE'\n}", 
            "title": "Create the Main Class"
        }, 
        {
            "location": "/vim-driver-create/#write-your-vim-driver", 
            "text": "The Vim driver is a simple class extending one abstract class and using a Starter utility", 
            "title": "Write your Vim driver"
        }, 
        {
            "location": "/vim-driver-create/#type-of-vim-instance", 
            "text": "OpenBaton provides a specific class for handling the  openstack  type or the  test  type thus these two types are supported. For all the other types a generic class will handle the communication between the NFVO and your plugin.", 
            "title": "Type of Vim Instance"
        }, 
        {
            "location": "/vim-driver-create/#implement-vimdriver", 
            "text": "The  VimDriver  is an abastract class that contains tha basic functionalities that a Vim Instance has to provide.   NOTE : If you want to implement a Monitoring plugin, then you need to implement the Abstract Class  MonitoringPlugin  Your  MyVim  class will implement the methods inherited from  VimDriver  that manages your Vim Instance:     Function  Description      List\\ NFVImage> listImages  Returns the list of Images    List\\ Server> listServer  Returns the list of Servers    List\\ Network> listNetworks  Returns the list of Network    List\\ DeploymentFlavour> listFlavors  Returns the list of DeploymentFlavour    Server launchInstanceAndWait  Creates a new Server    void deleteServerByIdAndWait  Removes the Server with id    Network createNetwork  Creates a new Network    Network getNetworkById  Returns the Network with id    Network updateNetwork  Updates a new Network    boolean deleteNetwork  Deletes the Network    Subnet createSubnet  Creates a new Subnet    Subnet updateSubnet  Updates the Subnet    boolean deleteSubnet  Deletes the Subnet    List\\ String> getSubnetsExtIds  Returns the list of SubnetsExtId    DeploymentFlavour addFlavor  Adds a new DeploymentFlavour    DeploymentFlavour updateFlavor  Updates the DeploymentFlavour    boolean deleteFlavor  Deletes the DeploymentFlavour    NFVImage addImage  Adds a new NFVImage    NFVImage updateImage  Updates the NFVImage    NFVImage copyImage  Copies the NFVImage    boolean deleteImage  Deletes the NFVImage    Quota getQuota  Returns the Quota    String getType  Returns the type     An example of the class:  package org.myplugin.example;\n\nimport org.openbaton.catalogue.mano.common.DeploymentFlavour;\nimport org.openbaton.catalogue.nfvo.*;\nimport org.openbaton.exceptions.VimDriverException;\nimport org.openbaton.vim.drivers.interfaces.VimDriver;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.context.annotation.Scope;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Set;\n\npublic class MyVim extends VimDriver{\n\n\n    private Logger log = LoggerFactory.getLogger(this.getClass());\n\n    @Override\n    public Server launchInstance(VimInstance vimInstance, String name, String image, String flavor, String keypair, Set String  network, Set String  secGroup, String userData) throws RemoteException {\n        // ...\n    }\n\n    @Override\n    public String getType(VimInstance vimInstance) {\n        // ...\n    }\n\n    @Override\n    public List NFVImage  listImages(VimInstance vimInstance) {\n        // ...\n    }\n\n    public static void main(String[] args) {\n        PluginStarter.registerPlugin(MyVim.class,  my-type ,  broker-ip , 5672, 10);\n    }\n}  As you can notice, there is the need of a  main  method to start multiple instances of the plugin (in this example are 10, the last parameter).", 
            "title": "Implement VimDriver"
        }, 
        {
            "location": "/vim-driver-create/#run-your-vim-driver-in-openbaton-environment", 
            "text": "Under the folder of your project  src/main/resources  you should create a file  plugin.conf.properties  and write the variable  type =  the-vim-type .  The structure of your project should be like:   Now you can run  ./gradlew build  and Gradle will create the jar that you can find in the folder  build/libs/myPlugin-1.0-SNAPSHOT.jar .  Once all these steps are done, you can copy and paste the  myPlugin-1.0-SNAPSHOT.jar  under the folder specified in the  openbaton.properties  (under  /etc/openbaton  folder)  plugin-installation-dir  property, as default path_to_NFVO/plugins.\nThe plugin sends the log messages to NFVO, the NFVO writes them into a log file. The path to this file can be set with nfvo.plugin.log.path properties in the /etc/openbaton/openbaton.properties. \nCongratulations you have your version of the interface for your Vim Instance that will be used by NFVO", 
            "title": "Run your Vim driver in OpenBaton environment"
        }, 
        {
            "location": "/vim-driver-create/#use-my-plugin", 
            "text": "Once you copied the jar file into the right folder, either you need to (re)start the NFVO or you type  installPlugin  in the NFVO console passing the needed arguments. In case you restart the NFVO, the plugin will automatically register and you can see that there will be a log file in the NFVO folder called  plugin-myPlugin.log  containing the logs of the plugin. The myPlugin now acts as a normal plugin so for using it check out the  Vim instance documentation  in order to point out to the new plugin.  NOTE : you can also launch your plugin from your command line just typing  $ java -jar myPlugin-1.0-SNAPSHOT.jar   \n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Use my plugin"
        }, 
        {
            "location": "/nfvo-sdk/", 
            "text": "NFVO Northbound SDK\n\n\nA SDK is available if you want to use the NFVO from a java application.\n\n\nImport it\n\n\nThe build.gradle file must contain:\n\n\nrepositories {\n    mavenCentral()\n    /**\n     * Only needed for openbaton snapshots dependencies\n     */\n    maven {\n        url 'https://oss.sonatype.org/content/repositories/snapshots/'\n    }\n}\n\ndependencies {\n    compile 'org.openbaton:sdk:3.2.0'\n}\n\n\n\n\nIn this way you will have access to the NFVO SDK.\n\n\nAnd then?\n\n\nThe UML diagram of the classes follows:\n\n\n\n\nThe NFVORequestor is the main and only class you need to use. From this class it is possible to retrieve all the Agents that are in charge of making calls to the NFVO. The NFVORequestor takes as constructor parameters:\n\n\n\n\n\n\n\n\nParams\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nusername\n\n\nthe username\n\n\n\n\n\n\npassword\n\n\nthe password\n\n\n\n\n\n\nprojectId\n\n\nthe id of the project to use\n\n\n\n\n\n\nsslEnabled\n\n\nset this to true if the NFVO uses SSL\n\n\n\n\n\n\nnfvoIp\n\n\nthe ip of the NFVO\n\n\n\n\n\n\nnfvoPort\n\n\nthe port of the orchestrator\n\n\n\n\n\n\nversion\n\n\nthe API version. Now only \"1\" is available\n\n\n\n\n\n\n\n\nImportant NOTE\n: Please pay attention that the NFVORequestor \nis not\n thread safe! To make it so is up to the developer. \n\n\nOnce you have the NFVORequestor object, you can get the Agents. Available agents are:\n\n\n\n\nConfigurationRestRequest\n\n\nEventAgent\n\n\nImageRestAgent\n\n\nKeyAgent\n\n\nNetworkServiceDescriptorRestAgent\n\n\nNetworkServiceRecordRestAgent\n\n\nProjectAgent\n\n\nUserAgent\n\n\nVimInstanceRestAgent\n\n\nVirtualLinkRestAgent\n\n\nVirtualNetworkFunctionDescriptorRestAgent\n\n\nVNFFGRestAgent\n\n\nVNFPackageAgent\n\n\n\n\neach of them exposes these methods:\n\n\n\n\ncreate\n\n\nfindById\n\n\nfindAll\n\n\ndelete\n\n\nupdate\n\n\n\n\nplus some specific methods and they refer to the \ncatalogue\n class contained in the name of the Agent. For instance, the NetworkServiceDescriptorRestAgent refers to NetworkServiceDescriptor class and, besides the above methods, exposes:\n\n\n\n\ngetVirtualNetworkFunctionDescriptors\n\n\ngetVirtualNetworkFunctionDescriptor\n\n\ndeleteVirtualNetworkFunctionDescriptors\n\n\ncreateVNFD\n\n\nupdateVNFD\n\n\ngetVNFDependencies\n\n\ngetVNFDependency\n\n\ndeleteVNFDependency\n\n\ncreateVNFDependency\n\n\nupdateVNFD\n\n\ngetPhysicalNetworkFunctionDescriptors\n\n\ngetPhysicalNetworkFunctionDescriptor\n\n\ndeletePhysicalNetworkFunctionDescriptor\n\n\ncreatePhysicalNetworkFunctionDescriptor\n\n\nupdatePNFD\n\n\ngetSecurities\n\n\ndeleteSecurity\n\n\ncreateSecurity\n\n\nupdateSecurity\n\n\n\n\nThe method names are explicit, they do what the name explains.\n\n\nUsage example\n\n\nCreate a VimInstance using the SDK\n\n\npublic class Main {\n\n    public static void main(String[] args) {\n        boolean sslEnabled = true;\n        NFVORequestor nfvoRequestor = new NFVORequestor(\nusername\n, \npassword\n, \nprojectId\n, sslEnabled, \nnfvo_ip\n, \nnfvo_port\n, \n1\n);\n        VimInstanceRestAgent vimInstanceAgent = nfvoRequestor.getVimInstanceAgent();\n\n        VimInstance vimInstance = new VimInstance();\n\n        // fill the vimInstance object accordingly to your VIM chosen\n\n        try {\n            vimInstance = vimInstanceAgent.create(vimInstance);\n        } catch (SDKException e) {\n            e.printStackTrace();\n        }\n\n        System.out.println(\nCreated VimInstance with id: \n + vimInstance.getId());\n    }\n}", 
            "title": "Open Baton SDKs"
        }, 
        {
            "location": "/nfvo-sdk/#nfvo-northbound-sdk", 
            "text": "A SDK is available if you want to use the NFVO from a java application.", 
            "title": "NFVO Northbound SDK"
        }, 
        {
            "location": "/nfvo-sdk/#import-it", 
            "text": "The build.gradle file must contain:  repositories {\n    mavenCentral()\n    /**\n     * Only needed for openbaton snapshots dependencies\n     */\n    maven {\n        url 'https://oss.sonatype.org/content/repositories/snapshots/'\n    }\n}\n\ndependencies {\n    compile 'org.openbaton:sdk:3.2.0'\n}  In this way you will have access to the NFVO SDK.", 
            "title": "Import it"
        }, 
        {
            "location": "/nfvo-sdk/#and-then", 
            "text": "The UML diagram of the classes follows:   The NFVORequestor is the main and only class you need to use. From this class it is possible to retrieve all the Agents that are in charge of making calls to the NFVO. The NFVORequestor takes as constructor parameters:     Params  Description      username  the username    password  the password    projectId  the id of the project to use    sslEnabled  set this to true if the NFVO uses SSL    nfvoIp  the ip of the NFVO    nfvoPort  the port of the orchestrator    version  the API version. Now only \"1\" is available     Important NOTE : Please pay attention that the NFVORequestor  is not  thread safe! To make it so is up to the developer.   Once you have the NFVORequestor object, you can get the Agents. Available agents are:   ConfigurationRestRequest  EventAgent  ImageRestAgent  KeyAgent  NetworkServiceDescriptorRestAgent  NetworkServiceRecordRestAgent  ProjectAgent  UserAgent  VimInstanceRestAgent  VirtualLinkRestAgent  VirtualNetworkFunctionDescriptorRestAgent  VNFFGRestAgent  VNFPackageAgent   each of them exposes these methods:   create  findById  findAll  delete  update   plus some specific methods and they refer to the  catalogue  class contained in the name of the Agent. For instance, the NetworkServiceDescriptorRestAgent refers to NetworkServiceDescriptor class and, besides the above methods, exposes:   getVirtualNetworkFunctionDescriptors  getVirtualNetworkFunctionDescriptor  deleteVirtualNetworkFunctionDescriptors  createVNFD  updateVNFD  getVNFDependencies  getVNFDependency  deleteVNFDependency  createVNFDependency  updateVNFD  getPhysicalNetworkFunctionDescriptors  getPhysicalNetworkFunctionDescriptor  deletePhysicalNetworkFunctionDescriptor  createPhysicalNetworkFunctionDescriptor  updatePNFD  getSecurities  deleteSecurity  createSecurity  updateSecurity   The method names are explicit, they do what the name explains.", 
            "title": "And then?"
        }, 
        {
            "location": "/nfvo-sdk/#usage-example", 
            "text": "", 
            "title": "Usage example"
        }, 
        {
            "location": "/nfvo-sdk/#create-a-viminstance-using-the-sdk", 
            "text": "public class Main {\n\n    public static void main(String[] args) {\n        boolean sslEnabled = true;\n        NFVORequestor nfvoRequestor = new NFVORequestor( username ,  password ,  projectId , sslEnabled,  nfvo_ip ,  nfvo_port ,  1 );\n        VimInstanceRestAgent vimInstanceAgent = nfvoRequestor.getVimInstanceAgent();\n\n        VimInstance vimInstance = new VimInstance();\n\n        // fill the vimInstance object accordingly to your VIM chosen\n\n        try {\n            vimInstance = vimInstanceAgent.create(vimInstance);\n        } catch (SDKException e) {\n            e.printStackTrace();\n        }\n\n        System.out.println( Created VimInstance with id:   + vimInstance.getId());\n    }\n}", 
            "title": "Create a VimInstance using the SDK"
        }, 
        {
            "location": "/how-to-register-event/", 
            "text": "How to register to NFVO Events\n\n\nThe Open Baton platform can be easily extended by writing new external modules that can \"react\" on some events happening in the system. We already showed how to trigger some operations to the NFVO in the page regarding the \nNFVO sdk\n. In this short tutorial we will show how to write an external module aware of the NFV environment managed by Open Baton. The NFVO sdk already gives the tools for registering to events, so the first steps are the same of the \nNFVO sdk\n page.\n\n\nInside the project folder create a \nbuild.gradle\n file as follows:\n\n\ngroup 'org.openbaton'\nversion '1.0-SNAPSHOT'\n\napply plugin: 'java'\n\nrepositories {\n    mavenCentral()\n    /**\n     * Only needed for openbaton snapshots dependencies\n     */\n    maven {\n        url 'https://oss.sonatype.org/content/repositories/snapshots/'\n    }\n}\n\ndependencies {\n    compile 'org.openbaton:sdk:3.2.0'\n}\n\n\n\n\nThe main idea behind the event mechanism is that you can register the endpoint where you want to receive the event. We are supporting at the moment two different kind of endpoint, ReST or Amqp. In this example we are using the ReST type. For doing that you need to create \nEventEndpoint\n object to be sent to the NFVO using the NFVORequestor. In the project folder create a .java as the following example.\n\n\npackage org.openbaton.event.module.main;\n\nimport org.openbaton.catalogue.nfvo.Action;\nimport org.openbaton.catalogue.nfvo.EndpointType;\nimport org.openbaton.catalogue.nfvo.EventEndpoint;\nimport org.openbaton.sdk.NFVORequestor;\nimport org.openbaton.sdk.api.exception.SDKException;\nimport org.openbaton.sdk.api.rest.EventAgent;\n\n/**\n * Created by lto on 26/09/16.\n */\npublic class EventModule {\n\n  /**\n   * This is the Username used to connect to the NFVO\n   */\n  private static String obUsername = \nadmin\n;\n  /**\n   * This is the Password used to connect to the NFVO\n   */\n  private static String obPassword = \nopenbaton\n;\n  /**\n   * This is the Project ID used to connect to the NFVO\n   */\n  private static String obProjectId = \ncef9283a-de4b-47e3-a221-d1192ce9e5bd\n;\n  /**\n   * This must be true if during the NFVO installation the ssl was enabled\n   */\n  private static boolean isSslEnabled = false;\n  /**\n   * This is the NFVO Ip\n   */\n  private static String obNfvoIp = \n127.0.0.1\n;\n  /**\n   * This is the NFVO port\n   */\n  private static String obNfvoPort = \n8080\n;\n\n  public static void main(String[] args) {\n\n    NFVORequestor\n        requestor =\n        new NFVORequestor(obUsername, obPassword, obProjectId, isSslEnabled, obNfvoIp, obNfvoPort, \n1\n);\n\n    /*\n      Now the Event Agent needs to be retrieved\n     */\n    EventAgent eventAgent = requestor.getEventAgent();\n\n    /*\n      Define your endpoint\n     */\n    EventEndpoint eventEndpoint = new EventEndpoint();\n    eventEndpoint.setName(\nMyEvent\n);\n    eventEndpoint.setDescription(\nMy event endpoint\n);\n\n    /*\n      Register to all the event describing the correct instantiation of NSR\n     */\n    eventEndpoint.setEvent(Action.INSTANTIATE_FINISH);\n    eventEndpoint.setType(EndpointType.REST);\n    eventEndpoint.setEndpoint(\nhttp://127.0.0.1/event/module\n);\n\n    /*\n    It is also possible to filter the event based on the NSR id or the VNFR id. Putting to null means you want to\n    receive events for all NSR or VNFR. Please consider that the events refer or to a NSR or to a VNFR so you can\n    only filter by NSR id the events that are related to NSR, same for the VNFRs.\n     */\n    eventEndpoint.setNetworkServiceId(null);\n    eventEndpoint.setVirtualNetworkFunctionId(null);\n\n    /*\n      Now register the endpoint\n     */\n    try {\n      eventAgent.create(eventEndpoint);\n    } catch (SDKException e) {\n      e.printStackTrace();\n      System.err.println(\nGot an exception :(\n);\n    }\n  }\n}\n\n\n\n\n\nAs written in the comment, some events are related only to NSR and some other only to the VNFR. The following table describes all the events:\n\n\n\n\n\n\n\n\nEvent Type (Action)\n\n\nNSR or VNFR related (or both)\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nGRANT_OPERATION\n\n\nVNFR\n\n\nThe VNFR has finished the GRANT_OPERATION action\n\n\n\n\n\n\nSCALE_IN\n\n\nVNFR\n\n\nThe VNFR has finished the SCALE_IN action\n\n\n\n\n\n\nSCALE_OUT\n\n\nVNFR\n\n\nThe VNFR has finished the SCALE_OUT action\n\n\n\n\n\n\nERROR\n\n\nBoth\n\n\nThe VNFR or NSR went in ERROR state\n\n\n\n\n\n\nINSTANTIATE\n\n\nVNFR\n\n\nThe VNFR has finished the INSTANTIATE action\n\n\n\n\n\n\nMODIFY\n\n\nVNFR\n\n\nThe VNFR has finished the MODIFY action\n\n\n\n\n\n\nHEAL\n\n\nBoth\n\n\nThe VNFR has finished the HEAL action or the NSR has completed the healing procedure\n\n\n\n\n\n\nSCALED\n\n\nBoth\n\n\nThe VNFR has finished the SCALE_IN or SCALE_OUT action or the NSR has completed the scaling procedure\n\n\n\n\n\n\nRELEASE_RESOURCES_FINISH\n\n\nNSR\n\n\nThe NSR is completely removed\n\n\n\n\n\n\nINSTANTIATE_FINISH\n\n\nNSR\n\n\nThe NSR is correctly instantiated\n\n\n\n\n\n\nSTART\n\n\nVNFR\n\n\nThe VNFR has finished the START action\n\n\n\n\n\n\nSTOP\n\n\nVNFR\n\n\nThe VNFR has finished the STOP action\n\n\n\n\n\n\n\n\nIf the event is related to the NSR in the event payload you will receive the NSR object else you will receive the related VNFR. An example of ReST web server based on \nSpring\n follows.\n\n\npackage org.openbaton.event.module.rest;\n\nimport com.google.gson.Gson;\nimport com.google.gson.GsonBuilder;\nimport com.google.gson.JsonObject;\n\nimport org.openbaton.catalogue.mano.record.NetworkServiceRecord;\nimport org.openbaton.catalogue.mano.record.VirtualNetworkFunctionRecord;\nimport org.openbaton.catalogue.nfvo.Action;\nimport org.springframework.http.MediaType;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.bind.annotation.RestController;\n\n/**\n * Created by lto on 26/09/16.\n */\n@RestController\n@RequestMapping(\n/event/module\n)\npublic class RestApi {\n\n  private Gson gson = new GsonBuilder().setPrettyPrinting().create();\n\n  @RequestMapping(method = RequestMethod.POST, consumes = MediaType.APPLICATION_JSON_VALUE)\n  public void receiveEvent(@RequestBody String msg){\n    JsonObject event = new JsonParser().parse(msg).getAsJsonObject();\n    System.out.println(\nReceived event from NFVO:\\n\n + event);\n    String action = event.get(\naction\n).getAsString();\n    System.out.println(\nThe action is: \n + action);\n\n    switch (Action.valueOf(action)) {\n      case INSTANTIATE_FINISH: // this event is only related to NSR\n        NetworkServiceRecord networkServiceRecord = gson.fromJson(event.get(\npayload\n).getAsJsonObject(), NetworkServiceRecord.class);\n        break;\n      case START:\n        VirtualNetworkFunctionRecord virtualNetworkFunctionRecord = gson.fromJson(event.get(\npayload\n).getAsJsonObject(), VirtualNetworkFunctionRecord.class);\n        break;\n    }\n\n    /**\n     * execute the module business logic\n     */\n  }\n}\n\n\n\n\nAs shown in the example class, the payload is a json string converted to the NetworkServiceRecord or VirtualNetworkFunctionRecord depending on the event. Another note is that the NFVO calls a POST on the specified eventEndpoint (in this case \"http://172.0.0.1/event/module\"), for that reason the RestApi example class is listening on that path for a POST method.", 
            "title": "The Event Mechanism tutorial"
        }, 
        {
            "location": "/how-to-register-event/#how-to-register-to-nfvo-events", 
            "text": "The Open Baton platform can be easily extended by writing new external modules that can \"react\" on some events happening in the system. We already showed how to trigger some operations to the NFVO in the page regarding the  NFVO sdk . In this short tutorial we will show how to write an external module aware of the NFV environment managed by Open Baton. The NFVO sdk already gives the tools for registering to events, so the first steps are the same of the  NFVO sdk  page.  Inside the project folder create a  build.gradle  file as follows:  group 'org.openbaton'\nversion '1.0-SNAPSHOT'\n\napply plugin: 'java'\n\nrepositories {\n    mavenCentral()\n    /**\n     * Only needed for openbaton snapshots dependencies\n     */\n    maven {\n        url 'https://oss.sonatype.org/content/repositories/snapshots/'\n    }\n}\n\ndependencies {\n    compile 'org.openbaton:sdk:3.2.0'\n}  The main idea behind the event mechanism is that you can register the endpoint where you want to receive the event. We are supporting at the moment two different kind of endpoint, ReST or Amqp. In this example we are using the ReST type. For doing that you need to create  EventEndpoint  object to be sent to the NFVO using the NFVORequestor. In the project folder create a .java as the following example.  package org.openbaton.event.module.main;\n\nimport org.openbaton.catalogue.nfvo.Action;\nimport org.openbaton.catalogue.nfvo.EndpointType;\nimport org.openbaton.catalogue.nfvo.EventEndpoint;\nimport org.openbaton.sdk.NFVORequestor;\nimport org.openbaton.sdk.api.exception.SDKException;\nimport org.openbaton.sdk.api.rest.EventAgent;\n\n/**\n * Created by lto on 26/09/16.\n */\npublic class EventModule {\n\n  /**\n   * This is the Username used to connect to the NFVO\n   */\n  private static String obUsername =  admin ;\n  /**\n   * This is the Password used to connect to the NFVO\n   */\n  private static String obPassword =  openbaton ;\n  /**\n   * This is the Project ID used to connect to the NFVO\n   */\n  private static String obProjectId =  cef9283a-de4b-47e3-a221-d1192ce9e5bd ;\n  /**\n   * This must be true if during the NFVO installation the ssl was enabled\n   */\n  private static boolean isSslEnabled = false;\n  /**\n   * This is the NFVO Ip\n   */\n  private static String obNfvoIp =  127.0.0.1 ;\n  /**\n   * This is the NFVO port\n   */\n  private static String obNfvoPort =  8080 ;\n\n  public static void main(String[] args) {\n\n    NFVORequestor\n        requestor =\n        new NFVORequestor(obUsername, obPassword, obProjectId, isSslEnabled, obNfvoIp, obNfvoPort,  1 );\n\n    /*\n      Now the Event Agent needs to be retrieved\n     */\n    EventAgent eventAgent = requestor.getEventAgent();\n\n    /*\n      Define your endpoint\n     */\n    EventEndpoint eventEndpoint = new EventEndpoint();\n    eventEndpoint.setName( MyEvent );\n    eventEndpoint.setDescription( My event endpoint );\n\n    /*\n      Register to all the event describing the correct instantiation of NSR\n     */\n    eventEndpoint.setEvent(Action.INSTANTIATE_FINISH);\n    eventEndpoint.setType(EndpointType.REST);\n    eventEndpoint.setEndpoint( http://127.0.0.1/event/module );\n\n    /*\n    It is also possible to filter the event based on the NSR id or the VNFR id. Putting to null means you want to\n    receive events for all NSR or VNFR. Please consider that the events refer or to a NSR or to a VNFR so you can\n    only filter by NSR id the events that are related to NSR, same for the VNFRs.\n     */\n    eventEndpoint.setNetworkServiceId(null);\n    eventEndpoint.setVirtualNetworkFunctionId(null);\n\n    /*\n      Now register the endpoint\n     */\n    try {\n      eventAgent.create(eventEndpoint);\n    } catch (SDKException e) {\n      e.printStackTrace();\n      System.err.println( Got an exception :( );\n    }\n  }\n}  As written in the comment, some events are related only to NSR and some other only to the VNFR. The following table describes all the events:     Event Type (Action)  NSR or VNFR related (or both)  Description      GRANT_OPERATION  VNFR  The VNFR has finished the GRANT_OPERATION action    SCALE_IN  VNFR  The VNFR has finished the SCALE_IN action    SCALE_OUT  VNFR  The VNFR has finished the SCALE_OUT action    ERROR  Both  The VNFR or NSR went in ERROR state    INSTANTIATE  VNFR  The VNFR has finished the INSTANTIATE action    MODIFY  VNFR  The VNFR has finished the MODIFY action    HEAL  Both  The VNFR has finished the HEAL action or the NSR has completed the healing procedure    SCALED  Both  The VNFR has finished the SCALE_IN or SCALE_OUT action or the NSR has completed the scaling procedure    RELEASE_RESOURCES_FINISH  NSR  The NSR is completely removed    INSTANTIATE_FINISH  NSR  The NSR is correctly instantiated    START  VNFR  The VNFR has finished the START action    STOP  VNFR  The VNFR has finished the STOP action     If the event is related to the NSR in the event payload you will receive the NSR object else you will receive the related VNFR. An example of ReST web server based on  Spring  follows.  package org.openbaton.event.module.rest;\n\nimport com.google.gson.Gson;\nimport com.google.gson.GsonBuilder;\nimport com.google.gson.JsonObject;\n\nimport org.openbaton.catalogue.mano.record.NetworkServiceRecord;\nimport org.openbaton.catalogue.mano.record.VirtualNetworkFunctionRecord;\nimport org.openbaton.catalogue.nfvo.Action;\nimport org.springframework.http.MediaType;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.bind.annotation.RestController;\n\n/**\n * Created by lto on 26/09/16.\n */\n@RestController\n@RequestMapping( /event/module )\npublic class RestApi {\n\n  private Gson gson = new GsonBuilder().setPrettyPrinting().create();\n\n  @RequestMapping(method = RequestMethod.POST, consumes = MediaType.APPLICATION_JSON_VALUE)\n  public void receiveEvent(@RequestBody String msg){\n    JsonObject event = new JsonParser().parse(msg).getAsJsonObject();\n    System.out.println( Received event from NFVO:\\n  + event);\n    String action = event.get( action ).getAsString();\n    System.out.println( The action is:   + action);\n\n    switch (Action.valueOf(action)) {\n      case INSTANTIATE_FINISH: // this event is only related to NSR\n        NetworkServiceRecord networkServiceRecord = gson.fromJson(event.get( payload ).getAsJsonObject(), NetworkServiceRecord.class);\n        break;\n      case START:\n        VirtualNetworkFunctionRecord virtualNetworkFunctionRecord = gson.fromJson(event.get( payload ).getAsJsonObject(), VirtualNetworkFunctionRecord.class);\n        break;\n    }\n\n    /**\n     * execute the module business logic\n     */\n  }\n}  As shown in the example class, the payload is a json string converted to the NetworkServiceRecord or VirtualNetworkFunctionRecord depending on the event. Another note is that the NFVO calls a POST on the specified eventEndpoint (in this case \"http://172.0.0.1/event/module\"), for that reason the RestApi example class is listening on that path for a POST method.", 
            "title": "How to register to NFVO Events"
        }, 
        {
            "location": "/FAQ/", 
            "text": "Frequently Asked Questions (FAQ)\n\n\nQ1: What type of database is the NFVO using?\n\n\nThe NFVO uses Hibernate for managing transactions with a relational database. By default the NFVO is configured with an in memory database (HSQL). \nOther types of databases are supported, for instance MySQL. This can be changed directly from the configuration file, outcommenting the : \n\n\n# mysql jdbc\nspring.datasource.url=jdbc:mysql://localhost:3306/openbaton\nspring.datasource.driver-class-name=com.mysql.jdbc.Driver\nspring.jpa.database-platform=org.hibernate.dialect.MySQLDialect\n\n\n\n\nQ2: The EMS does not register to the VNFM and the connection timeouts\n\n\nDouble check that you configured correctly the \nopenbaton.properties\n with the correct IP of the host where the NFVO is running\n\n\n# The broker ip that needs to be reachable from all the components\nnfvo.rabbit.brokerIp = the broker ip here \n\n\n\n\n\n\n\n\n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "FAQ"
        }, 
        {
            "location": "/FAQ/#frequently-asked-questions-faq", 
            "text": "", 
            "title": "Frequently Asked Questions (FAQ)"
        }, 
        {
            "location": "/FAQ/#q1-what-type-of-database-is-the-nfvo-using", 
            "text": "The NFVO uses Hibernate for managing transactions with a relational database. By default the NFVO is configured with an in memory database (HSQL). \nOther types of databases are supported, for instance MySQL. This can be changed directly from the configuration file, outcommenting the :   # mysql jdbc\nspring.datasource.url=jdbc:mysql://localhost:3306/openbaton\nspring.datasource.driver-class-name=com.mysql.jdbc.Driver\nspring.jpa.database-platform=org.hibernate.dialect.MySQLDialect", 
            "title": "Q1: What type of database is the NFVO using?"
        }, 
        {
            "location": "/FAQ/#q2-the-ems-does-not-register-to-the-vnfm-and-the-connection-timeouts", 
            "text": "Double check that you configured correctly the  openbaton.properties  with the correct IP of the host where the NFVO is running  # The broker ip that needs to be reachable from all the components\nnfvo.rabbit.brokerIp = the broker ip here    \n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Q2: The EMS does not register to the VNFM and the connection timeouts"
        }, 
        {
            "location": "/tosca-iperf-scenario/", 
            "text": "TOSCA Iperf Scenario\n\n\nThe definition follows the TOSCA Simple Profile for Network Functions Virtualization (NFV) \nVersion 1.0\n. Information about creating a complete TOSCA Template from scratch can be found in this \ntutorial\n.\n\n\nThis tutorial explains how to deploy a network service that uses iPerf. \niPerf\n is a tool for active measurements of the maximum achievable bandwidth between two or more machines.\nThis tutorial makes use of:\n\n\n\n\nGeneric VNFM (\ngeneric-vnfm\n)\n\n\nGeneric EMS (\ngeneric ems\n)\n\n\nOpenStack plugin (\nopenstack-plugin\n)\n\n\n\n\nRequirements\n\n\nIn order to execute this scenario, you need to have the following components up and running:\n\n\n\n\nThe NFVO\n\n\nthe OpenStack plugin\n\n\nthe Generic VNFM (includes already generic EMS)\n\n\na PoP (of type openstack) registered. You can use the following \njson descriptor\n by changing the values to your needs.\n\n\n\n\nMore information about the Iperf Scenario \nhere\n.\n\n\nComplete Example\n\n\ntosca_definitions_version: tosca_simple_profile_for_nfv_1_0\ndescription: Example of NSD\n\nmetadata:\n  ID: NSD-Iperf+FloatingIps\n  vendor: Fokus\n  version: 1.0\n\ntopology_template:\n\n  node_templates:\n\n    iperf-server: #VNF1\n        type: openbaton.type.VNF\n        properties:\n          vendor: Fokus\n          version: 1.0\n          endpoint: generic\n          type: server\n          vnfPackageLocation: https://github.com/openbaton/vnf-scripts.git\n          deploymentFlavour:\n            - flavour_key: m1.small\n        requirements:\n          - virtualLink: private\n          - vdu: VDU2        \n        interfaces:\n          lifecycle: # lifecycle\n            INSTANTIATE:\n              - install.sh\n              - install-srv.sh\n\n    iperf-client:\n      type: openbaton.type.VNF\n      properties:\n        ID: x\n        vendor: Fokus\n        version: 1.0\n        type: client\n        vnfPackageLocation: https://github.com/openbaton/vnf-scripts.git\n        deploymentFlavour:\n          - flavour_key: m1.small\n        endpoint: generic\n      requirements:\n         - virtualLink: private\n         - vdu: VDU1\n      interfaces:\n          lifecycle: # lifecycle\n            INSTANTIATE:\n              - install.sh\n            CONFIGURE:\n              - server_configure.sh\n\n    VDU1:\n      type: tosca.nodes.nfv.VDU\n      properties:\n        scale_in_out: 1\n      artifacts:\n        VDU1Image:\n          type: tosca.artifacts.Deployment.Image.VM\n          file: ubuntu-14.04-server-cloudimg-amd64-disk1\n\n    VDU2:\n      type: tosca.nodes.nfv.VDU\n      properties:\n        scale_in_out: 3\n      artifacts:\n        VDU1Image:\n          type: tosca.artifacts.Deployment.Image.VM\n          file: ubuntu-14.04-server-cloudimg-amd64-disk1\n\n    CP1:\n      type: tosca.nodes.nfv.CP\n      properties:\n        floatingIP: random\n      requirements:\n        - virtualBinding: VDU1\n        - virtualLink: private\n\n    CP2: #endpoints of VNF2\n      type: tosca.nodes.nfv.CP\n      requirements:\n        - virtualBinding: VDU2\n        - virtualLink: private\n\n    private:\n      type: tosca.nodes.nfv.VL\n      properties:\n        vendor: Fokus\n\nrelationships_template:\n  connection_server_client: \n    type: tosca.nodes.relationships.ConnectsTo\n    source: iperf-server\n    target: iperf-client\n    parameters:\n        - private\n\n\n\n\n\nNOTE\n: Save the definition in a file called iperf-floating-ips.yaml.\n\n\nOnboarding\n\n\nThe Iperf Template can be added used in \nCSAR\n and onboarded using the \nDashboard\n.\n\n\n\n\n\n\n\n\n\n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "**HIDDEN**"
        }, 
        {
            "location": "/tosca-iperf-scenario/#tosca-iperf-scenario", 
            "text": "The definition follows the TOSCA Simple Profile for Network Functions Virtualization (NFV)  Version 1.0 . Information about creating a complete TOSCA Template from scratch can be found in this  tutorial .  This tutorial explains how to deploy a network service that uses iPerf.  iPerf  is a tool for active measurements of the maximum achievable bandwidth between two or more machines.\nThis tutorial makes use of:   Generic VNFM ( generic-vnfm )  Generic EMS ( generic ems )  OpenStack plugin ( openstack-plugin )", 
            "title": "TOSCA Iperf Scenario"
        }, 
        {
            "location": "/tosca-iperf-scenario/#requirements", 
            "text": "In order to execute this scenario, you need to have the following components up and running:   The NFVO  the OpenStack plugin  the Generic VNFM (includes already generic EMS)  a PoP (of type openstack) registered. You can use the following  json descriptor  by changing the values to your needs.   More information about the Iperf Scenario  here .", 
            "title": "Requirements"
        }, 
        {
            "location": "/tosca-iperf-scenario/#complete-example", 
            "text": "tosca_definitions_version: tosca_simple_profile_for_nfv_1_0\ndescription: Example of NSD\n\nmetadata:\n  ID: NSD-Iperf+FloatingIps\n  vendor: Fokus\n  version: 1.0\n\ntopology_template:\n\n  node_templates:\n\n    iperf-server: #VNF1\n        type: openbaton.type.VNF\n        properties:\n          vendor: Fokus\n          version: 1.0\n          endpoint: generic\n          type: server\n          vnfPackageLocation: https://github.com/openbaton/vnf-scripts.git\n          deploymentFlavour:\n            - flavour_key: m1.small\n        requirements:\n          - virtualLink: private\n          - vdu: VDU2        \n        interfaces:\n          lifecycle: # lifecycle\n            INSTANTIATE:\n              - install.sh\n              - install-srv.sh\n\n    iperf-client:\n      type: openbaton.type.VNF\n      properties:\n        ID: x\n        vendor: Fokus\n        version: 1.0\n        type: client\n        vnfPackageLocation: https://github.com/openbaton/vnf-scripts.git\n        deploymentFlavour:\n          - flavour_key: m1.small\n        endpoint: generic\n      requirements:\n         - virtualLink: private\n         - vdu: VDU1\n      interfaces:\n          lifecycle: # lifecycle\n            INSTANTIATE:\n              - install.sh\n            CONFIGURE:\n              - server_configure.sh\n\n    VDU1:\n      type: tosca.nodes.nfv.VDU\n      properties:\n        scale_in_out: 1\n      artifacts:\n        VDU1Image:\n          type: tosca.artifacts.Deployment.Image.VM\n          file: ubuntu-14.04-server-cloudimg-amd64-disk1\n\n    VDU2:\n      type: tosca.nodes.nfv.VDU\n      properties:\n        scale_in_out: 3\n      artifacts:\n        VDU1Image:\n          type: tosca.artifacts.Deployment.Image.VM\n          file: ubuntu-14.04-server-cloudimg-amd64-disk1\n\n    CP1:\n      type: tosca.nodes.nfv.CP\n      properties:\n        floatingIP: random\n      requirements:\n        - virtualBinding: VDU1\n        - virtualLink: private\n\n    CP2: #endpoints of VNF2\n      type: tosca.nodes.nfv.CP\n      requirements:\n        - virtualBinding: VDU2\n        - virtualLink: private\n\n    private:\n      type: tosca.nodes.nfv.VL\n      properties:\n        vendor: Fokus\n\nrelationships_template:\n  connection_server_client: \n    type: tosca.nodes.relationships.ConnectsTo\n    source: iperf-server\n    target: iperf-client\n    parameters:\n        - private  NOTE : Save the definition in a file called iperf-floating-ips.yaml.", 
            "title": "Complete Example"
        }, 
        {
            "location": "/tosca-iperf-scenario/#onboarding", 
            "text": "The Iperf Template can be added used in  CSAR  and onboarded using the  Dashboard .    \n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Onboarding"
        }, 
        {
            "location": "/tosca-CSAR-onboarding/", 
            "text": "TOSCA CSAR on-boarding\n\n\nThis tutorial is more advanced and expects that you already know what TOSCA is and how Virtual Network Function Descriptor or Network Service Descriptor defined in the TOSCA format is structured.\nThe Cloud Service Archive \nCSAR\n is a package defined by OASIS TOSCA. It is a compressed file that includes a TOSCA template of a Network Service, and all the scripts or files that a VNF needs for the lifecycle time from creation to termination.\nThe CSAR is a zip file with this structure:\n\n\n\u251c\u2500\u2500 Definitions\n|   \u2514\u2500\u2500 testNSDiperf.yaml\n\u251c\u2500\u2500 Scripts\n|   \u251c\u2500\u2500 install.sh   \n|   \u2514\u2500\u2500 (VNF NAME)\n|        \u2514\u2500\u2500 script.sh \n\u2514\u2500\u2500 TOSCA-Metadata\n    \u251c\u2500\u2500 Metadata.yaml\n    \u2514\u2500\u2500 TOSCA.meta\n\n\n\n\n\nThe CSAR reader can read both NSDs and VNFDs written in TOSCA. The difference being that when reading a NSD it will onboard all VNFs included in the NSD and after that the NSD itself.\n\n\nThe \nTOSCA.meta\n file must contain the reference to the template in this case \nEntry-Definitions: Definitions/testNSDIperf.yaml\n. An optional feature is to define the vm image here in the metadata. It is easier to add it here one time instead of adding it multiple times in the template.\n\n\nTOSCA-Meta-File-Version: 1.0\nCSAR-Version: 1.1\nCreated-By: Fokus\nEntry-Definitions: Definitions/testNSDIperf.yaml\n\n\n\n\nThe \nMetadata.yaml\n defines essential properties for the VNF or VNFs and every CSAR has to include one. For more information on how to create such a file refer to the \nVNF Package tutorial\n. This is a simple example:\n\n\nname: NSDExample\nimage:\n    upload: false\n    names:\n        - ubuntu-14.04-server-cloudimg-amd64-disk1\nvim_types:\n    - openstack\n\n\n\n\nThe \nScripts\n folder contains all the files required from the lifecycle interfaces of the VNFs.\nIf the CSAR has a Network Service Template, then for every type of VNF included in the NS Template you have to include a folder with the scripts for that particular type.\nExample if one VNF is of type client, then the scripts for that VNF have to be put in Scripts/client folder. \n\n\nIn this example \ntestNSDIperf.yaml\n is a template for a Network Service. \nIn a CSAR the template can define either a Virtual Network Function or a Network Service that consists of multiple Virtual Network Functions. \nThe \nVNF Tosca tutorial\n and \nNS Tosca tutorial\n provide more information on how to construct a template of each kind. \n\n\ntosca_definitions_version: tosca_simple_profile_for_nfv_1_0\ndescription: Example of NSD\n\nmetadata:\n  ID: NSD-Iperf\n  vendor: Fokus\n  version: 1.0\n\ntopology_template:\n\n  node_templates:\n\n    iperf-server: #VNF1\n        type: openbaton.type.VNF\n        properties:\n          vendor: Fokus\n          version: 1.0\n          endpoint: generic\n          type: server\n          vnfPackageLocation: https://github.com/openbaton/vnf-scripts.git\n          deploymentFlavour:\n            - flavour_key: m1.small\n        requirements:\n          - virtualLink: private\n          - vdu: VDU2\n        interfaces:\n          lifecycle: # lifecycle\n            instantiate:\n              - install.sh\n              - install-srv.sh\n\n    iperf-client:\n      type: openbaton.type.VNF\n      properties:\n        ID: x\n        vendor: Fokus\n        version: 1.0\n        type: client\n        vnfPackageLocation: https://github.com/openbaton/vnf-scripts.git\n        deploymentFlavour:\n          - flavour_key: m1.small\n        endpoint: generic\n      requirements:\n         - virtualLink: private\n         - vdu: VDU1\n      interfaces:\n          lifecycle: # lifecycle\n            INSTANTIATE:\n              - install.sh\n            CONFIGURE:\n              - server_configure.sh\n\n    VDU1:\n      type: tosca.nodes.nfv.VDU\n      properties:\n        scale_in_out: 1\n      artifacts:\n        VDU1Image:\n          type: tosca.artifacts.Deployment.Image.VM\n          file: ubuntu-14.04-server-cloudimg-amd64-disk1\n\n    VDU2:\n      type: tosca.nodes.nfv.VDU\n      properties:\n        scale_in_out: 3\n      requirements:\n        - virtual_link: CP2\n      artifacts:\n        VDU1Image:\n          type: tosca.artifacts.Deployment.Image.VM\n          file: ubuntu-14.04-server-cloudimg-amd64-disk1\n\n    CP1:\n      type: tosca.nodes.nfv.CP\n      properties:\n        floatingIP: random\n      requirements:\n        - virtualBinding: VDU1\n        - virtualLink: private\n\n    CP2: #endpoints of VNF2\n      type: tosca.nodes.nfv.CP\n      requirements:\n        - virtualBinding: VDU2\n        - virtualLink: private\n\n    private:\n      type: tosca.nodes.nfv.VL\n      properties:\n        vendor: Fokus\n\nrelationships_template:\n  connection_server_client:\n    type: tosca.nodes.relationships.ConnectsTo\n    source: iperf-server\n    target: iperf-client\n    parameters:\n        - private\n\n\n\n\n\nSaving as CSAR\n\n\nTo save the three folders - Scripts, Definitions, TOSCA-Metadata as a CSAR go to the folder where you have saved them and run:\n\n\nzip -r iperf.csar . -x \n.*\n -x \n*/.*\n\n\n\n\n\nOnboarding VNF CSARs\n\n\nGo to the Catalogue -\n VNF Packages -\n Upload VNFPackage, check the \"Use CSAR Parser\" box and select the csar that you want to upload.\n\n\n \n\n\nOnboard Network Service CSARs\n\n\nGo to the Catalogue -\n NS Descriptors and click on \"Upload CSAR NSD\" and select the file.\n\n\n\n\n\n\n\n\n\n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "**HIDDEN**"
        }, 
        {
            "location": "/tosca-CSAR-onboarding/#tosca-csar-on-boarding", 
            "text": "This tutorial is more advanced and expects that you already know what TOSCA is and how Virtual Network Function Descriptor or Network Service Descriptor defined in the TOSCA format is structured.\nThe Cloud Service Archive  CSAR  is a package defined by OASIS TOSCA. It is a compressed file that includes a TOSCA template of a Network Service, and all the scripts or files that a VNF needs for the lifecycle time from creation to termination.\nThe CSAR is a zip file with this structure:  \u251c\u2500\u2500 Definitions\n|   \u2514\u2500\u2500 testNSDiperf.yaml\n\u251c\u2500\u2500 Scripts\n|   \u251c\u2500\u2500 install.sh   \n|   \u2514\u2500\u2500 (VNF NAME)\n|        \u2514\u2500\u2500 script.sh \n\u2514\u2500\u2500 TOSCA-Metadata\n    \u251c\u2500\u2500 Metadata.yaml\n    \u2514\u2500\u2500 TOSCA.meta  The CSAR reader can read both NSDs and VNFDs written in TOSCA. The difference being that when reading a NSD it will onboard all VNFs included in the NSD and after that the NSD itself.  The  TOSCA.meta  file must contain the reference to the template in this case  Entry-Definitions: Definitions/testNSDIperf.yaml . An optional feature is to define the vm image here in the metadata. It is easier to add it here one time instead of adding it multiple times in the template.  TOSCA-Meta-File-Version: 1.0\nCSAR-Version: 1.1\nCreated-By: Fokus\nEntry-Definitions: Definitions/testNSDIperf.yaml  The  Metadata.yaml  defines essential properties for the VNF or VNFs and every CSAR has to include one. For more information on how to create such a file refer to the  VNF Package tutorial . This is a simple example:  name: NSDExample\nimage:\n    upload: false\n    names:\n        - ubuntu-14.04-server-cloudimg-amd64-disk1\nvim_types:\n    - openstack  The  Scripts  folder contains all the files required from the lifecycle interfaces of the VNFs.\nIf the CSAR has a Network Service Template, then for every type of VNF included in the NS Template you have to include a folder with the scripts for that particular type.\nExample if one VNF is of type client, then the scripts for that VNF have to be put in Scripts/client folder.   In this example  testNSDIperf.yaml  is a template for a Network Service. \nIn a CSAR the template can define either a Virtual Network Function or a Network Service that consists of multiple Virtual Network Functions. \nThe  VNF Tosca tutorial  and  NS Tosca tutorial  provide more information on how to construct a template of each kind.   tosca_definitions_version: tosca_simple_profile_for_nfv_1_0\ndescription: Example of NSD\n\nmetadata:\n  ID: NSD-Iperf\n  vendor: Fokus\n  version: 1.0\n\ntopology_template:\n\n  node_templates:\n\n    iperf-server: #VNF1\n        type: openbaton.type.VNF\n        properties:\n          vendor: Fokus\n          version: 1.0\n          endpoint: generic\n          type: server\n          vnfPackageLocation: https://github.com/openbaton/vnf-scripts.git\n          deploymentFlavour:\n            - flavour_key: m1.small\n        requirements:\n          - virtualLink: private\n          - vdu: VDU2\n        interfaces:\n          lifecycle: # lifecycle\n            instantiate:\n              - install.sh\n              - install-srv.sh\n\n    iperf-client:\n      type: openbaton.type.VNF\n      properties:\n        ID: x\n        vendor: Fokus\n        version: 1.0\n        type: client\n        vnfPackageLocation: https://github.com/openbaton/vnf-scripts.git\n        deploymentFlavour:\n          - flavour_key: m1.small\n        endpoint: generic\n      requirements:\n         - virtualLink: private\n         - vdu: VDU1\n      interfaces:\n          lifecycle: # lifecycle\n            INSTANTIATE:\n              - install.sh\n            CONFIGURE:\n              - server_configure.sh\n\n    VDU1:\n      type: tosca.nodes.nfv.VDU\n      properties:\n        scale_in_out: 1\n      artifacts:\n        VDU1Image:\n          type: tosca.artifacts.Deployment.Image.VM\n          file: ubuntu-14.04-server-cloudimg-amd64-disk1\n\n    VDU2:\n      type: tosca.nodes.nfv.VDU\n      properties:\n        scale_in_out: 3\n      requirements:\n        - virtual_link: CP2\n      artifacts:\n        VDU1Image:\n          type: tosca.artifacts.Deployment.Image.VM\n          file: ubuntu-14.04-server-cloudimg-amd64-disk1\n\n    CP1:\n      type: tosca.nodes.nfv.CP\n      properties:\n        floatingIP: random\n      requirements:\n        - virtualBinding: VDU1\n        - virtualLink: private\n\n    CP2: #endpoints of VNF2\n      type: tosca.nodes.nfv.CP\n      requirements:\n        - virtualBinding: VDU2\n        - virtualLink: private\n\n    private:\n      type: tosca.nodes.nfv.VL\n      properties:\n        vendor: Fokus\n\nrelationships_template:\n  connection_server_client:\n    type: tosca.nodes.relationships.ConnectsTo\n    source: iperf-server\n    target: iperf-client\n    parameters:\n        - private", 
            "title": "TOSCA CSAR on-boarding"
        }, 
        {
            "location": "/tosca-CSAR-onboarding/#saving-as-csar", 
            "text": "To save the three folders - Scripts, Definitions, TOSCA-Metadata as a CSAR go to the folder where you have saved them and run:  zip -r iperf.csar . -x  .*  -x  */.*", 
            "title": "Saving as CSAR"
        }, 
        {
            "location": "/tosca-CSAR-onboarding/#onboarding-vnf-csars", 
            "text": "Go to the Catalogue -  VNF Packages -  Upload VNFPackage, check the \"Use CSAR Parser\" box and select the csar that you want to upload.", 
            "title": "Onboarding VNF CSARs"
        }, 
        {
            "location": "/tosca-CSAR-onboarding/#onboard-network-service-csars", 
            "text": "Go to the Catalogue -  NS Descriptors and click on \"Upload CSAR NSD\" and select the file.    \n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Onboard Network Service CSARs"
        }, 
        {
            "location": "/vnf-descriptor/", 
            "text": "Virtual Network Function Descriptor\n\n\nThe VirtualNetworkFunctionDescriptor is contained inside the Network Service Descriptor (NSD). It is a json file and is defined as follows:\n\n\n{  \n    \nvendor\n:\nfokus\n,\n    \nversion\n:\n0.2\n,\n    \nname\n:\niperf-server\n,\n    \ntype\n:\nserver\n,\n    \nendpoint\n:\ngeneric\n,\n    \nconfigurations\n:{\n        \nname\n:\nconfig_name\n,\n        \nconfigurationParameters\n:[\n        {\n            \nconfKey\n:\nkey\n,\n            \nvalue\n:\nvalue\n\n        }\n        ]\n    },\n    \nvdu\n:[  \n        {  \n            \nvm_image\n:[  \n                \nubuntu-14.04-server-cloudimg-amd64-disk1\n\n            ],\n            \nvimInstanceName\n:[\nvim-instance\n],\n            \nscale_in_out\n:2,\n            \nvnfc\n:[  \n                {  \n                    \nconnection_point\n:[  \n                        {  \n                            \nfloatingIp\n:\nrandom\n,\n                            \nvirtual_link_reference\n:\nprivate\n,\n                            \ninterfaceId\n:0\n                        }\n                    ]\n                }\n            ]\n        }\n    ],\n    \nvirtual_link\n:[  \n        {  \n            \nname\n:\nprivate\n\n        }\n    ],\n    \nlifecycle_event\n:[  \n        {  \n            \nevent\n:\nINSTANTIATE\n,\n            \nlifecycle_events\n:[  \n                \ninstall.sh\n,\n                \ninstall-srv.sh\n\n            ]\n        }\n    ],\n    \ndeployment_flavour\n:[  \n        {  \n            \nflavour_key\n:\nm1.small\n\n        }\n    ],\n    \nvnfPackageLocation\n:\nlink_to_gitrepo\n,\n    \nrequires\n:{\n        \nserver\n:{\n            \nparameters\n:[\nnetname_floatingIp\n]\n        }\n    }\n}\n\n\n\n\n\n\n\n\n\n\nParams\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\nname\n\n\nThe name to give to the VirtualNetworkFunctionDescriptor\n\n\n\n\n\n\nvendor\n\n\nThe vendor creating this VirtualNetworkFunctionDescriptor\n\n\n\n\n\n\nversion\n\n\nThe version of the VirtualNetworkFunctionDescriptor (can be any string)\n\n\n\n\n\n\ntype\n\n\nThe type of the VirtualNetworkFunctionDescriptor (can be any string) and it is used in the dependency parameters in the scripts\n\n\n\n\n\n\nendpoint\n\n\nThe endpoint of the VirtualNetworkFunctionDescriptor (can be any string) needs to point to a registered VnfManager\n\n\n\n\n\n\n\n\nThe other most important parameters are described in the following sections.\n\n\nVirtual Deployment Unit (VDU)\n\n\n\n\n\n\n\n\nParams\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\nvm_image\n\n\nThe list of image names or ids existing in the VimInstance or in the VNF Package\n\n\n\n\n\n\nvimInstanceName\n\n\nThe list of VimInstances. Only one of it will be chosen, randomly\n\n\n\n\n\n\nscale_in_out\n\n\nThe maximum number of instances (VMs) which can be created to support scale out/in.\n\n\n\n\n\n\nvnfc\n\n\nThis field contains a list of VNFComponents which will be deployed for this VNFD.\n\n\n\n\n\n\n\n\nVNFC\n\n\nAfter launching a network service, every VNFComponent will run on a separate virtual machine. If scaling is enabled by the scale_in_out field in the VDU, the number of instantiated VNFCs can increase.\nVNFCs contain the following fields:\n\n\n\n\n\n\n\n\nParams\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\nconnection_point\n\n\neach connection point is a reference to an Internal Virtual Link (see Connection Point at \nETSI NFV\n). Moreover you can specify a floatingIp to be assigned to this connection point in the form \"192.168.0.123\". Please be aware of the fact that the NFVO will try to allocate this IP from the external network associated to the tenant. Therefore it is important to have an already configured external network before making use of floating IPs. The possible values are the actual floatingip ip or \"random\" if no preference is specified. If omitted no floatingip will be assigned. Optionally, the ethernet interface to be attached to a specific network can be chosen through the \ninterfaceId\n. The interfaceId have to be a numeric value and is used while sorting the list of networks.\n\n\n\n\n\n\n\n\nConfigurations\n\n\nThe configuration object contains a list of parameters defined by key, value that can be used in the scripts (see \nVNF Parameters\n).\n\n\nVirtual Link (aka Internal Virtual Link)\n\n\nThe Internal Virtual Link points to a Virtual Link Descriptor defined in the Network Service Descriptor.\n\n\nNote:\n at the moment there are no difference between internal and external VL. All the available networks should be specified in the NSD-\nVLD, then in the VNFD-\nVL you specify which networks you want to use.\nFinally in the VNFD-\nVDU-\nVNFC-\nconnection_point you can specify which network to attach among those available in VNFD-\nVL. The virtual_link_reference parameter also must be filled with the exact same links.\n\n\nLifecycle Events\n\n\nA lifecycle event is composed by an Event and a list of strings that correspond to the script names needed to be run in that particular Event.\nCurrently supported events are:\n\n\n\n\n\n\n\n\nEvent name\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nINSTANTIATE\n\n\n...\n\n\n\n\n\n\nCONFIGURE\n\n\n...\n\n\n\n\n\n\nSTART\n\n\n...\n\n\n\n\n\n\nTERMINATE\n\n\n...\n\n\n\n\n\n\nSCALE_IN\n\n\n...\n\n\n\n\n\n\n\n\nThe VNF events state machine follows the  state diagram for the VNFR (and NSR) displayed in \nthis slide\n \n\n\nDeployment Flavour\n\n\nA delpoyment flavour corresponds to a flavour name existing in the VimInstance.\nFor example if you are using Openstack as Vim, the flavour_key parameter shall correspond to a \nflavour name of Openstack\n (e.q. m1.small).\n\n\nProvides\n\n\nThis list of parameter names defines the parameters that the VnfManager will fill at runtime. For that reason they have a meaning only if you \nwrite your own VnfManager\n. These parameters are then available in any scripts. For the usage of the parameters, please, refer to \nHow to use the parameters\n page.\n\n\nRequires\n\n\nThe requires field provides an alternative method for defining VNF dependencies. The regular way is to define VNF dependencies in the Network Service Descriptor by defining the source, target and parameters of the dependency. But you can also use the requires field in the VNFD to achieve the same result. Let's look at an example to understand how to do this. Here is a VNF dependency defined in the classic way. \n\n\n...\n\nvnf_dependency\n:[\n        {\n            \nsource\n:{\n                \nname\n:\nserver\n\n            },\n            \ntarget\n:{\n                \nname\n:\nclient\n\n            },\n            \nparameters\n:[\n                \nnetname_floatingIp\n\n            ]\n        }\n]\n...\n\n\n\n\nThis creates a VNF dependency that provides the floating ip of the VNFD with the type server to the VNFD with the type client. \nThe same can be done by writing the following in the requires field of the VNFD with type client: \n\n\n...\n\nrequires\n:{\n    \nserver\n:{\n        \nparameters\n:[\nnetname_floatingIp\n]\n    }\n}\n...\n\n\n\n\nThe \n\"server\"\n field specifies that the source of the dependency is the VNFD with the type server. The target is the VNFD that contains the requires field, in this case the VNFD with type client. \n\n\n\n\n\n\n\n\n\n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "**HIDDEN**"
        }, 
        {
            "location": "/vnf-descriptor/#virtual-network-function-descriptor", 
            "text": "The VirtualNetworkFunctionDescriptor is contained inside the Network Service Descriptor (NSD). It is a json file and is defined as follows:  {  \n     vendor : fokus ,\n     version : 0.2 ,\n     name : iperf-server ,\n     type : server ,\n     endpoint : generic ,\n     configurations :{\n         name : config_name ,\n         configurationParameters :[\n        {\n             confKey : key ,\n             value : value \n        }\n        ]\n    },\n     vdu :[  \n        {  \n             vm_image :[  \n                 ubuntu-14.04-server-cloudimg-amd64-disk1 \n            ],\n             vimInstanceName :[ vim-instance ],\n             scale_in_out :2,\n             vnfc :[  \n                {  \n                     connection_point :[  \n                        {  \n                             floatingIp : random ,\n                             virtual_link_reference : private ,\n                             interfaceId :0\n                        }\n                    ]\n                }\n            ]\n        }\n    ],\n     virtual_link :[  \n        {  \n             name : private \n        }\n    ],\n     lifecycle_event :[  \n        {  \n             event : INSTANTIATE ,\n             lifecycle_events :[  \n                 install.sh ,\n                 install-srv.sh \n            ]\n        }\n    ],\n     deployment_flavour :[  \n        {  \n             flavour_key : m1.small \n        }\n    ],\n     vnfPackageLocation : link_to_gitrepo ,\n     requires :{\n         server :{\n             parameters :[ netname_floatingIp ]\n        }\n    }\n}     Params  Meaning      name  The name to give to the VirtualNetworkFunctionDescriptor    vendor  The vendor creating this VirtualNetworkFunctionDescriptor    version  The version of the VirtualNetworkFunctionDescriptor (can be any string)    type  The type of the VirtualNetworkFunctionDescriptor (can be any string) and it is used in the dependency parameters in the scripts    endpoint  The endpoint of the VirtualNetworkFunctionDescriptor (can be any string) needs to point to a registered VnfManager     The other most important parameters are described in the following sections.", 
            "title": "Virtual Network Function Descriptor"
        }, 
        {
            "location": "/vnf-descriptor/#virtual-deployment-unit-vdu", 
            "text": "Params  Meaning      vm_image  The list of image names or ids existing in the VimInstance or in the VNF Package    vimInstanceName  The list of VimInstances. Only one of it will be chosen, randomly    scale_in_out  The maximum number of instances (VMs) which can be created to support scale out/in.    vnfc  This field contains a list of VNFComponents which will be deployed for this VNFD.", 
            "title": "Virtual Deployment Unit (VDU)"
        }, 
        {
            "location": "/vnf-descriptor/#vnfc", 
            "text": "After launching a network service, every VNFComponent will run on a separate virtual machine. If scaling is enabled by the scale_in_out field in the VDU, the number of instantiated VNFCs can increase.\nVNFCs contain the following fields:     Params  Meaning      connection_point  each connection point is a reference to an Internal Virtual Link (see Connection Point at  ETSI NFV ). Moreover you can specify a floatingIp to be assigned to this connection point in the form \"192.168.0.123\". Please be aware of the fact that the NFVO will try to allocate this IP from the external network associated to the tenant. Therefore it is important to have an already configured external network before making use of floating IPs. The possible values are the actual floatingip ip or \"random\" if no preference is specified. If omitted no floatingip will be assigned. Optionally, the ethernet interface to be attached to a specific network can be chosen through the  interfaceId . The interfaceId have to be a numeric value and is used while sorting the list of networks.", 
            "title": "VNFC"
        }, 
        {
            "location": "/vnf-descriptor/#configurations", 
            "text": "The configuration object contains a list of parameters defined by key, value that can be used in the scripts (see  VNF Parameters ).", 
            "title": "Configurations"
        }, 
        {
            "location": "/vnf-descriptor/#virtual-link-aka-internal-virtual-link", 
            "text": "The Internal Virtual Link points to a Virtual Link Descriptor defined in the Network Service Descriptor.  Note:  at the moment there are no difference between internal and external VL. All the available networks should be specified in the NSD- VLD, then in the VNFD- VL you specify which networks you want to use.\nFinally in the VNFD- VDU- VNFC- connection_point you can specify which network to attach among those available in VNFD- VL. The virtual_link_reference parameter also must be filled with the exact same links.", 
            "title": "Virtual Link (aka Internal Virtual Link)"
        }, 
        {
            "location": "/vnf-descriptor/#lifecycle-events", 
            "text": "A lifecycle event is composed by an Event and a list of strings that correspond to the script names needed to be run in that particular Event.\nCurrently supported events are:     Event name  Description      INSTANTIATE  ...    CONFIGURE  ...    START  ...    TERMINATE  ...    SCALE_IN  ...     The VNF events state machine follows the  state diagram for the VNFR (and NSR) displayed in  this slide", 
            "title": "Lifecycle Events"
        }, 
        {
            "location": "/vnf-descriptor/#deployment-flavour", 
            "text": "A delpoyment flavour corresponds to a flavour name existing in the VimInstance.\nFor example if you are using Openstack as Vim, the flavour_key parameter shall correspond to a  flavour name of Openstack  (e.q. m1.small).", 
            "title": "Deployment Flavour"
        }, 
        {
            "location": "/vnf-descriptor/#provides", 
            "text": "This list of parameter names defines the parameters that the VnfManager will fill at runtime. For that reason they have a meaning only if you  write your own VnfManager . These parameters are then available in any scripts. For the usage of the parameters, please, refer to  How to use the parameters  page.", 
            "title": "Provides"
        }, 
        {
            "location": "/vnf-descriptor/#requires", 
            "text": "The requires field provides an alternative method for defining VNF dependencies. The regular way is to define VNF dependencies in the Network Service Descriptor by defining the source, target and parameters of the dependency. But you can also use the requires field in the VNFD to achieve the same result. Let's look at an example to understand how to do this. Here is a VNF dependency defined in the classic way.   ... vnf_dependency :[\n        {\n             source :{\n                 name : server \n            },\n             target :{\n                 name : client \n            },\n             parameters :[\n                 netname_floatingIp \n            ]\n        }\n]\n...  This creates a VNF dependency that provides the floating ip of the VNFD with the type server to the VNFD with the type client. \nThe same can be done by writing the following in the requires field of the VNFD with type client:   ... requires :{\n     server :{\n         parameters :[ netname_floatingIp ]\n    }\n}\n...  The  \"server\"  field specifies that the source of the dependency is the VNFD with the type server. The target is the VNFD that contains the requires field, in this case the VNFD with type client.     \n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Requires"
        }, 
        {
            "location": "/nfvo-installation-src/", 
            "text": "Install Open Baton\n\n\nThis tutorial will guide towards the installation of an Open Baton environment composed by the following components: \n\n\n\n\nThe NFVO implemented in java using the \nspring.io\n framework. For more details about the NFVO architecture, you can refer to the next sections\n\n\nRabbitMQ\n as messaging system\n\n\nTest VIM Driver for being able to execute the \nhello world\n tutorial without needing an OpenStack instance. \n\n\n\n\nAnd a set of optional components: \n\n\n\n\nOpenStack VIM Driver for deploying VNFs on OpenStack\n\n\nGeneric VNFM for the instantiation of VNFs part of the Open Baton ecosystem \n\n\nFault Management System for the support to detection and recovery of VNF faults\n\n\nAuto Scaling Engine for the automatic creation and termination of VNF instances due to performance requirements\n\n\nNetwork Slicing Engine for \n\n\nMySQL\n as a mean to enable the persistence when using Open Baton\n\n\n\n\nRequirements\n\n\nTo facilitate the installation procedures we provide a bootstrap script which will install the desired components and configure them for running a \nhello world\n VNF out of the box. To execute the bootstrap procedure you need to have curl installed (see http://curl.haxx.se/). This command should work on any linux system: \n\n\napt-get install curl\n\n\n\n\nNOTE\n - We assume that you are performing the installation on top of a clean installation either of Ubuntu 14.04 or Debian Jessy. In other cases we suggest to install the components one by one. You can checkout the \nbootstrap\n repository and see the installation procedures which are executed by the bootstrap script. \n\n\nInstallation guide\n\n\nTo start the bootstrap procedure of the \ndevelopment\n Open Baton environment you can type the following command:\n\n\nsh \n(curl -s http://get.openbaton.org/bootstrap) develop\n\n\n\n\nVERY IMPORTANT NOTE\n - By default RabbitMQ is installed on the host of the NFVO. Be aware of the fact that during the installation you will be prompted for entering the RabbitMQ IP and Port. Please make sure that this IP can be\n  reached by external components (VMs, or host where will run other VNFMs) otherwise you will have runtime issues. If you are installing Open Baton on a VM running in OpenStack, the best is that you put here\n  the floating IP.\n\n\nDuring the bootstrap procedure you will be prompted for inputs. For instance you can choose to install or not the Generic VNFM as well as other additional components, or enable or not SSL. \nAt the end of the bootstrap procedure, if there are no errors, the dashboard should be reachable at: \nlocalhost:8080\n. \nDepending on which additional component you decided to add to the Open Baton installation then you should have the following structure:\n\n\n/opt/openbaton/\n\u251c\u2500\u2500 nfvo\n\u251c\u2500\u2500 generic-vnfm\n\u251c\u2500\u2500 fm-system\n\u251c\u2500\u2500 autoscaling\n\u2514\u2500\u2500 nse\n\n\n\n\nWhere:\n\n\n\n\nnfvo\n contains the source code and scripts of the NFVO\n\n\ngeneric-vnfm\n contains the source code and scripts required for dealing with the Generic VNFM\n\n\nfm-system\n contains the source code and scripts required for dealing with the Fault Management System (FMS)\n\n\nautoscaling\n contains the source code and scripts required for dealing with the Auto Scaling Engine (ASE)\n\n\nnse\n contains the source code and scripts required for dealing with the Network Slicing Engine (NSE)\n\n\n\n\nAt this point the NFVO is ready to be used. Please refer to the \nIntroduction\n on how to start using it or step into the \nhello world\n tutorial immediately.\n\n\nStarting and stopping the NFVO\n\n\nAfter the installation procedure the NFVO is running. If you want to stop it, enter this command:\n\n\ncd /opt/openbaton/nfvo\n./openbaton.sh stop\n\n\n\n\nTo start the nfvo, enter the command:\n\n\ncd /opt/openbaton/nfvo\n./openbaton.sh start\n\n\n\n\nStarting and stopping the Generic VNFM (and the other additional components)\n\n\nIf you are also using the Generic VNFM remember you can stop it with the following command:\n\n\ncd /opt/openbaton/generic-vnfm\n./generic-vnfm.sh stop\n\n\n\n\nand start it with the following command:\n\n\ncd /opt/openbaton/generic-vnfm\n./generic-vnfm.sh start\n\n\n\n\nNOTE\n - For all the other additional components the commands above still apply just adapted to the specific component (e.g.: for the Fault Management System you can use the 'fm-system.sh' script, etc.)\n\n\nConfigure it\n\n\nFor specific configuration refer to the \nconfiguration\n\n\n\n\n\n\n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "**HIDDEN**"
        }, 
        {
            "location": "/nfvo-installation-src/#install-open-baton", 
            "text": "This tutorial will guide towards the installation of an Open Baton environment composed by the following components:    The NFVO implemented in java using the  spring.io  framework. For more details about the NFVO architecture, you can refer to the next sections  RabbitMQ  as messaging system  Test VIM Driver for being able to execute the  hello world  tutorial without needing an OpenStack instance.    And a set of optional components:    OpenStack VIM Driver for deploying VNFs on OpenStack  Generic VNFM for the instantiation of VNFs part of the Open Baton ecosystem   Fault Management System for the support to detection and recovery of VNF faults  Auto Scaling Engine for the automatic creation and termination of VNF instances due to performance requirements  Network Slicing Engine for   MySQL  as a mean to enable the persistence when using Open Baton", 
            "title": "Install Open Baton"
        }, 
        {
            "location": "/nfvo-installation-src/#requirements", 
            "text": "To facilitate the installation procedures we provide a bootstrap script which will install the desired components and configure them for running a  hello world  VNF out of the box. To execute the bootstrap procedure you need to have curl installed (see http://curl.haxx.se/). This command should work on any linux system:   apt-get install curl  NOTE  - We assume that you are performing the installation on top of a clean installation either of Ubuntu 14.04 or Debian Jessy. In other cases we suggest to install the components one by one. You can checkout the  bootstrap  repository and see the installation procedures which are executed by the bootstrap script.", 
            "title": "Requirements"
        }, 
        {
            "location": "/nfvo-installation-src/#installation-guide", 
            "text": "To start the bootstrap procedure of the  development  Open Baton environment you can type the following command:  sh  (curl -s http://get.openbaton.org/bootstrap) develop  VERY IMPORTANT NOTE  - By default RabbitMQ is installed on the host of the NFVO. Be aware of the fact that during the installation you will be prompted for entering the RabbitMQ IP and Port. Please make sure that this IP can be\n  reached by external components (VMs, or host where will run other VNFMs) otherwise you will have runtime issues. If you are installing Open Baton on a VM running in OpenStack, the best is that you put here\n  the floating IP.  During the bootstrap procedure you will be prompted for inputs. For instance you can choose to install or not the Generic VNFM as well as other additional components, or enable or not SSL. \nAt the end of the bootstrap procedure, if there are no errors, the dashboard should be reachable at:  localhost:8080 . \nDepending on which additional component you decided to add to the Open Baton installation then you should have the following structure:  /opt/openbaton/\n\u251c\u2500\u2500 nfvo\n\u251c\u2500\u2500 generic-vnfm\n\u251c\u2500\u2500 fm-system\n\u251c\u2500\u2500 autoscaling\n\u2514\u2500\u2500 nse  Where:   nfvo  contains the source code and scripts of the NFVO  generic-vnfm  contains the source code and scripts required for dealing with the Generic VNFM  fm-system  contains the source code and scripts required for dealing with the Fault Management System (FMS)  autoscaling  contains the source code and scripts required for dealing with the Auto Scaling Engine (ASE)  nse  contains the source code and scripts required for dealing with the Network Slicing Engine (NSE)   At this point the NFVO is ready to be used. Please refer to the  Introduction  on how to start using it or step into the  hello world  tutorial immediately.", 
            "title": "Installation guide"
        }, 
        {
            "location": "/nfvo-installation-src/#starting-and-stopping-the-nfvo", 
            "text": "After the installation procedure the NFVO is running. If you want to stop it, enter this command:  cd /opt/openbaton/nfvo\n./openbaton.sh stop  To start the nfvo, enter the command:  cd /opt/openbaton/nfvo\n./openbaton.sh start", 
            "title": "Starting and stopping the NFVO"
        }, 
        {
            "location": "/nfvo-installation-src/#starting-and-stopping-the-generic-vnfm-and-the-other-additional-components", 
            "text": "If you are also using the Generic VNFM remember you can stop it with the following command:  cd /opt/openbaton/generic-vnfm\n./generic-vnfm.sh stop  and start it with the following command:  cd /opt/openbaton/generic-vnfm\n./generic-vnfm.sh start  NOTE  - For all the other additional components the commands above still apply just adapted to the specific component (e.g.: for the Fault Management System you can use the 'fm-system.sh' script, etc.)", 
            "title": "Starting and stopping the Generic VNFM (and the other additional components)"
        }, 
        {
            "location": "/nfvo-installation-src/#configure-it", 
            "text": "For specific configuration refer to the  configuration   \n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Configure it"
        }, 
        {
            "location": "/zabbix-server-configuration-3.0/", 
            "text": "Zabbix server 3.0 installation and configuration\n\n\nOn Ubuntu 14.04\n\n\nWhile performing the installation on the same host where the NFVO was installed, remember that both systems are heavily consuming CPU and Memory resources, therefore you'll need a powerful machine in order to have proper performances results.\n\n\nDuring the installation the installer will request to put a password for the user root of the mysql server. You can choose the password you like (we'll refer from now on to this password as MYSQL_USER_PASSWORD_DEFAULT variable), however make sure you use the same password while configuring zabbix components later on.\n\n\nsudo su\nZABBIX_PACKAGE=\nzabbix-release_3.0-1+trusty_all.deb\n\nZABBIX_REPO=\nhttp://repo.zabbix.com/zabbix/3.0/ubuntu/pool/main/z/zabbix-release/${ZABBIX_PACKAGE}\n\nwget \n${ZABBIX_REPO}\n\ndpkg -i \n${ZABBIX_PACKAGE}\n\nrm \n${ZABBIX_PACKAGE}\n\napt-get update \n apt-get -y install mysql-server zabbix-server-mysql zabbix-frontend-php\n\n\n\n\nOnce done, you should configure the file /etc/php5/apache2/php.ini file with the following commands: \n\n\n# choose the timezone you prefer\nsed -i 's/;date.timezone =/date.timezone = \nEurope\\/Berlin\n/' /etc/php5/apache2/php.ini\nsed -i 's/# DBPassword=/DBPassword=/' /etc/zabbix/zabbix_server.conf\nwget https://raw.githubusercontent.com/openbaton/juju-charm/develop/hooks/zabbix.conf.php\ncp zabbix.conf.php /etc/zabbix/web/zabbix.conf.php \nrm zabbix.conf.php\n\n\n\n\nImport all the related database tables: \n\n\nexport MYSQL_USER_PASSWORD_DEFAULT=\nput-your-root-mysql-password-here\n \nmysql -uroot -e \ncreate database zabbix character set utf8 collate utf8_bin;\n -p\n${MYSQL_USER_PASSWORD_DEFAULT}\n\nmysql -uroot -e \ngrant all privileges on zabbix.* to zabbix@localhost identified by '';\n -p\n${MYSQL_USER_PASSWORD_DEFAULT}\n\nzcat /usr/share/doc/zabbix-server-mysql/create.sql.gz | mysql -uroot -p\n${MYSQL_USER_PASSWORD_DEFAULT}\n zabbix\n\n\n\n\nRestart services and you are almost done:\n\n\nservice apache2 reload\nservice zabbix-server restart\n\n\n\n\nAt this point the Zabbix frontend should be available at http://your-ip/zabbix in the browser. Default username/password is Admin/zabbix. It will pop up a wizard window which will guide you through the final configuration of the server. \n\n\nAdditionally, you need to configure the auto registration action so that VNFs hosts are added automatically into zabbix db when they are started. \nFor doing it you can either do it via the zabbix dashboard reachable at  http://your-ip/zabbix/actionconf.php or using the provided python script. Follow the below guidelines to understand this process.  \n\n\nConfigure the auto registration using the provided helper script\n\n\nIn order to facilitate the configuration of the Zabbix Server, we also provide a zbx_helper.py script which executes all actions in once. \nYou should run the following command into the host: \n\n\nwget https://raw.githubusercontent.com/openbaton/juju-charm/develop/hooks/zbx_helper.py\n# modify any parameters like Zabbix username and password in the main function at the bottom of the script and execute the following: \npython zbx_helper.py -a\n\n\n\n\nAfter that, the zabbix server is ready to monitor your VNFs!", 
            "title": "**HIDDEN**"
        }, 
        {
            "location": "/zabbix-server-configuration-3.0/#zabbix-server-30-installation-and-configuration", 
            "text": "", 
            "title": "Zabbix server 3.0 installation and configuration"
        }, 
        {
            "location": "/zabbix-server-configuration-3.0/#on-ubuntu-1404", 
            "text": "While performing the installation on the same host where the NFVO was installed, remember that both systems are heavily consuming CPU and Memory resources, therefore you'll need a powerful machine in order to have proper performances results.  During the installation the installer will request to put a password for the user root of the mysql server. You can choose the password you like (we'll refer from now on to this password as MYSQL_USER_PASSWORD_DEFAULT variable), however make sure you use the same password while configuring zabbix components later on.  sudo su\nZABBIX_PACKAGE= zabbix-release_3.0-1+trusty_all.deb \nZABBIX_REPO= http://repo.zabbix.com/zabbix/3.0/ubuntu/pool/main/z/zabbix-release/${ZABBIX_PACKAGE} \nwget  ${ZABBIX_REPO} \ndpkg -i  ${ZABBIX_PACKAGE} \nrm  ${ZABBIX_PACKAGE} \napt-get update   apt-get -y install mysql-server zabbix-server-mysql zabbix-frontend-php  Once done, you should configure the file /etc/php5/apache2/php.ini file with the following commands:   # choose the timezone you prefer\nsed -i 's/;date.timezone =/date.timezone =  Europe\\/Berlin /' /etc/php5/apache2/php.ini\nsed -i 's/# DBPassword=/DBPassword=/' /etc/zabbix/zabbix_server.conf\nwget https://raw.githubusercontent.com/openbaton/juju-charm/develop/hooks/zabbix.conf.php\ncp zabbix.conf.php /etc/zabbix/web/zabbix.conf.php \nrm zabbix.conf.php  Import all the related database tables:   export MYSQL_USER_PASSWORD_DEFAULT= put-your-root-mysql-password-here  \nmysql -uroot -e  create database zabbix character set utf8 collate utf8_bin;  -p ${MYSQL_USER_PASSWORD_DEFAULT} \nmysql -uroot -e  grant all privileges on zabbix.* to zabbix@localhost identified by '';  -p ${MYSQL_USER_PASSWORD_DEFAULT} \nzcat /usr/share/doc/zabbix-server-mysql/create.sql.gz | mysql -uroot -p ${MYSQL_USER_PASSWORD_DEFAULT}  zabbix  Restart services and you are almost done:  service apache2 reload\nservice zabbix-server restart  At this point the Zabbix frontend should be available at http://your-ip/zabbix in the browser. Default username/password is Admin/zabbix. It will pop up a wizard window which will guide you through the final configuration of the server.   Additionally, you need to configure the auto registration action so that VNFs hosts are added automatically into zabbix db when they are started. \nFor doing it you can either do it via the zabbix dashboard reachable at  http://your-ip/zabbix/actionconf.php or using the provided python script. Follow the below guidelines to understand this process.", 
            "title": "On Ubuntu 14.04"
        }, 
        {
            "location": "/zabbix-server-configuration-3.0/#configure-the-auto-registration-using-the-provided-helper-script", 
            "text": "In order to facilitate the configuration of the Zabbix Server, we also provide a zbx_helper.py script which executes all actions in once. \nYou should run the following command into the host:   wget https://raw.githubusercontent.com/openbaton/juju-charm/develop/hooks/zbx_helper.py\n# modify any parameters like Zabbix username and password in the main function at the bottom of the script and execute the following: \npython zbx_helper.py -a  After that, the zabbix server is ready to monitor your VNFs!", 
            "title": "Configure the auto registration using the provided helper script"
        }, 
        {
            "location": "/zabbix-server-configuration-2.2/", 
            "text": "Zabbix server (2.2) installation and configuration\n\n\nOn Ubuntu 14.04\n\n\nWhile performing the installation on the same host where the NFVO was installed, remember that both systems are heavily consuming CPU and Memory resources, therefore you'll need a powerful machine in order to satisfy both requirements\n\n\nDuring the installation the installer will request to put a password for the user root of the mysql server. You can choose the password you like, however make sure you use the same password while configuring zabbix components\n\n\nsudo su\nwget http://repo.zabbix.com/zabbix/2.2/ubuntu/pool/main/z/zabbix-release/zabbix-release_2.2-1+trusty_all.deb\ndpkg -i zabbix-release_2.2-1+trusty_all.deb\napt-get update \n apt-get -y install mysql-server zabbix-server-mysql zabbix-frontend-php\n\n\n\n\nOnce done, you should configure the file /etc/php5/apache2/php.ini file with the following parameters: \n\n\n[PHP]\n.....\nmax_execution_time = 300\nmemory_limit = 128M\npost_max_size = 16M\nupload_max_filesize = 2M\nmax_input_time =  300\n......\n[Date]\ndate.timezone = Europe/Berlin\n\n\n\n\nRestart the apache service and you are almost done:\n\n\n/etc/init.d/apache2 restart\n\n\n\n\nAt this point the Zabbix frontend should be available at http://your-ip/zabbix in the browser. Default username/password is Admin/zabbix. It will pop up a wizard window which will guide you through the final configuration of the server. \n\n\nAdditionally, you need to configure the auto registration action so that VNFs hosts are added automatically into zabbix db when they are started. For doing it you can either do it via the zabbix dashboard reachable at  http://your-ip/zabbix/actionconf.php or using the provided sql file. Both options are explained below\n\n\nConfigure the auto registration using the dashboard\n\n\nFirst of all you need to open the actions tab\n\n\n\n\nThen you need to create an action:\n\n\n\n\nFinally you need to add two operations:\n\n\n\n\nadd host\n\n\nlink to template: you can select the template you prefer\n\n\n\n\n\n\nRemember to save all the changes in all tabs.\n\n\nConfigure the auto registration importing the sql file\n\n\nIn order to facilitate the configuration of the Zabbix Server, we also provide a zabbix.sql file with all the configuration already done. The file can be found in the folder zabbix-configuration of the zabbix-plugin project.\nYou should run the following command into the host: \n\n\n# Please note that this will overwrite whatever configuration or data is stored into the existing zabbix db.\nmysql -u root -p zabbix \n zabbix.sql\n\n\n\n\nAfter that, the zabbix server is ready to monitor your VNFs!", 
            "title": "**HIDDEN**"
        }, 
        {
            "location": "/zabbix-server-configuration-2.2/#zabbix-server-22-installation-and-configuration", 
            "text": "", 
            "title": "Zabbix server (2.2) installation and configuration"
        }, 
        {
            "location": "/zabbix-server-configuration-2.2/#on-ubuntu-1404", 
            "text": "While performing the installation on the same host where the NFVO was installed, remember that both systems are heavily consuming CPU and Memory resources, therefore you'll need a powerful machine in order to satisfy both requirements  During the installation the installer will request to put a password for the user root of the mysql server. You can choose the password you like, however make sure you use the same password while configuring zabbix components  sudo su\nwget http://repo.zabbix.com/zabbix/2.2/ubuntu/pool/main/z/zabbix-release/zabbix-release_2.2-1+trusty_all.deb\ndpkg -i zabbix-release_2.2-1+trusty_all.deb\napt-get update   apt-get -y install mysql-server zabbix-server-mysql zabbix-frontend-php  Once done, you should configure the file /etc/php5/apache2/php.ini file with the following parameters:   [PHP]\n.....\nmax_execution_time = 300\nmemory_limit = 128M\npost_max_size = 16M\nupload_max_filesize = 2M\nmax_input_time =  300\n......\n[Date]\ndate.timezone = Europe/Berlin  Restart the apache service and you are almost done:  /etc/init.d/apache2 restart  At this point the Zabbix frontend should be available at http://your-ip/zabbix in the browser. Default username/password is Admin/zabbix. It will pop up a wizard window which will guide you through the final configuration of the server.   Additionally, you need to configure the auto registration action so that VNFs hosts are added automatically into zabbix db when they are started. For doing it you can either do it via the zabbix dashboard reachable at  http://your-ip/zabbix/actionconf.php or using the provided sql file. Both options are explained below", 
            "title": "On Ubuntu 14.04"
        }, 
        {
            "location": "/zabbix-server-configuration-2.2/#configure-the-auto-registration-using-the-dashboard", 
            "text": "First of all you need to open the actions tab   Then you need to create an action:   Finally you need to add two operations:   add host  link to template: you can select the template you prefer    Remember to save all the changes in all tabs.", 
            "title": "Configure the auto registration using the dashboard"
        }, 
        {
            "location": "/zabbix-server-configuration-2.2/#configure-the-auto-registration-importing-the-sql-file", 
            "text": "In order to facilitate the configuration of the Zabbix Server, we also provide a zabbix.sql file with all the configuration already done. The file can be found in the folder zabbix-configuration of the zabbix-plugin project.\nYou should run the following command into the host:   # Please note that this will overwrite whatever configuration or data is stored into the existing zabbix db.\nmysql -u root -p zabbix   zabbix.sql  After that, the zabbix server is ready to monitor your VNFs!", 
            "title": "Configure the auto registration importing the sql file"
        }, 
        {
            "location": "/tosca-iperf-scenario/", 
            "text": "TOSCA Iperf Scenario\n\n\nThe definition follows the TOSCA Simple Profile for Network Functions Virtualization (NFV) \nVersion 1.0\n. Information about creating a complete TOSCA Template from scratch can be found in this \ntutorial\n.\n\n\nThis tutorial explains how to deploy a network service that uses iPerf. \niPerf\n is a tool for active measurements of the maximum achievable bandwidth between two or more machines.\nThis tutorial makes use of:\n\n\n\n\nGeneric VNFM (\ngeneric-vnfm\n)\n\n\nGeneric EMS (\ngeneric ems\n)\n\n\nOpenStack plugin (\nopenstack-plugin\n)\n\n\n\n\nRequirements\n\n\nIn order to execute this scenario, you need to have the following components up and running:\n\n\n\n\nThe NFVO\n\n\nthe OpenStack plugin\n\n\nthe Generic VNFM (includes already generic EMS)\n\n\na PoP (of type openstack) registered. You can use the following \njson descriptor\n by changing the values to your needs.\n\n\n\n\nMore information about the Iperf Scenario \nhere\n.\n\n\nComplete Example\n\n\ntosca_definitions_version: tosca_simple_profile_for_nfv_1_0\ndescription: Example of NSD\n\nmetadata:\n  ID: NSD-Iperf+FloatingIps\n  vendor: Fokus\n  version: 1.0\n\ntopology_template:\n\n  node_templates:\n\n    iperf-server: #VNF1\n        type: openbaton.type.VNF\n        properties:\n          vendor: Fokus\n          version: 1.0\n          endpoint: generic\n          type: server\n          vnfPackageLocation: https://github.com/openbaton/vnf-scripts.git\n          deploymentFlavour:\n            - flavour_key: m1.small\n        requirements:\n          - virtualLink: private\n          - vdu: VDU2        \n        interfaces:\n          lifecycle: # lifecycle\n            INSTANTIATE:\n              - install.sh\n              - install-srv.sh\n\n    iperf-client:\n      type: openbaton.type.VNF\n      properties:\n        ID: x\n        vendor: Fokus\n        version: 1.0\n        type: client\n        vnfPackageLocation: https://github.com/openbaton/vnf-scripts.git\n        deploymentFlavour:\n          - flavour_key: m1.small\n        endpoint: generic\n      requirements:\n         - virtualLink: private\n         - vdu: VDU1\n      interfaces:\n          lifecycle: # lifecycle\n            INSTANTIATE:\n              - install.sh\n            CONFIGURE:\n              - server_configure.sh\n\n    VDU1:\n      type: tosca.nodes.nfv.VDU\n      properties:\n        scale_in_out: 1\n      artifacts:\n        VDU1Image:\n          type: tosca.artifacts.Deployment.Image.VM\n          file: ubuntu-14.04-server-cloudimg-amd64-disk1\n\n    VDU2:\n      type: tosca.nodes.nfv.VDU\n      properties:\n        scale_in_out: 3\n      artifacts:\n        VDU1Image:\n          type: tosca.artifacts.Deployment.Image.VM\n          file: ubuntu-14.04-server-cloudimg-amd64-disk1\n\n    CP1:\n      type: tosca.nodes.nfv.CP\n      properties:\n        floatingIP: random\n      requirements:\n        - virtualBinding: VDU1\n        - virtualLink: private\n\n    CP2: #endpoints of VNF2\n      type: tosca.nodes.nfv.CP\n      requirements:\n        - virtualBinding: VDU2\n        - virtualLink: private\n\n    private:\n      type: tosca.nodes.nfv.VL\n      properties:\n        vendor: Fokus\n\nrelationships_template:\n  connection_server_client: \n    type: tosca.nodes.relationships.ConnectsTo\n    source: iperf-server\n    target: iperf-client\n    parameters:\n        - private\n\n\n\n\n\nNOTE\n: Save the definition in a file called iperf-floating-ips.yaml.\n\n\nOnboarding\n\n\nThe Iperf Template can be added used in \nCSAR\n and onboarded using the \nDashboard\n.\n\n\n\n\n\n\n\n\n\n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "**HIDDEN**"
        }, 
        {
            "location": "/tosca-iperf-scenario/#tosca-iperf-scenario", 
            "text": "The definition follows the TOSCA Simple Profile for Network Functions Virtualization (NFV)  Version 1.0 . Information about creating a complete TOSCA Template from scratch can be found in this  tutorial .  This tutorial explains how to deploy a network service that uses iPerf.  iPerf  is a tool for active measurements of the maximum achievable bandwidth between two or more machines.\nThis tutorial makes use of:   Generic VNFM ( generic-vnfm )  Generic EMS ( generic ems )  OpenStack plugin ( openstack-plugin )", 
            "title": "TOSCA Iperf Scenario"
        }, 
        {
            "location": "/tosca-iperf-scenario/#requirements", 
            "text": "In order to execute this scenario, you need to have the following components up and running:   The NFVO  the OpenStack plugin  the Generic VNFM (includes already generic EMS)  a PoP (of type openstack) registered. You can use the following  json descriptor  by changing the values to your needs.   More information about the Iperf Scenario  here .", 
            "title": "Requirements"
        }, 
        {
            "location": "/tosca-iperf-scenario/#complete-example", 
            "text": "tosca_definitions_version: tosca_simple_profile_for_nfv_1_0\ndescription: Example of NSD\n\nmetadata:\n  ID: NSD-Iperf+FloatingIps\n  vendor: Fokus\n  version: 1.0\n\ntopology_template:\n\n  node_templates:\n\n    iperf-server: #VNF1\n        type: openbaton.type.VNF\n        properties:\n          vendor: Fokus\n          version: 1.0\n          endpoint: generic\n          type: server\n          vnfPackageLocation: https://github.com/openbaton/vnf-scripts.git\n          deploymentFlavour:\n            - flavour_key: m1.small\n        requirements:\n          - virtualLink: private\n          - vdu: VDU2        \n        interfaces:\n          lifecycle: # lifecycle\n            INSTANTIATE:\n              - install.sh\n              - install-srv.sh\n\n    iperf-client:\n      type: openbaton.type.VNF\n      properties:\n        ID: x\n        vendor: Fokus\n        version: 1.0\n        type: client\n        vnfPackageLocation: https://github.com/openbaton/vnf-scripts.git\n        deploymentFlavour:\n          - flavour_key: m1.small\n        endpoint: generic\n      requirements:\n         - virtualLink: private\n         - vdu: VDU1\n      interfaces:\n          lifecycle: # lifecycle\n            INSTANTIATE:\n              - install.sh\n            CONFIGURE:\n              - server_configure.sh\n\n    VDU1:\n      type: tosca.nodes.nfv.VDU\n      properties:\n        scale_in_out: 1\n      artifacts:\n        VDU1Image:\n          type: tosca.artifacts.Deployment.Image.VM\n          file: ubuntu-14.04-server-cloudimg-amd64-disk1\n\n    VDU2:\n      type: tosca.nodes.nfv.VDU\n      properties:\n        scale_in_out: 3\n      artifacts:\n        VDU1Image:\n          type: tosca.artifacts.Deployment.Image.VM\n          file: ubuntu-14.04-server-cloudimg-amd64-disk1\n\n    CP1:\n      type: tosca.nodes.nfv.CP\n      properties:\n        floatingIP: random\n      requirements:\n        - virtualBinding: VDU1\n        - virtualLink: private\n\n    CP2: #endpoints of VNF2\n      type: tosca.nodes.nfv.CP\n      requirements:\n        - virtualBinding: VDU2\n        - virtualLink: private\n\n    private:\n      type: tosca.nodes.nfv.VL\n      properties:\n        vendor: Fokus\n\nrelationships_template:\n  connection_server_client: \n    type: tosca.nodes.relationships.ConnectsTo\n    source: iperf-server\n    target: iperf-client\n    parameters:\n        - private  NOTE : Save the definition in a file called iperf-floating-ips.yaml.", 
            "title": "Complete Example"
        }, 
        {
            "location": "/tosca-iperf-scenario/#onboarding", 
            "text": "The Iperf Template can be added used in  CSAR  and onboarded using the  Dashboard .    \n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Onboarding"
        }, 
        {
            "location": "/tosca-dummy-nsr/", 
            "text": "TOSCA Dummy Network Service Example\n\n\nThe template follows the TOSCA Simple Profile for Network Functions Virtualization (NFV) \nVersion 1.0\n\nRegarding the objects defined from ETSI please see: \nETSI GS NFV-MAN 001\n\n\nMore Information about creating TOSCA Network Service Templates in this \ntutorial\n.\n\n\nPrerequisites\n\n\nThe prerequisites are:\n\n\n\n\nOpenBaton running\n\n\nDummy VNFM running\n\n\nTest plugin \n\n\nVim Instance\n stored in the Catalogue\n\n\n\n\nComplete Example\n\n\ntosca_definitions_version: tosca_simple_profile_for_nfv_1_0\ndescription: NSDummy\n\nmetadata:\n  ID: dummy-NS\n  vendor: Fokus\n  version: 0.1\n\ntopology_template:\n\n  node_templates:\n\n    dummy-server: \n        type: openbaton.type.VNF\n        properties:\n          vendor: Fokus\n          version: 0.1\n          endpoint: dummy\n          type: server\n          configurations:\n            name: server-configurations\n            configurationParameters:\n              - key: value\n              - key2: value2\n          vnfPackageLocation: https://github.com/openbaton/vnf-scripts.git\n          deploymentFlavour:\n            - flavour_key: m1.small\n        requirements:\n          - virtualLink: private\n          - vdu: VDU2\n        interfaces:\n          lifecycle: \n            INSTANTIATE:\n              - install.sh\n              - install-srv.sh\n\n    dummy-client:\n      type: openbaton.type.VNF\n      properties:\n        ID: x\n        vendor: Fokus\n        version: 0.1\n        type: client\n        vnfPackageLocation: https://github.com/openbaton/vnf-scripts.git\n        deploymentFlavour:\n          - flavour_key: m1.small\n        endpoint: dummy\n      requirements:\n         - virtualLink: private\n         - vdu: VDU1\n      interfaces:\n          lifecycle: # lifecycle\n            INSTANTIATE:\n              - install.sh\n            CONFIGURE:\n              - server_start-clt.sh\n\n    VDU1:\n      type: tosca.nodes.nfv.VDU\n      properties:\n        scale_in_out: 1\n        vim_instance_name:\n          - test-vim-instance\n      artifacts:\n        VDU1Image:\n          type: tosca.artifacts.Deployment.Image.VM\n          file: ubuntu-14.04-server-cloudimg-amd64-disk1\n\n    VDU2:\n      type: tosca.nodes.nfv.VDU\n      properties:\n        scale_in_out: 2\n        vim_instance_name:\n          - test-vim-instance\n      artifacts:\n        VDU1Image:\n          type: tosca.artifacts.Deployment.Image.VM\n          file: ubuntu-14.04-server-cloudimg-amd64-disk1\n\n    CP1:\n      type: tosca.nodes.nfv.CP\n      properties:\n        floatingIP: random\n      requirements:\n        - virtualBinding: VDU1\n        - virtualLink: private\n\n    CP2: #endpoints of VNF2\n      type: tosca.nodes.nfv.CP\n      requirements:\n        - virtualBinding: VDU2\n        - virtualLink: private\n\n    private:\n      type: tosca.nodes.nfv.VL\n      properties:\n        vendor: Fokus\n\nrelationships_template:\n  connection_server_client: \n    type: tosca.nodes.relationships.ConnectsTo\n    source: dummy-server\n    target: dummy-client\n    parameters:\n        - private\n\n\n\n\n\n\nNOTE\n: Save the definition in a file called dummyns.yaml.\n\n\nUsing the API you can store the NSD written in TOSCA directly in the NFVO. You will need the dummy-vnfm and test vim instance.\n To do that follow these steps:\n\n\n1) Authentication:\nRun this command:\n\n\n$curl -v -u openbatonOSClient:secret -X POST http://localhost:8080/oauth/token -H \nAccept: application/json\n -d \nusername=admin\npassword=openbaton\ngrant_type=password\n\n\n\n\n\nThe NFVO will answer with an authetication key and a project id. You will need them to send the NSD in the next step. The response should look like this:\n\n\n{\n  # Authentication Key\n  \nvalue\n: \ne8726a35-61c8-4bcb-873e-3ab6cc989f6f\n,\n  \nexpiration\n: \nAug 30, 2016 9:14:22 PM\n,\n  \ntokenType\n: \nbearer\n,\n  \nrefreshToken\n: {\n    \nexpiration\n: \nSep 29, 2016 9:14:22 AM\n,\n    # Project ID\n    \nvalue\n: \n336ca2e6-8e78-48eb-b8f8-c5de862a21da\n\n  },...\n\n\n\n\nNote: \n Do not pay attention to the project-id supplied in this response.\n\n\n2) To send the NSD in the TOSCA format save the example above in a file named dummyns.yaml and get the project id of your project from the Dashboard under the menu Identity \n Menu. After that run this :\n\n\n$curl -i -X POST http://localhost:8080/api/v1/nsd-tosca -H \nContent-Type: text/yaml\n \nAccept: application/json\n -H \nproject-id: $Project-ID HERE$\n -H \nAuthorization: Bearer $AUTH KEY HERE$\n --data-binary @dummyns.yaml\n\n\n\n\nTo retrieve or to instantiate this NSD please use the Dashboard of OpenBaton in the page under the menu Catalogue \n NS Descriptors.\n\n\n\n\n\n\n\n\n\n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "**HIDDEN**"
        }, 
        {
            "location": "/tosca-dummy-nsr/#tosca-dummy-network-service-example", 
            "text": "The template follows the TOSCA Simple Profile for Network Functions Virtualization (NFV)  Version 1.0 \nRegarding the objects defined from ETSI please see:  ETSI GS NFV-MAN 001  More Information about creating TOSCA Network Service Templates in this  tutorial .", 
            "title": "TOSCA Dummy Network Service Example"
        }, 
        {
            "location": "/tosca-dummy-nsr/#prerequisites", 
            "text": "The prerequisites are:   OpenBaton running  Dummy VNFM running  Test plugin   Vim Instance  stored in the Catalogue", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/tosca-dummy-nsr/#complete-example", 
            "text": "tosca_definitions_version: tosca_simple_profile_for_nfv_1_0\ndescription: NSDummy\n\nmetadata:\n  ID: dummy-NS\n  vendor: Fokus\n  version: 0.1\n\ntopology_template:\n\n  node_templates:\n\n    dummy-server: \n        type: openbaton.type.VNF\n        properties:\n          vendor: Fokus\n          version: 0.1\n          endpoint: dummy\n          type: server\n          configurations:\n            name: server-configurations\n            configurationParameters:\n              - key: value\n              - key2: value2\n          vnfPackageLocation: https://github.com/openbaton/vnf-scripts.git\n          deploymentFlavour:\n            - flavour_key: m1.small\n        requirements:\n          - virtualLink: private\n          - vdu: VDU2\n        interfaces:\n          lifecycle: \n            INSTANTIATE:\n              - install.sh\n              - install-srv.sh\n\n    dummy-client:\n      type: openbaton.type.VNF\n      properties:\n        ID: x\n        vendor: Fokus\n        version: 0.1\n        type: client\n        vnfPackageLocation: https://github.com/openbaton/vnf-scripts.git\n        deploymentFlavour:\n          - flavour_key: m1.small\n        endpoint: dummy\n      requirements:\n         - virtualLink: private\n         - vdu: VDU1\n      interfaces:\n          lifecycle: # lifecycle\n            INSTANTIATE:\n              - install.sh\n            CONFIGURE:\n              - server_start-clt.sh\n\n    VDU1:\n      type: tosca.nodes.nfv.VDU\n      properties:\n        scale_in_out: 1\n        vim_instance_name:\n          - test-vim-instance\n      artifacts:\n        VDU1Image:\n          type: tosca.artifacts.Deployment.Image.VM\n          file: ubuntu-14.04-server-cloudimg-amd64-disk1\n\n    VDU2:\n      type: tosca.nodes.nfv.VDU\n      properties:\n        scale_in_out: 2\n        vim_instance_name:\n          - test-vim-instance\n      artifacts:\n        VDU1Image:\n          type: tosca.artifacts.Deployment.Image.VM\n          file: ubuntu-14.04-server-cloudimg-amd64-disk1\n\n    CP1:\n      type: tosca.nodes.nfv.CP\n      properties:\n        floatingIP: random\n      requirements:\n        - virtualBinding: VDU1\n        - virtualLink: private\n\n    CP2: #endpoints of VNF2\n      type: tosca.nodes.nfv.CP\n      requirements:\n        - virtualBinding: VDU2\n        - virtualLink: private\n\n    private:\n      type: tosca.nodes.nfv.VL\n      properties:\n        vendor: Fokus\n\nrelationships_template:\n  connection_server_client: \n    type: tosca.nodes.relationships.ConnectsTo\n    source: dummy-server\n    target: dummy-client\n    parameters:\n        - private  NOTE : Save the definition in a file called dummyns.yaml.  Using the API you can store the NSD written in TOSCA directly in the NFVO. You will need the dummy-vnfm and test vim instance.\n To do that follow these steps:  1) Authentication:\nRun this command:  $curl -v -u openbatonOSClient:secret -X POST http://localhost:8080/oauth/token -H  Accept: application/json  -d  username=admin password=openbaton grant_type=password   The NFVO will answer with an authetication key and a project id. You will need them to send the NSD in the next step. The response should look like this:  {\n  # Authentication Key\n   value :  e8726a35-61c8-4bcb-873e-3ab6cc989f6f ,\n   expiration :  Aug 30, 2016 9:14:22 PM ,\n   tokenType :  bearer ,\n   refreshToken : {\n     expiration :  Sep 29, 2016 9:14:22 AM ,\n    # Project ID\n     value :  336ca2e6-8e78-48eb-b8f8-c5de862a21da \n  },...  Note:   Do not pay attention to the project-id supplied in this response.  2) To send the NSD in the TOSCA format save the example above in a file named dummyns.yaml and get the project id of your project from the Dashboard under the menu Identity   Menu. After that run this :  $curl -i -X POST http://localhost:8080/api/v1/nsd-tosca -H  Content-Type: text/yaml   Accept: application/json  -H  project-id: $Project-ID HERE$  -H  Authorization: Bearer $AUTH KEY HERE$  --data-binary @dummyns.yaml  To retrieve or to instantiate this NSD please use the Dashboard of OpenBaton in the page under the menu Catalogue   NS Descriptors.    \n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Complete Example"
        }, 
        {
            "location": "/tosca-ims/", 
            "text": "Tutorial: OpenIMSCore Network Service Record in TOSCA\n\n\n\n\nThis tutorial shows how to deploy a Network Service Record composed by 5 VNFs, a basic \nOpenIMSCore\n.\n\n\nCompared to the \nIperf-Server - Iperf-Client\n the example provided here is far more complex. So we assume you are fimiliar with the architecture.\n\n\nRequirements\n\n\nIn order to execute this scenario, you need to have the following components up and running: \n\n\n\n\nNFVO\n\n\nGeneric VNFM\n\n\nOpenstack-Plugin\n\n\n\n\nStore the VimInstance\n\n\nUpload a VimInstance to the NFVO (e.g. this \nVimInstance\n). \n\n\nPrepare the CSAR Package\n\n\nDownload the necessary files from the \ntosca\n branch of the \ngithub repository\n and pack the NSD CSAR in the following way:\n\n\nExample for creating the NSD CSAR\n\n\n#Go to where you want to save the scripts\ngit clone -b tosca https://github.com/openbaton/openimscore-packages.git\n# Create the .csar file which needs to be uploaded\ncd openimscore-packages/TOSCA/ims-nsd\nzip -r ims.csar . -x \n.*\n -x \n*/.*\n\n\n\n\n\nFor this example we assume the network used to interconnect the components is called \"mgmt\", if you want to modify this example ensure you are naming the network accordingly, the scripts from the github do not handle different network names yet. Also the vimInstanceName may be different to you, depending on your setup. The deployment_flavor is optional but should containg enough RAM for the default configuration of the components to be able to run, else some components may crash on start. This example setup has been successfuly tested on clean \nUbuntu14.04 images\n with 2048 Mb RAM deployed on an \nOpenstack Kilo (2015.1.3)\n. Ensure that the image name defined in the Metadata.yaml of each package is existing.\n\n\nYou can easily onboard the CSAR from the Dashboard. ( Catalogue -\n NS Descriptors -\n Upload CSAR NSD)\n\n\nDeploy the Network Service Descriptor\n\n\nDeploy the stored NSD by using the dashboard.\n\n\nYou need to go again to the GUI, go to \nCatalogue -\n NS Descriptors\n, and open the drop down menu of the openIMSCore NSD by clicking on \nAction\n. Afterwards you need to press the \nLaunch\n button in order to start the deployment of this NSD.\n\n\nIf you go to \nOrchestrate NS -\n NS Records\n in the menu on the left side, you can follow the deployment process and check the current status of the deploying NSD.\n\n\nConclusions\n\n\nOnce the Network Service Record went to \"ACTIVE\" your \nOpenIMSCore\n - \nBind9\n - \nFHoSS\n deployment is finished.\n\n\n\n\nTo test your \nOpenIMSCore\n you may use a Sip client of your choice. Be sure to use the realm defined in your \nBind9 Virtual Network Function Descriptor\n while testing registration and call. By default the \nFHoSS\n conaints 2 users : alice and bob. The user is the same as the password, but you may also alter it to your needs modifying the \nFHoSS Virtual Network Function Descriptor\n ( You will find the users in \"var_user_data.sql\" file under the fhoss folder)\n\n\nFor Benchmarking we can use \nIMS Bench SIPp\n but then you should add more users to the \nFHoSS\n database since by default it only contains 2 users.\n\n\n\n\n\n\n\n\n\n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "**HIDDEN**"
        }, 
        {
            "location": "/tosca-ims/#tutorial-openimscore-network-service-record-in-tosca", 
            "text": "This tutorial shows how to deploy a Network Service Record composed by 5 VNFs, a basic  OpenIMSCore .  Compared to the  Iperf-Server - Iperf-Client  the example provided here is far more complex. So we assume you are fimiliar with the architecture.", 
            "title": "Tutorial: OpenIMSCore Network Service Record in TOSCA"
        }, 
        {
            "location": "/tosca-ims/#requirements", 
            "text": "In order to execute this scenario, you need to have the following components up and running:    NFVO  Generic VNFM  Openstack-Plugin", 
            "title": "Requirements"
        }, 
        {
            "location": "/tosca-ims/#store-the-viminstance", 
            "text": "Upload a VimInstance to the NFVO (e.g. this  VimInstance ).", 
            "title": "Store the VimInstance"
        }, 
        {
            "location": "/tosca-ims/#prepare-the-csar-package", 
            "text": "Download the necessary files from the  tosca  branch of the  github repository  and pack the NSD CSAR in the following way:", 
            "title": "Prepare the CSAR Package"
        }, 
        {
            "location": "/tosca-ims/#example-for-creating-the-nsd-csar", 
            "text": "#Go to where you want to save the scripts\ngit clone -b tosca https://github.com/openbaton/openimscore-packages.git\n# Create the .csar file which needs to be uploaded\ncd openimscore-packages/TOSCA/ims-nsd\nzip -r ims.csar . -x  .*  -x  */.*   For this example we assume the network used to interconnect the components is called \"mgmt\", if you want to modify this example ensure you are naming the network accordingly, the scripts from the github do not handle different network names yet. Also the vimInstanceName may be different to you, depending on your setup. The deployment_flavor is optional but should containg enough RAM for the default configuration of the components to be able to run, else some components may crash on start. This example setup has been successfuly tested on clean  Ubuntu14.04 images  with 2048 Mb RAM deployed on an  Openstack Kilo (2015.1.3) . Ensure that the image name defined in the Metadata.yaml of each package is existing.  You can easily onboard the CSAR from the Dashboard. ( Catalogue -  NS Descriptors -  Upload CSAR NSD)", 
            "title": "Example for creating the NSD CSAR"
        }, 
        {
            "location": "/tosca-ims/#deploy-the-network-service-descriptor", 
            "text": "Deploy the stored NSD by using the dashboard.  You need to go again to the GUI, go to  Catalogue -  NS Descriptors , and open the drop down menu of the openIMSCore NSD by clicking on  Action . Afterwards you need to press the  Launch  button in order to start the deployment of this NSD.  If you go to  Orchestrate NS -  NS Records  in the menu on the left side, you can follow the deployment process and check the current status of the deploying NSD.", 
            "title": "Deploy the Network Service Descriptor"
        }, 
        {
            "location": "/tosca-ims/#conclusions", 
            "text": "Once the Network Service Record went to \"ACTIVE\" your  OpenIMSCore  -  Bind9  -  FHoSS  deployment is finished.   To test your  OpenIMSCore  you may use a Sip client of your choice. Be sure to use the realm defined in your  Bind9 Virtual Network Function Descriptor  while testing registration and call. By default the  FHoSS  conaints 2 users : alice and bob. The user is the same as the password, but you may also alter it to your needs modifying the  FHoSS Virtual Network Function Descriptor  ( You will find the users in \"var_user_data.sql\" file under the fhoss folder)  For Benchmarking we can use  IMS Bench SIPp  but then you should add more users to the  FHoSS  database since by default it only contains 2 users.    \n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Conclusions"
        }, 
        {
            "location": "/tosca-vnfd/", 
            "text": "TOSCA Virtual Network Function Template\n\n\nThe definition follows the TOSCA Simple Profile for Network Functions Virtualization (NFV) \nVersion 1.0\n\nRegarding the objects defined from ETSI please see: \nETSI GS NFV-MAN 001\n\n\nPremise: some of the objects are defined by OpenBaton\n\n\nMapping between TOSCA and ETSI NFV\n\n\n\n\n\n\n\n\nTOSCA Type\n\n\nETSI Entity\n\n\n\n\n\n\n\n\n\n\ntosca.nodes.nfv.VDU\n\n\nVirtual Deployment Unit (vnfd:vdu)\n\n\n\n\n\n\ntosca.nodes.nfv.VL\n\n\nVirtual Link Descriptor\n\n\n\n\n\n\ntosca.nodes.nfv.CP\n\n\nConnection Point\n\n\n\n\n\n\n\n\nImportant Note:\n Remember for each component to specify the type and always use the types above. Otherwise the component will not be recognised and can not be parsed.\n\n\nDeploy a VNFD TOSCA Template\n\n\nWe are going to create a Virtual Network Function Descriptor (VNFD) from a TOSCA-defined VNFD Template.\nIt has the following structure:\n\n\ntosca_definitions_version: tosca_simple_profile_for_vnf_1_0\ndescription: Example of VNFD Template\n\nmetadata:\n  ID: dummy-server\n  vendor: Fokus\n  version: 1.0\n\ninputs: #Explained below\ntopology_template: #Explained below\n\n\n\n\n\n\n\n\n\n\nName\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntosca_definitions_version\n\n\nThe TOSCA NFV version that the template follows.\n\n\n\n\n\n\ndescription\n\n\nA short description of the template.\n\n\n\n\n\n\nmetadata\n\n\nAn Object containing metadata about the Virtual Network Function - name, version and creator.\n\n\n\n\n\n\ninputs\n\n\nExplained below\n\n\n\n\n\n\ntopology_template\n\n\nExplained below\n\n\n\n\n\n\n\n\nInputs Template\n\n\nThe Inputs Template consists of parameters needed for creating a Virtual Network Function Descriptor that can be added to Open Baton. An example of how the template should look like is shown below.\n\n\ninputs:\n  vnfPackageLocation: https://github.com/openbaton/vnf-scripts.git\n  endpoint: dummy\n  deploymentFlavour:\n    - flavour_key: m1.small\n  interfaces:\n    lifecycle:\n      INSTANTIATE :\n        - install.sh\n        - start-srv.sh\n  configurations:\n    name: server-configurations\n    configurationParameters:\n      - key: value\n      - key2: value2\n\n\n\n\n\nInputs Template\n parameters: \n\n\n\n\n\n\n\n\nName\n\n\nValue\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nvnfPackageLocation\n\n\nURL\n\n\nIt is URL where the Orchestrator will fetch the Scripts needed in the lifecycle events defined in the \ninterfaces\n\n\n\n\n\n\ndeploymentFlavour\n\n\nList of flavour_key\n\n\nIt is a list flavors each one refers to Virtual hardware templates called \"flavors\" in OpenStack\n\n\n\n\n\n\nendpoint\n\n\nString\n\n\nThe VNFManager deploying the VNF itself\n\n\n\n\n\n\ninterfaces\n\n\nSee the Table below\n\n\nDefines the lifecycle events and the scripts needed for their execution.\n\n\n\n\n\n\nconfigurations\n\n\nObject with two values \nname\n, \nconfigurationParameters\n\n\nname\n: is a String with the name of the Configuration, \nconfigurationParameters\n: the list of Parameters defined by a pair of \n key, value \n\n\n\n\n\n\n\n\nThe \nInterfaces\n for the VNF has only one option at the moment: \nlifecycle\n\n\nFor the \nlifecycle\n object are the following events defined in compliance with the ETSI Lifecycle Events. \n\n\n\n\n\n\n\n\nLifecycle event\n\n\nValue\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nINSTANTIATE\n\n\nList of Script files\n\n\nThe Scripts will be called for this Lifecycle event\n\n\n\n\n\n\nCONFIGURE\n\n\nList of Script files\n\n\nThe Scripts will be called for this Lifecycle event\n\n\n\n\n\n\nSTART\n\n\nList of Script files\n\n\nThe Scripts will be called for this Lifecycle event\n\n\n\n\n\n\nSTOP\n\n\nList of Script files\n\n\nThe Scripts will be called for this Lifecycle event\n\n\n\n\n\n\nTERMINATE\n\n\nList of Script files\n\n\nThe Scripts will be called for this Lifecycle event\n\n\n\n\n\n\n\n\nTopology Template\n\n\nAt the moment the Topology template includes only the Node Templates. \n\n\nNode Templates\n\n\nThe Node Templates are the descriptions of the objects (Virtual Deployment Units, Connection Points, Virtual Links) which constitute the Virtual Network Function. Each node is defined by its name and the parameters needed to create its descriptor.\n\n\nNode Template: Virtual Deployment Unit (VDU)\n\n\nThis is an example of a VDU template and similar to above after that we explain briefly the components of the template.\n\n\nVDU2:\n  type: tosca.nodes.nfv.VDU\n  properties:\n    scale_in_out: 2\n    vim_instance_name:\n         - test-vim-instance\n  artifacts:\n    type: tosca.artifacts.Deployment.Image.VM\n    file: ubuntu-14.04-server-cloudimg-amd64-disk1\n\n\n\n\n\n\n\n\n\n\nName\n\n\nValue\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntype\n\n\ntosca.nodes.nfv.VDU\n\n\nType of the node. In the example it defines the node as a VDU node.\n\n\n\n\n\n\nproperties\n\n\nSee the Table below\n\n\nDefines parameters needed for deploying a VDU\n\n\n\n\n\n\nrequirements\n\n\nList of requirement\n\n\nDescribes the component requirements for the VDU\n\n\n\n\n\n\nartifacts\n\n\nList of artifacts\n\n\nDescribes the list of images in OpenStack that will be used to instantiate a VNFC\n\n\n\n\n\n\n\n\nThe \nProperties\n Object of a VDU node has the following components:\n\n\n\n\n\n\n\n\nName\n\n\nValue\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nscale_in_out\n\n\nInteger\n\n\nMaximum value of VNFCs that can be instantiated in the process of scale-in/out\n\n\n\n\n\n\nvim_instance_name\n\n\nList \n String \n\n\nNames of Points of Persistence (PoP) where this VNFC will be instantiated \nNOTE:\n This is not required.\n\n\n\n\n\n\n\n\nThe \nArtifacts\n Object of a VDU node has the following components:\n\n\n\n\n\n\n\n\nName\n\n\nValue\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntype\n\n\ntosca.artifacts.Deployment.Image.VM\n\n\nOnly one type supported at the moment\n\n\n\n\n\n\nfile\n\n\nString\n\n\nName of the file located on OpenStack\n\n\n\n\n\n\n\n\nThe \nRequirements\n Object of a VDU node defines a list of virtual links to Connection Points. Exactly like the VNF Node the \nRequirements\n define a list of key-value pair, but in this case the only key is defined as follows:\n\n\n\n\n\n\n\n\nName\n\n\nValue\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nvirtualLink\n\n\nString\n\n\nShows where the VDU is connected\n\n\n\n\n\n\n\n\nNode Template: Connection Point (CP)\n\n\nThis is an example of a CP template and similar to above after that we explain briefly the components of the template.\n\n\nCP1:\n  type: tosca.nodes.nfv.CP\n  properties:\n    floatingIP: random\n  requirements:\n    - virtualBinding: VDU1\n    - virtualLink: private\n\n\n\n\n\n\n\n\n\n\n\nName\n\n\nValue\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntype\n\n\ntosca.nodes.nfv.CP\n\n\nType of the node. In the example it defines the node as a CP node.\n\n\n\n\n\n\nproperties: floatingIP\n\n\nString\n\n\nOnly property defined at the moment is \nfloatingIP\n. In this case \nfloatingIp\n means that has a public IP chosen \nrandom\n  by OpenStack\n\n\n\n\n\n\nrequirements: virtualBinding\n\n\nString\n\n\nIt describes the requirements for the CP in the example above the CP needs a \nvirtualBinding\n to the VDU in this case \nVDU1\n. The bindings can be multiple hence the requirements is a node.\n\n\n\n\n\n\nrequirements: virtualLink\n\n\nString\n\n\nIt refers to Node Template which describes the Virtual Link in this case the Virtual Link is called \nprivate\n. Same applies here regarding requirements being a list.\n\n\n\n\n\n\n\n\nNode Template: Virtual Link (VL)\n\n\nOpenBaton uses Virtual Link names as subnets from OpenStack.\n\n\nThis is the definition of a Virtual Link called \nprivate\n:\n\n\n\nprivate:\n  type: tosca.nodes.nfv.VL\n  properties:\n    vendor: Fokus\n\n\n\n\n\n\n\n\n\n\nName\n\n\nValue\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntype\n\n\ntosca.nodes.nfv.VL\n\n\nIt is the type of the node. In this example Virtual Link.\n\n\n\n\n\n\nproperties:vendor\n\n\nString\n\n\nInformation about the vendor of this Virtual Link.\n\n\n\n\n\n\n\n\nNOTE\n: Whenever a value of a given parameter is a string, it is best to put it in quotation marks. Example : \n\n\nconfigurations:\n    name: server-configurations\n    configurationParameters:\n      - key: \nvalue\n\n\n\n\n\n\nComplete Example\n\n\ntosca_definitions_version: tosca_simple_profile_for_nfv_1_0\ndescription: Example of VNFD Template\n\nmetadata:\n  ID: dummy-server\n  vendor: Fokus\n  version: 0.1\n\ninputs:\n  interfaces:\n    lifecycle:\n      INSTANTIATE :\n        - install.sh\n        - start-srv.sh\n\n  deploymentFlavour:\n    - flavour_key: m1.small\n  configurations:\n    name: server-configurations\n    configurationParameters:\n      - key: value\n      - key2: value2\n\n  vnfPackageLocation: https://github.com/openbaton/vnf-scripts.git\n  endpoint: dummy\n  type: server\n\ntopology_template:\n\n  node_templates:\n\n    vdu1:\n      type: tosca.nodes.nfv.VDU\n      properties:\n        scale_in_out: 1\n        vim_instance_name:\n         - test-vim-instance\n      artifacts:\n        VDU1Image:\n          type: tosca.artifacts.Deployment.Image.VM\n          file: ubuntu-14.04-server-cloudimg-amd64-disk1\n\n    cp1:\n      type: tosca.nodes.nfv.CP\n      requirements:\n        - virtualBinding: vdu1\n        - virtualLink: private\n\n    private:\n      type: tosca.nodes.nfv.VL\n      properties:\n        vendor: Fokus\n\n\n\n\n\nNOTE\n: Save the template in a file called server-iperf.yaml.\n\n\nYou can create a \nCSAR\n and upload it to the NFVO using the \nDashboard\n. \n\n\n\n\n\n\n\n\n\n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "**HIDDEN**"
        }, 
        {
            "location": "/tosca-vnfd/#tosca-virtual-network-function-template", 
            "text": "The definition follows the TOSCA Simple Profile for Network Functions Virtualization (NFV)  Version 1.0 \nRegarding the objects defined from ETSI please see:  ETSI GS NFV-MAN 001  Premise: some of the objects are defined by OpenBaton", 
            "title": "TOSCA Virtual Network Function Template"
        }, 
        {
            "location": "/tosca-vnfd/#mapping-between-tosca-and-etsi-nfv", 
            "text": "TOSCA Type  ETSI Entity      tosca.nodes.nfv.VDU  Virtual Deployment Unit (vnfd:vdu)    tosca.nodes.nfv.VL  Virtual Link Descriptor    tosca.nodes.nfv.CP  Connection Point     Important Note:  Remember for each component to specify the type and always use the types above. Otherwise the component will not be recognised and can not be parsed.", 
            "title": "Mapping between TOSCA and ETSI NFV"
        }, 
        {
            "location": "/tosca-vnfd/#deploy-a-vnfd-tosca-template", 
            "text": "We are going to create a Virtual Network Function Descriptor (VNFD) from a TOSCA-defined VNFD Template.\nIt has the following structure:  tosca_definitions_version: tosca_simple_profile_for_vnf_1_0\ndescription: Example of VNFD Template\n\nmetadata:\n  ID: dummy-server\n  vendor: Fokus\n  version: 1.0\n\ninputs: #Explained below\ntopology_template: #Explained below     Name  Description      tosca_definitions_version  The TOSCA NFV version that the template follows.    description  A short description of the template.    metadata  An Object containing metadata about the Virtual Network Function - name, version and creator.    inputs  Explained below    topology_template  Explained below", 
            "title": "Deploy a VNFD TOSCA Template"
        }, 
        {
            "location": "/tosca-vnfd/#inputs-template", 
            "text": "The Inputs Template consists of parameters needed for creating a Virtual Network Function Descriptor that can be added to Open Baton. An example of how the template should look like is shown below.  inputs:\n  vnfPackageLocation: https://github.com/openbaton/vnf-scripts.git\n  endpoint: dummy\n  deploymentFlavour:\n    - flavour_key: m1.small\n  interfaces:\n    lifecycle:\n      INSTANTIATE :\n        - install.sh\n        - start-srv.sh\n  configurations:\n    name: server-configurations\n    configurationParameters:\n      - key: value\n      - key2: value2  Inputs Template  parameters:      Name  Value  Description      vnfPackageLocation  URL  It is URL where the Orchestrator will fetch the Scripts needed in the lifecycle events defined in the  interfaces    deploymentFlavour  List of flavour_key  It is a list flavors each one refers to Virtual hardware templates called \"flavors\" in OpenStack    endpoint  String  The VNFManager deploying the VNF itself    interfaces  See the Table below  Defines the lifecycle events and the scripts needed for their execution.    configurations  Object with two values  name ,  configurationParameters  name : is a String with the name of the Configuration,  configurationParameters : the list of Parameters defined by a pair of   key, value      The  Interfaces  for the VNF has only one option at the moment:  lifecycle  For the  lifecycle  object are the following events defined in compliance with the ETSI Lifecycle Events.      Lifecycle event  Value  Description      INSTANTIATE  List of Script files  The Scripts will be called for this Lifecycle event    CONFIGURE  List of Script files  The Scripts will be called for this Lifecycle event    START  List of Script files  The Scripts will be called for this Lifecycle event    STOP  List of Script files  The Scripts will be called for this Lifecycle event    TERMINATE  List of Script files  The Scripts will be called for this Lifecycle event", 
            "title": "Inputs Template"
        }, 
        {
            "location": "/tosca-vnfd/#topology-template", 
            "text": "At the moment the Topology template includes only the Node Templates.", 
            "title": "Topology Template"
        }, 
        {
            "location": "/tosca-vnfd/#node-templates", 
            "text": "The Node Templates are the descriptions of the objects (Virtual Deployment Units, Connection Points, Virtual Links) which constitute the Virtual Network Function. Each node is defined by its name and the parameters needed to create its descriptor.", 
            "title": "Node Templates"
        }, 
        {
            "location": "/tosca-vnfd/#node-template-virtual-deployment-unit-vdu", 
            "text": "This is an example of a VDU template and similar to above after that we explain briefly the components of the template.  VDU2:\n  type: tosca.nodes.nfv.VDU\n  properties:\n    scale_in_out: 2\n    vim_instance_name:\n         - test-vim-instance\n  artifacts:\n    type: tosca.artifacts.Deployment.Image.VM\n    file: ubuntu-14.04-server-cloudimg-amd64-disk1     Name  Value  Description      type  tosca.nodes.nfv.VDU  Type of the node. In the example it defines the node as a VDU node.    properties  See the Table below  Defines parameters needed for deploying a VDU    requirements  List of requirement  Describes the component requirements for the VDU    artifacts  List of artifacts  Describes the list of images in OpenStack that will be used to instantiate a VNFC     The  Properties  Object of a VDU node has the following components:     Name  Value  Description      scale_in_out  Integer  Maximum value of VNFCs that can be instantiated in the process of scale-in/out    vim_instance_name  List   String   Names of Points of Persistence (PoP) where this VNFC will be instantiated  NOTE:  This is not required.     The  Artifacts  Object of a VDU node has the following components:     Name  Value  Description      type  tosca.artifacts.Deployment.Image.VM  Only one type supported at the moment    file  String  Name of the file located on OpenStack     The  Requirements  Object of a VDU node defines a list of virtual links to Connection Points. Exactly like the VNF Node the  Requirements  define a list of key-value pair, but in this case the only key is defined as follows:     Name  Value  Description      virtualLink  String  Shows where the VDU is connected", 
            "title": "Node Template: Virtual Deployment Unit (VDU)"
        }, 
        {
            "location": "/tosca-vnfd/#node-template-connection-point-cp", 
            "text": "This is an example of a CP template and similar to above after that we explain briefly the components of the template.  CP1:\n  type: tosca.nodes.nfv.CP\n  properties:\n    floatingIP: random\n  requirements:\n    - virtualBinding: VDU1\n    - virtualLink: private     Name  Value  Description      type  tosca.nodes.nfv.CP  Type of the node. In the example it defines the node as a CP node.    properties: floatingIP  String  Only property defined at the moment is  floatingIP . In this case  floatingIp  means that has a public IP chosen  random   by OpenStack    requirements: virtualBinding  String  It describes the requirements for the CP in the example above the CP needs a  virtualBinding  to the VDU in this case  VDU1 . The bindings can be multiple hence the requirements is a node.    requirements: virtualLink  String  It refers to Node Template which describes the Virtual Link in this case the Virtual Link is called  private . Same applies here regarding requirements being a list.", 
            "title": "Node Template: Connection Point (CP)"
        }, 
        {
            "location": "/tosca-vnfd/#node-template-virtual-link-vl", 
            "text": "OpenBaton uses Virtual Link names as subnets from OpenStack.  This is the definition of a Virtual Link called  private :  \nprivate:\n  type: tosca.nodes.nfv.VL\n  properties:\n    vendor: Fokus     Name  Value  Description      type  tosca.nodes.nfv.VL  It is the type of the node. In this example Virtual Link.    properties:vendor  String  Information about the vendor of this Virtual Link.     NOTE : Whenever a value of a given parameter is a string, it is best to put it in quotation marks. Example :   configurations:\n    name: server-configurations\n    configurationParameters:\n      - key:  value", 
            "title": "Node Template: Virtual Link (VL)"
        }, 
        {
            "location": "/tosca-vnfd/#complete-example", 
            "text": "tosca_definitions_version: tosca_simple_profile_for_nfv_1_0\ndescription: Example of VNFD Template\n\nmetadata:\n  ID: dummy-server\n  vendor: Fokus\n  version: 0.1\n\ninputs:\n  interfaces:\n    lifecycle:\n      INSTANTIATE :\n        - install.sh\n        - start-srv.sh\n\n  deploymentFlavour:\n    - flavour_key: m1.small\n  configurations:\n    name: server-configurations\n    configurationParameters:\n      - key: value\n      - key2: value2\n\n  vnfPackageLocation: https://github.com/openbaton/vnf-scripts.git\n  endpoint: dummy\n  type: server\n\ntopology_template:\n\n  node_templates:\n\n    vdu1:\n      type: tosca.nodes.nfv.VDU\n      properties:\n        scale_in_out: 1\n        vim_instance_name:\n         - test-vim-instance\n      artifacts:\n        VDU1Image:\n          type: tosca.artifacts.Deployment.Image.VM\n          file: ubuntu-14.04-server-cloudimg-amd64-disk1\n\n    cp1:\n      type: tosca.nodes.nfv.CP\n      requirements:\n        - virtualBinding: vdu1\n        - virtualLink: private\n\n    private:\n      type: tosca.nodes.nfv.VL\n      properties:\n        vendor: Fokus  NOTE : Save the template in a file called server-iperf.yaml.  You can create a  CSAR  and upload it to the NFVO using the  Dashboard .     \n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Complete Example"
        }, 
        {
            "location": "/tosca-nsd/", 
            "text": "TOSCA Network Service Template\n\n\nThis definition follows the TOSCA Simple Profile for Network Functions Virtualization (NFV) \nVersion 1.0\n\nIn this documentation we will present how to create a TOSCA Network Service Template compliant with OpenBaton. This template can be added to a CSAR and onboarded on the NFVO.\n\n\nPremise: some of the objects are defined by OpenBaton\n\n\nMapping between TOSCA and ETSI NFV\n\n\n\n\n\n\n\n\nTOSCA Type\n\n\nETSI Entity\n\n\n\n\n\n\n\n\n\n\nopenbaton.type.VNF\n\n\nVirtual Network Function Descriptor\n\n\n\n\n\n\ntosca.nodes.nfv.VDU\n\n\nVirtual Deployment Unit\n\n\n\n\n\n\ntosca.nodes.nfv.VL\n\n\nVirtual Link Descriptor\n\n\n\n\n\n\ntosca.nodes.nfv.CP\n\n\nConnection Point\n\n\n\n\n\n\n\n\nStructure\n\n\nWe are going to create a Template that represents a dummy scenario, similiar to the one explained \nhere\n, to illustrate how the Templates have to be structured and what can be specified.\n\n\nThe Template has the following structure: \n\n\ntosca_definitions_version: tosca_1.0\ndescription: Example of NS Template\n\nmetadata:\n  ID: dummy-NS\n  vendor: Fokus\n  version: 0.1\n\ntopology_template: #Explained below\nrelationships_template: #Explained below\n\n\n\n\n\n\n\n\n\n\nName\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntosca_definitions_version\n\n\nThe version of the template that follows it.\n\n\n\n\n\n\ndescription\n\n\nA short description of the template.\n\n\n\n\n\n\nmetadata\n\n\nAn Object containing metadata about the Network Service - name, version and creator.\n\n\n\n\n\n\nrelationships_template\n\n\nExplained below\n\n\n\n\n\n\ntopology_template\n\n\nExplained below\n\n\n\n\n\n\n\n\nTopology Template\n\n\nFor now the Topology template includes only the Node Templates. \n\n\nNode Templates\n\n\nThe Node Templates are the description of the objects which constitute the Network Service Descriptor. Each node is defined by its name and the parameters needed to create its descriptor.\n\n\nNode Template: Virtual Network Function (VNF)\n\n\nThis is an example of VNF Template defined inside the NSD Template. The parameters available and needed to create a Virtual Network Function Descriptor are defined and explained below: \n\n\ndummy-server:\n        type: openbaton.type.VNF\n        properties:\n          vendor: Fokus\n          version: 0.1\n          endpoint: dummy\n          type: server\n          configurations:\n            name: config_name\n            configurationParameters:\n              - key: value\n              - key2: value2\n          vnfPackageLocation: https://github.com/openbaton/vnf-scripts.git\n          deploymentFlavour:\n            - flavour_key: m1.small\n        requirements:\n          - virtualLink: private\n          - vdu: VDU2\n        interfaces:\n          lifecycle: # lifecycle\n            instantiate:\n              - install.sh\n              - start-srv.sh\n\n\n\n\nThis Virtual Network Function is called \ndummy-server\n \n\n\n\n\n\n\n\n\nName\n\n\nValue\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntype\n\n\nopenbaton.type.VNF\n\n\nType of the node. In the example it defines the node as a VNF node.\n\n\n\n\n\n\nproperties\n\n\nSee the Table below\n\n\nDefines parameters needed for deploying a VNFD\n\n\n\n\n\n\nrequirements\n\n\nSee the Table below\n\n\nDescribes the component requirements for the VNF\n\n\n\n\n\n\ninterfaces\n\n\nSee the Table below\n\n\nDefines the lifecycle events and the scripts needed for their execution.\n\n\n\n\n\n\n\n\nThe \nProperties\n for the VNF are:\n\n\n\n\n\n\n\n\nName\n\n\nValue\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nvendor\n\n\nString\n\n\nName of the provider of the VNF\n\n\n\n\n\n\nversion\n\n\nString\n\n\nVersion of the provider of the VNF\n\n\n\n\n\n\nconfigurations\n\n\nObject with two values \nname\n, \nconfigurationParameters\n\n\nname\n: is a String with the name of the Configuration, \nconfigurationParameters\n: the list of Parameters defined by a pair of \n key, value \n\n\n\n\n\n\nvnfPackageLocation\n\n\nURL\n\n\nIt is URL where the Orchestrator will fetch the Scripts needed in the lifecycle events defined in the \ninterfaces\n\n\n\n\n\n\ndeploymentFlavour\n\n\nList of flavour_key\n\n\nIt is a list flavors each one refers to Virtual hardware templates called \"flavors\" in OpenStack\n\n\n\n\n\n\nendpoint\n\n\nString\n\n\nThe VNFManager deploying the VNF itself\n\n\n\n\n\n\n\n\nThe \nRequirements\n for the VNF is an object containing a list of String key-value pairs and the keys are defined the following way:\n\n\n\n\n\n\n\n\nName\n\n\nValue\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nvirtualLink\n\n\nString\n\n\nShows where the VNF is connected\n\n\n\n\n\n\nvdu\n\n\nString\n\n\nDefines a VDU which is a part of the VNF\n\n\n\n\n\n\n\n\nThe \nInterfaces\n for the VNF has only one option at the moment: \nlifecycle\n\n\nFor the \nlifecycle\n object are the following events defined in compliance with the ETSI Lifecycle Events. \n\n\n\n\n\n\n\n\nLifecycle event\n\n\nValue\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nINSTANTIATE\n\n\nList of Script files\n\n\nThe Scripts will be called for this Lifecycle event\n\n\n\n\n\n\nCONFIGURE\n\n\nList of Script files\n\n\nThe Scripts will be called for this Lifecycle event\n\n\n\n\n\n\nSTART\n\n\nList of Script files\n\n\nThe Scripts will be called for this Lifecycle event\n\n\n\n\n\n\nSTOP\n\n\nList of Script files\n\n\nThe Scripts will be called for this Lifecycle event\n\n\n\n\n\n\nTERMINATE\n\n\nList of Script files\n\n\nThe Scripts will be called for this Lifecycle event\n\n\n\n\n\n\n\n\nNode Template: Virtual Deployment Unit (VDU)\n\n\nThis is an example of a VDU template and similar to above after that we explain briefly the components of the template.\n\n\nVDU2:\n  type: tosca.nodes.nfv.VDU\n  properties:\n    scale_in_out: 2\n    vim_instance_name:\n         - test-vim-instance\n  artifacts:\n    type: tosca.artifacts.Deployment.Image.VM\n    file: ubuntu-14.04-server-cloudimg-amd64-disk1\n\n\n\n\n\n\n\n\n\n\nName\n\n\nValue\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntype\n\n\ntosca.nodes.nfv.VDU\n\n\nType of the node. In the example it defines the node as a VDU node.\n\n\n\n\n\n\nproperties\n\n\nSee the Table below\n\n\nDefines parameters needed for deploying a VDU\n\n\n\n\n\n\nrequirements\n\n\nList of requirement\n\n\nDescribes the component requirements for the VDU\n\n\n\n\n\n\nartifacts\n\n\nList of artifacts\n\n\nDescribes the list of images in OpenStack that will be used to instantiate a VNFC\n\n\n\n\n\n\n\n\nThe \nProperties\n Object of a VDU node has the following components:\n\n\n\n\n\n\n\n\nName\n\n\nValue\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nscale_in_out\n\n\nInteger\n\n\nMaximum value of VNFCs that can be instantiated in the process of scale-in/out\n\n\n\n\n\n\nvim_instance_name\n\n\nList \n String \n\n\nNames of Points of Persistence (PoP) where this VNFC will be instantiated \nNOTE:\n This is not required.\n\n\n\n\n\n\n\n\nThe \nArtifacts\n Object of a VDU node has the following components:\n\n\n\n\n\n\n\n\nName\n\n\nValue\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntype\n\n\ntosca.artifacts.Deployment.Image.VM\n\n\nOnly one type supported at the moment\n\n\n\n\n\n\nfile\n\n\nString\n\n\nName of the file located on OpenStack\n\n\n\n\n\n\n\n\nThe \nRequirements\n Object of a VDU node defines a list of virtual links to Connection Points. Exactly like the VNF Node the \nRequirements\n define a list of key-value pair, but in this case the only key is defined as follows:\n\n\n\n\n\n\n\n\nName\n\n\nValue\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nvirtualLink\n\n\nString\n\n\nShows where the VDU is connected\n\n\n\n\n\n\n\n\nNode Template: Connection Point (CP)\n\n\nThis is an example of a CP template and similar to above after that we explain briefly the components of the template.\n\n\nCP1:\n  type: tosca.nodes.nfv.CP\n  properties:\n    floatingIP: random\n  requirements:\n    - virtualBinding: VDU1\n    - virtualLink: private\n\n\n\n\n\n\n\n\n\n\n\nName\n\n\nValue\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntype\n\n\ntosca.nodes.nfv.CP\n\n\nType of the node. In the example it defines the node as a CP node.\n\n\n\n\n\n\nproperties: floatingIP\n\n\nString\n\n\nOnly property defined at the moment is \nfloatingIP\n. In this case \nfloatingIp\n means that has a public IP chosen \nrandom\n  by OpenStack\n\n\n\n\n\n\nrequirements: virtualBinding\n\n\nString\n\n\nIt describes the requirements for the CP in the example above the CP needs a \nvirtualBinding\n to the VDU in this case \nVDU1\n. The bindings can be multiple hence the requirements is a node.\n\n\n\n\n\n\nrequirements: virtualLink\n\n\nString\n\n\nIt refers to Node Template which describes the Virtual Link in this case the Virtual Link is called \nprivate\n. Same applies here regarding requirements being a list.\n\n\n\n\n\n\n\n\nNode Template: Virtual Link (VL)\n\n\nOpenBaton uses Virtual Link names as subnets from OpenStack.\n\n\nThis is the definition of a Virtual Link called \nprivate\n:\n\n\n\nprivate:\n  type: tosca.nodes.nfv.VL\n  properties:\n    vendor: Fokus\n\n\n\n\n\n\n\n\n\n\nName\n\n\nValue\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntype\n\n\ntosca.nodes.nfv.VL\n\n\nIt is the type of the node. In this example Virtual Link.\n\n\n\n\n\n\nproperties:vendor\n\n\nString\n\n\nInformation about the vendor of this Virtual Link.\n\n\n\n\n\n\n\n\nRelationships Template\n\n\nThe Relationships Template creates the dependency between two VNFs.\nThis is the definition of Relationships Template called \nconnection_server_client\n:\n\n\n\nrelationships_template:\n  connection_server_client:\n    type: tosca.nodes.relationships.ConnectsTo\n    source: dummy-server\n    target: dummy-client\n    parameters:\n        - private\n\n\n\n\n\n\n\n\n\n\n\nName\n\n\nValue\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntype\n\n\ntosca.nodes.relationships.ConnectsTo\n\n\nIt is the type of the Relationships Template\n\n\n\n\n\n\nsource\n\n\nString\n\n\nIt is a String which refers to the Node Template that describes the source VNF that provides some parameters in order to realize the dependency with the target VNF\n\n\n\n\n\n\ntarget\n\n\nString\n\n\nIt is a String which refers to the Node Template that describes the target VNF that requires some parameters in order to realize the dependency with the source VNF\n\n\n\n\n\n\nparameters\n\n\nList \n String \n\n\nList of parameters for this dependency\n\n\n\n\n\n\n\n\nNOTE\n: Whenever a value of a given parameter is a string, it is best to put it in quotation marks. Example : \n\n\nconfigurations:\n    name: server-configurations\n    configurationParameters:\n      - key: \nvalue\n\n\n\n\n\n\nComplete Example\n\n\ntosca_definitions_version: tosca_simple_profile_for_nfv_1_0\ndescription: Example of NSD\n\nmetadata:\n  ID: dummy-NS\n  vendor: Fokus\n  version: 0.1\n\ntopology_template:\n\n  node_templates:\n\n    dummy-server:\n        type: openbaton.type.VNF\n        properties:\n          vendor: Fokus\n          version: 0.1\n          endpoint: dummy\n          type: server\n          configurations:\n            name: server-configurations\n            configurationParameters:\n              - key: value\n              - key2: value2\n          vnfPackageLocation: https://github.com/openbaton/vnf-scripts.git\n          deployment_flavour:\n            - flavour_key: m1.small\n            - flavour_key: m1.large\n        requirements:\n          - virtualLink: private\n          - vdu: VDU2\n        interfaces:\n          lifecycle:\n            INSTANTIATE:\n              - install.sh\n              - install-srv.sh\n\n    dummy-client:\n      type: openbaton.type.VNF\n      properties:\n        ID: x\n        vendor: Fokus\n        version: 0.1\n        type: client\n        vnfPackageLocation: https://github.com/openbaton/vnf-scripts.git\n        deploymentFlavour:\n          - flavour_key: m1.small\n        endpoint: dummy\n      requirements:\n         - virtualLink: private\n         - vdu: VDU1\n      interfaces:\n          lifecycle: # lifecycle\n            INSTANTIATE:\n              - install.sh\n            CONFIGURE:\n              - server_start-clt.sh\n\n    VDU1:\n      type: tosca.nodes.nfv.VDU\n      properties:\n        scale_in_out: 1\n        vim_instance_name:\n          - test-vim-instance\n      artifacts:\n        VDU1Image:\n          type: tosca.artifacts.Deployment.Image.VM\n          file: ubuntu-14.04-server-cloudimg-amd64-disk1\n\n    VDU2:\n      type: tosca.nodes.nfv.VDU\n      properties:\n        scale_in_out: 2\n        vim_instance_name:\n          - test-vim-instance\n      requirements:\n        - virtual_link: CP2\n      artifacts:\n        VDU1Image:\n          type: tosca.artifacts.Deployment.Image.VM\n          file: ubuntu-14.04-server-cloudimg-amd64-disk1\n\n    CP1:\n      type: tosca.nodes.nfv.CP\n      properties:\n        floatingIP: random\n      requirements:\n        - virtualBinding: VDU1\n        - virtualLink: private\n\n    CP2: #endpoints of VNF2\n      type: tosca.nodes.nfv.CP\n      requirements:\n        - virtualBinding: VDU2\n        - virtualLink: private\n\n    private:\n      type: tosca.nodes.nfv.VL\n      properties:\n        vendor: Fokus\n\nrelationships_template:\n  connection_server_client: \n    type: tosca.nodes.relationships.ConnectsTo\n    source: dummy-server\n    target: dummy-client\n    parameters:\n        - private\n\n\n\n\n\n\nNOTE\n: Save the definition in a file called testNSDIperf.yaml.\n\n\nYou can create a \nCSAR\n and upload it to the NFVO using the \nDashboard\n.\n\n\n\n\n\n\n\n\n\n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "**HIDDEN**"
        }, 
        {
            "location": "/tosca-nsd/#tosca-network-service-template", 
            "text": "This definition follows the TOSCA Simple Profile for Network Functions Virtualization (NFV)  Version 1.0 \nIn this documentation we will present how to create a TOSCA Network Service Template compliant with OpenBaton. This template can be added to a CSAR and onboarded on the NFVO.  Premise: some of the objects are defined by OpenBaton", 
            "title": "TOSCA Network Service Template"
        }, 
        {
            "location": "/tosca-nsd/#mapping-between-tosca-and-etsi-nfv", 
            "text": "TOSCA Type  ETSI Entity      openbaton.type.VNF  Virtual Network Function Descriptor    tosca.nodes.nfv.VDU  Virtual Deployment Unit    tosca.nodes.nfv.VL  Virtual Link Descriptor    tosca.nodes.nfv.CP  Connection Point", 
            "title": "Mapping between TOSCA and ETSI NFV"
        }, 
        {
            "location": "/tosca-nsd/#structure", 
            "text": "We are going to create a Template that represents a dummy scenario, similiar to the one explained  here , to illustrate how the Templates have to be structured and what can be specified.  The Template has the following structure:   tosca_definitions_version: tosca_1.0\ndescription: Example of NS Template\n\nmetadata:\n  ID: dummy-NS\n  vendor: Fokus\n  version: 0.1\n\ntopology_template: #Explained below\nrelationships_template: #Explained below     Name  Description      tosca_definitions_version  The version of the template that follows it.    description  A short description of the template.    metadata  An Object containing metadata about the Network Service - name, version and creator.    relationships_template  Explained below    topology_template  Explained below", 
            "title": "Structure"
        }, 
        {
            "location": "/tosca-nsd/#topology-template", 
            "text": "For now the Topology template includes only the Node Templates.", 
            "title": "Topology Template"
        }, 
        {
            "location": "/tosca-nsd/#node-templates", 
            "text": "The Node Templates are the description of the objects which constitute the Network Service Descriptor. Each node is defined by its name and the parameters needed to create its descriptor.", 
            "title": "Node Templates"
        }, 
        {
            "location": "/tosca-nsd/#node-template-virtual-network-function-vnf", 
            "text": "This is an example of VNF Template defined inside the NSD Template. The parameters available and needed to create a Virtual Network Function Descriptor are defined and explained below:   dummy-server:\n        type: openbaton.type.VNF\n        properties:\n          vendor: Fokus\n          version: 0.1\n          endpoint: dummy\n          type: server\n          configurations:\n            name: config_name\n            configurationParameters:\n              - key: value\n              - key2: value2\n          vnfPackageLocation: https://github.com/openbaton/vnf-scripts.git\n          deploymentFlavour:\n            - flavour_key: m1.small\n        requirements:\n          - virtualLink: private\n          - vdu: VDU2\n        interfaces:\n          lifecycle: # lifecycle\n            instantiate:\n              - install.sh\n              - start-srv.sh  This Virtual Network Function is called  dummy-server       Name  Value  Description      type  openbaton.type.VNF  Type of the node. In the example it defines the node as a VNF node.    properties  See the Table below  Defines parameters needed for deploying a VNFD    requirements  See the Table below  Describes the component requirements for the VNF    interfaces  See the Table below  Defines the lifecycle events and the scripts needed for their execution.     The  Properties  for the VNF are:     Name  Value  Description      vendor  String  Name of the provider of the VNF    version  String  Version of the provider of the VNF    configurations  Object with two values  name ,  configurationParameters  name : is a String with the name of the Configuration,  configurationParameters : the list of Parameters defined by a pair of   key, value     vnfPackageLocation  URL  It is URL where the Orchestrator will fetch the Scripts needed in the lifecycle events defined in the  interfaces    deploymentFlavour  List of flavour_key  It is a list flavors each one refers to Virtual hardware templates called \"flavors\" in OpenStack    endpoint  String  The VNFManager deploying the VNF itself     The  Requirements  for the VNF is an object containing a list of String key-value pairs and the keys are defined the following way:     Name  Value  Description      virtualLink  String  Shows where the VNF is connected    vdu  String  Defines a VDU which is a part of the VNF     The  Interfaces  for the VNF has only one option at the moment:  lifecycle  For the  lifecycle  object are the following events defined in compliance with the ETSI Lifecycle Events.      Lifecycle event  Value  Description      INSTANTIATE  List of Script files  The Scripts will be called for this Lifecycle event    CONFIGURE  List of Script files  The Scripts will be called for this Lifecycle event    START  List of Script files  The Scripts will be called for this Lifecycle event    STOP  List of Script files  The Scripts will be called for this Lifecycle event    TERMINATE  List of Script files  The Scripts will be called for this Lifecycle event", 
            "title": "Node Template: Virtual Network Function (VNF)"
        }, 
        {
            "location": "/tosca-nsd/#node-template-virtual-deployment-unit-vdu", 
            "text": "This is an example of a VDU template and similar to above after that we explain briefly the components of the template.  VDU2:\n  type: tosca.nodes.nfv.VDU\n  properties:\n    scale_in_out: 2\n    vim_instance_name:\n         - test-vim-instance\n  artifacts:\n    type: tosca.artifacts.Deployment.Image.VM\n    file: ubuntu-14.04-server-cloudimg-amd64-disk1     Name  Value  Description      type  tosca.nodes.nfv.VDU  Type of the node. In the example it defines the node as a VDU node.    properties  See the Table below  Defines parameters needed for deploying a VDU    requirements  List of requirement  Describes the component requirements for the VDU    artifacts  List of artifacts  Describes the list of images in OpenStack that will be used to instantiate a VNFC     The  Properties  Object of a VDU node has the following components:     Name  Value  Description      scale_in_out  Integer  Maximum value of VNFCs that can be instantiated in the process of scale-in/out    vim_instance_name  List   String   Names of Points of Persistence (PoP) where this VNFC will be instantiated  NOTE:  This is not required.     The  Artifacts  Object of a VDU node has the following components:     Name  Value  Description      type  tosca.artifacts.Deployment.Image.VM  Only one type supported at the moment    file  String  Name of the file located on OpenStack     The  Requirements  Object of a VDU node defines a list of virtual links to Connection Points. Exactly like the VNF Node the  Requirements  define a list of key-value pair, but in this case the only key is defined as follows:     Name  Value  Description      virtualLink  String  Shows where the VDU is connected", 
            "title": "Node Template: Virtual Deployment Unit (VDU)"
        }, 
        {
            "location": "/tosca-nsd/#node-template-connection-point-cp", 
            "text": "This is an example of a CP template and similar to above after that we explain briefly the components of the template.  CP1:\n  type: tosca.nodes.nfv.CP\n  properties:\n    floatingIP: random\n  requirements:\n    - virtualBinding: VDU1\n    - virtualLink: private     Name  Value  Description      type  tosca.nodes.nfv.CP  Type of the node. In the example it defines the node as a CP node.    properties: floatingIP  String  Only property defined at the moment is  floatingIP . In this case  floatingIp  means that has a public IP chosen  random   by OpenStack    requirements: virtualBinding  String  It describes the requirements for the CP in the example above the CP needs a  virtualBinding  to the VDU in this case  VDU1 . The bindings can be multiple hence the requirements is a node.    requirements: virtualLink  String  It refers to Node Template which describes the Virtual Link in this case the Virtual Link is called  private . Same applies here regarding requirements being a list.", 
            "title": "Node Template: Connection Point (CP)"
        }, 
        {
            "location": "/tosca-nsd/#node-template-virtual-link-vl", 
            "text": "OpenBaton uses Virtual Link names as subnets from OpenStack.  This is the definition of a Virtual Link called  private :  \nprivate:\n  type: tosca.nodes.nfv.VL\n  properties:\n    vendor: Fokus     Name  Value  Description      type  tosca.nodes.nfv.VL  It is the type of the node. In this example Virtual Link.    properties:vendor  String  Information about the vendor of this Virtual Link.", 
            "title": "Node Template: Virtual Link (VL)"
        }, 
        {
            "location": "/tosca-nsd/#relationships-template", 
            "text": "The Relationships Template creates the dependency between two VNFs.\nThis is the definition of Relationships Template called  connection_server_client :  \nrelationships_template:\n  connection_server_client:\n    type: tosca.nodes.relationships.ConnectsTo\n    source: dummy-server\n    target: dummy-client\n    parameters:\n        - private     Name  Value  Description      type  tosca.nodes.relationships.ConnectsTo  It is the type of the Relationships Template    source  String  It is a String which refers to the Node Template that describes the source VNF that provides some parameters in order to realize the dependency with the target VNF    target  String  It is a String which refers to the Node Template that describes the target VNF that requires some parameters in order to realize the dependency with the source VNF    parameters  List   String   List of parameters for this dependency     NOTE : Whenever a value of a given parameter is a string, it is best to put it in quotation marks. Example :   configurations:\n    name: server-configurations\n    configurationParameters:\n      - key:  value", 
            "title": "Relationships Template"
        }, 
        {
            "location": "/tosca-nsd/#complete-example", 
            "text": "tosca_definitions_version: tosca_simple_profile_for_nfv_1_0\ndescription: Example of NSD\n\nmetadata:\n  ID: dummy-NS\n  vendor: Fokus\n  version: 0.1\n\ntopology_template:\n\n  node_templates:\n\n    dummy-server:\n        type: openbaton.type.VNF\n        properties:\n          vendor: Fokus\n          version: 0.1\n          endpoint: dummy\n          type: server\n          configurations:\n            name: server-configurations\n            configurationParameters:\n              - key: value\n              - key2: value2\n          vnfPackageLocation: https://github.com/openbaton/vnf-scripts.git\n          deployment_flavour:\n            - flavour_key: m1.small\n            - flavour_key: m1.large\n        requirements:\n          - virtualLink: private\n          - vdu: VDU2\n        interfaces:\n          lifecycle:\n            INSTANTIATE:\n              - install.sh\n              - install-srv.sh\n\n    dummy-client:\n      type: openbaton.type.VNF\n      properties:\n        ID: x\n        vendor: Fokus\n        version: 0.1\n        type: client\n        vnfPackageLocation: https://github.com/openbaton/vnf-scripts.git\n        deploymentFlavour:\n          - flavour_key: m1.small\n        endpoint: dummy\n      requirements:\n         - virtualLink: private\n         - vdu: VDU1\n      interfaces:\n          lifecycle: # lifecycle\n            INSTANTIATE:\n              - install.sh\n            CONFIGURE:\n              - server_start-clt.sh\n\n    VDU1:\n      type: tosca.nodes.nfv.VDU\n      properties:\n        scale_in_out: 1\n        vim_instance_name:\n          - test-vim-instance\n      artifacts:\n        VDU1Image:\n          type: tosca.artifacts.Deployment.Image.VM\n          file: ubuntu-14.04-server-cloudimg-amd64-disk1\n\n    VDU2:\n      type: tosca.nodes.nfv.VDU\n      properties:\n        scale_in_out: 2\n        vim_instance_name:\n          - test-vim-instance\n      requirements:\n        - virtual_link: CP2\n      artifacts:\n        VDU1Image:\n          type: tosca.artifacts.Deployment.Image.VM\n          file: ubuntu-14.04-server-cloudimg-amd64-disk1\n\n    CP1:\n      type: tosca.nodes.nfv.CP\n      properties:\n        floatingIP: random\n      requirements:\n        - virtualBinding: VDU1\n        - virtualLink: private\n\n    CP2: #endpoints of VNF2\n      type: tosca.nodes.nfv.CP\n      requirements:\n        - virtualBinding: VDU2\n        - virtualLink: private\n\n    private:\n      type: tosca.nodes.nfv.VL\n      properties:\n        vendor: Fokus\n\nrelationships_template:\n  connection_server_client: \n    type: tosca.nodes.relationships.ConnectsTo\n    source: dummy-server\n    target: dummy-client\n    parameters:\n        - private  NOTE : Save the definition in a file called testNSDIperf.yaml.  You can create a  CSAR  and upload it to the NFVO using the  Dashboard .    \n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Complete Example"
        }, 
        {
            "location": "/tosca-CSAR-onboarding/", 
            "text": "TOSCA CSAR on-boarding\n\n\nThis tutorial is more advanced and expects that you already know what TOSCA is and how Virtual Network Function Descriptor or Network Service Descriptor defined in the TOSCA format is structured.\nThe Cloud Service Archive \nCSAR\n is a package defined by OASIS TOSCA. It is a compressed file that includes a TOSCA template of a Network Service, and all the scripts or files that a VNF needs for the lifecycle time from creation to termination.\nThe CSAR is a zip file with this structure:\n\n\n\u251c\u2500\u2500 Definitions\n|   \u2514\u2500\u2500 testNSDiperf.yaml\n\u251c\u2500\u2500 Scripts\n|   \u251c\u2500\u2500 install.sh   \n|   \u2514\u2500\u2500 (VNF NAME)\n|        \u2514\u2500\u2500 script.sh \n\u2514\u2500\u2500 TOSCA-Metadata\n    \u251c\u2500\u2500 Metadata.yaml\n    \u2514\u2500\u2500 TOSCA.meta\n\n\n\n\n\nThe CSAR reader can read both NSDs and VNFDs written in TOSCA. The difference being that when reading a NSD it will onboard all VNFs included in the NSD and after that the NSD itself.\n\n\nThe \nTOSCA.meta\n file must contain the reference to the template in this case \nEntry-Definitions: Definitions/testNSDIperf.yaml\n. An optional feature is to define the vm image here in the metadata. It is easier to add it here one time instead of adding it multiple times in the template.\n\n\nTOSCA-Meta-File-Version: 1.0\nCSAR-Version: 1.1\nCreated-By: Fokus\nEntry-Definitions: Definitions/testNSDIperf.yaml\n\n\n\n\nThe \nMetadata.yaml\n defines essential properties for the VNF or VNFs and every CSAR has to include one. For more information on how to create such a file refer to the \nVNF Package tutorial\n. This is a simple example:\n\n\nname: NSDExample\nimage:\n    upload: false\n    names:\n        - ubuntu-14.04-server-cloudimg-amd64-disk1\nvim_types:\n    - openstack\n\n\n\n\nThe \nScripts\n folder contains all the files required from the lifecycle interfaces of the VNFs.\nIf the CSAR has a Network Service Template, then for every type of VNF included in the NS Template you have to include a folder with the scripts for that particular type.\nExample if one VNF is of type client, then the scripts for that VNF have to be put in Scripts/client folder. \n\n\nIn this example \ntestNSDIperf.yaml\n is a template for a Network Service. \nIn a CSAR the template can define either a Virtual Network Function or a Network Service that consists of multiple Virtual Network Functions. \nThe \nVNF Tosca tutorial\n and \nNS Tosca tutorial\n provide more information on how to construct a template of each kind. \n\n\ntosca_definitions_version: tosca_simple_profile_for_nfv_1_0\ndescription: Example of NSD\n\nmetadata:\n  ID: NSD-Iperf\n  vendor: Fokus\n  version: 1.0\n\ntopology_template:\n\n  node_templates:\n\n    iperf-server: #VNF1\n        type: openbaton.type.VNF\n        properties:\n          vendor: Fokus\n          version: 1.0\n          endpoint: generic\n          type: server\n          vnfPackageLocation: https://github.com/openbaton/vnf-scripts.git\n          deploymentFlavour:\n            - flavour_key: m1.small\n        requirements:\n          - virtualLink: private\n          - vdu: VDU2\n        interfaces:\n          lifecycle: # lifecycle\n            instantiate:\n              - install.sh\n              - install-srv.sh\n\n    iperf-client:\n      type: openbaton.type.VNF\n      properties:\n        ID: x\n        vendor: Fokus\n        version: 1.0\n        type: client\n        vnfPackageLocation: https://github.com/openbaton/vnf-scripts.git\n        deploymentFlavour:\n          - flavour_key: m1.small\n        endpoint: generic\n      requirements:\n         - virtualLink: private\n         - vdu: VDU1\n      interfaces:\n          lifecycle: # lifecycle\n            INSTANTIATE:\n              - install.sh\n            CONFIGURE:\n              - server_configure.sh\n\n    VDU1:\n      type: tosca.nodes.nfv.VDU\n      properties:\n        scale_in_out: 1\n      artifacts:\n        VDU1Image:\n          type: tosca.artifacts.Deployment.Image.VM\n          file: ubuntu-14.04-server-cloudimg-amd64-disk1\n\n    VDU2:\n      type: tosca.nodes.nfv.VDU\n      properties:\n        scale_in_out: 3\n      requirements:\n        - virtual_link: CP2\n      artifacts:\n        VDU1Image:\n          type: tosca.artifacts.Deployment.Image.VM\n          file: ubuntu-14.04-server-cloudimg-amd64-disk1\n\n    CP1:\n      type: tosca.nodes.nfv.CP\n      properties:\n        floatingIP: random\n      requirements:\n        - virtualBinding: VDU1\n        - virtualLink: private\n\n    CP2: #endpoints of VNF2\n      type: tosca.nodes.nfv.CP\n      requirements:\n        - virtualBinding: VDU2\n        - virtualLink: private\n\n    private:\n      type: tosca.nodes.nfv.VL\n      properties:\n        vendor: Fokus\n\nrelationships_template:\n  connection_server_client:\n    type: tosca.nodes.relationships.ConnectsTo\n    source: iperf-server\n    target: iperf-client\n    parameters:\n        - private\n\n\n\n\n\nSaving as CSAR\n\n\nTo save the three folders - Scripts, Definitions, TOSCA-Metadata as a CSAR go to the folder where you have saved them and run:\n\n\nzip -r iperf.csar . -x \n.*\n -x \n*/.*\n\n\n\n\n\nOnboarding VNF CSARs\n\n\nGo to the Catalogue -\n VNF Packages -\n Upload VNFPackage, check the \"Use CSAR Parser\" box and select the csar that you want to upload.\n\n\n \n\n\nOnboard Network Service CSARs\n\n\nGo to the Catalogue -\n NS Descriptors and click on \"Upload CSAR NSD\" and select the file.\n\n\n\n\n\n\n\n\n\n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "**HIDDEN**"
        }, 
        {
            "location": "/tosca-CSAR-onboarding/#tosca-csar-on-boarding", 
            "text": "This tutorial is more advanced and expects that you already know what TOSCA is and how Virtual Network Function Descriptor or Network Service Descriptor defined in the TOSCA format is structured.\nThe Cloud Service Archive  CSAR  is a package defined by OASIS TOSCA. It is a compressed file that includes a TOSCA template of a Network Service, and all the scripts or files that a VNF needs for the lifecycle time from creation to termination.\nThe CSAR is a zip file with this structure:  \u251c\u2500\u2500 Definitions\n|   \u2514\u2500\u2500 testNSDiperf.yaml\n\u251c\u2500\u2500 Scripts\n|   \u251c\u2500\u2500 install.sh   \n|   \u2514\u2500\u2500 (VNF NAME)\n|        \u2514\u2500\u2500 script.sh \n\u2514\u2500\u2500 TOSCA-Metadata\n    \u251c\u2500\u2500 Metadata.yaml\n    \u2514\u2500\u2500 TOSCA.meta  The CSAR reader can read both NSDs and VNFDs written in TOSCA. The difference being that when reading a NSD it will onboard all VNFs included in the NSD and after that the NSD itself.  The  TOSCA.meta  file must contain the reference to the template in this case  Entry-Definitions: Definitions/testNSDIperf.yaml . An optional feature is to define the vm image here in the metadata. It is easier to add it here one time instead of adding it multiple times in the template.  TOSCA-Meta-File-Version: 1.0\nCSAR-Version: 1.1\nCreated-By: Fokus\nEntry-Definitions: Definitions/testNSDIperf.yaml  The  Metadata.yaml  defines essential properties for the VNF or VNFs and every CSAR has to include one. For more information on how to create such a file refer to the  VNF Package tutorial . This is a simple example:  name: NSDExample\nimage:\n    upload: false\n    names:\n        - ubuntu-14.04-server-cloudimg-amd64-disk1\nvim_types:\n    - openstack  The  Scripts  folder contains all the files required from the lifecycle interfaces of the VNFs.\nIf the CSAR has a Network Service Template, then for every type of VNF included in the NS Template you have to include a folder with the scripts for that particular type.\nExample if one VNF is of type client, then the scripts for that VNF have to be put in Scripts/client folder.   In this example  testNSDIperf.yaml  is a template for a Network Service. \nIn a CSAR the template can define either a Virtual Network Function or a Network Service that consists of multiple Virtual Network Functions. \nThe  VNF Tosca tutorial  and  NS Tosca tutorial  provide more information on how to construct a template of each kind.   tosca_definitions_version: tosca_simple_profile_for_nfv_1_0\ndescription: Example of NSD\n\nmetadata:\n  ID: NSD-Iperf\n  vendor: Fokus\n  version: 1.0\n\ntopology_template:\n\n  node_templates:\n\n    iperf-server: #VNF1\n        type: openbaton.type.VNF\n        properties:\n          vendor: Fokus\n          version: 1.0\n          endpoint: generic\n          type: server\n          vnfPackageLocation: https://github.com/openbaton/vnf-scripts.git\n          deploymentFlavour:\n            - flavour_key: m1.small\n        requirements:\n          - virtualLink: private\n          - vdu: VDU2\n        interfaces:\n          lifecycle: # lifecycle\n            instantiate:\n              - install.sh\n              - install-srv.sh\n\n    iperf-client:\n      type: openbaton.type.VNF\n      properties:\n        ID: x\n        vendor: Fokus\n        version: 1.0\n        type: client\n        vnfPackageLocation: https://github.com/openbaton/vnf-scripts.git\n        deploymentFlavour:\n          - flavour_key: m1.small\n        endpoint: generic\n      requirements:\n         - virtualLink: private\n         - vdu: VDU1\n      interfaces:\n          lifecycle: # lifecycle\n            INSTANTIATE:\n              - install.sh\n            CONFIGURE:\n              - server_configure.sh\n\n    VDU1:\n      type: tosca.nodes.nfv.VDU\n      properties:\n        scale_in_out: 1\n      artifacts:\n        VDU1Image:\n          type: tosca.artifacts.Deployment.Image.VM\n          file: ubuntu-14.04-server-cloudimg-amd64-disk1\n\n    VDU2:\n      type: tosca.nodes.nfv.VDU\n      properties:\n        scale_in_out: 3\n      requirements:\n        - virtual_link: CP2\n      artifacts:\n        VDU1Image:\n          type: tosca.artifacts.Deployment.Image.VM\n          file: ubuntu-14.04-server-cloudimg-amd64-disk1\n\n    CP1:\n      type: tosca.nodes.nfv.CP\n      properties:\n        floatingIP: random\n      requirements:\n        - virtualBinding: VDU1\n        - virtualLink: private\n\n    CP2: #endpoints of VNF2\n      type: tosca.nodes.nfv.CP\n      requirements:\n        - virtualBinding: VDU2\n        - virtualLink: private\n\n    private:\n      type: tosca.nodes.nfv.VL\n      properties:\n        vendor: Fokus\n\nrelationships_template:\n  connection_server_client:\n    type: tosca.nodes.relationships.ConnectsTo\n    source: iperf-server\n    target: iperf-client\n    parameters:\n        - private", 
            "title": "TOSCA CSAR on-boarding"
        }, 
        {
            "location": "/tosca-CSAR-onboarding/#saving-as-csar", 
            "text": "To save the three folders - Scripts, Definitions, TOSCA-Metadata as a CSAR go to the folder where you have saved them and run:  zip -r iperf.csar . -x  .*  -x  */.*", 
            "title": "Saving as CSAR"
        }, 
        {
            "location": "/tosca-CSAR-onboarding/#onboarding-vnf-csars", 
            "text": "Go to the Catalogue -  VNF Packages -  Upload VNFPackage, check the \"Use CSAR Parser\" box and select the csar that you want to upload.", 
            "title": "Onboarding VNF CSARs"
        }, 
        {
            "location": "/tosca-CSAR-onboarding/#onboard-network-service-csars", 
            "text": "Go to the Catalogue -  NS Descriptors and click on \"Upload CSAR NSD\" and select the file.    \n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Onboard Network Service CSARs"
        }, 
        {
            "location": "/vnfr-states/", 
            "text": "VNF Record States\n\n\nThe states of a VNF Record are reflecting the \nETSI NFV states\n and they are shown in the following picture.\n\n\n\n\nWhen the created NSR is called the VNF and the NSR are in state NULL. After the instantiate method is finished in the VNFManager, the corresponding VNFR state is set to INSTANTIATED. When all the VNFRs are in state INSTANTIATED then also the NSR goes into state INSTANTIATED. Then in case the VNFR is target of a dependency, the MODIFY message is sent to the VNFManager and when it comes back to the NFVO, the VNFR status is set to INACTIVE. When all the VNFR are in state INACTIVE then the NSR also goes in state INACTIVE. In any case the START message is sent to the VNFManager and when it comes back, the NFVO sets the VNFR state to ACTIVE. When all the VNFRs are in state ACTIVE then the NSR also goes into state ACTIVE. Then when the terminate NSR is called, the NFVO sends the TERMINATE message to all the VNFManagers. When this message returns to the NFVO, the related VNFR state is set to TERMINATED. When all the VNFRs are in state TERMINATED then the NSR is completely deleted from the database.\n\n\n\n\n\n\n\n\n\n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "**HIDDEN**"
        }, 
        {
            "location": "/vnfr-states/#vnf-record-states", 
            "text": "The states of a VNF Record are reflecting the  ETSI NFV states  and they are shown in the following picture.   When the created NSR is called the VNF and the NSR are in state NULL. After the instantiate method is finished in the VNFManager, the corresponding VNFR state is set to INSTANTIATED. When all the VNFRs are in state INSTANTIATED then also the NSR goes into state INSTANTIATED. Then in case the VNFR is target of a dependency, the MODIFY message is sent to the VNFManager and when it comes back to the NFVO, the VNFR status is set to INACTIVE. When all the VNFR are in state INACTIVE then the NSR also goes in state INACTIVE. In any case the START message is sent to the VNFManager and when it comes back, the NFVO sets the VNFR state to ACTIVE. When all the VNFRs are in state ACTIVE then the NSR also goes into state ACTIVE. Then when the terminate NSR is called, the NFVO sends the TERMINATE message to all the VNFManagers. When this message returns to the NFVO, the related VNFR state is set to TERMINATED. When all the VNFRs are in state TERMINATED then the NSR is completely deleted from the database.    \n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "VNF Record States"
        }, 
        {
            "location": "/vnf-parameters/", 
            "text": "VNF Parameters\n\n\n\n\nThe useful parameters that you can use in your scripts are defined in two different fields of a VNFD.\n\n\n...\n\nconfigurations\n:{\n                \nname\n:\nconfig_name\n,\n                \nconfigurationParameters\n:[\n                {\n                    \nconfKey\n:\nkey1\n,\n                    \nvalue\n:\nthe_value\n\n                }\n                ]\n            },\n\n...\n\n\nprovides\n:[\n        \nparam1\n,\n        \nparam2\n\n      ]\n...\n\n\n\n\nConfigurations\n\n\nThis field describes an Entity that has a list of ConfigurationParameters inside. This is a list of Entities containing key:value. These parameters are always available in your scripts. See the section below, \nhow to use the parameters\n, in order to see how to use them.\n\n\nProvides\n\n\nThis field is a list of parameter keys that will be available in all your scripts. The difference is that these parameters are parameters whose actual value will be known only at runtime. For that reason these parameters can only be filled by a specific VNFM. So you need to implement a VNFM able to handle these specific parameters in the fillSpecificParameters method (see \nHow to write a VNFM\n).\n\n\nNOTE\n: \n  there are some out-of-the-box parameters that will be added automatically to the VNFRecord. These parameters are:\n\n the networkName=IP,  key = \n network_name \n, value = \n actual-IP \n\n\n the hostname, key = \n hostname \n, value = the actual hostname\n* the floatingIp, key = \n network_name \n_floatingIp , value = the actual floatingIp\n\n\nHow to use the parameters\n\n\nAll the above parameters are available in all the scripts of the VNF that defines them. You just need to use them as environment variables, a script of the INSTANTIATE lifecycle event for instance would be:\n\n\n#!/bin/bash\n\necho \nthe value of the configuration parameter key1 is $key1\n\n\n\n\n\nAs described in the \nGeneric VNFM\n page, you can set up dependencies in order to use parameters from another VNF in the MODIFY lifecycle event. For doing that you need to specify in the Network Service Descriptor the VNF Dependency, for instance if a VNF vnf-1 is connected to network net1 and vnf-2 needs the ip of vnf-1 on that network the VNF Dependency will be:\n\n\n\n\nvnf_dependency\n:[\n        {\n            \nsource\n : {\n                \nname\n: \nvnf-1\n\n            },\n            \ntarget\n:{\n                \nname\n: \nvnf-2\n\n            },\n            \nparameters\n:[\n                \nnet1\n\n            ]\n        }\n    ]\n\n\n\n\n\nDone that, in the MODIFY scripts it is possible to use that ip in this way:\n\n\n#!/bin/bash\n\necho \nthe value of the ip on net1 of vnf-1 is $vnf1type_net1\n\n\n\n\n\nConclusion\n\n\nYou are always able to use the parameters of a VNF simply using the key as variable name, but when you want to use a parameter of a different VNF (like a relation) you need to specify the type followed by an underscore and then the name of the foreign parameter key (for instance \n$typeExt_key\n). In this last case, you can use them only in the MODIFY lifecycle event scripts.\n\n\n\n\n\n\n\n\n\n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "**HIDDEN**"
        }, 
        {
            "location": "/vnf-parameters/#vnf-parameters", 
            "text": "The useful parameters that you can use in your scripts are defined in two different fields of a VNFD.  ... configurations :{\n                 name : config_name ,\n                 configurationParameters :[\n                {\n                     confKey : key1 ,\n                     value : the_value \n                }\n                ]\n            },\n\n... provides :[\n         param1 ,\n         param2 \n      ]\n...", 
            "title": "VNF Parameters"
        }, 
        {
            "location": "/vnf-parameters/#configurations", 
            "text": "This field describes an Entity that has a list of ConfigurationParameters inside. This is a list of Entities containing key:value. These parameters are always available in your scripts. See the section below,  how to use the parameters , in order to see how to use them.", 
            "title": "Configurations"
        }, 
        {
            "location": "/vnf-parameters/#provides", 
            "text": "This field is a list of parameter keys that will be available in all your scripts. The difference is that these parameters are parameters whose actual value will be known only at runtime. For that reason these parameters can only be filled by a specific VNFM. So you need to implement a VNFM able to handle these specific parameters in the fillSpecificParameters method (see  How to write a VNFM ).  NOTE : \n  there are some out-of-the-box parameters that will be added automatically to the VNFRecord. These parameters are:  the networkName=IP,  key =   network_name  , value =   actual-IP    the hostname, key =   hostname  , value = the actual hostname\n* the floatingIp, key =   network_name  _floatingIp , value = the actual floatingIp", 
            "title": "Provides"
        }, 
        {
            "location": "/vnf-parameters/#how-to-use-the-parameters", 
            "text": "All the above parameters are available in all the scripts of the VNF that defines them. You just need to use them as environment variables, a script of the INSTANTIATE lifecycle event for instance would be:  #!/bin/bash\n\necho  the value of the configuration parameter key1 is $key1   As described in the  Generic VNFM  page, you can set up dependencies in order to use parameters from another VNF in the MODIFY lifecycle event. For doing that you need to specify in the Network Service Descriptor the VNF Dependency, for instance if a VNF vnf-1 is connected to network net1 and vnf-2 needs the ip of vnf-1 on that network the VNF Dependency will be:   vnf_dependency :[\n        {\n             source  : {\n                 name :  vnf-1 \n            },\n             target :{\n                 name :  vnf-2 \n            },\n             parameters :[\n                 net1 \n            ]\n        }\n    ]  Done that, in the MODIFY scripts it is possible to use that ip in this way:  #!/bin/bash\n\necho  the value of the ip on net1 of vnf-1 is $vnf1type_net1", 
            "title": "How to use the parameters"
        }, 
        {
            "location": "/vnf-parameters/#conclusion", 
            "text": "You are always able to use the parameters of a VNF simply using the key as variable name, but when you want to use a parameter of a different VNF (like a relation) you need to specify the type followed by an underscore and then the name of the foreign parameter key (for instance  $typeExt_key ). In this last case, you can use them only in the MODIFY lifecycle event scripts.    \n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Conclusion"
        }, 
        {
            "location": "/vnfm-generic-configuration/", 
            "text": "How to configure the Generic VNFM\n\n\nThis guide explains you how to configure the Generic VNFM after installation is completed. In general, after using the bootsrap procedure no changes described here are required unless you want to tune up your installation. \n\n\nGeneric VNFM properties overview\n\n\nAfter the bootstrap procedure the Generic VNFM's configuration file should be located under /etc located at: \n\n\n/etc/openbaton/openbaton-gvnfm.properties\n\n\n\n\nKeep in mind that whenever some of the parameters below referred are changed, you will need to restart the NFVO.\n\n\nmodify RabbitMQ parameters\n\n\nBy default RabbitMQ maybe installed on the same host where the generic VNFM is running. Be aware of the fact that if you want the Generic VNFM to interact with the NFVO you will need RabbitMQ to be reachable also from the outside.  \n\n\nIMPORTANT NOTES:\n\n\nThe Generic VNFM uses RabbitMQ to interact with the EMS agent installed inside VMs (ececuting VNF software). Therefore, you will need to configure the RabbitMQ endpoint (\nvnfm.rabbit.brokerIp\n) with the reachable IP of RabbitMQ (instead of localhost).\nfrom:\n\n\nvnfm.rabbitmq.brokerIp = localhost \n\n\n\n\nto:\n\n\nvnfm.rabbitmq.brokerIp = \nthe rabbitmq broker ip\n\n\n\n\n\nadditional rabbitMQ paramters required by the Generic VNFM:\n\n\nvnfm.rabbitmq.autodelete = true\nvnfm.rabbitmq.durable = true\nvnfm.rabbitmq.exclusive = false\nvnfm.rabbitmq.minConcurrency = 15\nvnfm.rabbitmq.maxConcurrency = 30\n\n# Timeout in seconds for any sendAndReceive\nvnfm.rabbitmq.sar.timeout = 1000\n\n\n\n\nparameters related with the EMS\n\n\nvnfm.ems.queue.autodelete = true\nvnfm.ems.queue.heartbeat = 120\nvnfm.ems.version = 0.20\n\n# Timeout in seconds for waiting the EMS to boot\nvnfm.ems.start.timeout = 500\n\n# delete the script where last modified is older than vnfm.ems.script.old (in minutes)\nvnfm.ems.script.old = 180\n#where the script log are stored\nvnfm.ems.script.logpath = /var/log/openbaton/scriptsLog/\nvnfm.ems.userdata.filepath = /etc/openbaton/openbaton-vnfm-generic-user-data.sh\n\n\n\n\nModify logging levels\n\n\nFeel free to modify that file for adding or removing specific functionalities.  For instance, you can decide to change logging levels (TRACE, DEBUG, INFO, WARN, and ERROR) and mechanisms:\n\n\n#########################################\n############### logging ################\n#########################################\n\nlogging.level.org.springframework=WARN\n# logging.level.org.springframework=INFO\nlogging.level.org.hibernate=WARN\nlogging.level.org.jclouds=WARN\nlogging.level.org.springframework.security=WARN\n# logging.level.org.springframework.amqp=DEBUG\n\n# Level for loggers on classes inside the root package \nde.fhg.fokus.ngni.osco\n (and its\n# sub-packages)\nlogging.level.org.openbaton = DEBUG\n\nlogging.file=/var/log/openbaton/generic-vnfm.log\n\n\n\n\nModify RabbitMQ parameters\n\n\nThese are additional parameters about the configuration of Rabbit MQ:\n\n\n#########################################\n############## RabbitMQ #################\n#########################################\n\n# Comma-separated list of addresses to which the client should connect to.\n# spring.rabbitmq.addresses= 192.168.145.54\n# Create an AmqpAdmin bean.\nspring.rabbitmq.dynamic=true\n# RabbitMQ host.\nspring.rabbitmq.host= ${vnfm.rabbitmq.brokerIp}\n# Acknowledge mode of container.\n# spring.rabbitmq.listener.acknowledge-mode=\n# Start the container automatically on startup.\n# spring.rabbitmq.listener.auto-startup=true\n# Minimum number of consumers.\nspring.rabbitmq.listener.concurrency= 15\n# Maximum number of consumers.\nspring.rabbitmq.listener.max-concurrency= 30\n# Number of messages to be handled in a single request. It should be greater than or equal to the transaction size (if used).\n# spring.rabbitmq.listener.prefetch=\n# Number of messages to be processed in a transaction. For best results it should be less than or equal to the prefetch count.\n# spring.rabbitmq.listener.transaction-size=\n# Login user to authenticate to the broker.\nspring.rabbitmq.username= admin\n# Login to authenticate against the broker.\nspring.rabbitmq.password= openbaton\n# RabbitMQ port.\nspring.rabbitmq.port=5672\n# Requested heartbeat timeout, in seconds; zero for none.\nspring.rabbitmq.requested-heartbeat = 60\n# Enable SSL support.\n# spring.rabbitmq.ssl.enabled=false\n# Path to the key store that holds the SSL certificate.\n# spring.rabbitmq.ssl.key-store=\n# Password used to access the key store.\n# spring.rabbitmq.ssl.key-store-password=\n# Trust store that holds SSL certificates.\n# spring.rabbitmq.ssl.trust-store=\n# Password used to access the trust store.\n# spring.rabbitmq.ssl.trust-store-password=\n# Virtual host to use when connecting to the broker.\n# spring.rabbitmq.virtual-host=", 
            "title": "**HIDDEN**"
        }, 
        {
            "location": "/vnfm-generic-configuration/#how-to-configure-the-generic-vnfm", 
            "text": "This guide explains you how to configure the Generic VNFM after installation is completed. In general, after using the bootsrap procedure no changes described here are required unless you want to tune up your installation.", 
            "title": "How to configure the Generic VNFM"
        }, 
        {
            "location": "/vnfm-generic-configuration/#generic-vnfm-properties-overview", 
            "text": "After the bootstrap procedure the Generic VNFM's configuration file should be located under /etc located at:   /etc/openbaton/openbaton-gvnfm.properties  Keep in mind that whenever some of the parameters below referred are changed, you will need to restart the NFVO.", 
            "title": "Generic VNFM properties overview"
        }, 
        {
            "location": "/vnfm-generic-configuration/#modify-rabbitmq-parameters", 
            "text": "By default RabbitMQ maybe installed on the same host where the generic VNFM is running. Be aware of the fact that if you want the Generic VNFM to interact with the NFVO you will need RabbitMQ to be reachable also from the outside.    IMPORTANT NOTES:  The Generic VNFM uses RabbitMQ to interact with the EMS agent installed inside VMs (ececuting VNF software). Therefore, you will need to configure the RabbitMQ endpoint ( vnfm.rabbit.brokerIp ) with the reachable IP of RabbitMQ (instead of localhost).\nfrom:  vnfm.rabbitmq.brokerIp = localhost   to:  vnfm.rabbitmq.brokerIp =  the rabbitmq broker ip", 
            "title": "modify RabbitMQ parameters"
        }, 
        {
            "location": "/vnfm-generic-configuration/#additional-rabbitmq-paramters-required-by-the-generic-vnfm", 
            "text": "vnfm.rabbitmq.autodelete = true\nvnfm.rabbitmq.durable = true\nvnfm.rabbitmq.exclusive = false\nvnfm.rabbitmq.minConcurrency = 15\nvnfm.rabbitmq.maxConcurrency = 30\n\n# Timeout in seconds for any sendAndReceive\nvnfm.rabbitmq.sar.timeout = 1000", 
            "title": "additional rabbitMQ paramters required by the Generic VNFM:"
        }, 
        {
            "location": "/vnfm-generic-configuration/#parameters-related-with-the-ems", 
            "text": "vnfm.ems.queue.autodelete = true\nvnfm.ems.queue.heartbeat = 120\nvnfm.ems.version = 0.20\n\n# Timeout in seconds for waiting the EMS to boot\nvnfm.ems.start.timeout = 500\n\n# delete the script where last modified is older than vnfm.ems.script.old (in minutes)\nvnfm.ems.script.old = 180\n#where the script log are stored\nvnfm.ems.script.logpath = /var/log/openbaton/scriptsLog/\nvnfm.ems.userdata.filepath = /etc/openbaton/openbaton-vnfm-generic-user-data.sh", 
            "title": "parameters related with the EMS"
        }, 
        {
            "location": "/vnfm-generic-configuration/#modify-logging-levels", 
            "text": "Feel free to modify that file for adding or removing specific functionalities.  For instance, you can decide to change logging levels (TRACE, DEBUG, INFO, WARN, and ERROR) and mechanisms:  #########################################\n############### logging ################\n#########################################\n\nlogging.level.org.springframework=WARN\n# logging.level.org.springframework=INFO\nlogging.level.org.hibernate=WARN\nlogging.level.org.jclouds=WARN\nlogging.level.org.springframework.security=WARN\n# logging.level.org.springframework.amqp=DEBUG\n\n# Level for loggers on classes inside the root package  de.fhg.fokus.ngni.osco  (and its\n# sub-packages)\nlogging.level.org.openbaton = DEBUG\n\nlogging.file=/var/log/openbaton/generic-vnfm.log", 
            "title": "Modify logging levels"
        }, 
        {
            "location": "/vnfm-generic-configuration/#modify-rabbitmq-parameters_1", 
            "text": "These are additional parameters about the configuration of Rabbit MQ:  #########################################\n############## RabbitMQ #################\n#########################################\n\n# Comma-separated list of addresses to which the client should connect to.\n# spring.rabbitmq.addresses= 192.168.145.54\n# Create an AmqpAdmin bean.\nspring.rabbitmq.dynamic=true\n# RabbitMQ host.\nspring.rabbitmq.host= ${vnfm.rabbitmq.brokerIp}\n# Acknowledge mode of container.\n# spring.rabbitmq.listener.acknowledge-mode=\n# Start the container automatically on startup.\n# spring.rabbitmq.listener.auto-startup=true\n# Minimum number of consumers.\nspring.rabbitmq.listener.concurrency= 15\n# Maximum number of consumers.\nspring.rabbitmq.listener.max-concurrency= 30\n# Number of messages to be handled in a single request. It should be greater than or equal to the transaction size (if used).\n# spring.rabbitmq.listener.prefetch=\n# Number of messages to be processed in a transaction. For best results it should be less than or equal to the prefetch count.\n# spring.rabbitmq.listener.transaction-size=\n# Login user to authenticate to the broker.\nspring.rabbitmq.username= admin\n# Login to authenticate against the broker.\nspring.rabbitmq.password= openbaton\n# RabbitMQ port.\nspring.rabbitmq.port=5672\n# Requested heartbeat timeout, in seconds; zero for none.\nspring.rabbitmq.requested-heartbeat = 60\n# Enable SSL support.\n# spring.rabbitmq.ssl.enabled=false\n# Path to the key store that holds the SSL certificate.\n# spring.rabbitmq.ssl.key-store=\n# Password used to access the key store.\n# spring.rabbitmq.ssl.key-store-password=\n# Trust store that holds SSL certificates.\n# spring.rabbitmq.ssl.trust-store=\n# Password used to access the trust store.\n# spring.rabbitmq.ssl.trust-store-password=\n# Virtual host to use when connecting to the broker.\n# spring.rabbitmq.virtual-host=", 
            "title": "Modify RabbitMQ parameters"
        }, 
        {
            "location": "/nsd-json-example/", 
            "text": "This network service is composed by two VNF (iperf-server and iperf-client), which the iperf-client is composed by two VNFC.\n\n\nNote:\n no vnf package is used in this example. Only a link to reach the scripts. Basically could be a link to a git repository in which there are all the scripts.\n\n\n{\n   \nname\n:\niperf-NS\n,\n   \nvendor\n:\nFokus\n,\n   \nversion\n:\n0.1\n,\n   \nvnfd\n:[\n      {\n         \nvendor\n:\ntbr\n,\n         \nversion\n:\n0.1\n,\n         \nname\n:\niperf-server\n,\n         \ntype\n:\nserver\n,\n         \nendpoint\n:\ngeneric\n,\n         \nconfigurations\n:{\n            \nname\n:\nconfig_name\n,\n            \nconfigurationParameters\n:[]\n         },\n         \nvdu\n:[\n            {\n               \nvm_image\n:[\n                  \nubuntu-14.04-server-cloudimg-amd64-disk1\n\n               ],\n               \nvimInstanceName\n:[\nvim-instance\n],\n               \nscale_in_out\n:1,\n               \nvnfc\n:[\n                  {\n                     \nconnection_point\n:[\n                        {\n                           \nvirtual_link_reference\n:\nprivate\n,\n                           \ninterfaceId\n:0\n                        }\n                     ]\n                  }\n               ]\n            }\n         ],\n         \nvirtual_link\n:[\n            {\n               \nname\n:\nprivate\n\n            }\n         ],\n         \nlifecycle_event\n:[\n            {\n               \nevent\n:\nINSTANTIATE\n,\n               \nlifecycle_events\n:[\n                  \ninstall.sh\n,\n          \nstart-srv.sh\n\n               ]\n            }\n         ],\n         \ndeployment_flavour\n:[\n            {\n               \nflavour_key\n:\nm1.small\n\n            }\n         ],\n            \nvnfPackageLocation\n:\nhttps://github.com/openbaton/vnf-scripts.git\n\n\n      },\n      {\n         \nvendor\n:\ntbr\n,\n         \nversion\n:\n0.1\n,\n         \nname\n:\niperf-client\n,\n         \ntype\n:\nclient\n,\n         \nendpoint\n:\ngeneric\n,\n         \nconfigurations\n:{\n            \nname\n:\nconfig_name\n,\n            \nconfigurationParameters\n:[\n\n            ]\n         },\n         \nvdu\n:[\n            {\n               \nvm_image\n:[\n                  \nubuntu-14.04-server-cloudimg-amd64-disk1\n\n               ],\n               \nvimInstanceName\n:[\nvim-instance\n],\n               \nscale_in_out\n:2,\n               \nvnfc\n:[\n                  {\n                     \nconnection_point\n:[\n                        {\n                           \nfloatingIp\n:\nrandom\n,\n                           \nvirtual_link_reference\n:\nprivate\n,\n                           \ninterfaceId\n:0\n                        }\n                     ]\n                  },\n                  {\n                     \nconnection_point\n:[\n                        {\n                           \nfloatingIp\n:\nrandom\n,\n                           \nvirtual_link_reference\n:\nprivate\n,\n                           \ninterfaceId\n:0\n                        }\n                     ]\n                  }\n               ]\n            }\n         ],\n         \nvirtual_link\n:[\n            {\n               \nname\n:\nprivate\n\n            }\n         ],\n         \nlifecycle_event\n:[\n            {\n               \nevent\n:\nINSTANTIATE\n,\n               \nlifecycle_events\n:[\n                  \ninstall.sh\n\n               ]\n            },\n            {\n               \nevent\n:\nCONFIGURE\n,\n               \nlifecycle_events\n:[\n                  \nserver_start-clt.sh\n\n               ]\n            }\n         ],\n         \ndeployment_flavour\n:[\n            {\n               \nflavour_key\n:\nm1.small\n\n            }\n         ],\n          \nvnfPackageLocation\n:\nhttps://github.com/openbaton/vnf-scripts.git\n\n      }\n   ],\n   \nvnffgd\n:[\n\n   ],\n   \nvld\n:[\n      {\n         \nname\n:\nprivate\n\n      }\n   ],\n   \nvnf_dependency\n:[\n      {\n         \nsource\n:{\n            \nname\n:\niperf-server\n\n         },\n         \ntarget\n:{\n            \nname\n:\niperf-client\n\n         },\n         \nparameters\n:[\n            \nprivate\n\n         ]\n      }\n   ]\n}", 
            "title": "**HIDDEN**"
        }, 
        {
            "location": "/integration-test-write/", 
            "text": "Write your own integration tests\n\n\nOverview\n\n\nIn this site we will describe how to write test cases for the integration tests. \nThe test scenarios are defined in .ini files which are in the directory \nintegration-tests/src/main/resources/integration-test-scenarios\n. If you want to add an integration test, just add its ini file to this folder. \n\n\nIni file structure\n\n\nIn the ini file you can describe a graph or tree like execution plan of different tasks. \nAs an example we will implement the test which is found in the \nscenario-real-iperf.ini\n file step by step. \nFirst we need a base node and define the maximum time of the integration test and the maximum number of concurrent successors. \n\n\n[it]\n;set the maximum time (in seconds) of the Integration test. e.g. 10 min = 600 seconds\nmax-integration-test-time = 800\n;set the maximum number of concurrent successors (max number of active child threads)\nmax-concurrent-successors = 10\n\n\n\n\nAfter that the first step is to store a vim instance to the orchestrator. \n\n\n[it]\n;set the maximum time (in seconds) of the Integration test. e.g. 10 min = 600 seconds\nmax-integration-test-time = 800\n;set the maximum number of concurrent successors (max number of active child threads)\nmax-concurrent-successors = 10\n\n;vimInstance-create\n[it/vim-c-1]\nclass-name = VimInstanceCreate\nname-file = real-vim.json\n\n\n\n\nThe node we just added will create a vim instance. That is defined by the class-name field. \nThe class VimInstanceCreate stores a vim instance from the \nreal-vim.json\n file to the orchestrator. \nA complete list of classes you can use is provided later in this document. \nThe file \nreal-vim.json\n has to be stored either in \n/etc/openbaton/integration-tests/vim-instances/real-vim.json\n or in \n.../integration-tests/src/main/resources/etc/json_file/vim_instances/real-vim.json\n. \nThe file in the first folder has a higher priority than the one in the second one.\n\n\nWe already know that we want to delete this vim from the orchestrator at the end of the test. \nSo we can add the following:\n\n\n[it]\n;set the maximum time (in seconds) of the Integration test. e.g. 10 min = 600 seconds\nmax-integration-test-time = 800\n;set the maximum number of concurrent successors (max number of active child threads)\nmax-concurrent-successors = 10\n\n;vimInstance-create\n[it/vim-c-1]\nclass-name = VimInstanceCreate\nname-file = real-vim.json\nsuccessor-remover = vim-d-1\n\n[it/vim-c-1/vim-d-1]\nclass-name = VimInstanceDelete\n\n\n\n\nThe successor-remover field specifies, that the node \nvim-d-1\n will be executed after every child node/task of \nvim-c-1\n has finished. \nEvery node can only have one successor-remover. \nThe new node gets the information which vim instance it should delete passed from the first node. \n\n\nThe next step will be to create and delete a network service descriptor (NSD). \n\n\n[it]\n;set the maximum time (in seconds) of the Integration test. e.g. 10 min = 600 seconds\nmax-integration-test-time = 800\n;set the maximum number of concurrent successors (max number of active child threads)\nmax-concurrent-successors = 10\n\n;vimInstance-create\n[it/vim-c-1]\nclass-name = VimInstanceCreate\nname-file = real-vim.json\nsuccessor-remover = vim-d-1\n\n[it/vim-c-1/vim-d-1]\nclass-name = VimInstanceDelete\n\n;nsd-create\n[it/vim-c-1/nsd-c-1]\nclass-name = NetworkServiceDescriptorCreate\nnum_instances = 1\nsuccessor-remover = nsd-d-1\nname-file = NetworkServiceDescriptor-iperf-real.json\n\n;nsd-delete\n[it/vim-c-1/nsd-c-1/nsd-d-1]\nclass-name = NetworkServiceDescriptorDelete\n\n\n\n\nHere the new nodes are \nnsd-c-1\n and \nnsd-d-1\n. \n\nnsd-d-1\n is the successor remover of \nnsd-c-1\n and will be executed if every child node/task from \nnsd-c-1\n finished. \n\nnsd-c-1\n has some fields that need explanation. \nnum_instances\n specifies how many of those tasks should be created. \nAt the moment there is just one so only one NSD will be stored on the orchestrator. \nBut if we would provide for example a 2, then this task would be executed twice concurrently. \nEvery task would be independent and every child node which is defined for \nnsd-c-1\n would be executed for every instance separately. \nThe name-file specifies the .json file that shall be used to create the NSD. \nIt may be stored either in \n/etc/openbaton/integration-tests/network-service-descriptors/NetworkServiceDescriptor-iperf-real.json\n or in \n.../integration-tests/src/main/resources/etc/json_file/network_service_descriptors/NetworkServiceDescriptor-iperf-real.json\n. \nAgain the former folder has a higher priority than the latter one. \n\n\nIn the next step we will deploy the network service record (NSR) from the created NSDs and wait for its instantiation. \n\n\n[it]\n;set the maximum time (in seconds) of the Integration test. e.g. 10 min = 600 seconds\nmax-integration-test-time = 800\n;set the maximum number of concurrent successors (max number of active child threads)\nmax-concurrent-successors = 10\n\n;vimInstance-create\n[it/vim-c-1]\nclass-name = VimInstanceCreate\nname-file = real-vim.json\nsuccessor-remover = vim-d-1\n\n[it/vim-c-1/vim-d-1]\nclass-name = VimInstanceDelete\n\n;nsd-create\n[it/vim-c-1/nsd-c-1]\nclass-name = NetworkServiceDescriptorCreate\nnum_instances = 1\nsuccessor-remover = nsd-d-1\nname-file = NetworkServiceDescriptor-iperf-real.json\n\n;nsd-delete\n[it/vim-c-1/nsd-c-1/nsd-d-1]\nclass-name = NetworkServiceDescriptorDelete\n\n;nsr-create\n[it/vim-c-1/nsd-c-1/nsr-c-1]\nclass-name = NetworkServiceRecordCreate\nnum_instances = 1\n\n;nsr-wait for creation\n[it/vim-c-1/nsd-c-1/nsr-c-1/nsr-w-1]\nclass-name = NetworkServiceRecordWait\n;the default timeout is 5 seconds\ntimeout = 600\naction = INSTANTIATE_FINISH\n\n\n\n\nnsr-c-1\n works similar to the creation of a NSD. It gets its information which NSD it should use from the preceiding task, so it has to be the NSD creation node. \nThe interesting part in this step is the \nnsr-w-1\n node. \nThis waits for the orchestrator to send the action INSTANTIATE_FINISH. If it receives it, the task was successful and the integration test proceeds. \n\n\nNow we will show how to test, if the network service is actually running.\nTherefore you can tell the integration test to ssh the instantiated virtual machines and execute commands.\nThose commands have to be written in scripts which can be placed in two locations.\nEither in \n/etc/openbaton/integration-tests/scripts/\n or in \n/integration-tests/src/main/resources/etc/scripts/\n in the\nproject itself. The former directory is checked first for a script name. If it does not exist there the latter location is used. \nBash sources the scripts on the remote machines. \nBut where do I specify the Virtual Machines on which the scripts shall be executed? Well, also in the .ini file.\nUse the \nGenericServiceTester\n.\n\n\n[it]\n;set the maximum time (in seconds) of the Integration test. e.g. 10 min = 600 seconds\nmax-integration-test-time = 800\n;set the maximum number of concurrent successors (max number of active child threads)\nmax-concurrent-successors = 10\n\n;vimInstance-create\n[it/vim-c-1]\nclass-name = VimInstanceCreate\nname-file = real-vim.json\nsuccessor-remover = vim-d-1\n\n[it/vim-c-1/vim-d-1]\nclass-name = VimInstanceDelete\n\n;nsd-create\n[it/vim-c-1/nsd-c-1]\nclass-name = NetworkServiceDescriptorCreate\nnum_instances = 1\nsuccessor-remover = nsd-d-1\nname-file = NetworkServiceDescriptor-iperf-real.json\n\n;nsd-delete\n[it/vim-c-1/nsd-c-1/nsd-d-1]\nclass-name = NetworkServiceDescriptorDelete\n\n;nsr-create\n[it/vim-c-1/nsd-c-1/nsr-c-1]\nclass-name = NetworkServiceRecordCreate\nnum_instances = 1\n\n;nsr-wait for creation\n[it/vim-c-1/nsd-c-1/nsr-c-1/nsr-w-1]\nclass-name = NetworkServiceRecordWait\n;the default timeout is 5 seconds\ntimeout = 600\naction = INSTANTIATE_FINISH\n\n[it/vim-c-1/nsd-c-1/nsr-c-1/nsr-w-1/gst-1]\nclass-name = GenericServiceTester\nvnf-type = client\nuser-name = ubuntu\nvm-scripts-path = /home/ubuntu\nscript-1 = iperf-running.sh\nscript-2 = iperf-clt-connection.sh\n\n\n\n\nThe class name specifies, that we want to use the GenericServiceTester to test our service.\nThe vnf-type is used to say on which virtual network functions the scripts should be executed and is equal to the one you wrote into the network service descriptor.\nIn our example the integration test would execute them on a virtual machine, which runs the iperfserver VNF which has the type 'server'. \nIn user-name you have to specify the user name of the virtual machine, so that the integration test can ssh into the machine. \nAnd vm-scripts-path declares the directory in which the testing scripts should be stored on the virtual machine. Keep in mind that this directory has to already exist, it will not be created by the integration test. \nAnd finally you have to specify the script name. script-1 will be the first script executed in that task.\nIf you want to execute more than that, just add script-2, script-3 and so on.\n\n\nHere is the script \niperf-running.sh\n used to see if iperf is running:\n\n\n#!/bin/bash\n\niperf_count=`exec ps -aux | grep -v grep | grep iperf | wc -l`\nif [ $iperf_count -lt 1 ]\nthen\n  exit 1\nelse\n  exit 0\nfi\n\n\n\n\n\nAs you can see the script exits with status 0 on success and otherwise on 1 like usual. \nEvery script you write for the integration test should exit on a value not 0 if they fail. \nThe integration test will just pass if all the scripts exit on 0.\n\n\nSo, now we know that iperf is running on the client virtual machine. But are the client and server really communicating at the moment?\nTo test that we added another script \niperf-clt-connection.sh\n to the client task, that checks if there is an outgoing or incoming connection related to iperf and exits successfully if one exists. Here's the script:\n\n\n#!/bin/bash\n\n# this will return the ip of the remote partner of the communication, here the iperf-server\noutgoing=`sudo netstat -npt | grep iperf | awk '{print $5}' | sed 's/:.*//'` \n\n# check if the communication partner is really the iperf-server\nif [ $outgoing == ${server_ip} ]\nthen\n  exit 0\nelse\n  exit 1\nfi\n\n\n\n\n(You may wonder where '${server_ip}' comes from. It is a variable provided by the integration test as explained later. \nWe use sudo for the netstat command, because the iperf command was started by the root user.)\n\n\nWe now also add a node in the ini file for the server. \n\n\n[it]\n;set the maximum time (in seconds) of the Integration test. e.g. 10 min = 600 seconds\nmax-integration-test-time = 800\n;set the maximum number of concurrent successors (max number of active child threads)\nmax-concurrent-successors = 10\n\n;vimInstance-create\n[it/vim-c-1]\nclass-name = VimInstanceCreate\nname-file = real-vim.json\nsuccessor-remover = vim-d-1\n\n[it/vim-c-1/vim-d-1]\nclass-name = VimInstanceDelete\n\n;nsd-create\n[it/vim-c-1/nsd-c-1]\nclass-name = NetworkServiceDescriptorCreate\nnum_instances = 1\nsuccessor-remover = nsd-d-1\nname-file = NetworkServiceDescriptor-iperf-real.json\n\n;nsd-delete\n[it/vim-c-1/nsd-c-1/nsd-d-1]\nclass-name = NetworkServiceDescriptorDelete\n\n;nsr-create\n[it/vim-c-1/nsd-c-1/nsr-c-1]\nclass-name = NetworkServiceRecordCreate\nnum_instances = 1\n\n;nsr-wait for creation\n[it/vim-c-1/nsd-c-1/nsr-c-1/nsr-w-1]\nclass-name = NetworkServiceRecordWait\n;the default timeout is 5 seconds\ntimeout = 600\naction = INSTANTIATE_FINISH\n\n[it/vim-c-1/nsd-c-1/nsr-c-1/nsr-w-1/gst-1]\nclass-name = GenericServiceTester\nvnf-type = client\nuser-name = ubuntu\nvm-scripts-path = /home/ubuntu\nscript-1 = iperf-running.sh\nscript-2 = iperf-clt-connection.sh\n\n\n[it/vim-c-1/nsd-c-1/nsr-c-1/nsr-w-1/gst-1/gst-2]\nclass-name = GenericServiceTester\nvnf-type = server\nnet-name = private\nuser-name = ubuntu\nvm-scripts-path = /home/ubuntu\nscript-1 = iperf-running.sh\nscript-2 = iperf-srv-connection.sh\n\n\n\n\nThe second script for the server task looks like this:\n\n\n#!/bin/bash\n\n\nincoming=`sudo netstat -npt | grep iperf | wc -l`\n\nif [ $incoming -eq 0 ] \nthen\n  exit 1\nelse\n  exit 0\nfi\n\n\n\n\nHere we just count if there are incoming connections to the server. \n\n\nAfter the iperf-running.sh script, the iperf-srv-connection.sh script will be executed on the server virtual machines \nand on the client one's also iperf-running.sh and then the script iperf-clt-conection.sh.\n\n\nNow imagine, that you did not specify one virtual network function component in the client's NSD, but five. And you want to test them all.\nDo you have to create five tasks for that? No, if you define the task for the client as shown above, the integration test will execute\nthe scripts on every virtual machine, that was deployed by the vnfd with the type \nclient\n.\n\n\nAnd if you have some virtual network function components connected to two different networks but just want to test the ones connected\nto one of them, you can add a \nnet-name\n field to the task and just the ones connected to it will be involved like in the server task.\n\n\nAfterwards we want to delete the NSDs and simutaniously wait for a message from the orchestrator, that the deletion finished. \n\n\n[it]\n;set the maximum time (in seconds) of the Integration test. e.g. 10 min = 600 seconds\nmax-integration-test-time = 800\n;set the maximum number of concurrent successors (max number of active child threads)\nmax-concurrent-successors = 10\n\n;vimInstance-create\n[it/vim-c-1]\nclass-name = VimInstanceCreate\nname-file = real-vim.json\nsuccessor-remover = vim-d-1\n\n[it/vim-c-1/vim-d-1]\nclass-name = VimInstanceDelete\n\n;nsd-create\n[it/vim-c-1/nsd-c-1]\nclass-name = NetworkServiceDescriptorCreate\nnum_instances = 1\nsuccessor-remover = nsd-d-1\nname-file = NetworkServiceDescriptor-iperf-real.json\n\n;nsd-delete\n[it/vim-c-1/nsd-c-1/nsd-d-1]\nclass-name = NetworkServiceDescriptorDelete\n\n;nsr-create\n[it/vim-c-1/nsd-c-1/nsr-c-1]\nclass-name = NetworkServiceRecordCreate\nnum_instances = 1\n\n;nsr-wait for creation\n[it/vim-c-1/nsd-c-1/nsr-c-1/nsr-w-1]\nclass-name = NetworkServiceRecordWait\n;the default timeout is 5 seconds\ntimeout = 600\naction = INSTANTIATE_FINISH\n\n[it/vim-c-1/nsd-c-1/nsr-c-1/nsr-w-1/gst-1]\nclass-name = GenericServiceTester\nvnf-type = client\nuser-name = ubuntu\nvm-scripts-path = /home/ubuntu\nscript-1 = iperf-running.sh\nscript-2 = iperf-clt-connection.sh\n\n\n[it/vim-c-1/nsd-c-1/nsr-c-1/nsr-w-1/gst-1/gst-2]\nclass-name = GenericServiceTester\nvnf-type = server\nnet-name = private\nuser-name = ubuntu\nvm-scripts-path = /home/ubuntu\nscript-1 = iperf-running.sh\nscript-2 = iperf-srv-connection.sh\n\n;nsr-wait for deletion\n[it/vim-c-1/nsd-c-1/nsr-c-1/nsr-w-1/gst-1/gst-2/nsr-w-2]\nclass-name = NetworkServiceRecordWait\n;the default timeout is 5 seconds\ntimeout = 360\naction = RELEASE_RESOURCES_FINISH\n\n;nsr-delete\n[it/vim-c-1/nsd-c-1/nsr-c-1/nsr-w-1/gst-1/gst-2/nsr-d-1]\nclass-name = NetworkServiceRecordDelete\n\n\n\n\nAs you can see the nodes \nnsr-w-2\n and \nnsr-d-1\n are both child nodes of \ngst-2\n. \nThis means that they are executed concurrently. \nThe \nnsr-w-2\n node waits for the action RELEASE_RESOURCES_FINISH sent by the NFVO and finishes successfully if it receives it. \n\n\nNow are all the child nodes of \nnsd-c-1\n finished and its successor remover nsd-d-1 will be executed which deletes the stored NSDs. \nAfter that all the child nodes of \nvim-c-1\n finished and its successor remover \nvim-d-1\n starts to delete the stored vim instance. \n\n\nA little more on scripts\n\n\nNow we come back to the '${server_ip}' variable in the iperf-clt-connection script. As mentioned earlier this variable is provided \nby the integration test. It stores the ip of the server. If you wanted to access the IPs of the clients, you could use ${client_ip}. \nThe problem is, that we could for example also have two or more instances of clients. Which ip is chosen? \nActually the script, which contains this variable will be executed twice or more on the virtual machine until every possible substitution was handled. \nYou have access to the IPs, floating IPs and configurations. \nYou can access ips by writing ${vnfrtype_ip} or ${vnfrtype_network_ip} (don't forget the braces). The 'vnfrtype' in our example would be 'server' or 'client'. \nThe 'network' is the virtual_link you specified in the VNFD for the VNF Component and will only retrieve the VNFC ips which are connected to this network. \nIf you have more than one VNFC Instance which is deployed, so for example you have two iperf-servers \ndeployed from one VNFD, then there would be two possibilities to substitute ${server_ip}. If you want to execute a script on the virtual machine of the \niperf-client which contains this variable the integration test will do the following. Execute the script containing the \nvariable with first the ip of one server. And then executing the same script, but now replacing the variable with the other ip. \nThat way you just have to write one script and all the VNF Components of the VNF will be tested. \nYou can access the floating ips of VNFCs by writing ${vnfrtype_fip} or ${vnfrtype_network_fip}. \nOf course, this will only work if there is a floating ip for that virtual machine. \nThe configurations are accessible by typing ${vnfrtype_configurationkey}. \nFor all the variables it is essential, that you enclose them with braces otherwise they won't work. \n\n\nTask execution order\n\n\nJust to clarify the execution order of the tasks specified in the ini files here is a little example without describing what the tasks do. \nThe successor-removers of a task are just executed when all the other child tasks and their subsequent tasks finished.\n\n\n[it/A]\nsuccessor-remover = H\n\n[it/A/H]\n...\n\n[it/A/B]\n...\n\n[it/A/C]\n...\n\n[it/A/C/D]\nsuccessor-remover = G\n\n[it/A/C/D/G]\n...\n\n[it/A/C/D/E]\n...\n\n[it/A/C/D/F]\n...\n\n\n\n\nThe execution order of this example looks like this:\n\n\n\n\nTasks that are side by side can run concurrently. \n\n\nOther important information\n\n\nFor the integration test to be able to ssh to the virtual machines on openstack, you have to provide a .pem file of a key-pair you are using on openstack.\nDownload this file, name it \nintegration-test.pem\n and put it into the directory \n/etc/openbaton/integration-tests/\n.\nFurthermore it has to have the correct permissions so you probably have to execute \nchmod 400 integration-test.pem\n.\nAnd don't forget to make the scripts executable.\nDo NOT use '-' in types of VNFDs or configuration names as you cannot use them in bash scripts it will not work for the integration test scripts. \n\n\nThe class-name types available\n\n\nAs mentioned earlier here is a summary of all the class-names available at the moment to use in a ini file node.\n\n\n\n\n\n\n\n\nclass-name\n\n\npurpose\n\n\nfields\n\n\nfield purpose\n\n\n\n\n\n\n\n\n\n\nGenericServiceTester\n\n\nTest the network service itself\n\n\nscript-1\n\n\nThe first script to be executed on the VM\n\n\n\n\n\n\n\n\n\n\n...\n\n\n\n\n\n\n\n\n\n\n\n\nscript-n\n\n\nThe n-th script to be executed on the VM\n\n\n\n\n\n\n\n\n\n\nvnf-type\n\n\nThe type of the VNFs that shall be tested\n\n\n\n\n\n\n\n\n\n\nuser-name\n\n\nThe user account on the VM on which the scripts will be executed\n\n\n\n\n\n\n\n\n\n\nvm-scripts-path\n\n\nThe path to the directory of the VM where the scripts will be stored before execution\n\n\n\n\n\n\n\n\n\n\nnet-name\n\n\nSpecifies the network/virtual-link to which the VMs that shall be tested are connected\n\n\n\n\n\n\nNetworkServiceDescriptorCreate\n\n\nStore a NSD on the NFVO\n\n\nexpected-to-fail\n\n\nIf set to true the task will fail if the onboarding of the NSD is successful\n\n\n\n\n\n\n\n\n\n\nname-file\n\n\nThe name of the json file which contains the NSD\n\n\n\n\n\n\nNetworkServiceDescriptorCreateFromPackage\n\n\nCreate a NSD by using a VNFPackage that was uploaded beforehand\n\n\nexpected-to-fail\n\n\nIf set to true the task will fail if the onboarding of the NSD is successful\n\n\n\n\n\n\n\n\n\n\nname-file\n\n\nThe name of the json file which contains the NSD\n\n\n\n\n\n\nNetworkServiceDescriptorDelete\n\n\nDelete a NSD from the NFVO\n\n\n\n\n\n\n\n\n\n\nNetworkServiceDescriptorWait\n\n\nWait for a specific event of the NFVO to happen that is related to NSDs\n\n\naction\n\n\nThe event which will be waited for to happen\n\n\n\n\n\n\nNetworkServiceRecordCreate\n\n\nDeploy a network service from a NSD and create the NSR\n\n\n\n\n\n\n\n\n\n\nNetworkServiceRecordDelete\n\n\nDelete the NSR\n\n\n\n\n\n\n\n\n\n\nNetworkServiceRecordGetLatest\n\n\nExpects to get passed a NSR from its preceding task, retrieves the latest version of this NSR from the NFVO and passes it to the following task\n\n\n\n\n\n\n\n\n\n\nNetworkServiceRecordWait\n\n\nWait for a specific event of the NFVO to happen that is related to NSRs\n\n\naction\n\n\nThe event which will be waited for to happen\n\n\n\n\n\n\n\n\n\n\ntimeout\n\n\nAfter this time (in seconds) the task will fail if the event did not occur yet\n\n\n\n\n\n\nPackageDelete\n\n\nDelete a VNFPackage\n\n\npackage-name\n\n\nThe name of the package that will be deleted\n\n\n\n\n\n\nPackageUpload\n\n\nUpload a VNFPackage\n\n\npackage-upload\n\n\nThe name of the package that will be uploaded\n\n\n\n\n\n\nPause\n\n\nUsed to elapse time until the next task will start\n\n\nduration\n\n\nThe time (in seconds) that this task shall do nothing and after which it will finish\n\n\n\n\n\n\nProjectCreate\n\n\nUsed to create a new Project\n\n\nas-user-name\n\n\nIf specified the integration tests will use this user to create the Project. If not the default user specified in the integration-tests.properties will be used.\n\n\n\n\n\n\n\n\n\n\nas-user-password\n\n\nThe password of the User that shall create the new Project. Just needed if \nas-user-name\n is specified.\n\n\n\n\n\n\n\n\n\n\nexpected-to-fail\n\n\nSet this to true if you expect the Project creation to fail.\n\n\n\n\n\n\n\n\n\n\nproject-name\n\n\nThe name of the new Project.\n\n\n\n\n\n\nProjectDelete\n\n\nUsed to delete a project\n\n\nas-user-name\n\n\nIf specified the integration tests will use this user to delete the Project. If not the default user specified in the integration-tests.properties will be used.\n\n\n\n\n\n\n\n\n\n\nas-user-password\n\n\nThe password of the User that shall delete the new Project. Just needed if \nas-user-name\n is specified.\n\n\n\n\n\n\n\n\n\n\nexpected-to-fail\n\n\nSet this to true if you expect deleting the Project to fail.\n\n\n\n\n\n\n\n\n\n\nproject-name\n\n\nThe name of the project to delete.\n\n\n\n\n\n\nScaleIn\n\n\nTriggers one scale in operation on a VNFR specified in the ini file\n\n\nvnf-type\n\n\nThe type of VNFR that shall be scaled in\n\n\n\n\n\n\nScaleOut\n\n\nTriggers one scale out operation on a VNFR specified in the ini file\n\n\nfloating-ip\n\n\nThe floating IP which shall be assigned to the new instance\n\n\n\n\n\n\n\n\n\n\nvirtual-link\n\n\nThe network/virtual-link to which the new instance shall be connected\n\n\n\n\n\n\n\n\n\n\nvnf-type\n\n\nThe type of the VNFR on which the scale out shall be performed\n\n\n\n\n\n\nScalingTester\n\n\nVerifies if the number of VNFCInstances is equal to a given number and passes an updated NSR to the next task, which can be important after a scaling operation\n\n\nvnfc-count\n\n\nThe expected number of instances of this VNF\n\n\n\n\n\n\n\n\n\n\nvnf-type\n\n\nThe type of the VNFR whose number of VNFCs should be checked\n\n\n\n\n\n\nUserCreate\n\n\nUsed to create a new User\n\n\nas-user-name\n\n\nIf specified the integration tests will use this user to create the User. If not the default user specified in the integration-tests.properties will be used.\n\n\n\n\n\n\n\n\n\n\nas-user-password\n\n\nThe password of the User that shall create the new User. Just needed if \nas-user-name\n is specified.\n\n\n\n\n\n\n\n\n\n\nenabled\n\n\nSet to true if the new User should be enabled.\n\n\n\n\n\n\n\n\n\n\nexpected-to-fail\n\n\nSet this to true if you expect the User creation to fail.\n\n\n\n\n\n\n\n\n\n\nguest-projects\n\n\nA comma separated list of project names. In each listed project the new User will obtain a GUEST role.\n\n\n\n\n\n\n\n\n\n\nnew-user-is-admin\n\n\nSet this to true if the new User should be an ADMIN.\n\n\n\n\n\n\n\n\n\n\nnew-user-name\n\n\nThe name of the User to create.\n\n\n\n\n\n\n\n\n\n\nnew-user-password\n\n\nThe password of the User to create.\n\n\n\n\n\n\n\n\n\n\nuser-projects\n\n\nA comma separated list of project names. In each listed project the new User will obtain a USER role.\n\n\n\n\n\n\nUserDelete\n\n\nUsed to delete a User\n\n\nas-user-name\n\n\nIf specified the integration tests will use this user to delete the User. If not the default user specified in the integration-tests.properties will be used.\n\n\n\n\n\n\n\n\n\n\nas-user-password\n\n\nThe password of the User that shall delete the User. Just needed if \nas-user-name\n is specified.\n\n\n\n\n\n\n\n\n\n\nexpected-to-fail\n\n\nSet this to true if you expect the User deletion to fail.\n\n\n\n\n\n\n\n\n\n\nuser-to-delete\n\n\nThe name of the User that shall be deleted.\n\n\n\n\n\n\nUserUpdate\n\n\nUsed to update a User\n\n\nas-user-name\n\n\nIf specified the integration tests will use this user to update the User. If not the default user specified in the integration-tests.properties will be used.\n\n\n\n\n\n\n\n\n\n\nas-user-password\n\n\nThe password of the User that shall create the new User. Just needed if \nas-user-name\n is specified.\n\n\n\n\n\n\n\n\n\n\nenabled\n\n\nSet to true if the updated User should be enabled.\n\n\n\n\n\n\n\n\n\n\nexpected-to-fail\n\n\nSet this to true if you expect updating the User to fail.\n\n\n\n\n\n\n\n\n\n\nguest-projects\n\n\nA comma separated list of project names. In each listed project the updated User will obtain a GUEST role.\n\n\n\n\n\n\n\n\n\n\nuser-is-admin\n\n\nSet this to true if the updated User should be an ADMIN.\n\n\n\n\n\n\n\n\n\n\nuser-name-new\n\n\nThe new name of the User.\n\n\n\n\n\n\n\n\n\n\nuser-name-old\n\n\nThe name of the User to update.\n\n\n\n\n\n\n\n\n\n\nuser-password-new\n\n\nThe new password of the User.\n\n\n\n\n\n\n\n\n\n\nuser-projects\n\n\nA comma separated list of project names. In each listed project the updated User will obtain a USER role.\n\n\n\n\n\n\nVimInstanceCreate\n\n\nStore a vim instance on the NFVO from a json file\n\n\nname-file\n\n\nThe name of the json file that contains the VimInstance\n\n\n\n\n\n\n\n\n\n\nas-user-name\n\n\nIf specified the integration tests will use this user to create the Vim Instance. If not the default user specified in the integration-tests.properties will be used.\n\n\n\n\n\n\n\n\n\n\nas-user-password\n\n\nThe password of the user that shall create the Vim Instance. Just needed if \nas-user-name\n is specified.\n\n\n\n\n\n\n\n\n\n\nexpected-to-fail\n\n\nSet this to true if you expect the Vim Instance creation to fail\n\n\n\n\n\n\n\n\n\n\nin-project\n\n\nThe name of the project to which the Vim Instance shall be uploaded. Just usable if you also specify a user to upload with \nas-user-name\n and \nas-user-password\n. If not specified the default project specified in the integration-tests.properties will be used.\n\n\n\n\n\n\nVimInstanceDelete\n\n\nDelete a vim instance\n\n\nas-user-name\n\n\nIf specified the integration tests will use this user to delete the Vim Instance. If not the default user specified in the integration-tests.properties will be used.\n\n\n\n\n\n\n\n\n\n\nas-user-password\n\n\nThe password of the user that shall delete the Vim Instance. Just needed if \nas-user-name\n is specified.\n\n\n\n\n\n\n\n\n\n\nexpected-to-fail\n\n\nSet this to true if you expect a failure while trying to delete the Vim Instance.\n\n\n\n\n\n\n\n\n\n\nin-project\n\n\nThe name of the project to which the Vim Instance shall be uploaded. Just usable if you also specify a user to upload with \nas-user-name\n and \nas-user-password\n. If not specified the default project specified in the integration-tests.properties will be used.\n\n\n\n\n\n\nVirtualNetworkFunctionDescriptorDelete\n\n\nDelete the VNFDs of a NSD passed from the preceding task, filtered by vnfd name and/or type; if no name and type are passed, all the VNFDs associated to the passed NSD will be deleted\n\n\nvnf-type\n\n\nThe type of the VNFDs that shall be deleted; this field can be omitted if the type is not important for the choice of VNFDs to delete\n\n\n\n\n\n\n\n\n\n\nvnf-name\n\n\nThe name of the VNFDs that shall be deleted; this field can be omitted if the name is not important for the choice of VNFDs to delete\n\n\n\n\n\n\nVirtualNetworkFunctionRecordWait\n\n\nWait for an event sent by the NFVO which is related to a VNFR\n\n\naction\n\n\nThe event which will be waited for to happen\n\n\n\n\n\n\n\n\n\n\ntimeout\n\n\nAfter this time (in seconds) the task will fail if the event did not occur yet\n\n\n\n\n\n\n\n\n\n\nvnf-type\n\n\nThe type of the VNFR that should produce the awaited event\n\n\n\n\n\n\nVNFRStatusTester\n\n\nChecks if the status of a specified VNFR is as expected\n\n\nstatus\n\n\nThe expected status in which the VNFR should be\n\n\n\n\n\n\n\n\n\n\nvnf-type\n\n\nThe type of the VNFR whose status shall be checked\n\n\n\n\n\n\n\n\nUsing VNFPackages\n\n\nHere is an example on how to use VNFPackages in your tests. \n\n\n[it]\n;set the maximum time (in seconds) of the Integration test. e.g. 10 min = 600 seconds\nmax-integration-test-time = 800\n;set the maximum number of concurrent successors (max number of active child threads)\nmax-concurrent-successors = 10\n\n;vimInstance-create\n[it/vim-c-1]\nclass-name = VimInstanceCreate\nname-file = vim.json\nsuccessor-remover = vim-d-1\n\n[it/vim-c-1/vim-d-1]\nclass-name = VimInstanceDelete\n\n;package-create\n[it/vim-c-1/vnfp-c-1]\nclass-name = PackageUpload\npackage-name = iperf-server-package.tar\nsuccessor-remover = vnfp-d-1\n\n;package-delete\n[it/vim-c-1/vnfp-c-1/vnfp-d-1]\nclass-name = PackageDelete\npackage-name = iperfServerPackage\n\n;nsd-create\n[it/vim-c-1/vnfp-c-1/nsd-c-1]\nclass-name = NetworkServiceDescriptorCreateFromPackage\nname-file = NetworkServiceDescriptor.json\nsuccessor-remover = nsd-d-1\n\n;nsd-delete\n[it/vim-c-1/vnfp-c-1/nsd-c-1/nsd-d-1]\nclass-name = NetworkServiceDescriptorDelete\n\n\n\n\nThis example begins by storing a vim instance. Then the package iperf-server-package.tar is stored by specifying the package file name in the package-name attribute. \nThe packages have to be in the directory /etc/openbaton/integration-tests/vnf-packages/. \nAfterwards a NSD is created from the VNFDs in the package and right after that deleted (to keep this example short we did not create a NSR from the NSD and so on). Be aware that you \nhave to use the class NetworkServiceDescriptorCreateFromPackage to store a NSD from a package. \nThen also the package will be deleted. You have to provide the name of the package you want to delete (not the file name this time but the name of the package defined in the Metadata.yaml). \nAt the end the vim instance is deleted. \n\n\nIf you create a NSD from a VNFPackage, the VNFD field of the NSD file would look something like this: \n\n\nvnfd\n:[\n{\n      \ntype\n:\nserver\n\n},\n{\n      \ntype\n:\nclient\n\n}\n\n   ],\n\n\n\n\nThe integration test will search for VNFDs with these types that were previously stored by a VNFPackage and use them for creating the NSD. \n\n\nScaling\n\n\nThere are three testers for Scaling already implemented. The first one is \nScaleOut\n. In the ini file this tester needs some additional attributes. Besides the normal \nclass-name\n you should also specify the VNFR type on which the scale out should be performed in the field \nvnf-type\n. Then you can also specify the virtual-link to which the new instance should be connected using \nvirtual-link\n. \nAnd you can determine a floating ip for the new instance using the field \nfloating-ip\n. \nHere is an example of a ScaleOut task in the ini file:\n\n\n[it/.../sc-o-1]\nclass-name = ScaleOut\nvnf-type = client\nvirtual-link = private\nfloating-ip = random\n\n\n\n\nThe second tester is \nScaleIn\n. Here you can just specify on which VNFR type the scale in should be executed. An example: \n\n\n[it/.../sc-i-1]\nclass-name = ScaleIn\nvnf-type = client\n\n\n\n\nAnd the third tester is used to see if after the scaling operation there is the right number of instances running. \nSpecify the VNFR type you want to test by providing \nvnf-type\n in the ini file and specify the number of expected VNFC instances by using \nvnfc-count\n. For example: \n\n\n[it/.../sc-t-1]\nclass-name = ScalingTester\nvnf-type = client\nvnfc-count = 2\n\n\n\n\nFurthermore note that the ScalingTester passes the updated NSR to the next tester. If you trigger a scaling function the NSR will change, but if you do not use ScalingTester (or NetworkServiceRecordGetLatest) the NSR used by the integration test will remain the old one before the scaling operation. \nSo the recommended proceeding after a scale out or scale in is to wait until the operation finishes and then use the \nScalingTester\n or at least the \nNetworkServiceRecordGetLatest\n to have the updated NSR.", 
            "title": "**HIDDEN**"
        }, 
        {
            "location": "/integration-test-write/#write-your-own-integration-tests", 
            "text": "", 
            "title": "Write your own integration tests"
        }, 
        {
            "location": "/integration-test-write/#overview", 
            "text": "In this site we will describe how to write test cases for the integration tests. \nThe test scenarios are defined in .ini files which are in the directory  integration-tests/src/main/resources/integration-test-scenarios . If you want to add an integration test, just add its ini file to this folder.", 
            "title": "Overview"
        }, 
        {
            "location": "/integration-test-write/#ini-file-structure", 
            "text": "In the ini file you can describe a graph or tree like execution plan of different tasks. \nAs an example we will implement the test which is found in the  scenario-real-iperf.ini  file step by step. \nFirst we need a base node and define the maximum time of the integration test and the maximum number of concurrent successors.   [it]\n;set the maximum time (in seconds) of the Integration test. e.g. 10 min = 600 seconds\nmax-integration-test-time = 800\n;set the maximum number of concurrent successors (max number of active child threads)\nmax-concurrent-successors = 10  After that the first step is to store a vim instance to the orchestrator.   [it]\n;set the maximum time (in seconds) of the Integration test. e.g. 10 min = 600 seconds\nmax-integration-test-time = 800\n;set the maximum number of concurrent successors (max number of active child threads)\nmax-concurrent-successors = 10\n\n;vimInstance-create\n[it/vim-c-1]\nclass-name = VimInstanceCreate\nname-file = real-vim.json  The node we just added will create a vim instance. That is defined by the class-name field. \nThe class VimInstanceCreate stores a vim instance from the  real-vim.json  file to the orchestrator. \nA complete list of classes you can use is provided later in this document. \nThe file  real-vim.json  has to be stored either in  /etc/openbaton/integration-tests/vim-instances/real-vim.json  or in  .../integration-tests/src/main/resources/etc/json_file/vim_instances/real-vim.json . \nThe file in the first folder has a higher priority than the one in the second one.  We already know that we want to delete this vim from the orchestrator at the end of the test. \nSo we can add the following:  [it]\n;set the maximum time (in seconds) of the Integration test. e.g. 10 min = 600 seconds\nmax-integration-test-time = 800\n;set the maximum number of concurrent successors (max number of active child threads)\nmax-concurrent-successors = 10\n\n;vimInstance-create\n[it/vim-c-1]\nclass-name = VimInstanceCreate\nname-file = real-vim.json\nsuccessor-remover = vim-d-1\n\n[it/vim-c-1/vim-d-1]\nclass-name = VimInstanceDelete  The successor-remover field specifies, that the node  vim-d-1  will be executed after every child node/task of  vim-c-1  has finished. \nEvery node can only have one successor-remover. \nThe new node gets the information which vim instance it should delete passed from the first node.   The next step will be to create and delete a network service descriptor (NSD).   [it]\n;set the maximum time (in seconds) of the Integration test. e.g. 10 min = 600 seconds\nmax-integration-test-time = 800\n;set the maximum number of concurrent successors (max number of active child threads)\nmax-concurrent-successors = 10\n\n;vimInstance-create\n[it/vim-c-1]\nclass-name = VimInstanceCreate\nname-file = real-vim.json\nsuccessor-remover = vim-d-1\n\n[it/vim-c-1/vim-d-1]\nclass-name = VimInstanceDelete\n\n;nsd-create\n[it/vim-c-1/nsd-c-1]\nclass-name = NetworkServiceDescriptorCreate\nnum_instances = 1\nsuccessor-remover = nsd-d-1\nname-file = NetworkServiceDescriptor-iperf-real.json\n\n;nsd-delete\n[it/vim-c-1/nsd-c-1/nsd-d-1]\nclass-name = NetworkServiceDescriptorDelete  Here the new nodes are  nsd-c-1  and  nsd-d-1 .  nsd-d-1  is the successor remover of  nsd-c-1  and will be executed if every child node/task from  nsd-c-1  finished.  nsd-c-1  has some fields that need explanation.  num_instances  specifies how many of those tasks should be created. \nAt the moment there is just one so only one NSD will be stored on the orchestrator. \nBut if we would provide for example a 2, then this task would be executed twice concurrently. \nEvery task would be independent and every child node which is defined for  nsd-c-1  would be executed for every instance separately. \nThe name-file specifies the .json file that shall be used to create the NSD. \nIt may be stored either in  /etc/openbaton/integration-tests/network-service-descriptors/NetworkServiceDescriptor-iperf-real.json  or in  .../integration-tests/src/main/resources/etc/json_file/network_service_descriptors/NetworkServiceDescriptor-iperf-real.json . \nAgain the former folder has a higher priority than the latter one.   In the next step we will deploy the network service record (NSR) from the created NSDs and wait for its instantiation.   [it]\n;set the maximum time (in seconds) of the Integration test. e.g. 10 min = 600 seconds\nmax-integration-test-time = 800\n;set the maximum number of concurrent successors (max number of active child threads)\nmax-concurrent-successors = 10\n\n;vimInstance-create\n[it/vim-c-1]\nclass-name = VimInstanceCreate\nname-file = real-vim.json\nsuccessor-remover = vim-d-1\n\n[it/vim-c-1/vim-d-1]\nclass-name = VimInstanceDelete\n\n;nsd-create\n[it/vim-c-1/nsd-c-1]\nclass-name = NetworkServiceDescriptorCreate\nnum_instances = 1\nsuccessor-remover = nsd-d-1\nname-file = NetworkServiceDescriptor-iperf-real.json\n\n;nsd-delete\n[it/vim-c-1/nsd-c-1/nsd-d-1]\nclass-name = NetworkServiceDescriptorDelete\n\n;nsr-create\n[it/vim-c-1/nsd-c-1/nsr-c-1]\nclass-name = NetworkServiceRecordCreate\nnum_instances = 1\n\n;nsr-wait for creation\n[it/vim-c-1/nsd-c-1/nsr-c-1/nsr-w-1]\nclass-name = NetworkServiceRecordWait\n;the default timeout is 5 seconds\ntimeout = 600\naction = INSTANTIATE_FINISH  nsr-c-1  works similar to the creation of a NSD. It gets its information which NSD it should use from the preceiding task, so it has to be the NSD creation node. \nThe interesting part in this step is the  nsr-w-1  node. \nThis waits for the orchestrator to send the action INSTANTIATE_FINISH. If it receives it, the task was successful and the integration test proceeds.   Now we will show how to test, if the network service is actually running.\nTherefore you can tell the integration test to ssh the instantiated virtual machines and execute commands.\nThose commands have to be written in scripts which can be placed in two locations.\nEither in  /etc/openbaton/integration-tests/scripts/  or in  /integration-tests/src/main/resources/etc/scripts/  in the\nproject itself. The former directory is checked first for a script name. If it does not exist there the latter location is used. \nBash sources the scripts on the remote machines. \nBut where do I specify the Virtual Machines on which the scripts shall be executed? Well, also in the .ini file.\nUse the  GenericServiceTester .  [it]\n;set the maximum time (in seconds) of the Integration test. e.g. 10 min = 600 seconds\nmax-integration-test-time = 800\n;set the maximum number of concurrent successors (max number of active child threads)\nmax-concurrent-successors = 10\n\n;vimInstance-create\n[it/vim-c-1]\nclass-name = VimInstanceCreate\nname-file = real-vim.json\nsuccessor-remover = vim-d-1\n\n[it/vim-c-1/vim-d-1]\nclass-name = VimInstanceDelete\n\n;nsd-create\n[it/vim-c-1/nsd-c-1]\nclass-name = NetworkServiceDescriptorCreate\nnum_instances = 1\nsuccessor-remover = nsd-d-1\nname-file = NetworkServiceDescriptor-iperf-real.json\n\n;nsd-delete\n[it/vim-c-1/nsd-c-1/nsd-d-1]\nclass-name = NetworkServiceDescriptorDelete\n\n;nsr-create\n[it/vim-c-1/nsd-c-1/nsr-c-1]\nclass-name = NetworkServiceRecordCreate\nnum_instances = 1\n\n;nsr-wait for creation\n[it/vim-c-1/nsd-c-1/nsr-c-1/nsr-w-1]\nclass-name = NetworkServiceRecordWait\n;the default timeout is 5 seconds\ntimeout = 600\naction = INSTANTIATE_FINISH\n\n[it/vim-c-1/nsd-c-1/nsr-c-1/nsr-w-1/gst-1]\nclass-name = GenericServiceTester\nvnf-type = client\nuser-name = ubuntu\nvm-scripts-path = /home/ubuntu\nscript-1 = iperf-running.sh\nscript-2 = iperf-clt-connection.sh  The class name specifies, that we want to use the GenericServiceTester to test our service.\nThe vnf-type is used to say on which virtual network functions the scripts should be executed and is equal to the one you wrote into the network service descriptor.\nIn our example the integration test would execute them on a virtual machine, which runs the iperfserver VNF which has the type 'server'. \nIn user-name you have to specify the user name of the virtual machine, so that the integration test can ssh into the machine. \nAnd vm-scripts-path declares the directory in which the testing scripts should be stored on the virtual machine. Keep in mind that this directory has to already exist, it will not be created by the integration test. \nAnd finally you have to specify the script name. script-1 will be the first script executed in that task.\nIf you want to execute more than that, just add script-2, script-3 and so on.  Here is the script  iperf-running.sh  used to see if iperf is running:  #!/bin/bash\n\niperf_count=`exec ps -aux | grep -v grep | grep iperf | wc -l`\nif [ $iperf_count -lt 1 ]\nthen\n  exit 1\nelse\n  exit 0\nfi  As you can see the script exits with status 0 on success and otherwise on 1 like usual. \nEvery script you write for the integration test should exit on a value not 0 if they fail. \nThe integration test will just pass if all the scripts exit on 0.  So, now we know that iperf is running on the client virtual machine. But are the client and server really communicating at the moment?\nTo test that we added another script  iperf-clt-connection.sh  to the client task, that checks if there is an outgoing or incoming connection related to iperf and exits successfully if one exists. Here's the script:  #!/bin/bash\n\n# this will return the ip of the remote partner of the communication, here the iperf-server\noutgoing=`sudo netstat -npt | grep iperf | awk '{print $5}' | sed 's/:.*//'` \n\n# check if the communication partner is really the iperf-server\nif [ $outgoing == ${server_ip} ]\nthen\n  exit 0\nelse\n  exit 1\nfi  (You may wonder where '${server_ip}' comes from. It is a variable provided by the integration test as explained later. \nWe use sudo for the netstat command, because the iperf command was started by the root user.)  We now also add a node in the ini file for the server.   [it]\n;set the maximum time (in seconds) of the Integration test. e.g. 10 min = 600 seconds\nmax-integration-test-time = 800\n;set the maximum number of concurrent successors (max number of active child threads)\nmax-concurrent-successors = 10\n\n;vimInstance-create\n[it/vim-c-1]\nclass-name = VimInstanceCreate\nname-file = real-vim.json\nsuccessor-remover = vim-d-1\n\n[it/vim-c-1/vim-d-1]\nclass-name = VimInstanceDelete\n\n;nsd-create\n[it/vim-c-1/nsd-c-1]\nclass-name = NetworkServiceDescriptorCreate\nnum_instances = 1\nsuccessor-remover = nsd-d-1\nname-file = NetworkServiceDescriptor-iperf-real.json\n\n;nsd-delete\n[it/vim-c-1/nsd-c-1/nsd-d-1]\nclass-name = NetworkServiceDescriptorDelete\n\n;nsr-create\n[it/vim-c-1/nsd-c-1/nsr-c-1]\nclass-name = NetworkServiceRecordCreate\nnum_instances = 1\n\n;nsr-wait for creation\n[it/vim-c-1/nsd-c-1/nsr-c-1/nsr-w-1]\nclass-name = NetworkServiceRecordWait\n;the default timeout is 5 seconds\ntimeout = 600\naction = INSTANTIATE_FINISH\n\n[it/vim-c-1/nsd-c-1/nsr-c-1/nsr-w-1/gst-1]\nclass-name = GenericServiceTester\nvnf-type = client\nuser-name = ubuntu\nvm-scripts-path = /home/ubuntu\nscript-1 = iperf-running.sh\nscript-2 = iperf-clt-connection.sh\n\n\n[it/vim-c-1/nsd-c-1/nsr-c-1/nsr-w-1/gst-1/gst-2]\nclass-name = GenericServiceTester\nvnf-type = server\nnet-name = private\nuser-name = ubuntu\nvm-scripts-path = /home/ubuntu\nscript-1 = iperf-running.sh\nscript-2 = iperf-srv-connection.sh  The second script for the server task looks like this:  #!/bin/bash\n\n\nincoming=`sudo netstat -npt | grep iperf | wc -l`\n\nif [ $incoming -eq 0 ] \nthen\n  exit 1\nelse\n  exit 0\nfi  Here we just count if there are incoming connections to the server.   After the iperf-running.sh script, the iperf-srv-connection.sh script will be executed on the server virtual machines \nand on the client one's also iperf-running.sh and then the script iperf-clt-conection.sh.  Now imagine, that you did not specify one virtual network function component in the client's NSD, but five. And you want to test them all.\nDo you have to create five tasks for that? No, if you define the task for the client as shown above, the integration test will execute\nthe scripts on every virtual machine, that was deployed by the vnfd with the type  client .  And if you have some virtual network function components connected to two different networks but just want to test the ones connected\nto one of them, you can add a  net-name  field to the task and just the ones connected to it will be involved like in the server task.  Afterwards we want to delete the NSDs and simutaniously wait for a message from the orchestrator, that the deletion finished.   [it]\n;set the maximum time (in seconds) of the Integration test. e.g. 10 min = 600 seconds\nmax-integration-test-time = 800\n;set the maximum number of concurrent successors (max number of active child threads)\nmax-concurrent-successors = 10\n\n;vimInstance-create\n[it/vim-c-1]\nclass-name = VimInstanceCreate\nname-file = real-vim.json\nsuccessor-remover = vim-d-1\n\n[it/vim-c-1/vim-d-1]\nclass-name = VimInstanceDelete\n\n;nsd-create\n[it/vim-c-1/nsd-c-1]\nclass-name = NetworkServiceDescriptorCreate\nnum_instances = 1\nsuccessor-remover = nsd-d-1\nname-file = NetworkServiceDescriptor-iperf-real.json\n\n;nsd-delete\n[it/vim-c-1/nsd-c-1/nsd-d-1]\nclass-name = NetworkServiceDescriptorDelete\n\n;nsr-create\n[it/vim-c-1/nsd-c-1/nsr-c-1]\nclass-name = NetworkServiceRecordCreate\nnum_instances = 1\n\n;nsr-wait for creation\n[it/vim-c-1/nsd-c-1/nsr-c-1/nsr-w-1]\nclass-name = NetworkServiceRecordWait\n;the default timeout is 5 seconds\ntimeout = 600\naction = INSTANTIATE_FINISH\n\n[it/vim-c-1/nsd-c-1/nsr-c-1/nsr-w-1/gst-1]\nclass-name = GenericServiceTester\nvnf-type = client\nuser-name = ubuntu\nvm-scripts-path = /home/ubuntu\nscript-1 = iperf-running.sh\nscript-2 = iperf-clt-connection.sh\n\n\n[it/vim-c-1/nsd-c-1/nsr-c-1/nsr-w-1/gst-1/gst-2]\nclass-name = GenericServiceTester\nvnf-type = server\nnet-name = private\nuser-name = ubuntu\nvm-scripts-path = /home/ubuntu\nscript-1 = iperf-running.sh\nscript-2 = iperf-srv-connection.sh\n\n;nsr-wait for deletion\n[it/vim-c-1/nsd-c-1/nsr-c-1/nsr-w-1/gst-1/gst-2/nsr-w-2]\nclass-name = NetworkServiceRecordWait\n;the default timeout is 5 seconds\ntimeout = 360\naction = RELEASE_RESOURCES_FINISH\n\n;nsr-delete\n[it/vim-c-1/nsd-c-1/nsr-c-1/nsr-w-1/gst-1/gst-2/nsr-d-1]\nclass-name = NetworkServiceRecordDelete  As you can see the nodes  nsr-w-2  and  nsr-d-1  are both child nodes of  gst-2 . \nThis means that they are executed concurrently. \nThe  nsr-w-2  node waits for the action RELEASE_RESOURCES_FINISH sent by the NFVO and finishes successfully if it receives it.   Now are all the child nodes of  nsd-c-1  finished and its successor remover nsd-d-1 will be executed which deletes the stored NSDs. \nAfter that all the child nodes of  vim-c-1  finished and its successor remover  vim-d-1  starts to delete the stored vim instance.", 
            "title": "Ini file structure"
        }, 
        {
            "location": "/integration-test-write/#a-little-more-on-scripts", 
            "text": "Now we come back to the '${server_ip}' variable in the iperf-clt-connection script. As mentioned earlier this variable is provided \nby the integration test. It stores the ip of the server. If you wanted to access the IPs of the clients, you could use ${client_ip}. \nThe problem is, that we could for example also have two or more instances of clients. Which ip is chosen? \nActually the script, which contains this variable will be executed twice or more on the virtual machine until every possible substitution was handled. \nYou have access to the IPs, floating IPs and configurations. \nYou can access ips by writing ${vnfrtype_ip} or ${vnfrtype_network_ip} (don't forget the braces). The 'vnfrtype' in our example would be 'server' or 'client'. \nThe 'network' is the virtual_link you specified in the VNFD for the VNF Component and will only retrieve the VNFC ips which are connected to this network. \nIf you have more than one VNFC Instance which is deployed, so for example you have two iperf-servers \ndeployed from one VNFD, then there would be two possibilities to substitute ${server_ip}. If you want to execute a script on the virtual machine of the \niperf-client which contains this variable the integration test will do the following. Execute the script containing the \nvariable with first the ip of one server. And then executing the same script, but now replacing the variable with the other ip. \nThat way you just have to write one script and all the VNF Components of the VNF will be tested. \nYou can access the floating ips of VNFCs by writing ${vnfrtype_fip} or ${vnfrtype_network_fip}. \nOf course, this will only work if there is a floating ip for that virtual machine. \nThe configurations are accessible by typing ${vnfrtype_configurationkey}. \nFor all the variables it is essential, that you enclose them with braces otherwise they won't work.", 
            "title": "A little more on scripts"
        }, 
        {
            "location": "/integration-test-write/#task-execution-order", 
            "text": "Just to clarify the execution order of the tasks specified in the ini files here is a little example without describing what the tasks do. \nThe successor-removers of a task are just executed when all the other child tasks and their subsequent tasks finished.  [it/A]\nsuccessor-remover = H\n\n[it/A/H]\n...\n\n[it/A/B]\n...\n\n[it/A/C]\n...\n\n[it/A/C/D]\nsuccessor-remover = G\n\n[it/A/C/D/G]\n...\n\n[it/A/C/D/E]\n...\n\n[it/A/C/D/F]\n...  The execution order of this example looks like this:   Tasks that are side by side can run concurrently.", 
            "title": "Task execution order"
        }, 
        {
            "location": "/integration-test-write/#other-important-information", 
            "text": "For the integration test to be able to ssh to the virtual machines on openstack, you have to provide a .pem file of a key-pair you are using on openstack.\nDownload this file, name it  integration-test.pem  and put it into the directory  /etc/openbaton/integration-tests/ .\nFurthermore it has to have the correct permissions so you probably have to execute  chmod 400 integration-test.pem .\nAnd don't forget to make the scripts executable.\nDo NOT use '-' in types of VNFDs or configuration names as you cannot use them in bash scripts it will not work for the integration test scripts.", 
            "title": "Other important information"
        }, 
        {
            "location": "/integration-test-write/#the-class-name-types-available", 
            "text": "As mentioned earlier here is a summary of all the class-names available at the moment to use in a ini file node.     class-name  purpose  fields  field purpose      GenericServiceTester  Test the network service itself  script-1  The first script to be executed on the VM      ...       script-n  The n-th script to be executed on the VM      vnf-type  The type of the VNFs that shall be tested      user-name  The user account on the VM on which the scripts will be executed      vm-scripts-path  The path to the directory of the VM where the scripts will be stored before execution      net-name  Specifies the network/virtual-link to which the VMs that shall be tested are connected    NetworkServiceDescriptorCreate  Store a NSD on the NFVO  expected-to-fail  If set to true the task will fail if the onboarding of the NSD is successful      name-file  The name of the json file which contains the NSD    NetworkServiceDescriptorCreateFromPackage  Create a NSD by using a VNFPackage that was uploaded beforehand  expected-to-fail  If set to true the task will fail if the onboarding of the NSD is successful      name-file  The name of the json file which contains the NSD    NetworkServiceDescriptorDelete  Delete a NSD from the NFVO      NetworkServiceDescriptorWait  Wait for a specific event of the NFVO to happen that is related to NSDs  action  The event which will be waited for to happen    NetworkServiceRecordCreate  Deploy a network service from a NSD and create the NSR      NetworkServiceRecordDelete  Delete the NSR      NetworkServiceRecordGetLatest  Expects to get passed a NSR from its preceding task, retrieves the latest version of this NSR from the NFVO and passes it to the following task      NetworkServiceRecordWait  Wait for a specific event of the NFVO to happen that is related to NSRs  action  The event which will be waited for to happen      timeout  After this time (in seconds) the task will fail if the event did not occur yet    PackageDelete  Delete a VNFPackage  package-name  The name of the package that will be deleted    PackageUpload  Upload a VNFPackage  package-upload  The name of the package that will be uploaded    Pause  Used to elapse time until the next task will start  duration  The time (in seconds) that this task shall do nothing and after which it will finish    ProjectCreate  Used to create a new Project  as-user-name  If specified the integration tests will use this user to create the Project. If not the default user specified in the integration-tests.properties will be used.      as-user-password  The password of the User that shall create the new Project. Just needed if  as-user-name  is specified.      expected-to-fail  Set this to true if you expect the Project creation to fail.      project-name  The name of the new Project.    ProjectDelete  Used to delete a project  as-user-name  If specified the integration tests will use this user to delete the Project. If not the default user specified in the integration-tests.properties will be used.      as-user-password  The password of the User that shall delete the new Project. Just needed if  as-user-name  is specified.      expected-to-fail  Set this to true if you expect deleting the Project to fail.      project-name  The name of the project to delete.    ScaleIn  Triggers one scale in operation on a VNFR specified in the ini file  vnf-type  The type of VNFR that shall be scaled in    ScaleOut  Triggers one scale out operation on a VNFR specified in the ini file  floating-ip  The floating IP which shall be assigned to the new instance      virtual-link  The network/virtual-link to which the new instance shall be connected      vnf-type  The type of the VNFR on which the scale out shall be performed    ScalingTester  Verifies if the number of VNFCInstances is equal to a given number and passes an updated NSR to the next task, which can be important after a scaling operation  vnfc-count  The expected number of instances of this VNF      vnf-type  The type of the VNFR whose number of VNFCs should be checked    UserCreate  Used to create a new User  as-user-name  If specified the integration tests will use this user to create the User. If not the default user specified in the integration-tests.properties will be used.      as-user-password  The password of the User that shall create the new User. Just needed if  as-user-name  is specified.      enabled  Set to true if the new User should be enabled.      expected-to-fail  Set this to true if you expect the User creation to fail.      guest-projects  A comma separated list of project names. In each listed project the new User will obtain a GUEST role.      new-user-is-admin  Set this to true if the new User should be an ADMIN.      new-user-name  The name of the User to create.      new-user-password  The password of the User to create.      user-projects  A comma separated list of project names. In each listed project the new User will obtain a USER role.    UserDelete  Used to delete a User  as-user-name  If specified the integration tests will use this user to delete the User. If not the default user specified in the integration-tests.properties will be used.      as-user-password  The password of the User that shall delete the User. Just needed if  as-user-name  is specified.      expected-to-fail  Set this to true if you expect the User deletion to fail.      user-to-delete  The name of the User that shall be deleted.    UserUpdate  Used to update a User  as-user-name  If specified the integration tests will use this user to update the User. If not the default user specified in the integration-tests.properties will be used.      as-user-password  The password of the User that shall create the new User. Just needed if  as-user-name  is specified.      enabled  Set to true if the updated User should be enabled.      expected-to-fail  Set this to true if you expect updating the User to fail.      guest-projects  A comma separated list of project names. In each listed project the updated User will obtain a GUEST role.      user-is-admin  Set this to true if the updated User should be an ADMIN.      user-name-new  The new name of the User.      user-name-old  The name of the User to update.      user-password-new  The new password of the User.      user-projects  A comma separated list of project names. In each listed project the updated User will obtain a USER role.    VimInstanceCreate  Store a vim instance on the NFVO from a json file  name-file  The name of the json file that contains the VimInstance      as-user-name  If specified the integration tests will use this user to create the Vim Instance. If not the default user specified in the integration-tests.properties will be used.      as-user-password  The password of the user that shall create the Vim Instance. Just needed if  as-user-name  is specified.      expected-to-fail  Set this to true if you expect the Vim Instance creation to fail      in-project  The name of the project to which the Vim Instance shall be uploaded. Just usable if you also specify a user to upload with  as-user-name  and  as-user-password . If not specified the default project specified in the integration-tests.properties will be used.    VimInstanceDelete  Delete a vim instance  as-user-name  If specified the integration tests will use this user to delete the Vim Instance. If not the default user specified in the integration-tests.properties will be used.      as-user-password  The password of the user that shall delete the Vim Instance. Just needed if  as-user-name  is specified.      expected-to-fail  Set this to true if you expect a failure while trying to delete the Vim Instance.      in-project  The name of the project to which the Vim Instance shall be uploaded. Just usable if you also specify a user to upload with  as-user-name  and  as-user-password . If not specified the default project specified in the integration-tests.properties will be used.    VirtualNetworkFunctionDescriptorDelete  Delete the VNFDs of a NSD passed from the preceding task, filtered by vnfd name and/or type; if no name and type are passed, all the VNFDs associated to the passed NSD will be deleted  vnf-type  The type of the VNFDs that shall be deleted; this field can be omitted if the type is not important for the choice of VNFDs to delete      vnf-name  The name of the VNFDs that shall be deleted; this field can be omitted if the name is not important for the choice of VNFDs to delete    VirtualNetworkFunctionRecordWait  Wait for an event sent by the NFVO which is related to a VNFR  action  The event which will be waited for to happen      timeout  After this time (in seconds) the task will fail if the event did not occur yet      vnf-type  The type of the VNFR that should produce the awaited event    VNFRStatusTester  Checks if the status of a specified VNFR is as expected  status  The expected status in which the VNFR should be      vnf-type  The type of the VNFR whose status shall be checked", 
            "title": "The class-name types available"
        }, 
        {
            "location": "/integration-test-write/#using-vnfpackages", 
            "text": "Here is an example on how to use VNFPackages in your tests.   [it]\n;set the maximum time (in seconds) of the Integration test. e.g. 10 min = 600 seconds\nmax-integration-test-time = 800\n;set the maximum number of concurrent successors (max number of active child threads)\nmax-concurrent-successors = 10\n\n;vimInstance-create\n[it/vim-c-1]\nclass-name = VimInstanceCreate\nname-file = vim.json\nsuccessor-remover = vim-d-1\n\n[it/vim-c-1/vim-d-1]\nclass-name = VimInstanceDelete\n\n;package-create\n[it/vim-c-1/vnfp-c-1]\nclass-name = PackageUpload\npackage-name = iperf-server-package.tar\nsuccessor-remover = vnfp-d-1\n\n;package-delete\n[it/vim-c-1/vnfp-c-1/vnfp-d-1]\nclass-name = PackageDelete\npackage-name = iperfServerPackage\n\n;nsd-create\n[it/vim-c-1/vnfp-c-1/nsd-c-1]\nclass-name = NetworkServiceDescriptorCreateFromPackage\nname-file = NetworkServiceDescriptor.json\nsuccessor-remover = nsd-d-1\n\n;nsd-delete\n[it/vim-c-1/vnfp-c-1/nsd-c-1/nsd-d-1]\nclass-name = NetworkServiceDescriptorDelete  This example begins by storing a vim instance. Then the package iperf-server-package.tar is stored by specifying the package file name in the package-name attribute. \nThe packages have to be in the directory /etc/openbaton/integration-tests/vnf-packages/. \nAfterwards a NSD is created from the VNFDs in the package and right after that deleted (to keep this example short we did not create a NSR from the NSD and so on). Be aware that you \nhave to use the class NetworkServiceDescriptorCreateFromPackage to store a NSD from a package. \nThen also the package will be deleted. You have to provide the name of the package you want to delete (not the file name this time but the name of the package defined in the Metadata.yaml). \nAt the end the vim instance is deleted.   If you create a NSD from a VNFPackage, the VNFD field of the NSD file would look something like this:   vnfd :[\n{\n       type : server \n},\n{\n       type : client \n}\n\n   ],  The integration test will search for VNFDs with these types that were previously stored by a VNFPackage and use them for creating the NSD.", 
            "title": "Using VNFPackages"
        }, 
        {
            "location": "/integration-test-write/#scaling", 
            "text": "There are three testers for Scaling already implemented. The first one is  ScaleOut . In the ini file this tester needs some additional attributes. Besides the normal  class-name  you should also specify the VNFR type on which the scale out should be performed in the field  vnf-type . Then you can also specify the virtual-link to which the new instance should be connected using  virtual-link . \nAnd you can determine a floating ip for the new instance using the field  floating-ip . \nHere is an example of a ScaleOut task in the ini file:  [it/.../sc-o-1]\nclass-name = ScaleOut\nvnf-type = client\nvirtual-link = private\nfloating-ip = random  The second tester is  ScaleIn . Here you can just specify on which VNFR type the scale in should be executed. An example:   [it/.../sc-i-1]\nclass-name = ScaleIn\nvnf-type = client  And the third tester is used to see if after the scaling operation there is the right number of instances running. \nSpecify the VNFR type you want to test by providing  vnf-type  in the ini file and specify the number of expected VNFC instances by using  vnfc-count . For example:   [it/.../sc-t-1]\nclass-name = ScalingTester\nvnf-type = client\nvnfc-count = 2  Furthermore note that the ScalingTester passes the updated NSR to the next tester. If you trigger a scaling function the NSR will change, but if you do not use ScalingTester (or NetworkServiceRecordGetLatest) the NSR used by the integration test will remain the old one before the scaling operation. \nSo the recommended proceeding after a scale out or scale in is to wait until the operation finishes and then use the  ScalingTester  or at least the  NetworkServiceRecordGetLatest  to have the updated NSR.", 
            "title": "Scaling"
        }, 
        {
            "location": "/tosca-fm/", 
            "text": "Fault Management in TOSCA\n\n\nThis is an example of how to use the Fault Management system with the yaml descriptor. \nThe Fault Management specifics must be placed in the properties of the VDU node. \n\n\nThis is an example of a VDU Node with a Fault Management Policy:\n\n\nVDU1:\n  type: tosca.nodes.nfv.VDU\n  properties:\n    scale_in_out: 1\n    fault_management_policy:\n      fm1:                                      # Name of the Policy\n        isVNFAlarm: true\n        criteria:\n          criteria1:                            # Criteria name\n            parameter_ref: \nnet.tcp.listen[80]\n\n            function: \nlast()\n\n            comparison_operator: \n=\n\n            threshold: \n0\n\n        period: 5\n        severity: CRITICAL\n  requirements:\n    - virtual_link: CP1\n\n\n\n\n\nMore about Fault Management and how to se it up: \nFault Management\n\n\n\n\n\n\n\n\n\n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "**HIDDEN**"
        }, 
        {
            "location": "/tosca-fm/#fault-management-in-tosca", 
            "text": "This is an example of how to use the Fault Management system with the yaml descriptor. \nThe Fault Management specifics must be placed in the properties of the VDU node.   This is an example of a VDU Node with a Fault Management Policy:  VDU1:\n  type: tosca.nodes.nfv.VDU\n  properties:\n    scale_in_out: 1\n    fault_management_policy:\n      fm1:                                      # Name of the Policy\n        isVNFAlarm: true\n        criteria:\n          criteria1:                            # Criteria name\n            parameter_ref:  net.tcp.listen[80] \n            function:  last() \n            comparison_operator:  = \n            threshold:  0 \n        period: 5\n        severity: CRITICAL\n  requirements:\n    - virtual_link: CP1  More about Fault Management and how to se it up:  Fault Management    \n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Fault Management in TOSCA"
        }, 
        {
            "location": "/tosca-asp/", 
            "text": "Autoscaling in TOSCA\n\n\nThis is an example of how to create Auto-scale policies with the yaml descriptor. \n\n\nauto_scale_policy:\n  scale-out:                  # Policy name \n    threshod: 100\n    comparisonOperator: \n=\n\n    period: 30\n    cooldown: 60\n    mode: REACTIVE\n    type: WEIGHTED\n    alarms:\n      alarm1:                 # Alarm name      \n        metric: \nsystem.cpu.load[percpu,avg1]\n\n        statistic: \navg\n\n        comparisonOperator: \n\n        threshold: 0.7\n        weight: 1\n    actions:\n      action1:                # Action name\n        type: SCALE_OUT\n        value: \n2\n\n        target: \ntarget\n\n\n\n\n\n\nMore about Autoscaling and how to se it up: \nAutoscaling\n\n\n\n\n\n\n\n\n\n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "**HIDDEN**"
        }, 
        {
            "location": "/tosca-asp/#autoscaling-in-tosca", 
            "text": "This is an example of how to create Auto-scale policies with the yaml descriptor.   auto_scale_policy:\n  scale-out:                  # Policy name \n    threshod: 100\n    comparisonOperator:  = \n    period: 30\n    cooldown: 60\n    mode: REACTIVE\n    type: WEIGHTED\n    alarms:\n      alarm1:                 # Alarm name      \n        metric:  system.cpu.load[percpu,avg1] \n        statistic:  avg \n        comparisonOperator:  \n        threshold: 0.7\n        weight: 1\n    actions:\n      action1:                # Action name\n        type: SCALE_OUT\n        value:  2 \n        target:  target   More about Autoscaling and how to se it up:  Autoscaling    \n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Autoscaling in TOSCA"
        }
    ]
}