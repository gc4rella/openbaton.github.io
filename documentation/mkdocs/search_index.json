{
    "docs": [
        {
            "location": "/", 
            "text": "OpenBaton\n\n\nOpenBaton is an open source project providing a comprehensive implementation of the ETSI Management and Orchestration (MANO) specification. \n\n\nWhat is NFV\n\n\nETSI NFV represents a concerted telco operator initiative fostering the development of virtual network infrastructures by porting and further adapting network functions to the specific cloud environment. \nETSI NFV has defined a large set of virtualisation use cases, spanning from the cloudification of the main core network functions such as IMS, Evolved Packet Core, and Radio Access Networks, as well as providing on demand and complete virtualised infrastructures as IaaS or PaaS to third parties, such as enterprises and professional radio. \nThat enables providing elastic deployments of cost efficient network infrastructures.\nOne of the main concerns of ETSI NFV is to prove the feasibility of the cloud deployments of the typical network functions through proof of concept trials and prototypes as well as providing indications for further standardization in the areas of underlying infrastructures, software architectures, networking and management, and orchestration to improve performance and grant security of the overall infrastructure.\nETSI NFV limits itself to this level of indications, considering that other standardization bodies and de-facto open source standards such as 3GPP and OpenStack should finalize the specific implementation work. \n\n\nIts main components\n\n\nOpenBaton provides the following components: \n\n\n\n\nA Network Function Virtualisation Orchestrator (NFVO) completely designed and implemented following the ETSI MANO specification\n\n\nA generic Virtual Network Function Manager (VNFM) able to manage the lifecycle of VNFs based on their descriptors\n\n\nA set of libraries which could be used for building your own VNFM\n\n\n\n\nCan I plug in my Network Functions?\n\n\nYes, this is possible using two different approaches:\n\n\n\n\nintegrating your own VNFM. In this case you can use either the REST interface, or the JMS one for interoperating with the NFVO\n\n\nimplementing a set of scripts which can be executed as part of the lifecycle event of your Virtual Network Function Descriptor. We provide a generic VNFM and EMS which can be used for executing them\n\n\n\n\nCan I use OpenBaton to build my own Network Service?\n\n\nYes! OpenBaton provides a NFVO which can interoperate with VNFMs implemented by third parties. In this project we provide also a set of tools (like the vnfm-sdk) which supports developers in building their own VNFM. \n\n\nGet started\n\n\nIn order to get started you can follow the \ninstallation guide\n\n\nGet in contact\n\n\n\n\nVia twitter: \ntwitter\n\n\nSubscribing to our mailing list: \nusers-at-openbaton-dot-org\n\n\nSending us an email to: \ninfo-at-openbaton-dot-org\n\n\n\n\n\n\n\n\n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Get Started"
        }, 
        {
            "location": "/#openbaton", 
            "text": "OpenBaton is an open source project providing a comprehensive implementation of the ETSI Management and Orchestration (MANO) specification.", 
            "title": "OpenBaton"
        }, 
        {
            "location": "/#what-is-nfv", 
            "text": "ETSI NFV represents a concerted telco operator initiative fostering the development of virtual network infrastructures by porting and further adapting network functions to the specific cloud environment. \nETSI NFV has defined a large set of virtualisation use cases, spanning from the cloudification of the main core network functions such as IMS, Evolved Packet Core, and Radio Access Networks, as well as providing on demand and complete virtualised infrastructures as IaaS or PaaS to third parties, such as enterprises and professional radio. \nThat enables providing elastic deployments of cost efficient network infrastructures.\nOne of the main concerns of ETSI NFV is to prove the feasibility of the cloud deployments of the typical network functions through proof of concept trials and prototypes as well as providing indications for further standardization in the areas of underlying infrastructures, software architectures, networking and management, and orchestration to improve performance and grant security of the overall infrastructure.\nETSI NFV limits itself to this level of indications, considering that other standardization bodies and de-facto open source standards such as 3GPP and OpenStack should finalize the specific implementation work.", 
            "title": "What is NFV"
        }, 
        {
            "location": "/#its-main-components", 
            "text": "OpenBaton provides the following components:    A Network Function Virtualisation Orchestrator (NFVO) completely designed and implemented following the ETSI MANO specification  A generic Virtual Network Function Manager (VNFM) able to manage the lifecycle of VNFs based on their descriptors  A set of libraries which could be used for building your own VNFM", 
            "title": "Its main components"
        }, 
        {
            "location": "/#can-i-plug-in-my-network-functions", 
            "text": "Yes, this is possible using two different approaches:   integrating your own VNFM. In this case you can use either the REST interface, or the JMS one for interoperating with the NFVO  implementing a set of scripts which can be executed as part of the lifecycle event of your Virtual Network Function Descriptor. We provide a generic VNFM and EMS which can be used for executing them", 
            "title": "Can I plug in my Network Functions?"
        }, 
        {
            "location": "/#can-i-use-openbaton-to-build-my-own-network-service", 
            "text": "Yes! OpenBaton provides a NFVO which can interoperate with VNFMs implemented by third parties. In this project we provide also a set of tools (like the vnfm-sdk) which supports developers in building their own VNFM.", 
            "title": "Can I use OpenBaton to build my own Network Service?"
        }, 
        {
            "location": "/#get-started", 
            "text": "In order to get started you can follow the  installation guide", 
            "title": "Get started"
        }, 
        {
            "location": "/#get-in-contact", 
            "text": "Via twitter:  twitter  Subscribing to our mailing list:  users-at-openbaton-dot-org  Sending us an email to:  info-at-openbaton-dot-org    \n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Get in contact"
        }, 
        {
            "location": "/install/", 
            "text": "Install OpenBaton\n\n\nThis how-to will walk you through getting started with OpenBaton. In particular it will show you how you can setup and configure its main components. It will also show you how to write your Network Service Descriptor and create your own Virtual Network Function Package and deploy it on your PoPs. \n\n\nOpenBaton comprises different components:\n\n\n\n\nthe Network Function Virtualisation Orchestrator (NFVO), always required for creating a composition of differnet Virtual Network Function Descriptors\n\n\ngeneric-VNFM, needed only when the VNFP approach is used. Using the generic-VNFM implies also the usage of the EMS which is automatically installed on the VDUs where VNF are to be installed. \n\n\n\n\n\n\nBefore you start\n\n\nFirst of all it is important to clarify the different deployment options. Depending on your requirements OpenBaton, using a plugin mechanism, supports different VIM implementations. In particular, in this relesae, two different vim plugins are available: \n\n\n\n\ntest-plugin: it is a mockup of the VIM interface which is quite useful for development. It basically does not create any real virtual resources and it can be used for developing new features on the NFVO without having to always deploy new services;\n\n\nopenstack-plugin: it provides an implementation of the VIM interface to OpenStack for requesting resources. \n\n\n\n\nDepending on which one is your target provider, you will need to configure runtime different Point of Presence (PoP). This is something which will be explained later on in this user guide. \n\n\nLet's move on\n\n\nNext step is to \ninstall the NFVO\n.\n\n\n\n\n\n\n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Overview"
        }, 
        {
            "location": "/install/#install-openbaton", 
            "text": "This how-to will walk you through getting started with OpenBaton. In particular it will show you how you can setup and configure its main components. It will also show you how to write your Network Service Descriptor and create your own Virtual Network Function Package and deploy it on your PoPs.   OpenBaton comprises different components:   the Network Function Virtualisation Orchestrator (NFVO), always required for creating a composition of differnet Virtual Network Function Descriptors  generic-VNFM, needed only when the VNFP approach is used. Using the generic-VNFM implies also the usage of the EMS which is automatically installed on the VDUs where VNF are to be installed.     Before you start  First of all it is important to clarify the different deployment options. Depending on your requirements OpenBaton, using a plugin mechanism, supports different VIM implementations. In particular, in this relesae, two different vim plugins are available:    test-plugin: it is a mockup of the VIM interface which is quite useful for development. It basically does not create any real virtual resources and it can be used for developing new features on the NFVO without having to always deploy new services;  openstack-plugin: it provides an implementation of the VIM interface to OpenStack for requesting resources.    Depending on which one is your target provider, you will need to configure runtime different Point of Presence (PoP). This is something which will be explained later on in this user guide.   Let's move on  Next step is to  install the NFVO .   \n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Install OpenBaton"
        }, 
        {
            "location": "/nfvo-installation/", 
            "text": "Install NFVO\n\n\nThe NFVO is implemented in java using the \nspring.io\n framework. For more details about the NFVO architecture, you can refer to the extend it section.\n\n\nInstall the latest NFVO version from the source code\n\n\nThe NFVO can be installed using different mechanisms. In this how to we will show you how to instantiate it using directly from the git repo. \n\n\nThe NFVO uses the Java Messaging System for communicating with the VNFMs. Therefore it is a prerequisite to have ActiveMQ up and running. To facilitate the installation procedures we provide an installation script which can be used for installing the NFVO and the prerequired libraries. Considering that this script needs to install some system libraries, it is required to execute it as super user. To execute the following command you need to have curl installed (see http://curl.haxx.se/). \n\n\nsudo su -\ncurl -fsSkL http://get.openbaton.org/bootstrap |bash\n\n\n\n\nAt the end of the installation procedure, if there are no errors, the dashboard is reachable at: \nlocalhost:8080\n and you should have the following structure:\n\n\n/opt/openbaton/\n\u251c\u2500\u2500 apache-activemq-5.11.1\n\u251c\u2500\u2500 generic-vnfm\n\u2514\u2500\u2500 nfvo\n\n\n\n\nWhere:\n\n\n\n\napache-activemq-5.11.1\n contains the activeMQ software (it is basically downloaded, extracted and executed)  \n\n\ngeneric-vnfm\ncontains the source code and scripts required for dealing with the generic-vnfm  \n\n\nnfvo\n contains the source code and scripts of the NFVO\n\n\n\n\nAt this point the NFVO is ready to be used. Please refer to the \nIntroduction\n on how to start using it.\n\n\nNote:\n considering that OpenBaton is installed as \n\"root\"\n user, would be good to change permissions of the installations folders for executing the differnet components as standard user. Here an example:\n\n\nsudo chown -R username: /opt/openbaton\nsudo chown -R username: /etc/openbaton\n\n\n\n\nStarting and stopping NFVO\n\n\nAfter the installation procedure the nfvo is running. If you want to stop it, enter this command:\n\n\ncd /opt/openbaton/nfvo\n./openbaton.sh stop\n\n\n\n\nNote (in case you are also using the generic-vnfm):\n remember to stop also the Generic VNFM with the following command:\n\n\ncd /opt/openbaton/generic-vnfm\n./generic-vnfm.sh stop\n\n\n\n\nTo start the nfvo, enter the command:\n\n\ncd /opt/openbaton/nfvo\n./openbaton.sh start\n\n\n\n\nNote (in case you are also using the generic-vnfm):\n remember to start also the Generic VNFM with the following command:\n\n\ncd /opt/openbaton/generic-vnfm\n./generic-vnfm.sh start\n\n\n\n\nNFVO properties overview\n\n\nThe NFVO is configured with default configuration parameters at the beginning. The configuration file is located at: \n\n\n/etc/openbaton/openbaton.properties\n\n\n\n\nThis file can be modified for specific parameters. For instance, you can decide to change logging levels (TRACE, DEBUG, INFO, WARN, and ERROR) and mechanisms:\n\n\nlogging.level.org.springframework=INFO\nlogging.level.org.hibernate=INFO\nlogging.level.org.jclouds=WARN\nlogging.level.org.springframework.security=WARN\n# Level for loggers on classes inside the root package \norg.project.openbaton\n (and its\n# sub-packages)\nlogging.level.org.openbaton.nfvo=INFO\n# Direct log to a log file\nlogging.file=/var/log/openbaton.log\n\n\n\n\nOr parameters related with persistency (hibernate):\n\n\n# DB properties\nspring.datasource.username=admin\nspring.datasource.password=changeme\n# hsql jdbc\nspring.datasource.url=jdbc:hsqldb:file:/tmp/openbaton/openbaton.hsdb\nspring.datasource.driver-class-name=org.hsqldb.jdbc.JDBCDriver\nspring.jpa.database-platform=org.hibernate.dialect.HSQLDialect\n# mysql jdbc\n#spring.datasource.url=jdbc:mysql://localhost:3306/openbaton\n#spring.datasource.driver-class-name=com.mysql.jdbc.Driver\n#spring.jpa.database-platform=org.hibernate.dialect.MySQLDialect\n# hibernate properties\nspring.jpa.show-sql=false\nspring.jpa.hibernate.ddl-auto=create-drop\n\n\n\n\nBy deafault ActiveMQ is installed on the host of the NFVO. Be aware of the fact that if you want your VNFM to be executed on a different host, you will need ActiveMQ to be reachable also from the extern.\n\n\nNote:\n when you want to deploy a VNF (EMS) in a VM which runs on a different host in respect to the NFVO, you will need to configure the activemq endpoint (spring.activemq.broker-url) with the real IP of the NFVO host (instead of localhost).\n\n\n# activeMQ\nspring.activemq.broker-url=tcp://localhost:61616\nspring.activemq.user=admin\nspring.activemq.password=admin\n\n\n\n\nThese parameters rapresent the maximum file size of the VNF Package which can be uploaded to the NFVO and the total maximum request size\n\n\n# filesUpload\nmultipart.maxFileSize=2046MB\nmultipart.maxRequestSize=2046MB\n\n\n\n\nThe following properties are related to the plugin mechanism used for loading VIM and Monitoring instances. The \nvim-plugin-installation-dir\n is the directory where all the jar files are, which implement the VIM interface (see the \nvim plugin documentation\n). The NFVO will load them at runtime.  \n\n\n# plugin install\n# the plugins inside that directory will be executed at startup\nplugin-installation-dir = ./plugins\n\n\n\n\nThis properties allows the user to delete the Network Service Records no matter in which status are they. Pleas note that in any case it is possible to remove a Network Service Record in \nNULL\n state.\n\n\n# nfvo behaviour\ndelete-on-all-status = false\n\n\n\n\nThose properties are needed in case you want to tune a bit the performances of the NFVO. When the VNFMs send a message to the NFVO, there is a pool of threads able to process these messages in parallel. These parameters allows you to change the pool configuration, for more details please check the \nspring documentation regarding thread pool executor\n \n\n\n# Thread pool executor configuration\n# for info see http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/scheduling/concurrent/ThreadPoolTaskExecutor.html\nvmanager-executor-core-pool-size = 20\nvmanager-executor-max-pool-size = 25\nvmanager-executor-queue-capacity = 500\nvmanager-keep-alive = 30\n\n\n\n\nWhenever some of those parameters are changed, you will need to restart the orchestrator.\n\n\nLet's move to the next step\n\n\nDependening on the approach used for deploying your VNF, you'll have either to install the generic-VNFM or install and register your own VNFM\n\n\n\n\n\n\n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Install NFVO"
        }, 
        {
            "location": "/nfvo-installation/#install-nfvo", 
            "text": "The NFVO is implemented in java using the  spring.io  framework. For more details about the NFVO architecture, you can refer to the extend it section.  Install the latest NFVO version from the source code  The NFVO can be installed using different mechanisms. In this how to we will show you how to instantiate it using directly from the git repo.   The NFVO uses the Java Messaging System for communicating with the VNFMs. Therefore it is a prerequisite to have ActiveMQ up and running. To facilitate the installation procedures we provide an installation script which can be used for installing the NFVO and the prerequired libraries. Considering that this script needs to install some system libraries, it is required to execute it as super user. To execute the following command you need to have curl installed (see http://curl.haxx.se/).   sudo su -\ncurl -fsSkL http://get.openbaton.org/bootstrap |bash  At the end of the installation procedure, if there are no errors, the dashboard is reachable at:  localhost:8080  and you should have the following structure:  /opt/openbaton/\n\u251c\u2500\u2500 apache-activemq-5.11.1\n\u251c\u2500\u2500 generic-vnfm\n\u2514\u2500\u2500 nfvo  Where:   apache-activemq-5.11.1  contains the activeMQ software (it is basically downloaded, extracted and executed)    generic-vnfm contains the source code and scripts required for dealing with the generic-vnfm    nfvo  contains the source code and scripts of the NFVO   At this point the NFVO is ready to be used. Please refer to the  Introduction  on how to start using it.  Note:  considering that OpenBaton is installed as  \"root\"  user, would be good to change permissions of the installations folders for executing the differnet components as standard user. Here an example:  sudo chown -R username: /opt/openbaton\nsudo chown -R username: /etc/openbaton  Starting and stopping NFVO  After the installation procedure the nfvo is running. If you want to stop it, enter this command:  cd /opt/openbaton/nfvo\n./openbaton.sh stop  Note (in case you are also using the generic-vnfm):  remember to stop also the Generic VNFM with the following command:  cd /opt/openbaton/generic-vnfm\n./generic-vnfm.sh stop  To start the nfvo, enter the command:  cd /opt/openbaton/nfvo\n./openbaton.sh start  Note (in case you are also using the generic-vnfm):  remember to start also the Generic VNFM with the following command:  cd /opt/openbaton/generic-vnfm\n./generic-vnfm.sh start  NFVO properties overview  The NFVO is configured with default configuration parameters at the beginning. The configuration file is located at:   /etc/openbaton/openbaton.properties  This file can be modified for specific parameters. For instance, you can decide to change logging levels (TRACE, DEBUG, INFO, WARN, and ERROR) and mechanisms:  logging.level.org.springframework=INFO\nlogging.level.org.hibernate=INFO\nlogging.level.org.jclouds=WARN\nlogging.level.org.springframework.security=WARN\n# Level for loggers on classes inside the root package  org.project.openbaton  (and its\n# sub-packages)\nlogging.level.org.openbaton.nfvo=INFO\n# Direct log to a log file\nlogging.file=/var/log/openbaton.log  Or parameters related with persistency (hibernate):  # DB properties\nspring.datasource.username=admin\nspring.datasource.password=changeme\n# hsql jdbc\nspring.datasource.url=jdbc:hsqldb:file:/tmp/openbaton/openbaton.hsdb\nspring.datasource.driver-class-name=org.hsqldb.jdbc.JDBCDriver\nspring.jpa.database-platform=org.hibernate.dialect.HSQLDialect\n# mysql jdbc\n#spring.datasource.url=jdbc:mysql://localhost:3306/openbaton\n#spring.datasource.driver-class-name=com.mysql.jdbc.Driver\n#spring.jpa.database-platform=org.hibernate.dialect.MySQLDialect\n# hibernate properties\nspring.jpa.show-sql=false\nspring.jpa.hibernate.ddl-auto=create-drop  By deafault ActiveMQ is installed on the host of the NFVO. Be aware of the fact that if you want your VNFM to be executed on a different host, you will need ActiveMQ to be reachable also from the extern.  Note:  when you want to deploy a VNF (EMS) in a VM which runs on a different host in respect to the NFVO, you will need to configure the activemq endpoint (spring.activemq.broker-url) with the real IP of the NFVO host (instead of localhost).  # activeMQ\nspring.activemq.broker-url=tcp://localhost:61616\nspring.activemq.user=admin\nspring.activemq.password=admin  These parameters rapresent the maximum file size of the VNF Package which can be uploaded to the NFVO and the total maximum request size  # filesUpload\nmultipart.maxFileSize=2046MB\nmultipart.maxRequestSize=2046MB  The following properties are related to the plugin mechanism used for loading VIM and Monitoring instances. The  vim-plugin-installation-dir  is the directory where all the jar files are, which implement the VIM interface (see the  vim plugin documentation ). The NFVO will load them at runtime.    # plugin install\n# the plugins inside that directory will be executed at startup\nplugin-installation-dir = ./plugins  This properties allows the user to delete the Network Service Records no matter in which status are they. Pleas note that in any case it is possible to remove a Network Service Record in  NULL  state.  # nfvo behaviour\ndelete-on-all-status = false  Those properties are needed in case you want to tune a bit the performances of the NFVO. When the VNFMs send a message to the NFVO, there is a pool of threads able to process these messages in parallel. These parameters allows you to change the pool configuration, for more details please check the  spring documentation regarding thread pool executor    # Thread pool executor configuration\n# for info see http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/scheduling/concurrent/ThreadPoolTaskExecutor.html\nvmanager-executor-core-pool-size = 20\nvmanager-executor-max-pool-size = 25\nvmanager-executor-queue-capacity = 500\nvmanager-keep-alive = 30  Whenever some of those parameters are changed, you will need to restart the orchestrator.  Let's move to the next step  Dependening on the approach used for deploying your VNF, you'll have either to install the generic-VNFM or install and register your own VNFM   \n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Install NFVO"
        }, 
        {
            "location": "/vim-instance/", 
            "text": "Register a new Point of Presence (PoP)\n\n\nThe \nVirtualised Infrastructure Manager\n (Vim) is the functional block, responsible for controlling and managing the\n NFVI compute, storage and network resources within a Point of Presence (PoP).\n\n\nIn order to interoperate with a PoP it is required to register the VIM instance responsible for it on the NFVO. For doing that you can write a JSon file containing the details of a Vim Instance like the one described below: \n\n\n{\n  \nname\n:\nvim-instance-name\n,\n  \nauthUrl\n:\nhttp://192.168.0.5:5000/v2.0\n,\n  \ntenant\n:\ntenantName\n,\n  \nusername\n:\nuserName\n,\n  \npassword\n:\npassword\n,\n  \nkeyPair\n:\nkeyName\n,\n  \nsecurityGroups\n: [\n    \nsecurityName\n\n  ],\n  \ntype\n:\nopenstack\n,\n  \nlocation\n:{\n        \nname\n:\nBerlin\n,\n        \nlatitude\n:\n52.525876\n,\n        \nlongitude\n:\n13.314400\n\n  }\n}\n\n\n\n\n\n\n\n\n\n\n\nParams\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\nname\n\n\nThe name of the VimInstance\n\n\n\n\n\n\nauthUrl\n\n\nThe endpoint to request the authentication\n\n\n\n\n\n\ntenant\n\n\nThe tenant is a string to refer to a group of users\n\n\n\n\n\n\nusername\n\n\nThe name of the user recognized in OpenStack in the keystone service\n\n\n\n\n\n\npassword\n\n\nThe password of the user recognized in the OpenStack in the keystone service\n\n\n\n\n\n\nkeyPair\n\n\nThe keyPair name stored into OpenStack to get the access to the VMs\n\n\n\n\n\n\nsecurityGroups\n\n\nRecognise a Security group into OpenStack where gives a sets of IP filter rules that are applied to an instance's networking.\n\n\n\n\n\n\ntype\n\n\nThe type of the Vim Instance that will start the corresponding plugin. Possible values are: \nopenstack\n or \ntest\n\n\n\n\n\n\nlocation\n\n\nThe location of the data Center. Name: String of the place where is the Data Center located. Latitude/Longitude geolocation point\n\n\n\n\n\n\n\n\nBy default we use only one tenant on your PoP. We are currently working on supporting the instantiation of different NSDs in different tenants. \n\n\nRegister the PoP using the GUI\n\n\nIn order to make use of your VIM described within your JSON descriptor, you need to request the NFVO to register it. \nYou can use the dashboard available at \nlocalhost:8080\n for this purpose. \nUnder the menu \nManage PoPs\n you can see the \nPoP instances\n. Click on the Register VIM button and upload your VIM descriptor. Following picture shows the dashboard: \n\n\n\n\nOnce the VIM instance is registered, it will appear on the list of available PoPs. At this point the VIM/PoP can be included in your Network Service Descriptors. \n\nPlease note that the name chosen must be unique and will be used to refer the VimInstance\n.\n\n\nFor more information about the dashboard see: \nOpenBaton Dashboard\n\n\nWhat are the supported VIM types?\n\n\nBy default the NFVO supports two different VIM types: \n\n\n\n\nopenstack: for interoperating with an OpenStack instance\n\n\ntest: for testing purposes implementing a VIM mockup\n\n\n\n\nFor each of those types there is a different implementation of the VIM API. The NFVO uses a plugin mechanism for interacting with VIMs. In the folders \nplugins\n under nfvo folder should be a jar file that implements the interface to the your VIM ( i.e. \nOpenstack\n )\n(you can change the folder where OpenBaton searches for the plugins by changing the variable \nplugin-installation-dir\n in the \nopenbaton.properties\n file under /etc/openbaton)\nThis jar is the implementation of the interface that communicates with your VIM.\n\n\nNote\n: You can implement your own interface just follow the documentation \nVim plugin\n.\n\n\n\n\n\n\n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Register a PoP"
        }, 
        {
            "location": "/vim-instance/#register-a-new-point-of-presence-pop", 
            "text": "The  Virtualised Infrastructure Manager  (Vim) is the functional block, responsible for controlling and managing the\n NFVI compute, storage and network resources within a Point of Presence (PoP).  In order to interoperate with a PoP it is required to register the VIM instance responsible for it on the NFVO. For doing that you can write a JSon file containing the details of a Vim Instance like the one described below:   {\n   name : vim-instance-name ,\n   authUrl : http://192.168.0.5:5000/v2.0 ,\n   tenant : tenantName ,\n   username : userName ,\n   password : password ,\n   keyPair : keyName ,\n   securityGroups : [\n     securityName \n  ],\n   type : openstack ,\n   location :{\n         name : Berlin ,\n         latitude : 52.525876 ,\n         longitude : 13.314400 \n  }\n}     Params  Meaning      name  The name of the VimInstance    authUrl  The endpoint to request the authentication    tenant  The tenant is a string to refer to a group of users    username  The name of the user recognized in OpenStack in the keystone service    password  The password of the user recognized in the OpenStack in the keystone service    keyPair  The keyPair name stored into OpenStack to get the access to the VMs    securityGroups  Recognise a Security group into OpenStack where gives a sets of IP filter rules that are applied to an instance's networking.    type  The type of the Vim Instance that will start the corresponding plugin. Possible values are:  openstack  or  test    location  The location of the data Center. Name: String of the place where is the Data Center located. Latitude/Longitude geolocation point     By default we use only one tenant on your PoP. We are currently working on supporting the instantiation of different NSDs in different tenants.", 
            "title": "Register a new Point of Presence (PoP)"
        }, 
        {
            "location": "/vim-instance/#register-the-pop-using-the-gui", 
            "text": "In order to make use of your VIM described within your JSON descriptor, you need to request the NFVO to register it. \nYou can use the dashboard available at  localhost:8080  for this purpose. \nUnder the menu  Manage PoPs  you can see the  PoP instances . Click on the Register VIM button and upload your VIM descriptor. Following picture shows the dashboard:    Once the VIM instance is registered, it will appear on the list of available PoPs. At this point the VIM/PoP can be included in your Network Service Descriptors.  Please note that the name chosen must be unique and will be used to refer the VimInstance .  For more information about the dashboard see:  OpenBaton Dashboard", 
            "title": "Register the PoP using the GUI"
        }, 
        {
            "location": "/vim-instance/#what-are-the-supported-vim-types", 
            "text": "By default the NFVO supports two different VIM types:    openstack: for interoperating with an OpenStack instance  test: for testing purposes implementing a VIM mockup   For each of those types there is a different implementation of the VIM API. The NFVO uses a plugin mechanism for interacting with VIMs. In the folders  plugins  under nfvo folder should be a jar file that implements the interface to the your VIM ( i.e.  Openstack  )\n(you can change the folder where OpenBaton searches for the plugins by changing the variable  plugin-installation-dir  in the  openbaton.properties  file under /etc/openbaton)\nThis jar is the implementation of the interface that communicates with your VIM.  Note : You can implement your own interface just follow the documentation  Vim plugin .   \n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "What are the supported VIM types?"
        }, 
        {
            "location": "/use/", 
            "text": "How to use OpenBaton\n\n\nIn order to use OpenBaton for launching your first Network Service, you will need to follow these steps:\n\n\n\n\nDecide which VNFM to use.\n\n\nCreate the VNF Package(s).\n\n\nPrepare the Network Service Descriptor (NSD).\n\n\n\n\nOnce these steps are completed you will be able to orchestrate your Network Service from the dashboard.\n\n\nVirtual Network Function Manager Approaches\n\n\nIn order to manage the Virtual Network Function(s), the NFV-MANO architectural framework expects a Virtual Network Function Manager (VNFM).\nTo facilitate ease of use and extensibility, the Openbaton project provides three different approaches to using a VNFM:\n\n\n\n\nUse the Generic VNFM\n\n\nBuild a VNFM using the SDK\n\n\nUse your own VNFM\n\n\n\n\nMain purposes of the approaches\n\n\n1. Use the Generic VNFM\n\n\nUsing the generic VNFM you don't need to create a VNFM to use Openbaton.\nIt is called \"Generic\" because it may be assigned the management of a single VNF instance, or the management of VNF multiple instances of the same type or of different types.\nIt is already included in Openbaton as default.\n\n\nPlease refer to the following doc for more details: \nUse the generic VNFM\n\n\n2. Build a VNFM using the SDK\n\n\nOpenbaton provides a Java SDK called vnfm-sdk which helps you to simply create a VNFM for your VNF.\nRegarding the type of the communication between the NFVO and the VNFM (Or-Vnfm), you can use the vnfm-sdk-jms or vnfm-sdk-rest, depending if you prefer to communicate with JMS or REST.\n\n\nPlease refer to the following doc for more details: \nBuild your own VNFM\n\n\n3. Use your own VNFM\n\n\nThis approach allows you to integrate your VNFM and VNF within Openbaton. In this case, the Or-Vnfm communication will be via REST interfaces.\n\n\nThe three pages following describe in details these three different approaches.\n\n\nPlease refer to the following doc for more details: \nBring your own VNFM\n\n\n\n\n\n\n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Introduction"
        }, 
        {
            "location": "/use/#how-to-use-openbaton", 
            "text": "In order to use OpenBaton for launching your first Network Service, you will need to follow these steps:   Decide which VNFM to use.  Create the VNF Package(s).  Prepare the Network Service Descriptor (NSD).   Once these steps are completed you will be able to orchestrate your Network Service from the dashboard.", 
            "title": "How to use OpenBaton"
        }, 
        {
            "location": "/use/#virtual-network-function-manager-approaches", 
            "text": "In order to manage the Virtual Network Function(s), the NFV-MANO architectural framework expects a Virtual Network Function Manager (VNFM).\nTo facilitate ease of use and extensibility, the Openbaton project provides three different approaches to using a VNFM:   Use the Generic VNFM  Build a VNFM using the SDK  Use your own VNFM", 
            "title": "Virtual Network Function Manager Approaches"
        }, 
        {
            "location": "/use/#main-purposes-of-the-approaches", 
            "text": "1. Use the Generic VNFM  Using the generic VNFM you don't need to create a VNFM to use Openbaton.\nIt is called \"Generic\" because it may be assigned the management of a single VNF instance, or the management of VNF multiple instances of the same type or of different types.\nIt is already included in Openbaton as default.  Please refer to the following doc for more details:  Use the generic VNFM  2. Build a VNFM using the SDK  Openbaton provides a Java SDK called vnfm-sdk which helps you to simply create a VNFM for your VNF.\nRegarding the type of the communication between the NFVO and the VNFM (Or-Vnfm), you can use the vnfm-sdk-jms or vnfm-sdk-rest, depending if you prefer to communicate with JMS or REST.  Please refer to the following doc for more details:  Build your own VNFM  3. Use your own VNFM  This approach allows you to integrate your VNFM and VNF within Openbaton. In this case, the Or-Vnfm communication will be via REST interfaces.  The three pages following describe in details these three different approaches.  Please refer to the following doc for more details:  Bring your own VNFM   \n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Main purposes of the approaches"
        }, 
        {
            "location": "/vnfm-generic/", 
            "text": "VNFManager Generic\n\n\nThe Generic VNFManager is an implementation following the \nETSI MANO\n specifications. For that reason it is highly tied to the EMS.\nThis VNFM may be assigned the management of a single VNF instance, or the management of multiple VNF instances of the same type or of different types.\n\n\nThe Generic VNFManager handles communication with the NFVO and with EMS. The communication NFVO \u2194 VNFM \u2194 EMS is done using the \nStomp\n protocol over ActiveMQ.  \n\n\nThe communication between the NFVO and Generic VNFManager:\n\n\n\n\nThe communication between the Generic VNFManager and EMS:\n\n\n\n\nAs you can see, the Generic VNFM sends commands to the EMS, which is running in the VM. Then the EMS executes the commands (scripts) locally in the VNFC. \nPlease note that the EMS executes those scripts as root user\n.\nThe following sequence diagram explains the communication messages.\n\n\n\n\nThe Generic VNFManager is supposed to be used for any type of VNF that follows some conventions regarding:\n\n\n\n\nVMs deployment\n\n\nScript execution costraints\n\n\nVMs termination\n\n\n\n\nVMs deployment\n\n\nAccordingly to the \nETSI MANO B.3\n the VNF instantiation flows can be done in two ways:\n\n\n\n\nWith resource allocation done by NFVO\n\n\nWith resource allocation done by VNF Manager\n\n\n\n\nThe Generic VNFM follows the first approach. In the first approach two messages will be sent to the NFVO:\n\n\n\n\n\n\nGRANT_OPERATION message\n: check if the resources are available on the selected PoP. If the GRANT_OPERATION message is returned, then there are enough resources, otherwise an ERROR message will be sent. After the GRANT_OPERATION message it is possible to send the ALLOCATE_RESOURCE message.  \n\n\n\n\n\n\nALLOCATE_RESOURCE message\n: This message ask the NFVO to create all the resources and then, if no errors occurred, the ALLOCATE_RESOURCE message will be returned to the VNFManager. Only the VNFMs which follow the first approach need to send this message.\n\n\n\n\n\n\nAfter that point the VMs are created and \nthe VNF record is filled with values\n, such as ips, that can be found directly in the VirtualNetworkFunctionRecord\u2192VirtualDeploymentUnit\u2192VNFCInstance object.\n\n\nScript Execution Costraints\n\n\nFor each operation of the VNF Lifecycle Management interface, the VNFManager sends scripts to the EMS which executes them locally in the VMs.\n\n\nNote\n: The scripts come from the VNFPackage which you need to create (see \nVNFPackage documentation\n).\n\n\nThe ordering of this scripts is defined in the NetworkServiceDescriptor from which the NetworkServiceRecord was created, in particular into the NetworkServiceDescriptor\u2192VirtualNetworkFunctionDescriptor\u2192LifecycleEvents.\nHere an example (to make it more readable it is shown only the \nVNF lifecycle event\n part):\n\n\n{// NSD\n  ...\n  {// VNFD\n    ...\n    \nlifecycle_event\n:[\n        {\n            \nevent\n:\nINSTANTIATE\n,\n            \nlifecycle_events\n:[\n                \ninstall.sh\n\n            ]\n        },\n        {\n            \nevent\n:\nCONFIGURE\n,\n            \nlifecycle_events\n:[\n                \nserver_configure.sh\n\n            ]\n        },\n        {\n            \nevent\n:\nSTART\n,\n            \nlifecycle_events\n:[\n                 \nserver_start.sh\n\n            ]\n        },\n        {\n            \nevent\n:\nTERMINATE\n,\n            \nlifecycle_events\n:[\n                 \nserver_terminate.sh\n\n            ]\n        }\n    ],\n    ...\n  }\n  ...\n}\n\n\n\n\nIn the following table is described for each \nVNF lifecycle event\n when the scripts are executed.\n\n\n\n\n\n\n\n\nVNF Lifecycle event\n\n\nWhen scripts are executed\n\n\n\n\n\n\n\n\n\n\nINSTANTIATE\n\n\nDuring the instantiation of the corresponding VNF\n\n\n\n\n\n\nCONFIGURE\n\n\nAfter the instantiation. Useful if the VNF depends on other VNFs, because we can get parameters provided by them (e.g. IP). The parameters are available as environment variables (see later).\n\n\n\n\n\n\nSTART\n\n\nAfter the instantiation or configuration (It depends whether the event CONFIGURE specified).\n\n\n\n\n\n\nTERMINATE\n\n\nDuring the termination of the corresponding VNF\n\n\n\n\n\n\n\n\nThe available parameters are defined in the VirtualNetworkFunctionDescriptor fields:\n\n\n\n\nprovides\n: it contains the VMs parameters which will be available after the instantiation (e.g. IP) for other VNFs.\n\n\nconfigurations\n: it contains specific parameters which you want to use in the scripts.\n\n\n\n\nIn the INSTANTIATE scripts, the parameters defined in these two fields are then available as environment variables into the script exactly as defined (i.e. you can get by $parameter_name).\n\n\nIn the MODIFY scripts, the INSTANTIATE parameters are still available but plus there are environment variables that come from other VNF sources, where they are specified in the provides field. \nThese kind of parameters are defined in the \nrequires\n fields (of the VNF target) and the VNFDependency\u2192parameters fields (of the NSD), and are then available as $\ntype_of_vnf_source\n_\nname_of_parameter\n (in the VNF target).\n\n\nNOTE\n: \nthe scripts in the CONFIGURE lifecycle event need to start with the type of the source VNF followed by _ and the name of the script (i.e. server_configure.sh)\n\n\nVMs termination\n\n\nAs for VMs deployment, VMs termination is done by the NFVO. Specific scripts can be run before termination by putting them under the TERMINATE lifecycle event.\n\n\nLaunch the Generic VNFM\n\n\nTo launch the Generic VNFM, execute the following command:\n\n\n$ cd \ngeneric directory\n\n$ ./generic.sh start\n\n\n\n\nThe Generic VNFM can handle more than one VNF (in parallel) of the same or different type, so that you need to start only one Generic VNFM.\n\n\nEXAMPLE WITH DEPENDENCY AND SCRIPTS\n\n\nLet's see a simple example with two VNFs: vnf-server and vnf-database.\nThe vnf-server needs the ip of the vnf-database to be able to connect properly. The following figure shows the source (vnf-database), the target (vnf-server)\nand the dependency (IP).\n\n\n\n\nINSTANTIATE scripts\n\n\nTo start the VNFs we'll have two scripts \ninstantiate-vnf-server.sh\n and \ninstantiate-vnf-database.sh\n (more scripts are possible). Here an example of the instantiate-vnf-server.sh script:\n\n\n#!/bin/bash\n\necho \nINSTANTIATIATION of the VNF server\n\necho \nThe following parameters are available:\n\necho \nThe answer to everything is.. ${ANSWER_TO_EVERYTHING}\n\n\n# ... Add the code to start the vnf_server ...\n\n\n\n\nMODIFY script\n\n\nAfter the instantiation of the vnf-server we would configure it with the following \ndatabase_connectToDb.sh\n script:\n\n\n#!/bin/bash\n\necho \nThis is the ip of the vnf-database: ${database_private}\n\n# ... Add the code to connect to the vnf-database with the ip: ${database_private1} ...\n\n\n\n\n\nNote1\n: \"database\" is the type of the vnf-database, private is the name of the network.\n\n\nNote2\n: All the scripts need to be in a repository or in the vnf package (see the vnf package structure \nhere\n).\n\n\nIn order to deploy the VNFs we have to create both the VNF descriptor: \nvnf-database-descriptor.json\n and \nvnf-server-descriptor.json\n. Below we'll be showed the most relevant part of them:\n\n\nvnf-database-descriptor.json\n\n\n{\n    \nname\n:\nvnf-database\n,\n    \ntype\n:\ndatabase\n,\n    \nendpoint\n:\ngeneric\n,\n    ...\n    \nlifecycle_event\n:[\n        {\n            \nevent\n:\nINSTANTIATE\n,\n            \nlifecycle_events\n:[\n                \ninstantiate-vnf-database.sh\n\n            ]\n        }\n    ],\n    ...\n}\n\n\n\n\nNote:\n to use the Generic VNFM for managing a VNF just set \"generic\" in the endpoint field.\n\n\nvnf-server-descriptor.json\n\n\n{\n    \nname\n:\nvnf-server\n,\n    \ntype\n:\nserver\n,\n    \nendpoint\n:\ngeneric\n,\n    ...\n    \nconfigurations\n:{\n            \nname\n:\nconfig_name\n,\n            \nconfigurationParameters\n:[\n            {\n                \nconfKey\n:\nANSWER_TO_EVERYTHING\n,\n                \nvalue\n:\n42\n\n            }\n            ]\n    },\n    ...\n    \nlifecycle_event\n:[\n        {\n            \nevent\n:\nINSTANTIATE\n,\n            \nlifecycle_events\n:[\n                \ninstantiate-vnf-server.sh\n\n            ]\n        },\n        {\n            \nevent\n:\nCONFIGURE\n,\n            \nlifecycle_events\n:[\n                \ndatabase_connectToDb.sh\n\n            ]\n        }\n    ],\n    ...\n}\n\n\n\n\nThe result network service descriptor shall include both the vnf descriptors above and the dependency:\n\n\n{\n    \nname\n:\nsimple-nsd\n,\n    \nvnfd\n:[\n        {\n            \nid\n:\n29d918b9-6245-4dc4-abc6-b7dd6e84f2c1\n\n        },\n        {\n            \nid\n:\n87820607-4048-4fad-b02b-dbcab8bb5c1c\n\n        }\n    ],\n    \nvld\n:[\n        {\n            \nname\n:\nprivate\n\n        }\n    ],\n    \nvnf_dependency\n:[\n        {\n            \nsource\n : {\n                \nname\n: \nvnf-database\n\n            },\n            \ntarget\n:{\n                \nname\n: \nvnf-server\n\n            },\n            \nparameters\n:[\n                \nprivate\n\n            ]\n        }\n    ]\n}\n\n\n\n\nSee the complete tutorial \u2192 \nVNFPackage tutorial\n.\n\n\n\n\n\n\n\n\n\n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Generic VNFM"
        }, 
        {
            "location": "/vnfm-generic/#vnfmanager-generic", 
            "text": "The Generic VNFManager is an implementation following the  ETSI MANO  specifications. For that reason it is highly tied to the EMS.\nThis VNFM may be assigned the management of a single VNF instance, or the management of multiple VNF instances of the same type or of different types.  The Generic VNFManager handles communication with the NFVO and with EMS. The communication NFVO \u2194 VNFM \u2194 EMS is done using the  Stomp  protocol over ActiveMQ.    The communication between the NFVO and Generic VNFManager:   The communication between the Generic VNFManager and EMS:   As you can see, the Generic VNFM sends commands to the EMS, which is running in the VM. Then the EMS executes the commands (scripts) locally in the VNFC.  Please note that the EMS executes those scripts as root user .\nThe following sequence diagram explains the communication messages.   The Generic VNFManager is supposed to be used for any type of VNF that follows some conventions regarding:   VMs deployment  Script execution costraints  VMs termination   VMs deployment  Accordingly to the  ETSI MANO B.3  the VNF instantiation flows can be done in two ways:   With resource allocation done by NFVO  With resource allocation done by VNF Manager   The Generic VNFM follows the first approach. In the first approach two messages will be sent to the NFVO:    GRANT_OPERATION message : check if the resources are available on the selected PoP. If the GRANT_OPERATION message is returned, then there are enough resources, otherwise an ERROR message will be sent. After the GRANT_OPERATION message it is possible to send the ALLOCATE_RESOURCE message.      ALLOCATE_RESOURCE message : This message ask the NFVO to create all the resources and then, if no errors occurred, the ALLOCATE_RESOURCE message will be returned to the VNFManager. Only the VNFMs which follow the first approach need to send this message.    After that point the VMs are created and  the VNF record is filled with values , such as ips, that can be found directly in the VirtualNetworkFunctionRecord\u2192VirtualDeploymentUnit\u2192VNFCInstance object.  Script Execution Costraints  For each operation of the VNF Lifecycle Management interface, the VNFManager sends scripts to the EMS which executes them locally in the VMs.  Note : The scripts come from the VNFPackage which you need to create (see  VNFPackage documentation ).  The ordering of this scripts is defined in the NetworkServiceDescriptor from which the NetworkServiceRecord was created, in particular into the NetworkServiceDescriptor\u2192VirtualNetworkFunctionDescriptor\u2192LifecycleEvents.\nHere an example (to make it more readable it is shown only the  VNF lifecycle event  part):  {// NSD\n  ...\n  {// VNFD\n    ...\n     lifecycle_event :[\n        {\n             event : INSTANTIATE ,\n             lifecycle_events :[\n                 install.sh \n            ]\n        },\n        {\n             event : CONFIGURE ,\n             lifecycle_events :[\n                 server_configure.sh \n            ]\n        },\n        {\n             event : START ,\n             lifecycle_events :[\n                  server_start.sh \n            ]\n        },\n        {\n             event : TERMINATE ,\n             lifecycle_events :[\n                  server_terminate.sh \n            ]\n        }\n    ],\n    ...\n  }\n  ...\n}  In the following table is described for each  VNF lifecycle event  when the scripts are executed.     VNF Lifecycle event  When scripts are executed      INSTANTIATE  During the instantiation of the corresponding VNF    CONFIGURE  After the instantiation. Useful if the VNF depends on other VNFs, because we can get parameters provided by them (e.g. IP). The parameters are available as environment variables (see later).    START  After the instantiation or configuration (It depends whether the event CONFIGURE specified).    TERMINATE  During the termination of the corresponding VNF     The available parameters are defined in the VirtualNetworkFunctionDescriptor fields:   provides : it contains the VMs parameters which will be available after the instantiation (e.g. IP) for other VNFs.  configurations : it contains specific parameters which you want to use in the scripts.   In the INSTANTIATE scripts, the parameters defined in these two fields are then available as environment variables into the script exactly as defined (i.e. you can get by $parameter_name).  In the MODIFY scripts, the INSTANTIATE parameters are still available but plus there are environment variables that come from other VNF sources, where they are specified in the provides field. \nThese kind of parameters are defined in the  requires  fields (of the VNF target) and the VNFDependency\u2192parameters fields (of the NSD), and are then available as $ type_of_vnf_source _ name_of_parameter  (in the VNF target).  NOTE :  the scripts in the CONFIGURE lifecycle event need to start with the type of the source VNF followed by _ and the name of the script (i.e. server_configure.sh)  VMs termination  As for VMs deployment, VMs termination is done by the NFVO. Specific scripts can be run before termination by putting them under the TERMINATE lifecycle event.", 
            "title": "VNFManager Generic"
        }, 
        {
            "location": "/vnfm-generic/#launch-the-generic-vnfm", 
            "text": "To launch the Generic VNFM, execute the following command:  $ cd  generic directory \n$ ./generic.sh start  The Generic VNFM can handle more than one VNF (in parallel) of the same or different type, so that you need to start only one Generic VNFM.", 
            "title": "Launch the Generic VNFM"
        }, 
        {
            "location": "/vnfm-generic/#example-with-dependency-and-scripts", 
            "text": "Let's see a simple example with two VNFs: vnf-server and vnf-database.\nThe vnf-server needs the ip of the vnf-database to be able to connect properly. The following figure shows the source (vnf-database), the target (vnf-server)\nand the dependency (IP).   INSTANTIATE scripts  To start the VNFs we'll have two scripts  instantiate-vnf-server.sh  and  instantiate-vnf-database.sh  (more scripts are possible). Here an example of the instantiate-vnf-server.sh script:  #!/bin/bash\n\necho  INSTANTIATIATION of the VNF server \necho  The following parameters are available: \necho  The answer to everything is.. ${ANSWER_TO_EVERYTHING} \n\n# ... Add the code to start the vnf_server ...  MODIFY script  After the instantiation of the vnf-server we would configure it with the following  database_connectToDb.sh  script:  #!/bin/bash\n\necho  This is the ip of the vnf-database: ${database_private} \n# ... Add the code to connect to the vnf-database with the ip: ${database_private1} ...  Note1 : \"database\" is the type of the vnf-database, private is the name of the network.  Note2 : All the scripts need to be in a repository or in the vnf package (see the vnf package structure  here ).  In order to deploy the VNFs we have to create both the VNF descriptor:  vnf-database-descriptor.json  and  vnf-server-descriptor.json . Below we'll be showed the most relevant part of them:  vnf-database-descriptor.json  {\n     name : vnf-database ,\n     type : database ,\n     endpoint : generic ,\n    ...\n     lifecycle_event :[\n        {\n             event : INSTANTIATE ,\n             lifecycle_events :[\n                 instantiate-vnf-database.sh \n            ]\n        }\n    ],\n    ...\n}  Note:  to use the Generic VNFM for managing a VNF just set \"generic\" in the endpoint field.  vnf-server-descriptor.json  {\n     name : vnf-server ,\n     type : server ,\n     endpoint : generic ,\n    ...\n     configurations :{\n             name : config_name ,\n             configurationParameters :[\n            {\n                 confKey : ANSWER_TO_EVERYTHING ,\n                 value : 42 \n            }\n            ]\n    },\n    ...\n     lifecycle_event :[\n        {\n             event : INSTANTIATE ,\n             lifecycle_events :[\n                 instantiate-vnf-server.sh \n            ]\n        },\n        {\n             event : CONFIGURE ,\n             lifecycle_events :[\n                 database_connectToDb.sh \n            ]\n        }\n    ],\n    ...\n}  The result network service descriptor shall include both the vnf descriptors above and the dependency:  {\n     name : simple-nsd ,\n     vnfd :[\n        {\n             id : 29d918b9-6245-4dc4-abc6-b7dd6e84f2c1 \n        },\n        {\n             id : 87820607-4048-4fad-b02b-dbcab8bb5c1c \n        }\n    ],\n     vld :[\n        {\n             name : private \n        }\n    ],\n     vnf_dependency :[\n        {\n             source  : {\n                 name :  vnf-database \n            },\n             target :{\n                 name :  vnf-server \n            },\n             parameters :[\n                 private \n            ]\n        }\n    ]\n}  See the complete tutorial \u2192  VNFPackage tutorial .    \n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "EXAMPLE WITH DEPENDENCY AND SCRIPTS"
        }, 
        {
            "location": "/vnfm-how-to-write/", 
            "text": "How to write a VNFManager\n\n\nThis section is going to describe how to write your own VNFManager by using any vnfm-sdk.\nMoreover, the vnfm-sdk contains all the things you may need for the development of the VNFManager of your choice as well.\n\n\nThe vnfm-sdk provides the following things:\n\n\n\n\nmultiple \nvnfm-sdks\n where you can choose your preferred type of communication\n\n\nCatalogue, shared with the NFVO containing all entities\n\n\nVNFMHelper\n for providing some methods out of the box\n\n\n\n\nRequirements\n\n\nBefore you can start with developing your own VNFManager you need to prepare your programming environment by installing/configuring the following requirements:\n\n\n\n\nJDK 7 (\ninstallation\n)\n\n\nGradle (\ninstallation\n)\n\n\n\n\nDevelop your own VNFManager\n\n\nThis part is going to describe the steps you need to do to develop your own VNFManager with the help of any vnfm-sdk.\n\n\nThe practical parts of implementing a basic VNFManager will focus on the usage of a specific vnfm-sdk, namely the vnfm-sdk-jms.\n\n\nPreparations\n\n\nThis section describes the initial steps for creating the project structure and configuring essential files for developing your own VNFManager.\nThis can be done in two ways.\nEither you may use your favorite IDE or you may do everything manually via the command line.\n\n\nOnce this is done, you can start implementing your VNFManager by using different communication models, the catalogue and several helpers.\n\n\nUsing your favorite IDE\n\n\nIn the following we will create the project and setup the configuration files by using your favorite IDE.\nSo first of all, start your IDE and go to the next step.\nAll the details base on the usage of \nIntelliJIdea\n.\n\n\nCreate a new project\n\n\nOnce you have started the IDE, click on File -\n New -\n Project...\n\n\nIn this dialog click on Gradle on the left and select java in the main properties window in the middle.\n\n\n\n\nThen click on next to go to the next window.\n\n\nIn the next dialog you need to define the GroupId, ArtifactId and the Version.\nMore information on the specific meaning can be found \nhere\n.\n\n\n\n\nContinue with the next dialog.\n\n\nIn this dialog you need to specify which gradle you want to use.\nIt is recommend to use the default gradle wrapper.\nAdditionally you can enable the auto-import.\n\n\n\n\nContinue with the next dialog by clicking on Next.\n\n\nIn the last dialog, you need to define the project name and the project location.\n\n\n\n\nOnce this is done you can click on Finish and continue with creating the Main Class.\n\n\nCreate the Main Class\n\n\nAfterwards, you need to create the Main Class of the VNFManager which will be started in the end.\nFor doing so, right click on the root folder my-vnfm, then click on New -\n Directory and insert what is show below.\n\n\n\n\nClick on OK to continue.\n\n\nAdditionally you need to create a new package.\nThis is done by a right-click on the previously created directory java.\nClick on New -\n Package.\nHere you can define the package name.\n\n\n\n\nFinally you can create your Main Class by clicking (right click) on the previously created package and click on New -\n Java Class.\n\n\n\n\nOnce you did all these steps, the initial project structure is created.\nWhat we miss right now is the configuration of the gradle files to define and fetch dependencies we need for implementing the VNFManager.\nThis is described in later sections.\n\n\nCreate the properties files\n\n\nThe properties files are used to define several parameters you need at runtime.\nSo just create the following file structure.\n\n\nDo a right-click on the main folder located in the src folder.\nClick on New -\n Directory and create a new folder with the name resources.\n\n\nDo again a right-click on the newly created folder resources and click on New -\n File.\nThis you need to do two times.\nThe first file is called application.properties and the second one is called conf.properties.\n\n\nWhat these files should contain is explained \nhere\n.\n\n\nUsing the command line\n\n\nThis section refers to the developers which don't like to use any IDE.\nBy not using any IDE we need to create all the folders and configuration files manually.\nSo we start with creating the project structure, the Main Class, initializing the gradle wrapper and according configuration files.\n\n\nCreate project folder\n\n\nFirst of all you need to create a new directory for your VNFManager.\nHere we call the new VNFManager my-vnfm.\nSo this can be replaced by whatever you want.\n\n\n$ mkdir my-vnfm\n\n\n\n\nCreate the Main Class\n\n\nThe Main class is the most important class you need to consider.\nHere you implement your main method and also methods you need to have for your VNFManager.\nFurther explanations are done in the according sections.\nThis is only for creating a proper file structure.\nSo execute the following commands to create the Main class in a proper folder and package structure.\n\n\nFirst, you need to create the folders and package by executing the following command in your root folder of the project.\n\n\n$ mkdir -p src/main/java/org/openbaton/vnfm\n\n\n\n\nThis creates the java folder src/main/java with the proposed package name org.openbaton.vnfm.\n\n\nIn the next step you create the Main Class called MyVNFM in this case.\n\n\n$ vim /src/main/java/org/openbaton/vnfm/MyVNFM.java\n\n\n\n\nAt this point you create only the basic Java Class used later as the Main Class for implementing your VNFManager.\nThe newly created Java Class should contain the following lines for now.\n\n\npackage org.openbaton.vnfm;\n\npublic class MyVNFM {\n}\n\n\n\n\nIf you have chosen a different package name you need to replace it as well at this point.\nOnce this is done, you need to initialize the gradle wrapper and configuring according files.\n\n\nThe Build.Gradle file\n\n\nFirst you need to create the build.gradle file by executing the following command from your root project folder.\n\n\n$ vim build.gradle\n\n\n\n\nThis gradle configuration file needs to contain initially the following lines.\n\n\nbuildscript {\n    dependencies {\n        classpath(\norg.springframework.boot:spring-boot-gradle-plugin:1.2.6.RELEASE\n)\n    }\n}\ngroup 'your.group'\nversion '1.0-SNAPSHOT'\n\napply plugin: 'java'\napply plugin: 'spring-boot'\napply plugin: 'maven'\n\n\n\n\nThe second gradle configuration is called settings.gradle.\nThis file contains only the project name.\nSo create a new file called settings.gradle in your root folder.\n\n\n$ vim settings.gradle\n\n\n\n\nAfterwards you need to add the following line containing your project name.\nIn our case my-vnfm.\n\n\nrootProject.name = 'my-vnfm'\n\n\n\n\nAfterwards go back to the root folder and run the following command to create automatically the gradle wrapper which is used for code management and compilation.\nFor more information on how to use the gradle wrapper have a look at the gradle wrapper documentation \nhere\n.\n\n\n$ gradle wrapper --gradle-version 2.4\n\n\n\n\nOnce you did all these steps, the initial project structure is created.\nWhat we miss right now is the configuration of the gradle files to define and fetch dependencies we need for implementing the VNFManager.\nThis is described in later sections.\n\n\nCreate the properties files\n\n\nThe properties files are used to define several parameters you need at runtime.\nSo just create the following file structure by executing the following commands.\n\n\n$ mkdir src/main/resources\n\n\n\n\nNow you need to create two new files by running both commands you can find in the following\n\n\n$ touch src/main/resources/application.properties\n$ touch src/main/resources/conf.properties\n\n\n\n\nWhat these files should contain is explained \nhere\n.\n\n\nConfigure Gradle\n\n\nFinally you need to extend your build.gradle for announcing the Main Class, plugins to apply and repositories to use.\nSo open the build.gradle an add missing line so that the file contains the following line.\n\n\n//...\n\nbootRepackage {\n    mainClass = 'org.openbaton.vnfm.MyVNFM'\n}\n\n//...\n\n\n\n\nTake care about the configuration of the mainClass.\nIf the name or package of your mainClass is different, you need to replace it here as well.\n\n\nProperty files\n\n\nThe previously created properties files are used to define several things.\nThey are located in src/main/resources and are called application.properties and conf.properties.\n\n\nThe \napplication.properties\n contains parameters for setting up all log levels and the configuration for ActiveMQ. This file is useful for configuring the springframework (see \nSpring Boot configuration file\n). This file can contain the following lines.\n\n\nlogging.level.org.springframework=INFO\nlogging.level.org.hibernate=INFO\nlogging.level.org.jclouds=INFO\n\nlogging.level.org.apache.activemq = WARN\nlogging.level.org.openbaton = DEBUG\n\n#### activeMQ\nspring.activemq.broker-url=tcp://localhost:61616\nspring.activemq.user=admin\nspring.activemq.password=admin\n\n\n\n\nIf you want to change log levels or the ActiveMQ access information you need to adapt it here. Please note that if the VNFManager is running in the same machine of the activeMQ broker, this file is not needed.\n\n\nNOTE\n: \nIf your VNFManager is running on a different machine than the activemq broker, you need to change the \nspring.activemq.broker-url\n accordingly with the ip:port of the activemq broker.\n\n\nThe \nconf.properties\n is also a very important configuration file.\nHere you need to define the type and endpoint of your VNFManager that is later used for registering on the NFVO.\nFurthermore, you can define your own parameters which can be used at runtime for whatever you want.\nSo this file has to contain at least the type and endpoint.\nAdditionally, it is defined the folder where the vim-plugins are located.\nIn this case the file should contain the following lines.\n\n\ntype=my-vnfm\nendpoint=my-vnfm-endpoint\n\nallocate = true\nconcurrency = 15\ntransacted = false\n\n#### Additionally\nvim-plugin-dir = ./plugins\n\n\n\n\nWhere the parameters mean:\n\n\n\n\n\n\n\n\nParams\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\ntype\n\n\nThe type of VNF you are going to handle\n\n\n\n\n\n\nendpoint\n\n\nThe endpoint used for requesting this VNFManager\n\n\n\n\n\n\nallocate\n\n\ntrue if the NFVO will ALLOCATE_RESOURCES, false if the VNFManager will do\n\n\n\n\n\n\nconcurrency\n\n\nThe number of concurrent Receiver (only for vnfm-sdk-jms)\n\n\n\n\n\n\ntransacted\n\n\nWhenever the JMS receiver method shoud be transacted, this allows the message to be resent in case of exception VNFManager side (only for vnfm-sdk-jms)\n\n\n\n\n\n\n\n\nChoose a vnfm-sdk\n\n\nBefore you can start with the implementation you need to select the type of communication you want to use for the communication between the Orchestrator (NFVO) and the VNFManager.\nEither you can use the vnfm-sdk-jms for using the \nJava Message Service (JMS)\n or the vnfm-sdk-rest for using the \nReST\n interface.\nHowever, your choice doesn't effect the upcoming implementation, because the communication itself is done automatically in the background.\nBut have in mind that both libraries depend on \nSpringBoot\n.\nSo, if you want to avoid this dependency, a third option might be: just use the simple vnfm-sdk artifact.\nBy using the simple vnfm-sdk you need to take care about all the communication between NFVO and VNFManager by yourself.\n\n\nOnce you have imported one of the vnfm-sdks you will have access to all the model classes and the vnfm-sdk classes needed to implement a VNFManager.\n\n\nThe following section shows you how to import the vnfm-sdk-jms, representative for all the other opportunities.\n\n\nImport a vnfm-sdk\n\n\nThis section shows how to import and configure your VNFManager to make use of the vnfm-sdk-jms.\n\n\nFor gathering the vnfm-sdk-jms library you need to import the libraries by adding the missing lines to your build.gradle:\n\n\n//...\n\ndependencies {\n    compile 'org.hibernate:hibernate-core:4.3.10.Final'\n    compile 'org.openbaton:vnfm-sdk-jms:0.7'\n}\n\n//...\n\n\n\n\nNote\n To make use of the vnfm-sdk-rest you need to change 'vnfm-sdk-jms' to 'vnfm-sdk-rest' only.\n\n\nSo the final build.gradle file results like:\n\n\nbuildscript {\n    dependencies {\n        classpath(\norg.springframework.boot:spring-boot-gradle-plugin:1.2.6.RELEASE\n)\n    }\n}\n\napply plugin: 'spring-boot'\napply plugin: 'java'\napply plugin: 'maven'\n\nrepositories {\n    mavenCentral()\n    maven {\n        url \nhttp://193.175.132.176:8081/nexus/content/groups/public\n\n    }\n}\n\ndependencies {\n    compile 'org.openbaton:vnfm-sdk-jms:0.7'\n    compile 'org.hibernate:hibernate-core:4.3.10.Final'\n}\n\ngroup = 'your.group'\nversion = 1.0-SNAPSHOT\n\n\n\n\nOnce you did this, you need to trigger the gradle build process by running the following command via the command line in your project's root folder.\n\n\n$ ./gradlew build\n\n\n\n\nThis will fetch all the dependencies defined in the build.gradle and gives you access to all the Classes you need.\nYou can also do this by using the IDE by running the corresponding gradle task.\n\n\nImplementation of the VNFManager\n\n\nThis section is going to describe the implementation of a basic VNFManager by using the vnfm-sdk-jms.\nIn the end, the VNFManager will be able to allocate and terminate resources by using its own openstack-plugin.\n\n\nSo first of all you need to define the main method used for starting your VNFManager.\nSo add the following to your Main Class that it looks as follows:\n\n\npackage org.openbaton.vnfm;\n\npublic class MyVNFM {\n\n    public static void main(String[] args){\n        SpringApplication.run(MyVNFM.class);\n    }\n}\n\n\n\n\nAfterwards you need to extend your Main Class (in this case MyVNFM) with the \nAbstractVnfmSpringJMS\n.\n\n\nThe \nAbstractVnfmSpringJMS\n takes care of all the configuration you need to register/unregister the VNFManager to the NFVO and handles incoming messages.\nWhereas the \nAbstractVnfm\n, extended by the \nAbstractVnfmSpringJMS\n, is independent of the type of communication.\nThis means more in detail that the \nAbstractVnfm\n processes the incoming messages and executes the right method depending on the defined Action inside the message.\nMoreover, it is responsible for loading predefined configuration files, setting up the VNFManager itself, creating the VNFR (based on the VNFD received in the first step) and doing essential parts like requesting the NFVO for granting operations or deciding who is responsible for allocate resources.\n\n\nOnce you extended your VNFMManger, you need to implement all the methods coming from the extension of \nAbstractVnfmSpringJMS\n as shown below:\n\n\npackage org.openbaton.vnfm;\n\nimport org.openbaton.catalogue.mano.record.VNFRecordDependency;\nimport org.openbaton.catalogue.mano.record.VirtualNetworkFunctionRecord;\nimport org.openbaton.common.vnfm_sdk.VnfmHelper;\nimport org.openbaton.common.vnfm_sdk.jms.AbstractVnfmSpringJMS;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.SpringApplication;\n\npublic class MyVNFM extends AbstractVnfmSpringJMS {\n\n    @Autowired\n    private VnfmHelper vnfmHelper;\n\n    /**\n     * This operation allows creating a VNF instance.\n     * @param virtualNetworkFunctionRecord\n     * @param scripts\n     */\n    @Override\n    public VirtualNetworkFunctionRecord instantiate(VirtualNetworkFunctionRecord virtualNetworkFunctionRecord, Object scripts) throws Exception {\n        return virtualNetworkFunctionRecord;\n    }\n\n    /**\n     * This operation allows retrieving\n     * VNF instance state and attributes.\n     */\n    @Override\n    public void query() {\n\n    }\n\n    /**\n     * This operation allows scaling\n     * (out/in, up/down) a VNF instance.\n     */\n    @Override\n    public void scale() {\n\n    }\n\n    /**\n     * This operation allows verifying if\n     * the VNF instantiation is possible.\n     */\n    @Override\n    public void checkInstantiationFeasibility() {\n\n    }\n\n    /**\n     * This operation allows verifying if\n     * the VNF instantiation is possible.\n     */\n    @Override\n    public void heal() {\n\n    }\n\n    /**\n     * This operation allows applying a minor/limited\n     * software update (e.g. patch) to a VNF instance.\n     */\n    @Override\n    public void updateSoftware() {\n\n    }\n\n    /**\n     * This operation allows making structural changes\n     * (e.g. configuration, topology, behavior,\n     * redundancy model) to a VNF instance.\n     * @param virtualNetworkFunctionRecord\n     * @param dependency\n     */\n    @Override\n    public VirtualNetworkFunctionRecord modify(VirtualNetworkFunctionRecord virtualNetworkFunctionRecord, VNFRecordDependency dependency) throws Exception {\n        return virtualNetworkFunctionRecord;\n    }\n\n    /**\n     * This operation allows deploying a new\n     * software release to a VNF instance.\n     */\n    @Override\n    public void upgradeSoftware() {\n\n    }\n\n    /**\n     * This operation allows terminating gracefully\n     * or forcefully a previously created VNF instance.\n     * @param virtualNetworkFunctionRecord\n     */\n    @Override\n    public VirtualNetworkFunctionRecord terminate(VirtualNetworkFunctionRecord virtualNetworkFunctionRecord) throws Exception{\n        return virtualNetworkFunctionRecord;\n    }\n\n    @Override\n    protected void checkEmsStarted(String hostname) throws RuntimeException {\n\n    }\n\n    @Override\n    public VirtualNetworkFunctionRecord start(VirtualNetworkFunctionRecord virtualNetworkFunctionRecord) throws Exception {\n        return virtualNetworkFunctionRecord;\n    }\n\n    @Override\n    public VirtualNetworkFunctionRecord configure(VirtualNetworkFunctionRecord virtualNetworkFunctionRecord) throws Exception {\n        return virtualNetworkFunctionRecord;\n    }\n\n    /**\n     * This operation allows providing notifications on state changes\n     * of a VNF instance, related to the VNF Lifecycle.\n     */\n    @Override\n    public void NotifyChange() {\n\n    }\n\n    public static void main(String[] args){\n        SpringApplication.run(MyVNFM.class);\n    }\n}\n\n\n\n\nNow you can implement whatever you want. If the VirtualNetworkFunctionRecord is returned, it will go back directly to the NFVO.\n\n\nOne of the methods that can be overwritten is the \nfillSpecificParameters\n. This method is important when you have specified some \"provides\" in your VNFD, in facts you can fill them in this method and make them available afterwards to the scripts (see \nHow to use the parameters\n). \n\n\nAn example of allocating and terminating resource by using a plugin can be found \nhere\n and \nhere\n.\n\n\nNote\n If you use vnfm-sdk-jms or vnfm-sdk-rest \nthe VNFManager main class needs to be stateless\n since it can (will) run each method potentially in parallel.\nFor what concerns vnfm-sdk-jms, even setting concurrency to 1, will not ensure to have always the same instance of the class.\n\n\nUsing the VnfmHelper\n\n\nAdditionally you can autowire the VnfmHelper to make use of several helper methods that are very useful.\nIn this case your VNFManager should look like this:\n\n\npackage org.openbaton.vnfm;\n\nimport org.springframework.beans.factory.annotation.Autowired;\n\npublic class MyVNFM extends AbstractVnfmSpringJMS {\n\n    @Autowired\n    private VnfmHelper vnfmHelper;\n\n    [...]\n}\n\n\n\n\nThe vnfmHelper helps with some methods out of the box:\n\n\npackage org.openbaton.common.vnfm_sdk;\n\nimport org.openbaton.catalogue.nfvo.messages.Interfaces.NFVMessage;\n\npublic abstract class VnfmHelper {\n\n    /**\n     * This operation sends a NFVMessage\n     * to the NFVO and doesn't wait for answer.\n     * @param nfvMessage\n     */\n    public abstract void sendToNfvo(NFVMessage nfvMessage);\n\n    /**\n     * This operation send a NFVMessage\n     * to the NFVO and waits for the answer.\n     * @param nfvMessage\n     */\n    public abstract NFVMessage sendAndReceive(NFVMessage nfvMessage) throws Exception;\n}\n\n\n\n\nAt the moment, the main purpose of the VnfmHelper is to send messages to the NFVO and wait for the answer if needed.\n\n\nNote\n This class needs to be implemented in case you want to use only the vnfm-sdk and must be provided to the AbstarctVnfm.\n\n\nUsing plugins\n\n\nThis section describes the initialization and usage of plugins.\nTherefore, you need to do several things:\n\n\n\n\nCreate a Registry\n\n\nStart the plugins\n\n\nConnect an according VIM to the plugin\n\n\n\n\nNote\n If you want to use plugins, you need to fetch also the interfaces and VIM implementations by adding the following lines to your build.gradle dependencies\n\n\ncompile 'org.openbaton:vim-int:0.7'\ncompile 'org.openbaton:vim-impl:0.7'\n\n\n\n\nAfter that you need to rebuild your project for fetching the dependencies automatically.\n\n\nNow you can use the ResourceManagement interface.\nIn the end it should look like the following:\n\n\npackage org.openbaton.vnfm;\n\nimport org.openbaton.nfvo.vim_interfaces.resource_management.ResourceManagement;\nimport org.springframework.context.ConfigurableApplicationContext;\nimport org.springframework.beans.factory.annotation.Autowired;\n\nimport org.openbaton.plugin.utils.PluginStartup;\nimport java.io.IOException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\n\npublic class MyVNFM extends AbstractVnfmSpringJMS {\n\n    @Autowired\n    private ConfigurableApplicationContext context;\n\n    private ResourceManagement resourceManagement;\n\n    [...]\n\n    @Override\n    protected void setup() {\n        super.setup();\n        try {\n            int registryport = 19345;\n            Registry registry = LocateRegistry.createRegistry(registryport);\n            PluginStartup.startPluginRecursive(\n./plugins\n, true, \nlocalhost\n, \n + registryport);\n        } catch (IOException e) {\n            log.error(e.getMessage(), e);\n        }\n        resourceManagement = (ResourceManagement) context.getBean(\nopenstackVIM\n, \nopenstack\n, 19345);\n    }\n}\n\n\n\n\nThis code expects that the plugins are located in ./plugins.\nSo just copy the openstack plugin of your choice to this path.\nNow you are able to use a VIM inside your VNFManager to allocate and release resources whenever you want.\n\n\nAllocate Resources\n\n\nThe following code snippet shows how to instantiate (allocate) resources at VNFManager side with the help of the VIM.\n\n\n@Override\npublic VirtualNetworkFunctionRecord instantiate(VirtualNetworkFunctionRecord virtualNetworkFunctionRecord, Object object) {\n    log.debug(\nProcessing allocation of Resources for vnfr: \n + virtualNetworkFunctionRecord);\n    List\nFuture\nVNFCInstance\n vnfcInstances = new ArrayList\n();\n    try {\n        for (VirtualDeploymentUnit vdu : virtualNetworkFunctionRecord.getVdu()) {\n            log.debug(\nCreating \n + vdu.getVnfc().size() + \n VMs\n);\n            for (VNFComponent vnfComponent : vdu.getVnfc()) {\n                Future\nVNFCInstance\n allocate = resourceManagement.allocate(vdu, virtualNetworkFunctionRecord, vnfComponent, \n#userdata\n, vnfComponent.isExposed());\n                vnfcInstances.add(allocate);\n            }\n        }\n    } catch (VimDriverException e) {\n        log.error(e.getMessage(), e);\n        throw new RuntimeException(e.getMessage(), e);\n    } catch (VimException e) {\n        log.error(e.getMessage(), e);\n        throw new RuntimeException(e.getMessage(), e);\n    }\n    //Print ids of deployed VDUs\n    for (Future\nVNFCInstance\n vnfcInstance : vnfcInstances) {\n        try {\n            log.debug(\nCreated VNFCInstance with id: \n + vnfcInstance.get());\n        } catch (InterruptedException e) {\n            log.error(e.getMessage(), e);\n            throw new RuntimeException(e.getMessage(), e);\n        } catch (ExecutionException e) {\n            log.error(e.getMessage(), e);\n            throw new RuntimeException(e.getMessage(), e);\n        }\n    }\n    log.debug(\nAllocated all Resources for vnfr: \n + virtualNetworkFunctionRecord);\n    return virtualNetworkFunctionRecord;\n}\n\n\n\n\nNote\n Keep in mind that you need to set \nallocate\n to false in conf.properties, if you want to allocate resources on the VNFManager side.\n\n\nRelease Resources\n\n\nThe next code snippet shows an implementation of the terminate method used for releasing resources at VNFManager side.\n\n\n@Override\npublic VirtualNetworkFunctionRecord terminate(VirtualNetworkFunctionRecord virtualNetworkFunctionRecord) {\n    log.info(\nTerminating vnfr with id \n + virtualNetworkFunctionRecord.getId());\n    for (VirtualDeploymentUnit vdu : virtualNetworkFunctionRecord.getVdu()) {\n        Set\nVNFCInstance\n vnfciToRem = new HashSet\n();\n        for (VNFCInstance vnfcInstance : vdu.getVnfc_instance()) {\n            log.debug(\nReleasing resources for vdu with id \n + vdu.getId());\n            try {\n                resourceManagement.release(vnfcInstance, vdu.getVimInstance());\n            } catch (VimException e) {\n                log.error(e.getMessage(), e);\n                throw new RuntimeException(e.getMessage(), e);\n            }\n            vnfciToRem.add(vnfcInstance);\n            log.debug(\nReleased resources for vdu with id \n + vdu.getId());\n        }\n        vdu.getVnfc_instance().removeAll(vnfciToRem);\n    }\n    log.info(\nTerminated vnfr with id \n + virtualNetworkFunctionRecord.getId());\n    return virtualNetworkFunctionRecord;\n}\n\n\n\n\nStart the VNFManager\n\n\nOnce you finalized your VNFManager you can compile and start it with the following commands.\n\n\n$ ./gradlew clean build\n$ java -jar build/libs/my-vnfm.jar\n\n\n\n\nIf everything is fine, your VNFManager will register to NFVO and is able now to receive requests and process them.\n\n\n\n\n\n\n\n\n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  &amp;&amp; (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Write your own VNFM"
        }, 
        {
            "location": "/vnfm-how-to-write/#how-to-write-a-vnfmanager", 
            "text": "This section is going to describe how to write your own VNFManager by using any vnfm-sdk.\nMoreover, the vnfm-sdk contains all the things you may need for the development of the VNFManager of your choice as well.  The vnfm-sdk provides the following things:   multiple  vnfm-sdks  where you can choose your preferred type of communication  Catalogue, shared with the NFVO containing all entities  VNFMHelper  for providing some methods out of the box", 
            "title": "How to write a VNFManager"
        }, 
        {
            "location": "/vnfm-how-to-write/#requirements", 
            "text": "Before you can start with developing your own VNFManager you need to prepare your programming environment by installing/configuring the following requirements:   JDK 7 ( installation )  Gradle ( installation )", 
            "title": "Requirements"
        }, 
        {
            "location": "/vnfm-how-to-write/#develop-your-own-vnfmanager", 
            "text": "This part is going to describe the steps you need to do to develop your own VNFManager with the help of any vnfm-sdk.  The practical parts of implementing a basic VNFManager will focus on the usage of a specific vnfm-sdk, namely the vnfm-sdk-jms.  Preparations  This section describes the initial steps for creating the project structure and configuring essential files for developing your own VNFManager.\nThis can be done in two ways.\nEither you may use your favorite IDE or you may do everything manually via the command line.  Once this is done, you can start implementing your VNFManager by using different communication models, the catalogue and several helpers.  Using your favorite IDE  In the following we will create the project and setup the configuration files by using your favorite IDE.\nSo first of all, start your IDE and go to the next step.\nAll the details base on the usage of  IntelliJIdea .  Create a new project  Once you have started the IDE, click on File -  New -  Project...  In this dialog click on Gradle on the left and select java in the main properties window in the middle.   Then click on next to go to the next window.  In the next dialog you need to define the GroupId, ArtifactId and the Version.\nMore information on the specific meaning can be found  here .   Continue with the next dialog.  In this dialog you need to specify which gradle you want to use.\nIt is recommend to use the default gradle wrapper.\nAdditionally you can enable the auto-import.   Continue with the next dialog by clicking on Next.  In the last dialog, you need to define the project name and the project location.   Once this is done you can click on Finish and continue with creating the Main Class.  Create the Main Class  Afterwards, you need to create the Main Class of the VNFManager which will be started in the end.\nFor doing so, right click on the root folder my-vnfm, then click on New -  Directory and insert what is show below.   Click on OK to continue.  Additionally you need to create a new package.\nThis is done by a right-click on the previously created directory java.\nClick on New -  Package.\nHere you can define the package name.   Finally you can create your Main Class by clicking (right click) on the previously created package and click on New -  Java Class.   Once you did all these steps, the initial project structure is created.\nWhat we miss right now is the configuration of the gradle files to define and fetch dependencies we need for implementing the VNFManager.\nThis is described in later sections.  Create the properties files  The properties files are used to define several parameters you need at runtime.\nSo just create the following file structure.  Do a right-click on the main folder located in the src folder.\nClick on New -  Directory and create a new folder with the name resources.  Do again a right-click on the newly created folder resources and click on New -  File.\nThis you need to do two times.\nThe first file is called application.properties and the second one is called conf.properties.  What these files should contain is explained  here .  Using the command line  This section refers to the developers which don't like to use any IDE.\nBy not using any IDE we need to create all the folders and configuration files manually.\nSo we start with creating the project structure, the Main Class, initializing the gradle wrapper and according configuration files.  Create project folder  First of all you need to create a new directory for your VNFManager.\nHere we call the new VNFManager my-vnfm.\nSo this can be replaced by whatever you want.  $ mkdir my-vnfm  Create the Main Class  The Main class is the most important class you need to consider.\nHere you implement your main method and also methods you need to have for your VNFManager.\nFurther explanations are done in the according sections.\nThis is only for creating a proper file structure.\nSo execute the following commands to create the Main class in a proper folder and package structure.  First, you need to create the folders and package by executing the following command in your root folder of the project.  $ mkdir -p src/main/java/org/openbaton/vnfm  This creates the java folder src/main/java with the proposed package name org.openbaton.vnfm.  In the next step you create the Main Class called MyVNFM in this case.  $ vim /src/main/java/org/openbaton/vnfm/MyVNFM.java  At this point you create only the basic Java Class used later as the Main Class for implementing your VNFManager.\nThe newly created Java Class should contain the following lines for now.  package org.openbaton.vnfm;\n\npublic class MyVNFM {\n}  If you have chosen a different package name you need to replace it as well at this point.\nOnce this is done, you need to initialize the gradle wrapper and configuring according files.  The Build.Gradle file  First you need to create the build.gradle file by executing the following command from your root project folder.  $ vim build.gradle  This gradle configuration file needs to contain initially the following lines.  buildscript {\n    dependencies {\n        classpath( org.springframework.boot:spring-boot-gradle-plugin:1.2.6.RELEASE )\n    }\n}\ngroup 'your.group'\nversion '1.0-SNAPSHOT'\n\napply plugin: 'java'\napply plugin: 'spring-boot'\napply plugin: 'maven'  The second gradle configuration is called settings.gradle.\nThis file contains only the project name.\nSo create a new file called settings.gradle in your root folder.  $ vim settings.gradle  Afterwards you need to add the following line containing your project name.\nIn our case my-vnfm.  rootProject.name = 'my-vnfm'  Afterwards go back to the root folder and run the following command to create automatically the gradle wrapper which is used for code management and compilation.\nFor more information on how to use the gradle wrapper have a look at the gradle wrapper documentation  here .  $ gradle wrapper --gradle-version 2.4  Once you did all these steps, the initial project structure is created.\nWhat we miss right now is the configuration of the gradle files to define and fetch dependencies we need for implementing the VNFManager.\nThis is described in later sections.  Create the properties files  The properties files are used to define several parameters you need at runtime.\nSo just create the following file structure by executing the following commands.  $ mkdir src/main/resources  Now you need to create two new files by running both commands you can find in the following  $ touch src/main/resources/application.properties\n$ touch src/main/resources/conf.properties  What these files should contain is explained  here .  Configure Gradle  Finally you need to extend your build.gradle for announcing the Main Class, plugins to apply and repositories to use.\nSo open the build.gradle an add missing line so that the file contains the following line.  //...\n\nbootRepackage {\n    mainClass = 'org.openbaton.vnfm.MyVNFM'\n}\n\n//...  Take care about the configuration of the mainClass.\nIf the name or package of your mainClass is different, you need to replace it here as well.  Property files  The previously created properties files are used to define several things.\nThey are located in src/main/resources and are called application.properties and conf.properties.  The  application.properties  contains parameters for setting up all log levels and the configuration for ActiveMQ. This file is useful for configuring the springframework (see  Spring Boot configuration file ). This file can contain the following lines.  logging.level.org.springframework=INFO\nlogging.level.org.hibernate=INFO\nlogging.level.org.jclouds=INFO\n\nlogging.level.org.apache.activemq = WARN\nlogging.level.org.openbaton = DEBUG\n\n#### activeMQ\nspring.activemq.broker-url=tcp://localhost:61616\nspring.activemq.user=admin\nspring.activemq.password=admin  If you want to change log levels or the ActiveMQ access information you need to adapt it here. Please note that if the VNFManager is running in the same machine of the activeMQ broker, this file is not needed.  NOTE :  If your VNFManager is running on a different machine than the activemq broker, you need to change the  spring.activemq.broker-url  accordingly with the ip:port of the activemq broker.  The  conf.properties  is also a very important configuration file.\nHere you need to define the type and endpoint of your VNFManager that is later used for registering on the NFVO.\nFurthermore, you can define your own parameters which can be used at runtime for whatever you want.\nSo this file has to contain at least the type and endpoint.\nAdditionally, it is defined the folder where the vim-plugins are located.\nIn this case the file should contain the following lines.  type=my-vnfm\nendpoint=my-vnfm-endpoint\n\nallocate = true\nconcurrency = 15\ntransacted = false\n\n#### Additionally\nvim-plugin-dir = ./plugins  Where the parameters mean:     Params  Meaning      type  The type of VNF you are going to handle    endpoint  The endpoint used for requesting this VNFManager    allocate  true if the NFVO will ALLOCATE_RESOURCES, false if the VNFManager will do    concurrency  The number of concurrent Receiver (only for vnfm-sdk-jms)    transacted  Whenever the JMS receiver method shoud be transacted, this allows the message to be resent in case of exception VNFManager side (only for vnfm-sdk-jms)", 
            "title": "Develop your own VNFManager"
        }, 
        {
            "location": "/vnfm-how-to-write/#choose-a-vnfm-sdk", 
            "text": "Before you can start with the implementation you need to select the type of communication you want to use for the communication between the Orchestrator (NFVO) and the VNFManager.\nEither you can use the vnfm-sdk-jms for using the  Java Message Service (JMS)  or the vnfm-sdk-rest for using the  ReST  interface.\nHowever, your choice doesn't effect the upcoming implementation, because the communication itself is done automatically in the background.\nBut have in mind that both libraries depend on  SpringBoot .\nSo, if you want to avoid this dependency, a third option might be: just use the simple vnfm-sdk artifact.\nBy using the simple vnfm-sdk you need to take care about all the communication between NFVO and VNFManager by yourself.  Once you have imported one of the vnfm-sdks you will have access to all the model classes and the vnfm-sdk classes needed to implement a VNFManager.  The following section shows you how to import the vnfm-sdk-jms, representative for all the other opportunities.  Import a vnfm-sdk  This section shows how to import and configure your VNFManager to make use of the vnfm-sdk-jms.  For gathering the vnfm-sdk-jms library you need to import the libraries by adding the missing lines to your build.gradle:  //...\n\ndependencies {\n    compile 'org.hibernate:hibernate-core:4.3.10.Final'\n    compile 'org.openbaton:vnfm-sdk-jms:0.7'\n}\n\n//...  Note  To make use of the vnfm-sdk-rest you need to change 'vnfm-sdk-jms' to 'vnfm-sdk-rest' only.  So the final build.gradle file results like:  buildscript {\n    dependencies {\n        classpath( org.springframework.boot:spring-boot-gradle-plugin:1.2.6.RELEASE )\n    }\n}\n\napply plugin: 'spring-boot'\napply plugin: 'java'\napply plugin: 'maven'\n\nrepositories {\n    mavenCentral()\n    maven {\n        url  http://193.175.132.176:8081/nexus/content/groups/public \n    }\n}\n\ndependencies {\n    compile 'org.openbaton:vnfm-sdk-jms:0.7'\n    compile 'org.hibernate:hibernate-core:4.3.10.Final'\n}\n\ngroup = 'your.group'\nversion = 1.0-SNAPSHOT  Once you did this, you need to trigger the gradle build process by running the following command via the command line in your project's root folder.  $ ./gradlew build  This will fetch all the dependencies defined in the build.gradle and gives you access to all the Classes you need.\nYou can also do this by using the IDE by running the corresponding gradle task.", 
            "title": "Choose a vnfm-sdk"
        }, 
        {
            "location": "/vnfm-how-to-write/#implementation-of-the-vnfmanager", 
            "text": "This section is going to describe the implementation of a basic VNFManager by using the vnfm-sdk-jms.\nIn the end, the VNFManager will be able to allocate and terminate resources by using its own openstack-plugin.  So first of all you need to define the main method used for starting your VNFManager.\nSo add the following to your Main Class that it looks as follows:  package org.openbaton.vnfm;\n\npublic class MyVNFM {\n\n    public static void main(String[] args){\n        SpringApplication.run(MyVNFM.class);\n    }\n}  Afterwards you need to extend your Main Class (in this case MyVNFM) with the  AbstractVnfmSpringJMS .  The  AbstractVnfmSpringJMS  takes care of all the configuration you need to register/unregister the VNFManager to the NFVO and handles incoming messages.\nWhereas the  AbstractVnfm , extended by the  AbstractVnfmSpringJMS , is independent of the type of communication.\nThis means more in detail that the  AbstractVnfm  processes the incoming messages and executes the right method depending on the defined Action inside the message.\nMoreover, it is responsible for loading predefined configuration files, setting up the VNFManager itself, creating the VNFR (based on the VNFD received in the first step) and doing essential parts like requesting the NFVO for granting operations or deciding who is responsible for allocate resources.  Once you extended your VNFMManger, you need to implement all the methods coming from the extension of  AbstractVnfmSpringJMS  as shown below:  package org.openbaton.vnfm;\n\nimport org.openbaton.catalogue.mano.record.VNFRecordDependency;\nimport org.openbaton.catalogue.mano.record.VirtualNetworkFunctionRecord;\nimport org.openbaton.common.vnfm_sdk.VnfmHelper;\nimport org.openbaton.common.vnfm_sdk.jms.AbstractVnfmSpringJMS;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.SpringApplication;\n\npublic class MyVNFM extends AbstractVnfmSpringJMS {\n\n    @Autowired\n    private VnfmHelper vnfmHelper;\n\n    /**\n     * This operation allows creating a VNF instance.\n     * @param virtualNetworkFunctionRecord\n     * @param scripts\n     */\n    @Override\n    public VirtualNetworkFunctionRecord instantiate(VirtualNetworkFunctionRecord virtualNetworkFunctionRecord, Object scripts) throws Exception {\n        return virtualNetworkFunctionRecord;\n    }\n\n    /**\n     * This operation allows retrieving\n     * VNF instance state and attributes.\n     */\n    @Override\n    public void query() {\n\n    }\n\n    /**\n     * This operation allows scaling\n     * (out/in, up/down) a VNF instance.\n     */\n    @Override\n    public void scale() {\n\n    }\n\n    /**\n     * This operation allows verifying if\n     * the VNF instantiation is possible.\n     */\n    @Override\n    public void checkInstantiationFeasibility() {\n\n    }\n\n    /**\n     * This operation allows verifying if\n     * the VNF instantiation is possible.\n     */\n    @Override\n    public void heal() {\n\n    }\n\n    /**\n     * This operation allows applying a minor/limited\n     * software update (e.g. patch) to a VNF instance.\n     */\n    @Override\n    public void updateSoftware() {\n\n    }\n\n    /**\n     * This operation allows making structural changes\n     * (e.g. configuration, topology, behavior,\n     * redundancy model) to a VNF instance.\n     * @param virtualNetworkFunctionRecord\n     * @param dependency\n     */\n    @Override\n    public VirtualNetworkFunctionRecord modify(VirtualNetworkFunctionRecord virtualNetworkFunctionRecord, VNFRecordDependency dependency) throws Exception {\n        return virtualNetworkFunctionRecord;\n    }\n\n    /**\n     * This operation allows deploying a new\n     * software release to a VNF instance.\n     */\n    @Override\n    public void upgradeSoftware() {\n\n    }\n\n    /**\n     * This operation allows terminating gracefully\n     * or forcefully a previously created VNF instance.\n     * @param virtualNetworkFunctionRecord\n     */\n    @Override\n    public VirtualNetworkFunctionRecord terminate(VirtualNetworkFunctionRecord virtualNetworkFunctionRecord) throws Exception{\n        return virtualNetworkFunctionRecord;\n    }\n\n    @Override\n    protected void checkEmsStarted(String hostname) throws RuntimeException {\n\n    }\n\n    @Override\n    public VirtualNetworkFunctionRecord start(VirtualNetworkFunctionRecord virtualNetworkFunctionRecord) throws Exception {\n        return virtualNetworkFunctionRecord;\n    }\n\n    @Override\n    public VirtualNetworkFunctionRecord configure(VirtualNetworkFunctionRecord virtualNetworkFunctionRecord) throws Exception {\n        return virtualNetworkFunctionRecord;\n    }\n\n    /**\n     * This operation allows providing notifications on state changes\n     * of a VNF instance, related to the VNF Lifecycle.\n     */\n    @Override\n    public void NotifyChange() {\n\n    }\n\n    public static void main(String[] args){\n        SpringApplication.run(MyVNFM.class);\n    }\n}  Now you can implement whatever you want. If the VirtualNetworkFunctionRecord is returned, it will go back directly to the NFVO.  One of the methods that can be overwritten is the  fillSpecificParameters . This method is important when you have specified some \"provides\" in your VNFD, in facts you can fill them in this method and make them available afterwards to the scripts (see  How to use the parameters ).   An example of allocating and terminating resource by using a plugin can be found  here  and  here .  Note  If you use vnfm-sdk-jms or vnfm-sdk-rest  the VNFManager main class needs to be stateless  since it can (will) run each method potentially in parallel.\nFor what concerns vnfm-sdk-jms, even setting concurrency to 1, will not ensure to have always the same instance of the class.  Using the VnfmHelper  Additionally you can autowire the VnfmHelper to make use of several helper methods that are very useful.\nIn this case your VNFManager should look like this:  package org.openbaton.vnfm;\n\nimport org.springframework.beans.factory.annotation.Autowired;\n\npublic class MyVNFM extends AbstractVnfmSpringJMS {\n\n    @Autowired\n    private VnfmHelper vnfmHelper;\n\n    [...]\n}  The vnfmHelper helps with some methods out of the box:  package org.openbaton.common.vnfm_sdk;\n\nimport org.openbaton.catalogue.nfvo.messages.Interfaces.NFVMessage;\n\npublic abstract class VnfmHelper {\n\n    /**\n     * This operation sends a NFVMessage\n     * to the NFVO and doesn't wait for answer.\n     * @param nfvMessage\n     */\n    public abstract void sendToNfvo(NFVMessage nfvMessage);\n\n    /**\n     * This operation send a NFVMessage\n     * to the NFVO and waits for the answer.\n     * @param nfvMessage\n     */\n    public abstract NFVMessage sendAndReceive(NFVMessage nfvMessage) throws Exception;\n}  At the moment, the main purpose of the VnfmHelper is to send messages to the NFVO and wait for the answer if needed.  Note  This class needs to be implemented in case you want to use only the vnfm-sdk and must be provided to the AbstarctVnfm.  Using plugins  This section describes the initialization and usage of plugins.\nTherefore, you need to do several things:   Create a Registry  Start the plugins  Connect an according VIM to the plugin   Note  If you want to use plugins, you need to fetch also the interfaces and VIM implementations by adding the following lines to your build.gradle dependencies  compile 'org.openbaton:vim-int:0.7'\ncompile 'org.openbaton:vim-impl:0.7'  After that you need to rebuild your project for fetching the dependencies automatically.  Now you can use the ResourceManagement interface.\nIn the end it should look like the following:  package org.openbaton.vnfm;\n\nimport org.openbaton.nfvo.vim_interfaces.resource_management.ResourceManagement;\nimport org.springframework.context.ConfigurableApplicationContext;\nimport org.springframework.beans.factory.annotation.Autowired;\n\nimport org.openbaton.plugin.utils.PluginStartup;\nimport java.io.IOException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\n\npublic class MyVNFM extends AbstractVnfmSpringJMS {\n\n    @Autowired\n    private ConfigurableApplicationContext context;\n\n    private ResourceManagement resourceManagement;\n\n    [...]\n\n    @Override\n    protected void setup() {\n        super.setup();\n        try {\n            int registryport = 19345;\n            Registry registry = LocateRegistry.createRegistry(registryport);\n            PluginStartup.startPluginRecursive( ./plugins , true,  localhost ,   + registryport);\n        } catch (IOException e) {\n            log.error(e.getMessage(), e);\n        }\n        resourceManagement = (ResourceManagement) context.getBean( openstackVIM ,  openstack , 19345);\n    }\n}  This code expects that the plugins are located in ./plugins.\nSo just copy the openstack plugin of your choice to this path.\nNow you are able to use a VIM inside your VNFManager to allocate and release resources whenever you want.  Allocate Resources  The following code snippet shows how to instantiate (allocate) resources at VNFManager side with the help of the VIM.  @Override\npublic VirtualNetworkFunctionRecord instantiate(VirtualNetworkFunctionRecord virtualNetworkFunctionRecord, Object object) {\n    log.debug( Processing allocation of Resources for vnfr:   + virtualNetworkFunctionRecord);\n    List Future VNFCInstance  vnfcInstances = new ArrayList ();\n    try {\n        for (VirtualDeploymentUnit vdu : virtualNetworkFunctionRecord.getVdu()) {\n            log.debug( Creating   + vdu.getVnfc().size() +   VMs );\n            for (VNFComponent vnfComponent : vdu.getVnfc()) {\n                Future VNFCInstance  allocate = resourceManagement.allocate(vdu, virtualNetworkFunctionRecord, vnfComponent,  #userdata , vnfComponent.isExposed());\n                vnfcInstances.add(allocate);\n            }\n        }\n    } catch (VimDriverException e) {\n        log.error(e.getMessage(), e);\n        throw new RuntimeException(e.getMessage(), e);\n    } catch (VimException e) {\n        log.error(e.getMessage(), e);\n        throw new RuntimeException(e.getMessage(), e);\n    }\n    //Print ids of deployed VDUs\n    for (Future VNFCInstance  vnfcInstance : vnfcInstances) {\n        try {\n            log.debug( Created VNFCInstance with id:   + vnfcInstance.get());\n        } catch (InterruptedException e) {\n            log.error(e.getMessage(), e);\n            throw new RuntimeException(e.getMessage(), e);\n        } catch (ExecutionException e) {\n            log.error(e.getMessage(), e);\n            throw new RuntimeException(e.getMessage(), e);\n        }\n    }\n    log.debug( Allocated all Resources for vnfr:   + virtualNetworkFunctionRecord);\n    return virtualNetworkFunctionRecord;\n}  Note  Keep in mind that you need to set  allocate  to false in conf.properties, if you want to allocate resources on the VNFManager side.  Release Resources  The next code snippet shows an implementation of the terminate method used for releasing resources at VNFManager side.  @Override\npublic VirtualNetworkFunctionRecord terminate(VirtualNetworkFunctionRecord virtualNetworkFunctionRecord) {\n    log.info( Terminating vnfr with id   + virtualNetworkFunctionRecord.getId());\n    for (VirtualDeploymentUnit vdu : virtualNetworkFunctionRecord.getVdu()) {\n        Set VNFCInstance  vnfciToRem = new HashSet ();\n        for (VNFCInstance vnfcInstance : vdu.getVnfc_instance()) {\n            log.debug( Releasing resources for vdu with id   + vdu.getId());\n            try {\n                resourceManagement.release(vnfcInstance, vdu.getVimInstance());\n            } catch (VimException e) {\n                log.error(e.getMessage(), e);\n                throw new RuntimeException(e.getMessage(), e);\n            }\n            vnfciToRem.add(vnfcInstance);\n            log.debug( Released resources for vdu with id   + vdu.getId());\n        }\n        vdu.getVnfc_instance().removeAll(vnfciToRem);\n    }\n    log.info( Terminated vnfr with id   + virtualNetworkFunctionRecord.getId());\n    return virtualNetworkFunctionRecord;\n}  Start the VNFManager  Once you finalized your VNFManager you can compile and start it with the following commands.  $ ./gradlew clean build\n$ java -jar build/libs/my-vnfm.jar  If everything is fine, your VNFManager will register to NFVO and is able now to receive requests and process them.    \n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  &amp;&amp; (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Implementation of the VNFManager"
        }, 
        {
            "location": "/vnfm-vendor-specific/", 
            "text": "Use my VNFM\n\n\nIn this section are described the REST interfaces which allow you to integrate your VNFM with Openbaton's NFVO.\n\n\nNFVO - VNFM ReST interface\n\n\nNfvo exposes a ReST interface for the communication with the VnfManagers. The sequence diagram regarding the instantiation of a NetworkServiceRecord is shown in the following picture.\n\n\n\n\nAs shown in the picture, NFVO calls some ReST methods on the vnfm in a particular order. Then it expects some kind of back call. The list of these call exchange is described in the following sections. The ALLOCATE_RESOURCES call is not needed if the vnfm will take care of creating VMs. The communication with the EMS is particular to each VnfManagers. In order to be able to be found, the Vnfm needs to register to the NFVO. This can be done through a particular call.\n\n\n\n\n\n\n\n\nParams\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\nOrEndpoint\n\n\nthe endpoint of the NFVO (i.e. http://127.0.0.1:8080)\n\n\n\n\n\n\nVnfmEnpoint\n\n\nthe endpoint of the Vnfm. this is given while registering\n\n\n\n\n\n\n\n\nRegistration (Vnfm-Or):\n\n\npath:\n\n\nPOST \nOrEndpoint\n /admin/v1/vnfm-register\n\n\nbody:\n\n\n{\n    \ntype\n:\ndummy\n,\n    \nendpointType\n:\nREST\n,\n    \nendpoint\n:\nVnfmEndpoint\n\n}\n\n\n\n\nwhere:\n\n \ntype\n is the vnfm type you are going to handle (specified in VirtualNetowrkFunctionDescriptor \u2192 endpoint).\n \nendpointType\n is the vnfm type you are going to implement (REST or JMS).\n* \nendpoint\n is the vnfm endpoint you have chosen (basically http://\n:\n).\n\n\nInstantiate (Or-Vnfm)\n\n\npath\n\n\nPOST \nVnfmEnpoint\n\n\nbody\n\n\n{\n    \nscriptsLink\n:\nlinktogit\n, // a link to the reposritory where the links are located\n    \nscripts\n:\nscriptsfiles\n, // the scripts files coming from the vnfPackage, in case no scriptsLink is provided\n    \nvnfd\n:{  ...  }, // the VirtualNetowrkFunctionDescriptor from which a VirtualNetowrkFunctionRecord is created\n    \nvnfdf\n:{  ...  }, // the deployment flavours to be used\n    \nvlrs\n:[  ...  ], // the list of VirtualLinkRecords of the NetworkServiceRecord.\n    \nextention\n:{  \nnsr-id\n:\n...\n  }, // some info like the NetworkServiceRecord id\n    \naction\n:\nINSTANTIATE\n // the action to be executed\n}\n\n\n\n\nIn this action either the \nscriptsLink\n or the \nscripts\n fields are set. The vnfm-sdk will take care of them.\n\n\nInstantiate (Vnfm-Or)\n\n\npath\n\n\nPOST \nOrEndpoint\n /admin/v1/vnfm-core-actions\n\n\nbody\n\n\n{\n    \nvirtualNetworkFunctionRecord\n:{  ...  }, // the created VirtualNetowrkFunctionRecord\n    \naction\n:\nINSTANTIATE\n\n}\n\n\n\n\nModify (aka AddRelations) (Or-Vnfm)\n\n\npath\n\n\nPOST \nVnfmEnpoint\n\n\nbody\n\n\n{\n    \nvnfr\n:{  }, // the VirtualNetowrkFunctionRecord target of the depedendecy\n    \nvnfrd\n:{  }, // the VNFDependency containing all the source parameters needed by the scripts\n    \naction\n:\nMODIFY\n\n}\n\n\n\n\nModify (aka AddRelations) (Vnfm-Or)\n\n\npath\n\n\nPOST \nOrEndpoint\n /admin/v1/vnfm-core-actions\n\n\nbody\n\n\n{\n    \nvirtualNetworkFunctionRecord\n:{  },\n    \naction\n:\nMODIFY\n\n}\n\n\n\n\nStart (Or-Vnfm)\n\n\npath\n\n\nPOST \nVnfmEnpoint\n\n\nbody\n\n\n{\n    \nvnfr\n:{  ...  },\n    \naction\n:\nSTART\n\n}\n\n\n\n\nStart (Vnfm-Or)\n\n\npath\n\n\nPOST \nOrEndpoint\n /admin/v1/vnfm-core-actions\n\n\nbody\n\n\n{\n    \nvirtualNetworkFunctionRecord\n:{  ...  },\n    \naction\n:\nSTART\n\n}\n\n\n\n\n\n\n\n\n\n\n\n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Integrate your own VNFM"
        }, 
        {
            "location": "/vnfm-vendor-specific/#use-my-vnfm", 
            "text": "In this section are described the REST interfaces which allow you to integrate your VNFM with Openbaton's NFVO.", 
            "title": "Use my VNFM"
        }, 
        {
            "location": "/vnfm-vendor-specific/#nfvo-vnfm-rest-interface", 
            "text": "Nfvo exposes a ReST interface for the communication with the VnfManagers. The sequence diagram regarding the instantiation of a NetworkServiceRecord is shown in the following picture.   As shown in the picture, NFVO calls some ReST methods on the vnfm in a particular order. Then it expects some kind of back call. The list of these call exchange is described in the following sections. The ALLOCATE_RESOURCES call is not needed if the vnfm will take care of creating VMs. The communication with the EMS is particular to each VnfManagers. In order to be able to be found, the Vnfm needs to register to the NFVO. This can be done through a particular call.     Params  Meaning      OrEndpoint  the endpoint of the NFVO (i.e. http://127.0.0.1:8080)    VnfmEnpoint  the endpoint of the Vnfm. this is given while registering     Registration (Vnfm-Or):  path:  POST  OrEndpoint  /admin/v1/vnfm-register  body:  {\n     type : dummy ,\n     endpointType : REST ,\n     endpoint : VnfmEndpoint \n}  where:   type  is the vnfm type you are going to handle (specified in VirtualNetowrkFunctionDescriptor \u2192 endpoint).   endpointType  is the vnfm type you are going to implement (REST or JMS).\n*  endpoint  is the vnfm endpoint you have chosen (basically http:// : ).  Instantiate (Or-Vnfm)  path  POST  VnfmEnpoint  body  {\n     scriptsLink : linktogit , // a link to the reposritory where the links are located\n     scripts : scriptsfiles , // the scripts files coming from the vnfPackage, in case no scriptsLink is provided\n     vnfd :{  ...  }, // the VirtualNetowrkFunctionDescriptor from which a VirtualNetowrkFunctionRecord is created\n     vnfdf :{  ...  }, // the deployment flavours to be used\n     vlrs :[  ...  ], // the list of VirtualLinkRecords of the NetworkServiceRecord.\n     extention :{   nsr-id : ...   }, // some info like the NetworkServiceRecord id\n     action : INSTANTIATE  // the action to be executed\n}  In this action either the  scriptsLink  or the  scripts  fields are set. The vnfm-sdk will take care of them.  Instantiate (Vnfm-Or)  path  POST  OrEndpoint  /admin/v1/vnfm-core-actions  body  {\n     virtualNetworkFunctionRecord :{  ...  }, // the created VirtualNetowrkFunctionRecord\n     action : INSTANTIATE \n}  Modify (aka AddRelations) (Or-Vnfm)  path  POST  VnfmEnpoint  body  {\n     vnfr :{  }, // the VirtualNetowrkFunctionRecord target of the depedendecy\n     vnfrd :{  }, // the VNFDependency containing all the source parameters needed by the scripts\n     action : MODIFY \n}  Modify (aka AddRelations) (Vnfm-Or)  path  POST  OrEndpoint  /admin/v1/vnfm-core-actions  body  {\n     virtualNetworkFunctionRecord :{  },\n     action : MODIFY \n}  Start (Or-Vnfm)  path  POST  VnfmEnpoint  body  {\n     vnfr :{  ...  },\n     action : START \n}  Start (Vnfm-Or)  path  POST  OrEndpoint  /admin/v1/vnfm-core-actions  body  {\n     virtualNetworkFunctionRecord :{  ...  },\n     action : START \n}    \n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "NFVO - VNFM ReST interface"
        }, 
        {
            "location": "/vnfpackage/", 
            "text": "VNFPackage\n\n\nNote\n: This is the initial version of the VNFPackage and might change most probably in the next releases to improve and simplify the creation, usability and power.\n\n\nThis doc describes essential components of a VNFPackage, how to create them and how to use them after onboarding.\nTherefore, you can find a practical tutorial at the end with all the steps starting from the creation over onboarding and finally referencing it by a NSD.\n\n\nA VNFPackage is a tar-archive that contains all the information required for creating a VNF for the openbaton NFVO.\nAfter onboarding the VNFPackage on the NFVO you can use the VNF directly in the NSD by referencing the VNFD by its id.\nA VNFPackage includes the VNFD, the image, scripts and a Metadata file structured as shown in the next part.\n\n\nPackage structure\n\n\nThe VNFPackage has the following structure:\n\n\n- Metadata.yaml\n- vnfd.json\n- scripts/\n    - 1_script.sh\n    - 2_script.sh\n- image.img\n\n\n\n\nMetadata.yaml\n\n\nThe Metadata.yaml defines essential properties for the VNF. This file bases on the YAML syntax where information are stored in simple \nkey> : \nvalue> associations.\n\n\nThe example of a Metadata.yaml file below shows a basic definition of a VNFPackage.\n\n\nname: vnfPackage_name\nscripts-link: scripts_link\nimage:\n    upload: option\n    ids: list_of_ids\n    names: list_of_names\n    link: image_link\nimage-config:\n    name: image_name\n    diskFormat: disk_format\n    containerFormat: container_format\n    minCPU: min_cpu\n    minDisk: min_disk\n    minRam: min_ram\n    isPublic: is_public\n\n\n\n\nIn the following each property is explained in more detail. Please consider also the notes since some properties are optional (or even not implemented) and if they are defined, they may have more priority than other and override them therefore.\n\n\n\n\nname\n: The name defines the name of the VNFPackage itself used to store it on the database.\n\n\nscripts-link\n: This link points to a public git repository where scripts are stored that are needed to be executed for managing the lifecycle of the exposed VNF.\n\n\nNote\n Either you can define the scripts-link or put the scripts into the folder scripts/.\n    The scripts-link has a higher priority than the scripts located in the folder scripts/.\n    So if you set the scripts-link, the scripts in folder scripts/ are ignored completely.\n\n\nNote\n The scripts-link is processed by the Element Management System (EMS) in the meaning of fetching the files from that link.\n    So you need to take care about ensuring that the URL defined is available.\n\n\nNote\n Scripts are executed during different lifecycle-events.\n\n\n\n\n\n\nimage\n:\n\n\nupload\n: Here you can choose between different options (true, false, check).\n\n\ntrue: choosing this option means to upload the defined image on all the VimInstances. It does not matter if an image with the defined name exists or not.\n\n\nfalse: choosing this option means that you assume that the image (defined in the ids or names) is already present.\nIf the image does not exist, the VNFPackage onboarding will throw an exception.\nIn this case the image (if defined) will be ignored.\n\n\ncheck: this option means that the VNFPackageManagement checks first if the image is available (defined in ids or names).\nIf the image does not exist, a new one with the image defined in the VNFPackage will be created.\n\n\n\n\n\n\nids\n: The list of image ids is used to fetch the image from the corresponding VimInstance.\n    To do it, the manager iterates over all ids and checks if an image with that id exists on the VimInstance.\n    The defined ids have a higher priority than the list of names.\n    We distinguish between the following cases:\n\n\nIf it finds no image with these ids, it continues with the list of image names.\n\n\nIf it finds one image with these ids, this image will be used.\n\n\nIf it finds multiple images with the same id (should never happen) or multiple ids matching to multiple images, an exception will be thrown because it is not clear which image to use.\n\n\n\n\n\n\nnames\n: The list of image names is used to fetch the image from the corresponding VimInstance.\n    To do it, manager iterates over all names and checks if an image with that name exists on the VimInstance.\n    The list of names have a lower priority than the list of ids.\n    We distinguish between the following cases:\n\n\nIf it finds no image with that name, an exception will be thrown except you defined the upload option check.\nThen it will create a new image defined in the VNFPackage.\n\n\nIf it finds one image, this image will be used.\n\n\nIf it finds multiple images with the same name or multiple names matching to multiple images, an exception will be thrown because it is not clear which image to use.\n\n\n\n\n\n\nlink\n: This link points to an image available at this URL used to upload the image to the cloud environment.\n\n\nNote\n Either you have to define the image-link or put the image directly into the VNFPackage.\n    Otherwise a NotFoundException will be thrown and the VNFPackage will not onboard.\n    The image-link has a higher priority than the image stored in the VNFPackage directly.\n\n\n\n\n\n\n\n\n\n\nimage-config\n: All the properties explained below are required to upload the image to the cloud environment properly.\n    In case of creating a new image this configuration will be used.\n\n\nname\n: This defines the name for the image to upload either located directly in the VNFPackage or available via the URL defined in image-link.\n\n\ndiskFormat\n: The diskFormat defines the format in which disk type the image is stored.\n\n\ncontainerFormat\n: The containerFormat defines the format in which container type the image is stored .\n\n\nminCPU\n: The minCPU defines the minimum amount of CPU cores for using this image properly.\n\n\nminDisk\n: The minDisk defines the minimum amount of disk space for using this image properly.\n\n\nminRam\n: The minRam defines the minimum amount of RAM for using this image properly.\n\n\nisPublic\n: The isPublic defines whether the image is available public or not.\n\n\n\n\n\n\n\n\nVNFD>.json\n\n\nThe \nvnfd>.json contains the VirtualNetworkFunctionDescriptor (VNFD) onboarded on the Orchestrator.\nThis VNFD can later be referenced in a NSD by its id to make use of it.\nA more detailed explanation of the VNFD can be found \nhere\n.\n\n\nNote\n The name of the file is not important but the file extension .json is, since the VNFPackageManagement is looking for this kind of file format.\n\n\nscripts\n\n\nThe scripts folder contains all the scripts required for starting, configuring or whatever you want to do on the running instance.\nThe execution order is defined by the lifecycle_events inside the VNFD.\nThis lifecycle_events are triggered by the NFVO in the meaning of: if the event \"INSTANTIATE\" contains a script in the lifecycle_events, this script is executed when the NFVO calls the instantiate method for the specific VNFR.\n\n\nNote\n The scripts in the folder \nscripts\n are fetched only if the \nscripts-link\n is not defined in the \nMetadata.yaml\n.\n    This means that the scripts in that folder have less priority than the scripts located under \nscripts-link\n.\n\n\nNote\n Scripts are executed when a specific Event is fired and this Event references to specific scripts.\n\n\nimage>.img\n\n\nThis image is used to upload it to all the cloud environments which are addressed inside the VNFD with that image.\nIt doesn't matter whether an image already exists on the considered cloud environment or not.\n\n\nNote\n This image has lower priority than the \nimage-links\n defined in \nMetadata.yaml\n.\n    This means that the image will be ignored if the \nimage-links\n is defined.\n\n\nNote\n The name of the image doesn't matter but the suffix .img since the VNFPackageManagement is looking for a file with this suffix.\n    However, the name and all the properties for storing it on the cloud environment are defined in \nMetadata.yaml\n under the key \nimage\n.\n\n\nTutorial\n\n\nThis section explains how to create, upload and make use of VNFPackages.\nThe chosen scenario is a NetworkService for testing the network connectivity by using \niPerf\n.\niPerf is a tool for active measurements of the maximum achievable bandwidth on IP networks.\nTherefore, we need a server and a client installing the iPerf server/client and configuring them for communication between.\n\n\nCreation of VNFPackages\n\n\nFor doing so, we need to create two VNFPackages and reference them in the NSD.\nSo we need one VNFPackage for the iperf server (called iperf-server) and one for the iperf client (called iperf-client).\nFirst we will start with the creation of the iperf-server VNFPackage and then we will create the iperf-client VNFPackage.\n\n\nFirst of all we should create a directory for each VNFPackage where we put all the files related to the VNFPackage because in the end we need to pack them into a tar archive for onboarding it on the NFVO.\n\n\nVNFPackage [iperf-server]\n\n\nThis iperf-server VNFPackage has to install the iperf server and needs to provide its ip to the iperf client.\n\n\nMetadata [iperf-server]\n\n\nIn the Metadata.yaml we define the name of the VNFPackage, the scripts location and also the properties for the image to upload.\nSince the image-link is not implemented in the current release we will put the image directly into the VNFPackage.\nFinally, it looks as shown below.\n\n\nname: iperf-server\nscripts-link: https://script-link-to-git.git\nimage:\n    upload: check\n    names:\n        - iperf_server_image\nimage-config:\n    name: iperf_server_image\n    diskFormat: QCOW2\n    containerFormat: BARE\n    minCPU: 2\n    minDisk: 5\n    minRam: 2048\n    isPublic: false\n\n\n\n\nVNFD [iperf-server]\n\n\nThis is how the \nVNFD\n looks like for the iperf-server VNFPackage.\nImportant to notice here is the vm_image that points to the image we have defined in the Metadata.yaml\n\n\n{\n    \nvendor\n:\nfokus\n,\n    \nversion\n:\n0.2\n,\n    \nname\n:\niperf-server\n,\n    \ntype\n:\nserver\n,\n    \nendpoint\n:\ngeneric\n,\n    \nvdu\n:[\n        {\n            \nvm_image\n:[\n                \niperf_server_image\n\n            ],\n            \nvimInstanceName\n:\nvim-instance\n,\n            \nscale_in_out\n:2,\n            \nvnfc\n:[\n                {\n                    \nexposed\n:true,\n                    \nconnection_point\n:[\n                        {\n                            \nvirtual_link_reference\n:\nprivate\n\n                        }\n                    ]\n                }\n            ]\n        }\n    ],\n    \nvirtual_link\n:[\n        {\n            \nname\n:\nprivate\n\n        }\n    ],\n    \nlifecycle_event\n:[\n        {\n            \nevent\n:\nINSTANTIATE\n,\n            \nlifecycle_events\n:[\n                \ninstall.sh\n,\n                \ninstall-srv.sh\n\n            ]\n        }\n    ],\n    \ndeployment_flavour\n:[\n        {\n            \ndf_constraint\n:[\n                \nconstraint1\n,\n                \nconstraint2\n\n            ],\n            \ncostituent_vdu\n:[\n            ],\n            \nflavour_key\n:\nm1.small\n\n        }\n    ]\n}\n\n\n\n\nImage\n\n\nThe image we have to choose must be a debian 64bit image (e.g. ubuntu amd64) for satisfying the EMS and scripts which are designed for that kind of image.\nWe have chosen this one \nubuntu-14.04.3-server-amd64.iso\n.\n\n\nVNFPackage [iperf-client]\n\n\nThis iperf-server VNFPackage has to install the iperf client and needs to configure it to set the iperf servers' IP.\n\n\nMetadata [iperf-client]\n\n\nIn the Metadata.yaml we define the name of the VNFPackage, the scripts location and also the properties for the image to upload.\nSince the image-link is not implemented in the current release we will put the image directly into the VNFPackage.\nFinally, it looks as shown below.\n\n\nname: iperf-client\nscripts-link: https://gitlab.fokus.fraunhofer.de/openbaton/scripts-test-public.git\nimage:\n    upload: check\n    names:\n        - iperf_client_image\nimage-config:\n    name: iperf_client_image\n    diskFormat: QCOW2\n    containerFormat: BARE\n    minCPU: 2\n    minDisk: 5\n    minRam: 2048\n    isPublic: false\n\n\n\n\nVNFD [iperf-client]\n\n\nThis is how the \nVNFD\n looks like for the iperf-client VNFPackage.\nImportant to notice here is the vm_image that points to the image we have defined in the Metadata.yaml\n\n\n{\n    \nvendor\n:\nfokus\n,\n    \nversion\n:\n0.1\n,\n    \nname\n:\niperf-client\n,\n    \ntype\n:\nclient\n,\n    \nendpoint\n:\ngeneric\n,\n    \nvdu\n:[\n        {\n            \nvm_image\n:[\n                \niperf_client_image\n\n            ],\n            \nvirtual_memory_resource_element\n:\n1024\n,\n            \nvirtual_network_bandwidth_resource\n:\n1000000\n,\n            \nvimInstanceName\n:\nvim-instance\n,\n            \nvdu_constraint\n:\n,\n            \nhigh_availability\n:\nACTIVE_PASSIVE\n,\n            \nscale_in_out\n:2,\n            \nvnfc\n:[\n                {\n                    \nconnection_point\n:[\n                        {\n                            \nvirtual_link_reference\n:\nprivate\n\n                        }\n                    ]\n                }\n            ]\n        }\n    ],\n    \nvirtual_link\n:[\n        {\n            \nname\n:\nprivate\n\n        }\n    ],\n    \nlifecycle_event\n:[\n        {\n            \nevent\n:\nINSTANTIATE\n,\n            \nlifecycle_events\n:[\n                \ninstall.sh\n\n            ]\n        },\n        {\n            \nevent\n:\nCONFIGURE\n,\n            \nlifecycle_events\n:[\n                \nserver_configure.sh\n\n            ]\n        }\n    ],\n    \ndeployment_flavour\n:[\n        {\n            \ndf_constraint\n:[\n                \nconstraint1\n,\n                \nconstraint2\n\n            ],\n            \ncostituent_vdu\n:[\n            ],\n            \nflavour_key\n:\nm1.small\n\n        }\n    ]\n}\n\n\n\n\nImage\n\n\nThe image we have to choose must be a debian 64bit image (e.g. ubuntu amd64) for satisfying the EMS and scripts which are designed for that kind of architecture.\nWe have chosen this one \nubuntu-14.04.3-server-amd64.iso\n.\n\n\nOnboarding VNFPackages\n\n\nOnce we have finalized the creation of VNFPackages and packed them into a tar we can onboard them on the NFVO. Make sure that you also uploaded a VimInstance before onboarding the package. Onboarding can be done as shown in the following:\n\n\n$ curl -X POST -v -F file=@vnf-package.tar \nhttp://localhost:8080/api/v1/vnf-packages\n\n\n\n\n\nThis must be done for both VNFPackages expecting that the NFVO is running locally and the tar archive is called vnf-package.tar.\nOtherwise you need to adapt the path to the package and also the URL where the NFVO is located.\nNow where we onboarded the VNFPackages they are available on the NFVO and we can make use of it by referencing them in the NSD by their ids'.\n\n\nNote\n You could use the \nDashboard\n as well for onboarding the VNFPackages.\n\n\nTo get the ids of the newly created VNFDs you need to fetch the VNFDs by invoking the following command:\n\n\n$ curl -X \nGET http://localhost:8080/api/v1/vnf-descriptors\n\n\n\n\n\nThis request will return a list of already existing VNFDs.\nJust looking for the VNFDs we created before and use the id to reference them in the NSD.\nThe following list of VNFDs is an example of this request.\nTo make it more readable only the interesting parts are shown.\n\n\n[\n  [...]\n  {\n    [...]\n    \nid\n: \n29d918b9-6245-4dc4-abc6-b7dd6e84f2c1\n,\n    \nname\n: \niperf-server\n,\n    [...]\n  },\n  {\n    [...]\n    \nid\n: \n87820607-4048-4fad-b02b-dbcab8bb5c1c\n,\n    \nname\n: \niperf-client\n,\n    [...]\n  }\n  [...]\n]\n\n\n\n\nNSD [iperf]\n\n\nIn this section we will create a \nNSD\n and reference the previously created VNFPackages by their ids'.\nFor doing that we just need to define the \nid\n for each VNFPackges' VNFD in the list of VNFDs.\nTo provide also the iperf-servers' IP to the iperf-client we need to define dependencies you can find under the key \nvnf_dependency\n setting the source to \niperf-server\n and the target to \niperf-client\n by providing the parameter \nprivate1\n.\n\n\nNote\n When creating the NSD the VNFD is fetched by the id defined. Other properties we would set in the VNFD in this NSD will be ignored.\n\n\n{\n    \nname\n:\niperf\n,\n    \nvendor\n:\nfokus\n,\n    \nversion\n:\n0.1-ALPHA\n,\n    \nvnfd\n:[\n        {\n            \nid\n:\n29d918b9-6245-4dc4-abc6-b7dd6e84f2c1\n\n        },\n        {\n            \nid\n:\n87820607-4048-4fad-b02b-dbcab8bb5c1c\n\n        }\n    ],\n    \nvld\n:[\n        {\n            \nname\n:\nprivate\n\n        }\n    ],\n    \nvnf_dependency\n:[\n        {\n            \nsource\n : {\n                \nname\n: \niperf-server\n\n            },\n            \ntarget\n:{\n                \nname\n: \niperf-client\n\n            },\n            \nparameters\n:[\n                \nprivate1\n\n            ]\n        }\n    ]\n}\n\n\n\n\nFinally you can onboard this NSD and create a NSR that bases on both VNFPackages created before.\n\n\nOnboard NSD\n\n\nThe following command will onboard the NSD on the NFVO:\n\n\n$ curl -X POST -v -F file=@nsd.json \nhttp://localhost:8080/api/v1/ns-descriptors\n\n\n\n\n\nThis will return the NSD with the id we need to create NSR.\nAfterwards, we can deploy the NSD.\n\n\nNote\n You could use the \nDashboard\n as well for onboarding the NSD.\n\n\nCreate NSR (Deployment)\n\n\nTo deploy the NSD we create a NSR with the following command:\n\n\n$ curl -X POST -v -F file=@vnf-package.tar \nhttp://localhost:8080/api/v1/ns-records/\nNSD_ID\n\n\n\n\n\nInstallation and configuration is done automatically and provides you with a configured iperf server/client infrastructure.\n\n\nNote\n You could use the \nDashboard\n as well for creating the NSR of this NSD.\n\n\n\n\n\n\n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Create your own VNF Package"
        }, 
        {
            "location": "/vnfpackage/#vnfpackage", 
            "text": "Note : This is the initial version of the VNFPackage and might change most probably in the next releases to improve and simplify the creation, usability and power.  This doc describes essential components of a VNFPackage, how to create them and how to use them after onboarding.\nTherefore, you can find a practical tutorial at the end with all the steps starting from the creation over onboarding and finally referencing it by a NSD.  A VNFPackage is a tar-archive that contains all the information required for creating a VNF for the openbaton NFVO.\nAfter onboarding the VNFPackage on the NFVO you can use the VNF directly in the NSD by referencing the VNFD by its id.\nA VNFPackage includes the VNFD, the image, scripts and a Metadata file structured as shown in the next part.", 
            "title": "VNFPackage"
        }, 
        {
            "location": "/vnfpackage/#package-structure", 
            "text": "The VNFPackage has the following structure:  - Metadata.yaml\n- vnfd.json\n- scripts/\n    - 1_script.sh\n    - 2_script.sh\n- image.img", 
            "title": "Package structure"
        }, 
        {
            "location": "/vnfpackage/#metadatayaml", 
            "text": "The Metadata.yaml defines essential properties for the VNF. This file bases on the YAML syntax where information are stored in simple  key> :  value> associations.  The example of a Metadata.yaml file below shows a basic definition of a VNFPackage.  name: vnfPackage_name\nscripts-link: scripts_link\nimage:\n    upload: option\n    ids: list_of_ids\n    names: list_of_names\n    link: image_link\nimage-config:\n    name: image_name\n    diskFormat: disk_format\n    containerFormat: container_format\n    minCPU: min_cpu\n    minDisk: min_disk\n    minRam: min_ram\n    isPublic: is_public  In the following each property is explained in more detail. Please consider also the notes since some properties are optional (or even not implemented) and if they are defined, they may have more priority than other and override them therefore.   name : The name defines the name of the VNFPackage itself used to store it on the database.  scripts-link : This link points to a public git repository where scripts are stored that are needed to be executed for managing the lifecycle of the exposed VNF.  Note  Either you can define the scripts-link or put the scripts into the folder scripts/.\n    The scripts-link has a higher priority than the scripts located in the folder scripts/.\n    So if you set the scripts-link, the scripts in folder scripts/ are ignored completely.  Note  The scripts-link is processed by the Element Management System (EMS) in the meaning of fetching the files from that link.\n    So you need to take care about ensuring that the URL defined is available.  Note  Scripts are executed during different lifecycle-events.    image :  upload : Here you can choose between different options (true, false, check).  true: choosing this option means to upload the defined image on all the VimInstances. It does not matter if an image with the defined name exists or not.  false: choosing this option means that you assume that the image (defined in the ids or names) is already present.\nIf the image does not exist, the VNFPackage onboarding will throw an exception.\nIn this case the image (if defined) will be ignored.  check: this option means that the VNFPackageManagement checks first if the image is available (defined in ids or names).\nIf the image does not exist, a new one with the image defined in the VNFPackage will be created.    ids : The list of image ids is used to fetch the image from the corresponding VimInstance.\n    To do it, the manager iterates over all ids and checks if an image with that id exists on the VimInstance.\n    The defined ids have a higher priority than the list of names.\n    We distinguish between the following cases:  If it finds no image with these ids, it continues with the list of image names.  If it finds one image with these ids, this image will be used.  If it finds multiple images with the same id (should never happen) or multiple ids matching to multiple images, an exception will be thrown because it is not clear which image to use.    names : The list of image names is used to fetch the image from the corresponding VimInstance.\n    To do it, manager iterates over all names and checks if an image with that name exists on the VimInstance.\n    The list of names have a lower priority than the list of ids.\n    We distinguish between the following cases:  If it finds no image with that name, an exception will be thrown except you defined the upload option check.\nThen it will create a new image defined in the VNFPackage.  If it finds one image, this image will be used.  If it finds multiple images with the same name or multiple names matching to multiple images, an exception will be thrown because it is not clear which image to use.    link : This link points to an image available at this URL used to upload the image to the cloud environment.  Note  Either you have to define the image-link or put the image directly into the VNFPackage.\n    Otherwise a NotFoundException will be thrown and the VNFPackage will not onboard.\n    The image-link has a higher priority than the image stored in the VNFPackage directly.      image-config : All the properties explained below are required to upload the image to the cloud environment properly.\n    In case of creating a new image this configuration will be used.  name : This defines the name for the image to upload either located directly in the VNFPackage or available via the URL defined in image-link.  diskFormat : The diskFormat defines the format in which disk type the image is stored.  containerFormat : The containerFormat defines the format in which container type the image is stored .  minCPU : The minCPU defines the minimum amount of CPU cores for using this image properly.  minDisk : The minDisk defines the minimum amount of disk space for using this image properly.  minRam : The minRam defines the minimum amount of RAM for using this image properly.  isPublic : The isPublic defines whether the image is available public or not.", 
            "title": "Metadata.yaml"
        }, 
        {
            "location": "/vnfpackage/#vnfd62json", 
            "text": "The  vnfd>.json contains the VirtualNetworkFunctionDescriptor (VNFD) onboarded on the Orchestrator.\nThis VNFD can later be referenced in a NSD by its id to make use of it.\nA more detailed explanation of the VNFD can be found  here .  Note  The name of the file is not important but the file extension .json is, since the VNFPackageManagement is looking for this kind of file format.", 
            "title": "&lt;VNFD>.json"
        }, 
        {
            "location": "/vnfpackage/#scripts", 
            "text": "The scripts folder contains all the scripts required for starting, configuring or whatever you want to do on the running instance.\nThe execution order is defined by the lifecycle_events inside the VNFD.\nThis lifecycle_events are triggered by the NFVO in the meaning of: if the event \"INSTANTIATE\" contains a script in the lifecycle_events, this script is executed when the NFVO calls the instantiate method for the specific VNFR.  Note  The scripts in the folder  scripts  are fetched only if the  scripts-link  is not defined in the  Metadata.yaml .\n    This means that the scripts in that folder have less priority than the scripts located under  scripts-link .  Note  Scripts are executed when a specific Event is fired and this Event references to specific scripts.", 
            "title": "scripts"
        }, 
        {
            "location": "/vnfpackage/#image62img", 
            "text": "This image is used to upload it to all the cloud environments which are addressed inside the VNFD with that image.\nIt doesn't matter whether an image already exists on the considered cloud environment or not.  Note  This image has lower priority than the  image-links  defined in  Metadata.yaml .\n    This means that the image will be ignored if the  image-links  is defined.  Note  The name of the image doesn't matter but the suffix .img since the VNFPackageManagement is looking for a file with this suffix.\n    However, the name and all the properties for storing it on the cloud environment are defined in  Metadata.yaml  under the key  image .", 
            "title": "&lt;image>.img"
        }, 
        {
            "location": "/vnfpackage/#tutorial", 
            "text": "This section explains how to create, upload and make use of VNFPackages.\nThe chosen scenario is a NetworkService for testing the network connectivity by using  iPerf .\niPerf is a tool for active measurements of the maximum achievable bandwidth on IP networks.\nTherefore, we need a server and a client installing the iPerf server/client and configuring them for communication between.", 
            "title": "Tutorial"
        }, 
        {
            "location": "/vnfpackage/#creation-of-vnfpackages", 
            "text": "For doing so, we need to create two VNFPackages and reference them in the NSD.\nSo we need one VNFPackage for the iperf server (called iperf-server) and one for the iperf client (called iperf-client).\nFirst we will start with the creation of the iperf-server VNFPackage and then we will create the iperf-client VNFPackage.  First of all we should create a directory for each VNFPackage where we put all the files related to the VNFPackage because in the end we need to pack them into a tar archive for onboarding it on the NFVO.  VNFPackage [iperf-server]  This iperf-server VNFPackage has to install the iperf server and needs to provide its ip to the iperf client.  Metadata [iperf-server]  In the Metadata.yaml we define the name of the VNFPackage, the scripts location and also the properties for the image to upload.\nSince the image-link is not implemented in the current release we will put the image directly into the VNFPackage.\nFinally, it looks as shown below.  name: iperf-server\nscripts-link: https://script-link-to-git.git\nimage:\n    upload: check\n    names:\n        - iperf_server_image\nimage-config:\n    name: iperf_server_image\n    diskFormat: QCOW2\n    containerFormat: BARE\n    minCPU: 2\n    minDisk: 5\n    minRam: 2048\n    isPublic: false  VNFD [iperf-server]  This is how the  VNFD  looks like for the iperf-server VNFPackage.\nImportant to notice here is the vm_image that points to the image we have defined in the Metadata.yaml  {\n     vendor : fokus ,\n     version : 0.2 ,\n     name : iperf-server ,\n     type : server ,\n     endpoint : generic ,\n     vdu :[\n        {\n             vm_image :[\n                 iperf_server_image \n            ],\n             vimInstanceName : vim-instance ,\n             scale_in_out :2,\n             vnfc :[\n                {\n                     exposed :true,\n                     connection_point :[\n                        {\n                             virtual_link_reference : private \n                        }\n                    ]\n                }\n            ]\n        }\n    ],\n     virtual_link :[\n        {\n             name : private \n        }\n    ],\n     lifecycle_event :[\n        {\n             event : INSTANTIATE ,\n             lifecycle_events :[\n                 install.sh ,\n                 install-srv.sh \n            ]\n        }\n    ],\n     deployment_flavour :[\n        {\n             df_constraint :[\n                 constraint1 ,\n                 constraint2 \n            ],\n             costituent_vdu :[\n            ],\n             flavour_key : m1.small \n        }\n    ]\n}  Image  The image we have to choose must be a debian 64bit image (e.g. ubuntu amd64) for satisfying the EMS and scripts which are designed for that kind of image.\nWe have chosen this one  ubuntu-14.04.3-server-amd64.iso .  VNFPackage [iperf-client]  This iperf-server VNFPackage has to install the iperf client and needs to configure it to set the iperf servers' IP.  Metadata [iperf-client]  In the Metadata.yaml we define the name of the VNFPackage, the scripts location and also the properties for the image to upload.\nSince the image-link is not implemented in the current release we will put the image directly into the VNFPackage.\nFinally, it looks as shown below.  name: iperf-client\nscripts-link: https://gitlab.fokus.fraunhofer.de/openbaton/scripts-test-public.git\nimage:\n    upload: check\n    names:\n        - iperf_client_image\nimage-config:\n    name: iperf_client_image\n    diskFormat: QCOW2\n    containerFormat: BARE\n    minCPU: 2\n    minDisk: 5\n    minRam: 2048\n    isPublic: false  VNFD [iperf-client]  This is how the  VNFD  looks like for the iperf-client VNFPackage.\nImportant to notice here is the vm_image that points to the image we have defined in the Metadata.yaml  {\n     vendor : fokus ,\n     version : 0.1 ,\n     name : iperf-client ,\n     type : client ,\n     endpoint : generic ,\n     vdu :[\n        {\n             vm_image :[\n                 iperf_client_image \n            ],\n             virtual_memory_resource_element : 1024 ,\n             virtual_network_bandwidth_resource : 1000000 ,\n             vimInstanceName : vim-instance ,\n             vdu_constraint : ,\n             high_availability : ACTIVE_PASSIVE ,\n             scale_in_out :2,\n             vnfc :[\n                {\n                     connection_point :[\n                        {\n                             virtual_link_reference : private \n                        }\n                    ]\n                }\n            ]\n        }\n    ],\n     virtual_link :[\n        {\n             name : private \n        }\n    ],\n     lifecycle_event :[\n        {\n             event : INSTANTIATE ,\n             lifecycle_events :[\n                 install.sh \n            ]\n        },\n        {\n             event : CONFIGURE ,\n             lifecycle_events :[\n                 server_configure.sh \n            ]\n        }\n    ],\n     deployment_flavour :[\n        {\n             df_constraint :[\n                 constraint1 ,\n                 constraint2 \n            ],\n             costituent_vdu :[\n            ],\n             flavour_key : m1.small \n        }\n    ]\n}  Image  The image we have to choose must be a debian 64bit image (e.g. ubuntu amd64) for satisfying the EMS and scripts which are designed for that kind of architecture.\nWe have chosen this one  ubuntu-14.04.3-server-amd64.iso .", 
            "title": "Creation of VNFPackages"
        }, 
        {
            "location": "/vnfpackage/#onboarding-vnfpackages", 
            "text": "Once we have finalized the creation of VNFPackages and packed them into a tar we can onboard them on the NFVO. Make sure that you also uploaded a VimInstance before onboarding the package. Onboarding can be done as shown in the following:  $ curl -X POST -v -F file=@vnf-package.tar  http://localhost:8080/api/v1/vnf-packages   This must be done for both VNFPackages expecting that the NFVO is running locally and the tar archive is called vnf-package.tar.\nOtherwise you need to adapt the path to the package and also the URL where the NFVO is located.\nNow where we onboarded the VNFPackages they are available on the NFVO and we can make use of it by referencing them in the NSD by their ids'.  Note  You could use the  Dashboard  as well for onboarding the VNFPackages.  To get the ids of the newly created VNFDs you need to fetch the VNFDs by invoking the following command:  $ curl -X  GET http://localhost:8080/api/v1/vnf-descriptors   This request will return a list of already existing VNFDs.\nJust looking for the VNFDs we created before and use the id to reference them in the NSD.\nThe following list of VNFDs is an example of this request.\nTo make it more readable only the interesting parts are shown.  [\n  [...]\n  {\n    [...]\n     id :  29d918b9-6245-4dc4-abc6-b7dd6e84f2c1 ,\n     name :  iperf-server ,\n    [...]\n  },\n  {\n    [...]\n     id :  87820607-4048-4fad-b02b-dbcab8bb5c1c ,\n     name :  iperf-client ,\n    [...]\n  }\n  [...]\n]", 
            "title": "Onboarding VNFPackages"
        }, 
        {
            "location": "/vnfpackage/#nsd-iperf", 
            "text": "In this section we will create a  NSD  and reference the previously created VNFPackages by their ids'.\nFor doing that we just need to define the  id  for each VNFPackges' VNFD in the list of VNFDs.\nTo provide also the iperf-servers' IP to the iperf-client we need to define dependencies you can find under the key  vnf_dependency  setting the source to  iperf-server  and the target to  iperf-client  by providing the parameter  private1 .  Note  When creating the NSD the VNFD is fetched by the id defined. Other properties we would set in the VNFD in this NSD will be ignored.  {\n     name : iperf ,\n     vendor : fokus ,\n     version : 0.1-ALPHA ,\n     vnfd :[\n        {\n             id : 29d918b9-6245-4dc4-abc6-b7dd6e84f2c1 \n        },\n        {\n             id : 87820607-4048-4fad-b02b-dbcab8bb5c1c \n        }\n    ],\n     vld :[\n        {\n             name : private \n        }\n    ],\n     vnf_dependency :[\n        {\n             source  : {\n                 name :  iperf-server \n            },\n             target :{\n                 name :  iperf-client \n            },\n             parameters :[\n                 private1 \n            ]\n        }\n    ]\n}  Finally you can onboard this NSD and create a NSR that bases on both VNFPackages created before.  Onboard NSD  The following command will onboard the NSD on the NFVO:  $ curl -X POST -v -F file=@nsd.json  http://localhost:8080/api/v1/ns-descriptors   This will return the NSD with the id we need to create NSR.\nAfterwards, we can deploy the NSD.  Note  You could use the  Dashboard  as well for onboarding the NSD.  Create NSR (Deployment)  To deploy the NSD we create a NSR with the following command:  $ curl -X POST -v -F file=@vnf-package.tar  http://localhost:8080/api/v1/ns-records/ NSD_ID   Installation and configuration is done automatically and provides you with a configured iperf server/client infrastructure.  Note  You could use the  Dashboard  as well for creating the NSR of this NSD.   \n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "NSD [iperf]"
        }, 
        {
            "location": "/ns-descriptor/", 
            "text": "Network Service Descriptor\n\n\nThe Network Service Descriptor contains the values that are defined in \nETSI MANO specification\n. The NFVO is able to handle JSON file describing a Network Service Descriptor. An example of the most important fields follows:\n\n\n{  \n    \nname\n:\niperf-NSD\n,\n    \nvendor\n:\nfokus\n,\n    \nversion\n:\n0.1-ALPHA\n,\n    \nvnfd\n:[  ...  ],\n    \nvld\n:[  \n        {  \n            \nname\n:\nprivate\n\n        }\n    ],\n    \nvnf_dependency\n:[\n        {\n            \nsource\n : {\n                \nname\n: \niperf-server\n\n            },\n            \ntarget\n:{\n                \nname\n: \niperf-client\n\n            },\n            \nparameters\n:[\n                \nip1\n\n            ]\n        }\n    ]\n}\n\n\n\n\nYou can see a complete NSD json \nhere\n.\n\n\n\n\n\n\n\n\nParams\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\nname\n\n\nThe name to give to the NetworkServiceDescriptor\n\n\n\n\n\n\nvendor\n\n\nThe vendor creating this NetworkServiceDescriptor\n\n\n\n\n\n\nversion\n\n\nThe version of the NetworkServiceDescriptor (can be any string)\n\n\n\n\n\n\nvnfd\n\n\nA list of VirtualNetworkFunctionDescriptors (see \nVirtualNetworkFunctionDescriptor\n)\n\n\n\n\n\n\nvld\n\n\nA list of VirtualLinkDescriptors\n\n\n\n\n\n\nvnf_dependency\n\n\nA list of VNF_Dependencies\n\n\n\n\n\n\n\n\nVirtualLinkDescriptor\n\n\nThe Virtual Link Descriptor (VLD) describes the basic topology of the connectivity between one or more VNFs connected to this VL.\nThe VLD must contain a parameter \nname\n with the value of a network that will be used by the VirtualNetworkFunctionDescriptors.\nIf the network exists, then this network will be used, if not a new one will be created.\n\n\nVNF Dependencies\n\n\nA VNF Dependency is composed by \n\n\n\n\n\n\n\n\nParams\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\nsource\n\n\nThe name of the VirtualNetworkFunctionDescriptor that provides one or more parameters (see \nVNFManager Generic\n and \nVNF Parameters\n)\n\n\n\n\n\n\ntarget\n\n\nThe name of the VirtualNetworkFunctionDescriptor that requires one or more parameters (see \nVNFManager Generic\n and \nVNF Parameters\n)\n\n\n\n\n\n\nparameters\n\n\nThe name of the parameters that the \ntarget\n requires\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Create the NSD"
        }, 
        {
            "location": "/ns-descriptor/#network-service-descriptor", 
            "text": "The Network Service Descriptor contains the values that are defined in  ETSI MANO specification . The NFVO is able to handle JSON file describing a Network Service Descriptor. An example of the most important fields follows:  {  \n     name : iperf-NSD ,\n     vendor : fokus ,\n     version : 0.1-ALPHA ,\n     vnfd :[  ...  ],\n     vld :[  \n        {  \n             name : private \n        }\n    ],\n     vnf_dependency :[\n        {\n             source  : {\n                 name :  iperf-server \n            },\n             target :{\n                 name :  iperf-client \n            },\n             parameters :[\n                 ip1 \n            ]\n        }\n    ]\n}  You can see a complete NSD json  here .     Params  Meaning      name  The name to give to the NetworkServiceDescriptor    vendor  The vendor creating this NetworkServiceDescriptor    version  The version of the NetworkServiceDescriptor (can be any string)    vnfd  A list of VirtualNetworkFunctionDescriptors (see  VirtualNetworkFunctionDescriptor )    vld  A list of VirtualLinkDescriptors    vnf_dependency  A list of VNF_Dependencies     VirtualLinkDescriptor  The Virtual Link Descriptor (VLD) describes the basic topology of the connectivity between one or more VNFs connected to this VL.\nThe VLD must contain a parameter  name  with the value of a network that will be used by the VirtualNetworkFunctionDescriptors.\nIf the network exists, then this network will be used, if not a new one will be created.  VNF Dependencies  A VNF Dependency is composed by      Params  Meaning      source  The name of the VirtualNetworkFunctionDescriptor that provides one or more parameters (see  VNFManager Generic  and  VNF Parameters )    target  The name of the VirtualNetworkFunctionDescriptor that requires one or more parameters (see  VNFManager Generic  and  VNF Parameters )    parameters  The name of the parameters that the  target  requires       \n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Network Service Descriptor"
        }, 
        {
            "location": "/nfvo-how-to-use-gui/", 
            "text": "OpenBaton Dashboard\n\n\nThe Dashboard of OpenBaton helps you managing the lifecycle of different objects like \nVimInstaces, Network Service Descriptors/Records and Virtual Network Function Descriptors/Records in the OpenBaton environment.\n\n\nOverview\n\n\nThe index page shows an overview of the state of the NFVO \n\n\n\n\nNumber of Network Service Records\n\n\nNumber of Virtual Network Functions\n\n\nNumber of Virtual Deployment Units\n\n\nNumber of Network Service Descriptors\n\n\n\n\n\n\nManage PoPs\n\n\nOn this page you can see the list of Vim Instances registered\n\n\n\n\nFor registering a new Vim Instance you should click on the button in the top-right corner \nRegister Vim\n of this page and select your json to register a Vim Instance\n\n\n\n\nIf you want to delete a Vim Instance you can click on the button \nAction\n and then \nDelete\n in the menu\n\n\nCatalogue\n\n\nIn the menu on the left side under the template \nCatalogue\n you can manage \n\n\n\n\nNS Descriptors\n\n\nVNF Packages\n\n\n\n\nNetwork Service Descriptors\n\n\nIn the menu on the left side under the template Catalogue you can find the \nNS Decriptors\n button.\nOn this page you can see the list of NS Descriptors stored in OpenBaton\n\n\n\n\nYou have two options for storing a NS Descriptor:\n\n\n\n\nCreate a NSD by filling in a form\n\n\nCreate a NSD by using a json file\n\n\n\n\nCreate a NSD by using a json file\n\n\n\n\nCreate a NSD by filling in a form\n\n\n\n\nNetwork Service Descriptor Information\n\n\nIf you click on the id of a NSD shown in the list of NSDs you can see the information\nstored in this Network Service Descriptor.\n\n\n\n\nYou can observe the NSD in json format by clicking on the \nShow JSON\n button\n\n\n\n\nOn the page \nNetwork Service Descriptor Information\n you can also look at the \nGraphical view\n of the Network Service Descriptor \nby clicking on \nShow Graph\n\n\n\n\nIf you click on the \nAction\n button in the list of VNFDs you can delete the VNFD from the NSD\nand the information about the \nDependencies\n stored in the Network Service Descriptor\n\n\n\n\nIf you click on the \nAction\n button in the list of VNFDependencies you can delete the VNFDependency from the NSD\n\n\nVirtual Network Function Descriptor Information\n\n\nIn the list of Virtual Network Function Descriptors in NSD template you can click on the id of a Virtual Network Function Descriptor to get to this page\n\n\n\n\nAt the bottom of the page you can see the Virtual Deployment Unit (VDU) tab and if you click on the \nid\n of the \nVDU you can see the details of it\n\n\n\n\nVNF Packages\n\n\nOn this page you can upload the \nVNF Package\n. For more information about the VNF Package please read the \nVNF Package documentation\n \nFor uploading a \n.tar\n you can click on the button \nUpload VNFPackage\n and this window will be shown where you can drag \n drop the file or just click on the white area and choose your file using your file manager\n\n\n\n\nAfter you click on the button \nStart\n the package will be sent to the \nNFVO\n and once the process is finished you will see the package appearing in the list\n\n\n\n\n\n\nNetwork Service Records\n\n\nIn the menu on the left side if you click on the \nOrchestrator NS\n and then \nNS Records\n you will see the list of \nNetwork Service Records\n\nLike in this screenshot \n\n\n\n\nOn this page you can see the details of a Network Service Record by clicking on the id\n\n\n\n\nOn this page you can look at the JSON file of the NSR by clicking on the link \nShow JSON\n and also the \nGraphical view\n. \nof Network Service Record by clicking on the link \nShow Graph\n. \nIn the table of VNF Records you can delete a VNFR by clicking on \nAction\n and then \nDelete\n. \nTo look at the details of a VNFR just click on the \nid\n of it.\n\n\n\n\n\n\n\n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  &amp;&amp; (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Use via the Dashboard"
        }, 
        {
            "location": "/nfvo-how-to-use-gui/#openbaton-dashboard", 
            "text": "The Dashboard of OpenBaton helps you managing the lifecycle of different objects like \nVimInstaces, Network Service Descriptors/Records and Virtual Network Function Descriptors/Records in the OpenBaton environment.", 
            "title": "OpenBaton Dashboard"
        }, 
        {
            "location": "/nfvo-how-to-use-gui/#overview", 
            "text": "The index page shows an overview of the state of the NFVO    Number of Network Service Records  Number of Virtual Network Functions  Number of Virtual Deployment Units  Number of Network Service Descriptors", 
            "title": "Overview"
        }, 
        {
            "location": "/nfvo-how-to-use-gui/#manage-pops", 
            "text": "On this page you can see the list of Vim Instances registered   For registering a new Vim Instance you should click on the button in the top-right corner  Register Vim  of this page and select your json to register a Vim Instance   If you want to delete a Vim Instance you can click on the button  Action  and then  Delete  in the menu", 
            "title": "Manage PoPs"
        }, 
        {
            "location": "/nfvo-how-to-use-gui/#catalogue", 
            "text": "In the menu on the left side under the template  Catalogue  you can manage    NS Descriptors  VNF Packages   Network Service Descriptors  In the menu on the left side under the template Catalogue you can find the  NS Decriptors  button.\nOn this page you can see the list of NS Descriptors stored in OpenBaton   You have two options for storing a NS Descriptor:   Create a NSD by filling in a form  Create a NSD by using a json file   Create a NSD by using a json file   Create a NSD by filling in a form   Network Service Descriptor Information  If you click on the id of a NSD shown in the list of NSDs you can see the information\nstored in this Network Service Descriptor.   You can observe the NSD in json format by clicking on the  Show JSON  button   On the page  Network Service Descriptor Information  you can also look at the  Graphical view  of the Network Service Descriptor \nby clicking on  Show Graph   If you click on the  Action  button in the list of VNFDs you can delete the VNFD from the NSD\nand the information about the  Dependencies  stored in the Network Service Descriptor   If you click on the  Action  button in the list of VNFDependencies you can delete the VNFDependency from the NSD  Virtual Network Function Descriptor Information  In the list of Virtual Network Function Descriptors in NSD template you can click on the id of a Virtual Network Function Descriptor to get to this page   At the bottom of the page you can see the Virtual Deployment Unit (VDU) tab and if you click on the  id  of the \nVDU you can see the details of it   VNF Packages  On this page you can upload the  VNF Package . For more information about the VNF Package please read the  VNF Package documentation  \nFor uploading a  .tar  you can click on the button  Upload VNFPackage  and this window will be shown where you can drag   drop the file or just click on the white area and choose your file using your file manager   After you click on the button  Start  the package will be sent to the  NFVO  and once the process is finished you will see the package appearing in the list", 
            "title": "Catalogue"
        }, 
        {
            "location": "/nfvo-how-to-use-gui/#network-service-records", 
            "text": "In the menu on the left side if you click on the  Orchestrator NS  and then  NS Records  you will see the list of  Network Service Records \nLike in this screenshot    On this page you can see the details of a Network Service Record by clicking on the id   On this page you can look at the JSON file of the NSR by clicking on the link  Show JSON  and also the  Graphical view . \nof Network Service Record by clicking on the link  Show Graph . \nIn the table of VNF Records you can delete a VNFR by clicking on  Action  and then  Delete . \nTo look at the details of a VNFR just click on the  id  of it.    \n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  &amp;&amp; (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Network Service Records"
        }, 
        {
            "location": "/nfvo-sdk/", 
            "text": "NFVO SDK\n\n\nA SDK is available if you want to use the NFVO from a java application.\n\n\nImport it\n\n\nThe build.gradle file must contain:\n\n\nrepositories {\n    mavenCentral()\n    maven {\n        url \nhttp://get.openbaton.org:8081/nexus/content/groups/public\n\n    }\n}\n\ndependencies {\n    compile 'org.openbaton:sdk:0.6'\n}\n\n\n\n\nIn this way you will have access to the NFVO SDK.\n\n\nAnd then?\n\n\nThe UML diagram of the classes follows:\n\n\n\n\nThe NFVORequestor is the main and only class you need to use. From this class it is possible to retrieve all the Agents that are in charge of making calls to the NFVO. The NFVORequestor takes as constructor parameters:\n\n\n\n\n\n\n\n\nParams\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\nusername\n\n\nthe username if the security is enabled in the NFVO\n\n\n\n\n\n\npassword\n\n\nthe password if the security is enabled in the NFVO\n\n\n\n\n\n\nnfvo_ip\n\n\nthe ip of the NFVO\n\n\n\n\n\n\nnfvo_port\n\n\nthe port of the orchestrator\n\n\n\n\n\n\nversion\n\n\nthe API version. Now only \"1\" is available\n\n\n\n\n\n\n\n\nOnce you have the NFVORequestor object, you can get the Agents. Available agents are:\n\n\n\n\nConfigurationRestRequest\n\n\nEventAgent\n\n\nImageRestAgent\n\n\nNetworkServiceDescriptorRestAgent\n\n\nNetworkServiceRecordRestAgent\n\n\nVimInstanceRestAgent\n\n\nVirtualLinkRestAgent\n\n\nVNFFGRestAgent\n\n\n\n\neach of them exposes these methods:\n\n\n\n\ncreate\n\n\nfindById\n\n\nfindAll\n\n\ndelete\n\n\nupdate\n\n\n\n\nplus some specific methods and they refer to the \ncatalogue\n class contained in the name of the Agent. For instance, the NetworkServiceDescriptorRestAgent refers to NetworkServiceDescriptor class and, besides the above methods, exposes:\n\n\n\n\ngetVirtualNetworkFunctionDescriptors\n\n\ngetVirtualNetworkFunctionDescriptor\n\n\ndeleteVirtualNetworkFunctionDescriptors\n\n\ncreateVNFD\n\n\nupdateVNFD\n\n\ngetVNFDependencies\n\n\ngetVNFDependency\n\n\ndeleteVNFDependency\n\n\ncreateVNFDependency\n\n\nupdateVNFD\n\n\ngetPhysicalNetworkFunctionDescriptors\n\n\ngetPhysicalNetworkFunctionDescriptor\n\n\ndeletePhysicalNetworkFunctionDescriptor\n\n\ncreatePhysicalNetworkFunctionDescriptor\n\n\nupdatePNFD\n\n\ngetSecurities\n\n\ndeleteSecurity\n\n\ncreateSecurity\n\n\nupdateSecurity\n\n\n\n\nThe method names are explicit, they do what the name explains.\n\n\nUse it\n\n\nCreate VimInstance\n\n\npublic class Main {\n\n    public static void main(String[] args) {\n        NFVORequestor nfvoRequestor = new NFVORequestor(\nusername\n,\npassword\n,\nnfvo_ip\n,\nnfvo_port\n,\n1\n);\n        VimInstanceRestAgent vimInstanceAgent = nfvoRequestor.getVimInstanceAgent();\n\n        VimInstance vimInstance = new VimInstance();\n\n        // fill the vimInstance object accordingly to your VIM chosen\n\n        try {\n            vimInstance = vimInstanceAgent.create(vimInstance);\n        } catch (SDKException e) {\n            e.printStackTrace();\n        }\n\n        System.out.println(\nCreated VimInstance with id: \n + vimInstance.getId());\n    }\n}", 
            "title": "Use via the SDK"
        }, 
        {
            "location": "/nfvo-sdk/#nfvo-sdk", 
            "text": "A SDK is available if you want to use the NFVO from a java application.  Import it  The build.gradle file must contain:  repositories {\n    mavenCentral()\n    maven {\n        url  http://get.openbaton.org:8081/nexus/content/groups/public \n    }\n}\n\ndependencies {\n    compile 'org.openbaton:sdk:0.6'\n}  In this way you will have access to the NFVO SDK.  And then?  The UML diagram of the classes follows:   The NFVORequestor is the main and only class you need to use. From this class it is possible to retrieve all the Agents that are in charge of making calls to the NFVO. The NFVORequestor takes as constructor parameters:     Params  Meaning      username  the username if the security is enabled in the NFVO    password  the password if the security is enabled in the NFVO    nfvo_ip  the ip of the NFVO    nfvo_port  the port of the orchestrator    version  the API version. Now only \"1\" is available     Once you have the NFVORequestor object, you can get the Agents. Available agents are:   ConfigurationRestRequest  EventAgent  ImageRestAgent  NetworkServiceDescriptorRestAgent  NetworkServiceRecordRestAgent  VimInstanceRestAgent  VirtualLinkRestAgent  VNFFGRestAgent   each of them exposes these methods:   create  findById  findAll  delete  update   plus some specific methods and they refer to the  catalogue  class contained in the name of the Agent. For instance, the NetworkServiceDescriptorRestAgent refers to NetworkServiceDescriptor class and, besides the above methods, exposes:   getVirtualNetworkFunctionDescriptors  getVirtualNetworkFunctionDescriptor  deleteVirtualNetworkFunctionDescriptors  createVNFD  updateVNFD  getVNFDependencies  getVNFDependency  deleteVNFDependency  createVNFDependency  updateVNFD  getPhysicalNetworkFunctionDescriptors  getPhysicalNetworkFunctionDescriptor  deletePhysicalNetworkFunctionDescriptor  createPhysicalNetworkFunctionDescriptor  updatePNFD  getSecurities  deleteSecurity  createSecurity  updateSecurity   The method names are explicit, they do what the name explains.  Use it  Create VimInstance  public class Main {\n\n    public static void main(String[] args) {\n        NFVORequestor nfvoRequestor = new NFVORequestor( username , password , nfvo_ip , nfvo_port , 1 );\n        VimInstanceRestAgent vimInstanceAgent = nfvoRequestor.getVimInstanceAgent();\n\n        VimInstance vimInstance = new VimInstance();\n\n        // fill the vimInstance object accordingly to your VIM chosen\n\n        try {\n            vimInstance = vimInstanceAgent.create(vimInstance);\n        } catch (SDKException e) {\n            e.printStackTrace();\n        }\n\n        System.out.println( Created VimInstance with id:   + vimInstance.getId());\n    }\n}", 
            "title": "NFVO SDK"
        }, 
        {
            "location": "/use-case-example/", 
            "text": "Use case example: Iperf client - server\n\n\n\n\nIn this page there is a full use case example explaining how the deployment process works, step-by-step. We assume that the NFVO and the Generic VNFM are ready to receive invocations.\n\n\nThe following pictures shows what is going to be deployed, an \nIperf\n client and an Iperf server.\n\n\n\n\nAs shown in the picture, the iperf server is the source of the dependency and the client is the target. In this case the client needs the IP of the server. The semantics of the vnf dependency is: the source provides some parameters to the target.\n\n\nBefore starting we need to send the VimInstance to the NFVO and the Network Service Descriptor. For doing this please have a look into the \nVim instance documentation\n, \nVNF Package documentation\n and \nNetwork Service Descriptor documentation\n. In fact, for creating a Network Service Record, we need to have a Network Service Descriptor loaded into the catalogue with two Virtual Network Functions (iperf client and server) created from a VNF Package. A Virtual Network Function Descriptor Json-File for Iperf client looks like this:\n\n\n{\n    \nvendor\n:\nfokus\n,\n    \nversion\n:\n0.1\n,\n    \nname\n:\niperf-client\n,\n    \ntype\n:\nclient\n,\n    \nendpoint\n:\ngeneric\n,\n    \nvdu\n:[\n        {\n            \nvm_image\n:[\n                \nubuntu-14.04-server-cloudimg-amd64-disk1\n\n            ],\n            \ncomputation_requirement\n:\n,\n            \nvirtual_memory_resource_element\n:\n1024\n,\n            \nvirtual_network_bandwidth_resource\n:\n1000000\n,\n            \nlifecycle_event\n:[\n\n            ],\n            \nvimInstanceName\n:\nvim-instance\n,\n            \nvdu_constraint\n:\n,\n            \nhigh_availability\n:\nACTIVE_PASSIVE\n,\n            \nscale_in_out\n:2,\n            \nvnfc\n:[\n                {\n                    \nconnection_point\n:[\n                        {\n                            \nvirtual_link_reference\n:\nprivate\n\n                        }\n                    ]\n                }\n            ],\n            \nmonitoring_parameter\n:[\n                \ncpu_utilization\n\n            ]\n        }\n    ],\n    \nvirtual_link\n:[\n        {\n            \nname\n:\nprivate\n\n        }\n    ],\n    \nconnection_point\n:[\n\n    ],\n    \nlifecycle_event\n:[\n        {\n            \nevent\n:\nINSTANTIATE\n,\n            \nlifecycle_events\n:[\n                \ninstall.sh\n\n            ]\n        },\n        {\n            \nevent\n:\nCONFIGURE\n,\n            \nlifecycle_events\n:[\n                \nserver_configure.sh\n\n            ]\n        }\n    ],\n    \nvdu_dependency\n:[\n\n    ],\n    \nmonitoring_parameter\n:[\n        \ncpu_utilization\n\n    ],\n    \ndeployment_flavour\n:[\n        {\n            \ndf_constraint\n:[\n                \nconstraint1\n,\n                \nconstraint2\n\n            ],\n            \ncostituent_vdu\n:[\n\n            ],\n            \nflavour_key\n:\nm1.small\n\n        }\n    ],\n    \nmanifest_file\n:\n\n}\n\n\n\n\nThis is a perfect example of a dependency. The VNFManager Generic, after creation of the client VNF described, will run the \ninstall.sh\n script during the instantiate method. The install.sh script is:\n\n\n#!/bin/bash\n\nsudo apt-get update \n sudo apt-get install -y iperf screen\n\n\n\n\nAs said before in the documentation \nVNFManager Generic\n, \nthe scripts in the CONFIGURE lifecycle event need to start with the type of the source VNF followed by _ and the name of the script\n, so the `server_configure.sh is:\n\n\n#!/bin/bash\n\nscreen -d -m -S client iperf -c $server_private1 -t 300\n\n\n\n\nThese scripts shown above, are contained in the VNF Package or in a git repository accessible from the VM. Be aware that all the scripts will be executed with root permissions. Once all these steps are done we are ready to create a Network Service Record from the id of the Network Service Descriptor. \n\n\nLet's again have a look at the sequence diagram of a create Network Service Record operation.\n\n\n\n\nWhen the Network Service Record create is called with the Iperf Network Service Descriptor's id, the steps defined in the sequence diagram above happen.\n\n\nINSTANTIATE Method\n\n\nThe first message sent to the Generic VNFM is the INSTANTIATE message \n(1)\n. This message contains the VNF Descriptor and some other parameters needed to create the VNF Record, for instance the list of Virtual Link Records. The Generic VNFM  is called and then the create Virtual Network Function Record and the Virtual Network Function Record is created \n(2)\n and sent back to the NFVO into a GrantOperation message \n(3)\n. This message will trigger the NFVO to check if there are enough resources to create that VNF Record. If so, then a GrantOperation message with the updated VNF Record is sent back to the Generic VNFManager. Then the Generic VNFManager creates an AllocateResources message with the received VNF Record and sends it to the NFVO \n(4)\n. The NFVO after creating the Resources (VMs) sends back the AllocateResources message to the VNFManager. Here the instantiate method is called \n(5)\n. Inside this method, the scripts (or the link to the git repository containing the scripts) contained in the VNF Package is sent to the EMS, the scripts are saved locally to the VM and then the Generic VNFManager will call the execution of each script defined in the VNF Descriptor \n(6)\n. Once all of the scripts are executed and there wasn't any error, the VNFManager sends the Instantiate message back to the NFVO \n(7)\n. \n\n\nMODIFY Method\n\n\nIf the VNF is target for some dependencies, like the iperf client, the MODIFY message is sent to the VNFManager by the NFVO \n(8)\n. Then the VNFManager executes the scripts contained in the CONFIGURE lifecycle event defined in the VNF Descriptor \n(9)\n, and sends back the modify message to the NFVO \n(10)\n, if no errors occurred. In this case, the scripts environment will contain the variables defined in the related VNF dependency.\n\n\nSTART Method\n\n\nHere exactly as before, the NFVO sends the START message to the Generic VNFManager \n(11)\n, and the VNFManager calls the EMS for execution of the scripts defined in the START lifecycle (none for this example) \n(12)\n. And the start message is then sent back to the NFVO meaning that no errors occurred \n(13)\n.\n\n\nConclusions\n\n\nWhen all the VNF Records are done with all of the scripts defined in the lifecycle events, the NFVO will put the state of the VNF Record to ACTIVE and when all the VNF Records are in state ACTIVE, also the Network Service Record will be in state ACTIVE. This means that the service was correctly run. For knowing more about the states of a VNF Record please refer to \nVNF Record state documentation\n\n\n\n\n\n\n\n\n\n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "A full example ;-)"
        }, 
        {
            "location": "/use-case-example/#use-case-example-iperf-client-server", 
            "text": "In this page there is a full use case example explaining how the deployment process works, step-by-step. We assume that the NFVO and the Generic VNFM are ready to receive invocations.  The following pictures shows what is going to be deployed, an  Iperf  client and an Iperf server.   As shown in the picture, the iperf server is the source of the dependency and the client is the target. In this case the client needs the IP of the server. The semantics of the vnf dependency is: the source provides some parameters to the target.  Before starting we need to send the VimInstance to the NFVO and the Network Service Descriptor. For doing this please have a look into the  Vim instance documentation ,  VNF Package documentation  and  Network Service Descriptor documentation . In fact, for creating a Network Service Record, we need to have a Network Service Descriptor loaded into the catalogue with two Virtual Network Functions (iperf client and server) created from a VNF Package. A Virtual Network Function Descriptor Json-File for Iperf client looks like this:  {\n     vendor : fokus ,\n     version : 0.1 ,\n     name : iperf-client ,\n     type : client ,\n     endpoint : generic ,\n     vdu :[\n        {\n             vm_image :[\n                 ubuntu-14.04-server-cloudimg-amd64-disk1 \n            ],\n             computation_requirement : ,\n             virtual_memory_resource_element : 1024 ,\n             virtual_network_bandwidth_resource : 1000000 ,\n             lifecycle_event :[\n\n            ],\n             vimInstanceName : vim-instance ,\n             vdu_constraint : ,\n             high_availability : ACTIVE_PASSIVE ,\n             scale_in_out :2,\n             vnfc :[\n                {\n                     connection_point :[\n                        {\n                             virtual_link_reference : private \n                        }\n                    ]\n                }\n            ],\n             monitoring_parameter :[\n                 cpu_utilization \n            ]\n        }\n    ],\n     virtual_link :[\n        {\n             name : private \n        }\n    ],\n     connection_point :[\n\n    ],\n     lifecycle_event :[\n        {\n             event : INSTANTIATE ,\n             lifecycle_events :[\n                 install.sh \n            ]\n        },\n        {\n             event : CONFIGURE ,\n             lifecycle_events :[\n                 server_configure.sh \n            ]\n        }\n    ],\n     vdu_dependency :[\n\n    ],\n     monitoring_parameter :[\n         cpu_utilization \n    ],\n     deployment_flavour :[\n        {\n             df_constraint :[\n                 constraint1 ,\n                 constraint2 \n            ],\n             costituent_vdu :[\n\n            ],\n             flavour_key : m1.small \n        }\n    ],\n     manifest_file : \n}  This is a perfect example of a dependency. The VNFManager Generic, after creation of the client VNF described, will run the  install.sh  script during the instantiate method. The install.sh script is:  #!/bin/bash\n\nsudo apt-get update   sudo apt-get install -y iperf screen  As said before in the documentation  VNFManager Generic ,  the scripts in the CONFIGURE lifecycle event need to start with the type of the source VNF followed by _ and the name of the script , so the `server_configure.sh is:  #!/bin/bash\n\nscreen -d -m -S client iperf -c $server_private1 -t 300  These scripts shown above, are contained in the VNF Package or in a git repository accessible from the VM. Be aware that all the scripts will be executed with root permissions. Once all these steps are done we are ready to create a Network Service Record from the id of the Network Service Descriptor.   Let's again have a look at the sequence diagram of a create Network Service Record operation.   When the Network Service Record create is called with the Iperf Network Service Descriptor's id, the steps defined in the sequence diagram above happen.  INSTANTIATE Method  The first message sent to the Generic VNFM is the INSTANTIATE message  (1) . This message contains the VNF Descriptor and some other parameters needed to create the VNF Record, for instance the list of Virtual Link Records. The Generic VNFM  is called and then the create Virtual Network Function Record and the Virtual Network Function Record is created  (2)  and sent back to the NFVO into a GrantOperation message  (3) . This message will trigger the NFVO to check if there are enough resources to create that VNF Record. If so, then a GrantOperation message with the updated VNF Record is sent back to the Generic VNFManager. Then the Generic VNFManager creates an AllocateResources message with the received VNF Record and sends it to the NFVO  (4) . The NFVO after creating the Resources (VMs) sends back the AllocateResources message to the VNFManager. Here the instantiate method is called  (5) . Inside this method, the scripts (or the link to the git repository containing the scripts) contained in the VNF Package is sent to the EMS, the scripts are saved locally to the VM and then the Generic VNFManager will call the execution of each script defined in the VNF Descriptor  (6) . Once all of the scripts are executed and there wasn't any error, the VNFManager sends the Instantiate message back to the NFVO  (7) .   MODIFY Method  If the VNF is target for some dependencies, like the iperf client, the MODIFY message is sent to the VNFManager by the NFVO  (8) . Then the VNFManager executes the scripts contained in the CONFIGURE lifecycle event defined in the VNF Descriptor  (9) , and sends back the modify message to the NFVO  (10) , if no errors occurred. In this case, the scripts environment will contain the variables defined in the related VNF dependency.  START Method  Here exactly as before, the NFVO sends the START message to the Generic VNFManager  (11) , and the VNFManager calls the EMS for execution of the scripts defined in the START lifecycle (none for this example)  (12) . And the start message is then sent back to the NFVO meaning that no errors occurred  (13) .", 
            "title": "Use case example: Iperf client - server"
        }, 
        {
            "location": "/use-case-example/#conclusions", 
            "text": "When all the VNF Records are done with all of the scripts defined in the lifecycle events, the NFVO will put the state of the VNF Record to ACTIVE and when all the VNF Records are in state ACTIVE, also the Network Service Record will be in state ACTIVE. This means that the service was correctly run. For knowing more about the states of a VNF Record please refer to  VNF Record state documentation    \n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Conclusions"
        }, 
        {
            "location": "/extend/", 
            "text": "Extend OpenBaton\n\n\nBeing an open source implementation, OpenBaton can be easily extended for supporting additional features or capabilities.\n\n\nExtend the NFVO\n\n\nThe NFVO has been implemented as a java modular application using the Spring.io framework. It is pretty easy to add a new module for extending the supported features. Please refer to the \nNFVO documentation\n for learning a bit more about the NFVO architecture.\n\n\nIt is possible to extend the NFVO by implementing new plugins. The options available is to implement a new Monitoring plugin or a new VIM plugin. The procedure is the same so we will explain how to write a VIM plugin, please see the \nplugin sdk documentation page\n\n\nBefore doing that you can have a look inside the architecture of the NFVO in the \nfollowing page\n\n\n\n\n\n\n\n\n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Extend it"
        }, 
        {
            "location": "/extend/#extend-openbaton", 
            "text": "Being an open source implementation, OpenBaton can be easily extended for supporting additional features or capabilities.  Extend the NFVO  The NFVO has been implemented as a java modular application using the Spring.io framework. It is pretty easy to add a new module for extending the supported features. Please refer to the  NFVO documentation  for learning a bit more about the NFVO architecture.  It is possible to extend the NFVO by implementing new plugins. The options available is to implement a new Monitoring plugin or a new VIM plugin. The procedure is the same so we will explain how to write a VIM plugin, please see the  plugin sdk documentation page  Before doing that you can have a look inside the architecture of the NFVO in the  following page    \n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Extend OpenBaton"
        }, 
        {
            "location": "/nfvo-architecture/", 
            "text": "NFVO Architecture\n\n\nNFVO\n is a modular software composed by the modules illustrated in the following picture:\n\n\n\n\nAPI\n\n\nThis module contains the necessary classes exposing APIs as ReST server. The most importat ones are the classes managing VimInstances, NetworkServiceDescriptors and NetworkServiceRecords. For more details please see \nthe api documentation\n\n\nMAIN\n\n\nThis module contains the classes in charge of the startup of the whole system and gathering configuratons for instance.\n\n\nCOMMON\n\n\nThis module contains the classes that are common to the NFVO\n\n\nCLI\n\n\nThis module contains the NFVO console.\n\n\nDASHBOARD\n\n\nThis module contains the web dashboard available at localhost:8080\n\n\nCORE-INT\n\n\nThis module contains the interfaces of the core functionalities regarding only the internal NFVO interfaces. Most of them are definend in \nETSI MANO specification\n in NFV-MANO interfaces section.\n\n\nCORE-IMPL\n\n\nThis module contains the beans implementing the core-int interfaces.\n\n\nVNFM-INT\n\n\nThis module contains the interfaces of the core functionalities regarding only the NFVO interfaces to the VnfManagers. Most of them are definend in \nETSI MANO specification\n in NFV-MANO interfaces section.\n\n\nVNFM-IMPL\n\n\nThis module contains the beans implementing the vnfm-int interfaces.\n\n\nREPOSITORY\n\n\nThis module contains specific repositories interfacing the database in a generic way.\n\n\nCATALOGUE\n\n\nThis module contains the complete model of NFVO that is sharde in the openbaton libraries.\n\n\nVIM-INT\n\n\nThis module contains the interfaces of the core functionalities regarding only the NFVO interfaces to the VIM. Most of them are definend in \nETSI MANO specification\n in NFV-MANO interfaces section.\n\n\nVIM-IMPL\n\n\nThis module contains the beans implementing the vim-int interfaces.\n\n\nPLUGIN\n\n\nThis module contains the utility classes used to interface to the openbaton plugins.\n\n\nVIM-DRIVERS\n\n\nThis module contains the interface for the VIM openbaton plugins.\n\n\nEXCEPTION\n\n\nThis module contains all the exception classes common to every project containing openbaton libraries.\n\n\nMONITORING\n\n\nThis module contains the interface for the monitoring of the openbaton plugins.\n\n\n\n\n\n\n\n\n\n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "NFVO Architecture"
        }, 
        {
            "location": "/nfvo-architecture/#nfvo-architecture", 
            "text": "NFVO  is a modular software composed by the modules illustrated in the following picture:   API  This module contains the necessary classes exposing APIs as ReST server. The most importat ones are the classes managing VimInstances, NetworkServiceDescriptors and NetworkServiceRecords. For more details please see  the api documentation  MAIN  This module contains the classes in charge of the startup of the whole system and gathering configuratons for instance.  COMMON  This module contains the classes that are common to the NFVO  CLI  This module contains the NFVO console.  DASHBOARD  This module contains the web dashboard available at localhost:8080  CORE-INT  This module contains the interfaces of the core functionalities regarding only the internal NFVO interfaces. Most of them are definend in  ETSI MANO specification  in NFV-MANO interfaces section.  CORE-IMPL  This module contains the beans implementing the core-int interfaces.  VNFM-INT  This module contains the interfaces of the core functionalities regarding only the NFVO interfaces to the VnfManagers. Most of them are definend in  ETSI MANO specification  in NFV-MANO interfaces section.  VNFM-IMPL  This module contains the beans implementing the vnfm-int interfaces.  REPOSITORY  This module contains specific repositories interfacing the database in a generic way.  CATALOGUE  This module contains the complete model of NFVO that is sharde in the openbaton libraries.  VIM-INT  This module contains the interfaces of the core functionalities regarding only the NFVO interfaces to the VIM. Most of them are definend in  ETSI MANO specification  in NFV-MANO interfaces section.  VIM-IMPL  This module contains the beans implementing the vim-int interfaces.  PLUGIN  This module contains the utility classes used to interface to the openbaton plugins.  VIM-DRIVERS  This module contains the interface for the VIM openbaton plugins.  EXCEPTION  This module contains all the exception classes common to every project containing openbaton libraries.  MONITORING  This module contains the interface for the monitoring of the openbaton plugins.    \n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "NFVO Architecture"
        }, 
        {
            "location": "/vim-plugin/", 
            "text": "Create Vim Plugin\n\n\nOpenBaton is an open source project providing a reference implementation of the NFVO and VNFM based on the ETSI specification, it is implemented in java using the spring.io framework. It consists of two main components: a NFVO and a generic VNFM. This project plugin-sdk contains modules that are needed to implement a plugin for OpenBaton system.\n\n\nHow does this works?\n\n\nAn OpenBaton Plugin is a \nRMI\n Server that connects to the NFVO or any other rmiregistry with access to the OpenBaton catalogue as codebase. It offers an implementation of an interface that is used by the NFVO. By default the NFVO starts a rmiregistry at localhost:1099.\n\n\nRequirements\n\n\nBefore you can start with developing your own Vim Plugin you need to prepare your programming environment by installing/configuring the following requirements:\n\n\n\n\nJDK 7 (\ninstallation\n)\n\n\nGradle (\ninstallation\n)\n\n\n\n\nCreate a new project\n\n\nOnce you have started the IDE, click on File -\n New -\n Project...\n\n\nIn this dialog click on Gradle on the left and select java in the main properties window in the middle.\n\n\n\n\nThen click on next to go to the next window.\n\n\nIn the next dialog you need to define the GroupId, ArtifactId and the Version.\nMore information on the specific meaning can be found \nhere\n.\n\n\n\n\nContinue with the next dialog.\n\n\nIn this dialog you need to specify which gradle you want to use.\nIt is recommend to use the default gradle wrapper.\nAdditionally you can enable the auto-import.\n\n\n\n\nContinue with the next dialog by clicking on Next.\n\n\nIn the last dialog, you need to define the project name and the project location.\n\n\n\n\nOnce this is done you can click on Finish and continue with creating the Main Class.\n\n\nCreate the Main Class\n\n\nAfterwards, you need to create the Main Class of the VIM plugin which will be started in the end.\nFor doing so, right click on the root folder my-vim, then click on New -\n Directory and insert what is show below.\n\n\n\n\nClick on OK to continue.\n\n\nAdditionally you need to create a new package.\nThis is done by a right-click on the previously created directory java.\nClick on New -\n Package.\nHere you can define the package name.\n\n\n\n\nFinally you can create your MyVim Class by clicking (right click) on the previously created package and click on New -\n Java Class.\n\n\n\n\nOnce you did all these steps, the initial project structure is created.\nWhat we miss right now is the configuration of the gradle files to define and fetch dependencies we need for implementing the Vim plugin.\nThis is described in later sections.\n\n\nIn order to create a VIM plugin for OpenBaton system you need to add to your \nbuild.gradle\n file:\n\n\n\ngroup 'org.myplugin.example'\nversion '1.0-SNAPSHOT'\n\nbuildscript {\n    repositories {\n        mavenLocal()\n        mavenCentral()\n    }\n    dependencies {\n        classpath(\norg.springframework.boot:spring-boot-gradle-plugin:1.2.6.RELEASE\n)\n    }\n}\n\nrepositories {\n    maven { url \nhttp://get.openbaton.org:8081/nexus/content/groups/public/\n }\n}\n\napply plugin: 'java'\napply plugin: 'maven'\napply plugin: 'spring-boot'\n\n\nmainClassName = 'org.myplugin.example.Starter'\n\n\ndependencies {\n    compile 'org.openbaton:plugin-sdk:0.8'\n    compile'org.springframework:spring-context:4.2.1.RELEASE'\n}\n\n\n\n\n\nWrite your Vim plugin\n\n\nThe Vim plugin is splitted into two classes \n\n\n\n\nImplementation of \nVimDriver\n\n\nThe \nStarter Class\n that contain the main function for bootstrapping the Vim plugin\n\n\n\n\nType of Vim Instance\n\n\nOpenBaton expects only these three \ntype\n of Vim Instance:\n\n\n\n\nTest\n\n\nOpenStack\n\n\nAmazon\n\n\n\n\nNOTE:\n Your Vim plugin implementation \ntype\n should be one of these to be launched and used by OpenBaton\n\n\n1. Implement VimDriver\n\n\nThe \nVimDriver\n is an bastract class that contains tha basic functionality that a Vim Instance should be provide, and extends the \nRemote Class\n. \n\n\nNOTE\n: If you want to implement a Monitoring plugin, then you need to implement the Interface \nResourcePerformanceManagement\n\n\nYour \nMyVim\n class will implement the methods inherited from \nVimDriver\n that manages your Vim Instance:\n\n\n\n\n\n\n\n\nFunction\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nList\\\nNFVImage> listImages\n\n\nReturns the list of Images\n\n\n\n\n\n\nList\\\nServer> listServer\n\n\nReturns the list of Servers\n\n\n\n\n\n\nList\\\nNetwork> listNetworks\n\n\nReturns the list of Network\n\n\n\n\n\n\nList\\\nDeploymentFlavour> listFlavors\n\n\nReturns the list of DeploymentFlavour\n\n\n\n\n\n\nServer launchInstanceAndWait\n\n\nCreates a new Server\n\n\n\n\n\n\nvoid deleteServerByIdAndWait\n\n\nRemoves the Server with id\n\n\n\n\n\n\nNetwork createNetwork\n\n\nCreates a new Network\n\n\n\n\n\n\nNetwork getNetworkById\n\n\nReturns the Network with id\n\n\n\n\n\n\nNetwork updateNetwork\n\n\nUpdates a new Network\n\n\n\n\n\n\nboolean deleteNetwork\n\n\nDeletes the Network\n\n\n\n\n\n\nSubnet createSubnet\n\n\nCreates a new Subnet\n\n\n\n\n\n\nSubnet updateSubnet\n\n\nUpdates the Subnet\n\n\n\n\n\n\nboolean deleteSubnet\n\n\nDeletes the Subnet\n\n\n\n\n\n\nList\\\nString> getSubnetsExtIds\n\n\nReturns the list of SubnetsExtId\n\n\n\n\n\n\nDeploymentFlavour addFlavor\n\n\nAdds a new DeploymentFlavour\n\n\n\n\n\n\nDeploymentFlavour updateFlavor\n\n\nUpdates the DeploymentFlavour\n\n\n\n\n\n\nboolean deleteFlavor\n\n\nDeletes the DeploymentFlavour\n\n\n\n\n\n\nNFVImage addImage\n\n\nAdds a new NFVImage\n\n\n\n\n\n\nNFVImage updateImage\n\n\nUpdates the NFVImage\n\n\n\n\n\n\nNFVImage copyImage\n\n\nCopies the NFVImage\n\n\n\n\n\n\nboolean deleteImage\n\n\nDeletes the NFVImage\n\n\n\n\n\n\nQuota getQuota\n\n\nReturns the Quota\n\n\n\n\n\n\nString getType\n\n\nReturns the type\n\n\n\n\n\n\n\n\nAn example of the class:\n\n\npackage org.myplugin.example;\n\nimport org.openbaton.catalogue.mano.common.DeploymentFlavour;\nimport org.openbaton.catalogue.nfvo.*;\nimport org.openbaton.vim.drivers.exceptions.VimDriverException;\nimport org.openbaton.vim.drivers.interfaces.VimDriver;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.context.annotation.Scope;\nimport org.springframework.stereotype.Service;\n\nimport java.rmi.RemoteException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Set;\n\n@Service\n@Scope(\nprototype\n)\npublic class MyVim implements VimDriver{\n\n\n    private Logger log = LoggerFactory.getLogger(this.getClass());\n\n    @Override\n    public Server launchInstance(VimInstance vimInstance, String name, String image, String flavor, String keypair, Set\nString\n network, Set\nString\n secGroup, String userData) throws RemoteException {\n        // ...\n    }\n\n    @Override\n    public String getType(VimInstance vimInstance) {\n        // ...\n    }\n\n    @Override\n    public List\nNFVImage\n listImages(VimInstance vimInstance) {\n        // ...\n    }\n\n\n    // ...\n}\n\n\n\n\n2. Starter Class\n\n\nCreate another class and set the path to it in a variable \nmainClassName\n in \nbuild.gradle\n.\nThe starter class should be like the following:\n\n\npackage org.myplugin.example;\n\nimport org.openbaton.plugin.PluginStarter;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class Starter {\n\n    private static Logger log = LoggerFactory.getLogger(Starter.class);\n\n    public static void main(String[] args) {\n        log.info(\nparams are: pluginName registryIp registryPort\\ndefault is test localhost 1099\n);\n\n        if (args.length \n 1)\n            PluginStarter.run(MyVim.class, args[0], args[1], Integer.parseInt(args[2]));\n        else\n            PluginStarter.run(MyVim.class, \ntest\n, \nlocalhost\n, 1099);\n    }\n}\n\n\n\n\nRun your Vim plugin in OpenBaton environment\n\n\nUnder the folder of your project \nsrc/main/resources\n you should create a file \nplugin.conf.properties\n and write the variable \ntype = \nthe-vim-type\n.\nThe structure of your project should be like:\n\n\n\n\nNow you can run \n./gradlew build\n and Gradle will create the jar that you can find in the folder \nbuild/libs/myPlugin-1.0-SNAPSHOT.jar\n.\n\n\nOnce all these steps are done, you can copy and paste the \nmyPlugin-1.0-SNAPSHOT.jar\n under the folder specified in the \nopenbaton.properties\n (under \n/etc/openbaton\n folder) \nplugin-installation-dir\n property, as default NFVO/plugins.\n\n\nCongratulations you have your version of the interface for your Vim Instance that will be used by NFVO\n\n\nUse my plugin\n\n\nOnce you copied the jar file into the right folder, you need to (re)start the NFVO. The plugin will automatically register and you can see that there will be a log file in the NFVO folder called \nplugin-myPlugin.log\n containing the logs of the plugin. The myPlugin now acts as a normal plugin so for using it check out the \nVim instance documentation\n in order to point out to the new plugin.\n\n\nNOTE\n: Since you are using an implementation of \nRMI\n you can also launch your plugin from your command line just typing\n\n\n$ java -jar myPlugin-1.0-SNAPSHOT.jar [the-vim-type] [ip_NFVO] 1099\n\n\n\n\n\n\n\n\n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Write your own Plugin"
        }, 
        {
            "location": "/vim-plugin/#create-vim-plugin", 
            "text": "OpenBaton is an open source project providing a reference implementation of the NFVO and VNFM based on the ETSI specification, it is implemented in java using the spring.io framework. It consists of two main components: a NFVO and a generic VNFM. This project plugin-sdk contains modules that are needed to implement a plugin for OpenBaton system.", 
            "title": "Create Vim Plugin"
        }, 
        {
            "location": "/vim-plugin/#how-does-this-works", 
            "text": "An OpenBaton Plugin is a  RMI  Server that connects to the NFVO or any other rmiregistry with access to the OpenBaton catalogue as codebase. It offers an implementation of an interface that is used by the NFVO. By default the NFVO starts a rmiregistry at localhost:1099.", 
            "title": "How does this works?"
        }, 
        {
            "location": "/vim-plugin/#requirements", 
            "text": "Before you can start with developing your own Vim Plugin you need to prepare your programming environment by installing/configuring the following requirements:   JDK 7 ( installation )  Gradle ( installation )   Create a new project  Once you have started the IDE, click on File -  New -  Project...  In this dialog click on Gradle on the left and select java in the main properties window in the middle.   Then click on next to go to the next window.  In the next dialog you need to define the GroupId, ArtifactId and the Version.\nMore information on the specific meaning can be found  here .   Continue with the next dialog.  In this dialog you need to specify which gradle you want to use.\nIt is recommend to use the default gradle wrapper.\nAdditionally you can enable the auto-import.   Continue with the next dialog by clicking on Next.  In the last dialog, you need to define the project name and the project location.   Once this is done you can click on Finish and continue with creating the Main Class.  Create the Main Class  Afterwards, you need to create the Main Class of the VIM plugin which will be started in the end.\nFor doing so, right click on the root folder my-vim, then click on New -  Directory and insert what is show below.   Click on OK to continue.  Additionally you need to create a new package.\nThis is done by a right-click on the previously created directory java.\nClick on New -  Package.\nHere you can define the package name.   Finally you can create your MyVim Class by clicking (right click) on the previously created package and click on New -  Java Class.   Once you did all these steps, the initial project structure is created.\nWhat we miss right now is the configuration of the gradle files to define and fetch dependencies we need for implementing the Vim plugin.\nThis is described in later sections.  In order to create a VIM plugin for OpenBaton system you need to add to your  build.gradle  file:  \ngroup 'org.myplugin.example'\nversion '1.0-SNAPSHOT'\n\nbuildscript {\n    repositories {\n        mavenLocal()\n        mavenCentral()\n    }\n    dependencies {\n        classpath( org.springframework.boot:spring-boot-gradle-plugin:1.2.6.RELEASE )\n    }\n}\n\nrepositories {\n    maven { url  http://get.openbaton.org:8081/nexus/content/groups/public/  }\n}\n\napply plugin: 'java'\napply plugin: 'maven'\napply plugin: 'spring-boot'\n\n\nmainClassName = 'org.myplugin.example.Starter'\n\n\ndependencies {\n    compile 'org.openbaton:plugin-sdk:0.8'\n    compile'org.springframework:spring-context:4.2.1.RELEASE'\n}", 
            "title": "Requirements"
        }, 
        {
            "location": "/vim-plugin/#write-your-vim-plugin", 
            "text": "The Vim plugin is splitted into two classes    Implementation of  VimDriver  The  Starter Class  that contain the main function for bootstrapping the Vim plugin   Type of Vim Instance  OpenBaton expects only these three  type  of Vim Instance:   Test  OpenStack  Amazon   NOTE:  Your Vim plugin implementation  type  should be one of these to be launched and used by OpenBaton  1. Implement VimDriver  The  VimDriver  is an bastract class that contains tha basic functionality that a Vim Instance should be provide, and extends the  Remote Class .   NOTE : If you want to implement a Monitoring plugin, then you need to implement the Interface  ResourcePerformanceManagement  Your  MyVim  class will implement the methods inherited from  VimDriver  that manages your Vim Instance:     Function  Description      List\\ NFVImage> listImages  Returns the list of Images    List\\ Server> listServer  Returns the list of Servers    List\\ Network> listNetworks  Returns the list of Network    List\\ DeploymentFlavour> listFlavors  Returns the list of DeploymentFlavour    Server launchInstanceAndWait  Creates a new Server    void deleteServerByIdAndWait  Removes the Server with id    Network createNetwork  Creates a new Network    Network getNetworkById  Returns the Network with id    Network updateNetwork  Updates a new Network    boolean deleteNetwork  Deletes the Network    Subnet createSubnet  Creates a new Subnet    Subnet updateSubnet  Updates the Subnet    boolean deleteSubnet  Deletes the Subnet    List\\ String> getSubnetsExtIds  Returns the list of SubnetsExtId    DeploymentFlavour addFlavor  Adds a new DeploymentFlavour    DeploymentFlavour updateFlavor  Updates the DeploymentFlavour    boolean deleteFlavor  Deletes the DeploymentFlavour    NFVImage addImage  Adds a new NFVImage    NFVImage updateImage  Updates the NFVImage    NFVImage copyImage  Copies the NFVImage    boolean deleteImage  Deletes the NFVImage    Quota getQuota  Returns the Quota    String getType  Returns the type     An example of the class:  package org.myplugin.example;\n\nimport org.openbaton.catalogue.mano.common.DeploymentFlavour;\nimport org.openbaton.catalogue.nfvo.*;\nimport org.openbaton.vim.drivers.exceptions.VimDriverException;\nimport org.openbaton.vim.drivers.interfaces.VimDriver;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.context.annotation.Scope;\nimport org.springframework.stereotype.Service;\n\nimport java.rmi.RemoteException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Set;\n\n@Service\n@Scope( prototype )\npublic class MyVim implements VimDriver{\n\n\n    private Logger log = LoggerFactory.getLogger(this.getClass());\n\n    @Override\n    public Server launchInstance(VimInstance vimInstance, String name, String image, String flavor, String keypair, Set String  network, Set String  secGroup, String userData) throws RemoteException {\n        // ...\n    }\n\n    @Override\n    public String getType(VimInstance vimInstance) {\n        // ...\n    }\n\n    @Override\n    public List NFVImage  listImages(VimInstance vimInstance) {\n        // ...\n    }\n\n\n    // ...\n}  2. Starter Class  Create another class and set the path to it in a variable  mainClassName  in  build.gradle .\nThe starter class should be like the following:  package org.myplugin.example;\n\nimport org.openbaton.plugin.PluginStarter;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class Starter {\n\n    private static Logger log = LoggerFactory.getLogger(Starter.class);\n\n    public static void main(String[] args) {\n        log.info( params are: pluginName registryIp registryPort\\ndefault is test localhost 1099 );\n\n        if (args.length   1)\n            PluginStarter.run(MyVim.class, args[0], args[1], Integer.parseInt(args[2]));\n        else\n            PluginStarter.run(MyVim.class,  test ,  localhost , 1099);\n    }\n}", 
            "title": "Write your Vim plugin"
        }, 
        {
            "location": "/vim-plugin/#run-your-vim-plugin-in-openbaton-environment", 
            "text": "Under the folder of your project  src/main/resources  you should create a file  plugin.conf.properties  and write the variable  type =  the-vim-type .\nThe structure of your project should be like:   Now you can run  ./gradlew build  and Gradle will create the jar that you can find in the folder  build/libs/myPlugin-1.0-SNAPSHOT.jar .  Once all these steps are done, you can copy and paste the  myPlugin-1.0-SNAPSHOT.jar  under the folder specified in the  openbaton.properties  (under  /etc/openbaton  folder)  plugin-installation-dir  property, as default NFVO/plugins.  Congratulations you have your version of the interface for your Vim Instance that will be used by NFVO", 
            "title": "Run your Vim plugin in OpenBaton environment"
        }, 
        {
            "location": "/vim-plugin/#use-my-plugin", 
            "text": "Once you copied the jar file into the right folder, you need to (re)start the NFVO. The plugin will automatically register and you can see that there will be a log file in the NFVO folder called  plugin-myPlugin.log  containing the logs of the plugin. The myPlugin now acts as a normal plugin so for using it check out the  Vim instance documentation  in order to point out to the new plugin.  NOTE : Since you are using an implementation of  RMI  you can also launch your plugin from your command line just typing  $ java -jar myPlugin-1.0-SNAPSHOT.jar [the-vim-type] [ip_NFVO] 1099   \n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Use my plugin"
        }, 
        {
            "location": "/FAQ/", 
            "text": "Frequently Asked Questions (FAQ)\n\n\nQ1 ActiveMQ:connection refused\n\n\nI'm getting this error message: \n\n\n2015-10-01 11:40:49.475 ERROR 26648 --- [enerContainer-1] o.s.j.l.DefaultMessageListenerContainer  : Could not refresh JMS Connection for destination 'event-register' - retrying using FixedBackOff{interval=5000, currentAttempts=1, maxAttempts=unlimited}. Cause: Could not connect to broker URL: tcp://localhost:61616. Reason: java.net.ConnectException: Connection refused\n\n\n\n\nAnswer: double check that ActiveMQ is up and running: \n\n\napache-activemq-5.11.1/bin/activemq status\n\n\n\n\nif not running, you need to start it. \n\n\nQ2 What type of database is the NFVO using?\n\n\nThe NFVO uses Hibernate for managing transactions with a relational database. By default the NFVO is configured with an in memory database (HSQL). \nOther types of databases are supported, for instance MySQL. This can be changed directly from the configuration file, outcommenting the : \n\n\n# mysql jdbc\nspring.datasource.url=jdbc:mysql://localhost:3306/openbaton\nspring.datasource.driver-class-name=com.mysql.jdbc.Driver\nspring.jpa.database-platform=org.hibernate.dialect.MySQLDialect\n\n\n\n\n\n\n\n\n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "FAQ"
        }, 
        {
            "location": "/FAQ/#frequently-asked-questions-faq", 
            "text": "Q1 ActiveMQ:connection refused  I'm getting this error message:   2015-10-01 11:40:49.475 ERROR 26648 --- [enerContainer-1] o.s.j.l.DefaultMessageListenerContainer  : Could not refresh JMS Connection for destination 'event-register' - retrying using FixedBackOff{interval=5000, currentAttempts=1, maxAttempts=unlimited}. Cause: Could not connect to broker URL: tcp://localhost:61616. Reason: java.net.ConnectException: Connection refused  Answer: double check that ActiveMQ is up and running:   apache-activemq-5.11.1/bin/activemq status  if not running, you need to start it.   Q2 What type of database is the NFVO using?  The NFVO uses Hibernate for managing transactions with a relational database. By default the NFVO is configured with an in memory database (HSQL). \nOther types of databases are supported, for instance MySQL. This can be changed directly from the configuration file, outcommenting the :   # mysql jdbc\nspring.datasource.url=jdbc:mysql://localhost:3306/openbaton\nspring.datasource.driver-class-name=com.mysql.jdbc.Driver\nspring.jpa.database-platform=org.hibernate.dialect.MySQLDialect   \n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Frequently Asked Questions (FAQ)"
        }, 
        {
            "location": "/vnf-descriptor/", 
            "text": "Virtual Network Function Descriptor\n\n\nThe VirtualNetworkFunctionDescriptor is contained inside the Network Service Descriptor (NSD). It is a json file and is defined as follows:\n\n\n{  \n    \nvendor\n:\nfokus\n,\n    \nversion\n:\n0.2\n,\n    \nname\n:\niperf-server\n,\n    \ntype\n:\nserver\n,\n    \nendpoint\n:\ngeneric\n,\n    \nconfigurations\n:{\n        \nname\n:\nconfig_name\n,\n        \nconfigurationParameters\n:[\n        {\n            \nconfKey\n:\nkey\n,\n            \nvalue\n:\nvalue\n\n        }\n        ]\n    },\n    \nvdu\n:[  \n        {  \n            \nvm_image\n:[  \n                \nubuntu-14.04-server-cloudimg-amd64-disk1\n\n            ],\n            \nvimInstanceName\n:\nvim-instance\n,\n            \nscale_in_out\n:2,\n            \nvnfc\n:[  \n                {  \n                    \nexposed\n:true,\n                    \nconnection_point\n:[  \n                        {  \n                            \nvirtual_link_reference\n:\nprivate\n\n                        }\n                    ]\n                }\n            ]\n        }\n    ],\n    \nvirtual_link\n:[  \n        {  \n            \nname\n:\nprivate\n\n        }\n    ],\n    \nlifecycle_event\n:[  \n        {  \n            \nevent\n:\nINSTANTIATE\n,\n            \nlifecycle_events\n:[  \n                \ninstall.sh\n,\n                \ninstall-srv.sh\n\n            ]\n        }\n    ],\n    \ndeployment_flavour\n:[  \n        {  \n            \nflavour_key\n:\nm1.small\n\n        }\n    ],\n    \nprovides\n:[\n        \nip\n,\n        \nsource\n,\n        \nparam1\n,\n        \nparam2\n\n      ]\n}\n\n\n\n\n\n\n\n\n\n\nParams\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\nname\n\n\nThe name to give to the VirtualNetworkFunctionDescriptor\n\n\n\n\n\n\nvendor\n\n\nThe vendor creating this VirtualNetworkFunctionDescriptor\n\n\n\n\n\n\nversion\n\n\nThe version of the VirtualNetworkFunctionDescriptor (can be any string)\n\n\n\n\n\n\ntype\n\n\nThe type of the VirtualNetworkFunctionDescriptor (can be any string) and it is used in the dependency parameters in the scripts\n\n\n\n\n\n\nendpoint\n\n\nThe endpoint of the VirtualNetworkFunctionDescriptor (can be any string) needs to point to a registered VnfManager\n\n\n\n\n\n\n\n\nThe other most important parameters are described in the following sections.\n\n\nVirtual Deployment Unit (VDU)\n\n\n\n\n\n\n\n\nParams\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\nvm_image\n\n\nThe list of image names or ids existing in the VimInstance or in the VNF Package\n\n\n\n\n\n\nvimInstanceName\n\n\nThe VimInstance name chosen\n\n\n\n\n\n\nscale_in_out\n\n\nThe maximum number of instances (VMs) which can be created to support scale out/in.\n\n\n\n\n\n\nvnfc\n\n\nThis field contains a list of VNFComponents which will be deployed for this VNFD.\n\n\n\n\n\n\n\n\nVNFC\n\n\nAfter launching a network service, every VNFComponent will run on a separate virtual machine. If scaling is enabled by the scale_in_out field in the VDU, the number of instantiated VNFCs can increase.\nVNFCs contain the following fields:\n\n\n\n\n\n\n\n\nParams\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\nexposed\n\n\nin case the machine needs to be reachable\n\n\n\n\n\n\nconnection_point\n\n\neach connection point is a reference to an Internal Virtual Link (see Connection Point at \nETSI NFV\n)\n\n\n\n\n\n\n\n\nConfigurations\n\n\nThe configuration object contains a list of parameters defined by key, value that can be used in the scripts (see \nVNF Parameters\n).\n\n\nVirtual Link (aka Internal Virtual Link)\n\n\nThe Internal Virtual Link points to a Virtual Link Descriptor defined in the Network Service Descriptor.\n\n\nNote:\n at the moment there are no difference between internal and external VL. All the available networks should be specified in the NSD-\nVLD, then in the VNFD-\nVL you specify which networks you want to use.\nFinally in the VNFD-\nVDU-\nVNFC-\nconnection_point you can specify which network to attach among those available in VNFD-\nVL. The virtual_link_reference parameter also must be filled with the exact same links.\n\n\nLifecycle Events\n\n\nA lifecycle event is composed by an Event and a list of strings that correspond to the script names needed to be run in that particular Event.\n\n\nDeployment Flavour\n\n\nA delpoyment flavour corresponds to a flavour name existing in the VimInstance.\nFor example if you are using Openstack as Vim, the flavour_key parameter shall correspond to a \nflavour name of Openstack\n (e.q. m1.small).\n\n\nProvides, Requires\n\n\nThis list of parameter names defines the parameters that the VnfManager will fill at runtime. For that reason they have a meaning only if you \nwrite your own VnfManager\n. This parameters are then available in any scripts. For the usage of the parameters, please, refer to \nHow to use the parameters\n page.\n\n\n\n\n\n\n\n\n\n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "**HIDDEN**"
        }, 
        {
            "location": "/vnf-descriptor/#virtual-network-function-descriptor", 
            "text": "The VirtualNetworkFunctionDescriptor is contained inside the Network Service Descriptor (NSD). It is a json file and is defined as follows:  {  \n     vendor : fokus ,\n     version : 0.2 ,\n     name : iperf-server ,\n     type : server ,\n     endpoint : generic ,\n     configurations :{\n         name : config_name ,\n         configurationParameters :[\n        {\n             confKey : key ,\n             value : value \n        }\n        ]\n    },\n     vdu :[  \n        {  \n             vm_image :[  \n                 ubuntu-14.04-server-cloudimg-amd64-disk1 \n            ],\n             vimInstanceName : vim-instance ,\n             scale_in_out :2,\n             vnfc :[  \n                {  \n                     exposed :true,\n                     connection_point :[  \n                        {  \n                             virtual_link_reference : private \n                        }\n                    ]\n                }\n            ]\n        }\n    ],\n     virtual_link :[  \n        {  \n             name : private \n        }\n    ],\n     lifecycle_event :[  \n        {  \n             event : INSTANTIATE ,\n             lifecycle_events :[  \n                 install.sh ,\n                 install-srv.sh \n            ]\n        }\n    ],\n     deployment_flavour :[  \n        {  \n             flavour_key : m1.small \n        }\n    ],\n     provides :[\n         ip ,\n         source ,\n         param1 ,\n         param2 \n      ]\n}     Params  Meaning      name  The name to give to the VirtualNetworkFunctionDescriptor    vendor  The vendor creating this VirtualNetworkFunctionDescriptor    version  The version of the VirtualNetworkFunctionDescriptor (can be any string)    type  The type of the VirtualNetworkFunctionDescriptor (can be any string) and it is used in the dependency parameters in the scripts    endpoint  The endpoint of the VirtualNetworkFunctionDescriptor (can be any string) needs to point to a registered VnfManager     The other most important parameters are described in the following sections.  Virtual Deployment Unit (VDU)     Params  Meaning      vm_image  The list of image names or ids existing in the VimInstance or in the VNF Package    vimInstanceName  The VimInstance name chosen    scale_in_out  The maximum number of instances (VMs) which can be created to support scale out/in.    vnfc  This field contains a list of VNFComponents which will be deployed for this VNFD.     VNFC  After launching a network service, every VNFComponent will run on a separate virtual machine. If scaling is enabled by the scale_in_out field in the VDU, the number of instantiated VNFCs can increase.\nVNFCs contain the following fields:     Params  Meaning      exposed  in case the machine needs to be reachable    connection_point  each connection point is a reference to an Internal Virtual Link (see Connection Point at  ETSI NFV )     Configurations  The configuration object contains a list of parameters defined by key, value that can be used in the scripts (see  VNF Parameters ).  Virtual Link (aka Internal Virtual Link)  The Internal Virtual Link points to a Virtual Link Descriptor defined in the Network Service Descriptor.  Note:  at the moment there are no difference between internal and external VL. All the available networks should be specified in the NSD- VLD, then in the VNFD- VL you specify which networks you want to use.\nFinally in the VNFD- VDU- VNFC- connection_point you can specify which network to attach among those available in VNFD- VL. The virtual_link_reference parameter also must be filled with the exact same links.  Lifecycle Events  A lifecycle event is composed by an Event and a list of strings that correspond to the script names needed to be run in that particular Event.  Deployment Flavour  A delpoyment flavour corresponds to a flavour name existing in the VimInstance.\nFor example if you are using Openstack as Vim, the flavour_key parameter shall correspond to a  flavour name of Openstack  (e.q. m1.small).  Provides, Requires  This list of parameter names defines the parameters that the VnfManager will fill at runtime. For that reason they have a meaning only if you  write your own VnfManager . This parameters are then available in any scripts. For the usage of the parameters, please, refer to  How to use the parameters  page.    \n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Virtual Network Function Descriptor"
        }, 
        {
            "location": "/vnfr-states/", 
            "text": "VNF Record States\n\n\n\n\nThe states of a VNF Record are reflecting the \nETSI NFV states\n and they are shown in the following picture.\n\n\n\n\nWhen the create NSR is called the VNF and the NSR are in state NULL. After the instantiate method is finished in the VNFManager, the corresponding VNFR state is set to INSTANTIATED. When all the VNFR are in state INSTANTIATED then also the NSR goes in state INSTANTIATED. Then in case the VNFR is target of a dependency, the MODIFY message is sent to the VNFManager and when it comes back to the NFVO, the VNFR status is set to INACTIVE. When all the VNFR are in state INACTIVE then also the NSR goes in state INACTIVE. In any case the START message is sent to the VNFManager and when it comes back, the NFVO set the VNFR state to ACTIVE. When all the VNFR are in state ACTIVE then also the NSR goes in state ACTIVE. Then when the terminate NSR is called, the NFVO sends to all the VNFManagers the TERMINATE message. When this message returns to the NFVO, the related VNFR state is set to TERMINATED. When all the VNFR are in state TERMINATED then the NSR is completely deleted from the database.\n\n\n\n\n\n\n\n\n\n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "**HIDDEN**"
        }, 
        {
            "location": "/vnfr-states/#vnf-record-states", 
            "text": "The states of a VNF Record are reflecting the  ETSI NFV states  and they are shown in the following picture.   When the create NSR is called the VNF and the NSR are in state NULL. After the instantiate method is finished in the VNFManager, the corresponding VNFR state is set to INSTANTIATED. When all the VNFR are in state INSTANTIATED then also the NSR goes in state INSTANTIATED. Then in case the VNFR is target of a dependency, the MODIFY message is sent to the VNFManager and when it comes back to the NFVO, the VNFR status is set to INACTIVE. When all the VNFR are in state INACTIVE then also the NSR goes in state INACTIVE. In any case the START message is sent to the VNFManager and when it comes back, the NFVO set the VNFR state to ACTIVE. When all the VNFR are in state ACTIVE then also the NSR goes in state ACTIVE. Then when the terminate NSR is called, the NFVO sends to all the VNFManagers the TERMINATE message. When this message returns to the NFVO, the related VNFR state is set to TERMINATED. When all the VNFR are in state TERMINATED then the NSR is completely deleted from the database.    \n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "VNF Record States"
        }, 
        {
            "location": "/vnf-parameters/", 
            "text": "VNF Parameters\n\n\n\n\nThe useful parameters that you can use in your scripts are defined in two different fields of a VNFD.\n\n\n...\n\nconfigurations\n:{\n                \nname\n:\nconfig_name\n,\n                \nconfigurationParameters\n:[\n                {\n                    \nconfKey\n:\nkey1\n,\n                    \nvalue\n:\nthe_value\n\n                }\n                ]\n            },\n\n...\n\n\nprovides\n:[\n        \nparam1\n,\n        \nparam2\n\n      ]\n...\n\n\n\n\nConfigurations\n\n\nThis field describes an Entity that has a list of ConfigurationParameters inside. This is a list of Entities containing key:value. These parameters are always available in your scripts. See the section below, \nhow to use the parameters\n, in order to see how to use them.\n\n\nProvides\n\n\nThis field is a list of parameter keys that will be available in all your scripts. The difference is that these parameters are parameters whose actual value will be known only at runtime. For that reason these parameters can only be filled by a specific VNFM. So you need to implement a VNFM able to handle these specific parameters in the fillSpecificParameters method (see \nHow to write a VNFM\n).\n\n\nNOTE\n: \nthere are some out-of-the-box parameters that will be added automatically to the VNFRecord. One of these parameters is key = \n network_name \n, value = \n actual-IP \n\n\nHow to use the parameters\n\n\nAll the above parameters are available in all the scripts of the VNF that defines them. You just need to use them as environment variables, a script of the INSTANTIATE lifecycle event for instance would be:\n\n\n#!/bin/bash\n\necho \nthe value of the configuration parameter key1 is $key1\n\n\n\n\n\nAs described in the \nGeneric VNFM\n page, you can set up dependencies in order to use parameters from another VNF in the MODIFY lifecycle event. For doing that you need to specify in the Network Service Descriptor the VNF Dependency, for instance if a VNF vnf-1 is connected to network net1 and vnf-2 needs the ip of vnf-1 on that network the VNF Dependency will be:\n\n\n\n\nvnf_dependency\n:[\n        {\n            \nsource\n : {\n                \nname\n: \nvnf-1\n\n            },\n            \ntarget\n:{\n                \nname\n: \nvnf-2\n\n            },\n            \nparameters\n:[\n                \nnet1\n\n            ]\n        }\n    ]\n\n\n\n\n\nDone that, in the MODIFY scripts it is possible to use that ip in this way:\n\n\n#!/bin/bash\n\necho \nthe value of the ip on net1 of vnf-1 is $vnf1type_net1\n\n\n\n\n\nConclusion\n\n\nYou are always able to use the parameters of a VNF simply using the key as variable name, but when you want to use a parameter of a different VNF (like a relation) you need to specify the type followed by an underscore and then the name of the foreign parameter key (for instance \n$typeExt_key\n). In this last case, you can use them only in the MODIFY lifecycle event scripts.\n\n\n\n\n\n\n\n\n\n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "**HIDDEN**"
        }, 
        {
            "location": "/vnf-parameters/#vnf-parameters", 
            "text": "The useful parameters that you can use in your scripts are defined in two different fields of a VNFD.  ... configurations :{\n                 name : config_name ,\n                 configurationParameters :[\n                {\n                     confKey : key1 ,\n                     value : the_value \n                }\n                ]\n            },\n\n... provides :[\n         param1 ,\n         param2 \n      ]\n...  Configurations  This field describes an Entity that has a list of ConfigurationParameters inside. This is a list of Entities containing key:value. These parameters are always available in your scripts. See the section below,  how to use the parameters , in order to see how to use them.  Provides  This field is a list of parameter keys that will be available in all your scripts. The difference is that these parameters are parameters whose actual value will be known only at runtime. For that reason these parameters can only be filled by a specific VNFM. So you need to implement a VNFM able to handle these specific parameters in the fillSpecificParameters method (see  How to write a VNFM ).  NOTE :  there are some out-of-the-box parameters that will be added automatically to the VNFRecord. One of these parameters is key =   network_name  , value =   actual-IP   How to use the parameters  All the above parameters are available in all the scripts of the VNF that defines them. You just need to use them as environment variables, a script of the INSTANTIATE lifecycle event for instance would be:  #!/bin/bash\n\necho  the value of the configuration parameter key1 is $key1   As described in the  Generic VNFM  page, you can set up dependencies in order to use parameters from another VNF in the MODIFY lifecycle event. For doing that you need to specify in the Network Service Descriptor the VNF Dependency, for instance if a VNF vnf-1 is connected to network net1 and vnf-2 needs the ip of vnf-1 on that network the VNF Dependency will be:   vnf_dependency :[\n        {\n             source  : {\n                 name :  vnf-1 \n            },\n             target :{\n                 name :  vnf-2 \n            },\n             parameters :[\n                 net1 \n            ]\n        }\n    ]  Done that, in the MODIFY scripts it is possible to use that ip in this way:  #!/bin/bash\n\necho  the value of the ip on net1 of vnf-1 is $vnf1type_net1   Conclusion  You are always able to use the parameters of a VNF simply using the key as variable name, but when you want to use a parameter of a different VNF (like a relation) you need to specify the type followed by an underscore and then the name of the foreign parameter key (for instance  $typeExt_key ). In this last case, you can use them only in the MODIFY lifecycle event scripts.    \n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "VNF Parameters"
        }, 
        {
            "location": "/nsd-json-example/", 
            "text": "This network service is composed by two VNF (iperf-server and iperf-client), which the iperf-client is composed by two VNFC.\n\n\nNote:\n no vnf package is used in this example. Only a link to reach the scripts. Basically could be a link to a git repository in which there are all the scripts.\n\n\n{\n   \nname\n:\niperf-NS\n,\n   \nvendor\n:\ntbr\n,\n   \nversion\n:\n0.1\n,\n   \nvnfd\n:[\n      {\n         \nvendor\n:\ntbr\n,\n         \nversion\n:\n0.1\n,\n         \nname\n:\niperf-server\n,\n         \ntype\n:\nserver\n,\n         \nendpoint\n:\ngeneric\n,\n         \nconfigurations\n:{\n            \nname\n:\nconfig_name\n,\n            \nconfigurationParameters\n:[]\n         },\n         \nvdu\n:[\n            {\n               \nvm_image\n:[\n                  \nubuntu-14.04-server-cloudimg-amd64-disk1\n\n               ],\n               \nvimInstanceName\n:\nvim-instance\n,\n               \nscale_in_out\n:1,\n               \nvnfc\n:[\n                  {\n                     \nexposed\n:true,\n                     \nconnection_point\n:[\n                        {\n                           \nvirtual_link_reference\n:\nprivate\n\n                        }\n                     ]\n                  }\n               ]\n            }\n         ],\n         \nvirtual_link\n:[\n            {\n               \nname\n:\nprivate\n\n            }\n         ],\n         \nlifecycle_event\n:[\n            {\n               \nevent\n:\nINSTANTIATE\n,\n               \nlifecycle_events\n:[\n                  \ninstall.sh\n,\n          \nstart-srv.sh\n\n               ]\n            }\n         ],\n         \ndeployment_flavour\n:[\n            {\n               \nflavour_key\n:\nm1.small\n\n            }\n         ],\n         \nvnfPackage\n:{\n            \nscriptsLink\n:\nhttps://ENTER A VALID LINK TO REACH THE SCRIPTS\n\n         }\n      },\n      {\n         \nvendor\n:\ntbr\n,\n         \nversion\n:\n0.1\n,\n         \nname\n:\niperf-client\n,\n         \ntype\n:\nclient\n,\n         \nendpoint\n:\ngeneric\n,\n         \nconfigurations\n:{\n            \nname\n:\nconfig_name\n,\n            \nconfigurationParameters\n:[\n\n            ]\n         },\n         \nvdu\n:[\n            {\n               \nvm_image\n:[\n                  \nubuntu-14.04-server-cloudimg-amd64-disk1\n\n               ],\n               \nvimInstanceName\n:\nvim-instance\n,\n               \nscale_in_out\n:2,\n               \nvnfc\n:[\n                  {\n                     \nexposed\n:true,\n                     \nconnection_point\n:[\n                        {\n                           \nvirtual_link_reference\n:\nprivate\n\n                        }\n                     ]\n                  },\n                  {\n                     \nexposed\n:true,\n                     \nconnection_point\n:[\n                        {\n                           \nvirtual_link_reference\n:\nprivate\n\n                        }\n                     ]\n                  }\n               ]\n            }\n         ],\n         \nvirtual_link\n:[\n            {\n               \nname\n:\nprivate\n\n            }\n         ],\n         \nlifecycle_event\n:[\n            {\n               \nevent\n:\nINSTANTIATE\n,\n               \nlifecycle_events\n:[\n                  \ninstall.sh\n\n               ]\n            },\n            {\n               \nevent\n:\nCONFIGURE\n,\n               \nlifecycle_events\n:[\n                  \nserver_start-clt.sh\n\n               ]\n            }\n         ],\n         \ndeployment_flavour\n:[\n            {\n               \nflavour_key\n:\nm1.small\n\n            }\n         ],\n         \nvnfPackage\n:{\n            \nscriptsLink\n:\nhttps://ENTER A VALID LINK TO REACH THE SCRIPTS\n\n         }\n      }\n   ],\n   \nvnffgd\n:[\n\n   ],\n   \nvld\n:[\n      {\n         \nname\n:\nprivate\n\n      }\n   ],\n   \nvnf_dependency\n:[\n      {\n         \nsource\n:{\n            \nname\n:\niperf-server\n\n         },\n         \ntarget\n:{\n            \nname\n:\niperf-client\n\n         },\n         \nparameters\n:[\n            \nprivate\n\n         ]\n      }\n   ]\n}", 
            "title": "**HIDDEN**"
        }
    ]
}