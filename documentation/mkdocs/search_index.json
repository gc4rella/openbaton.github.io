{
    "docs": [
        {
            "location": "/", 
            "text": "OpenBaton\n\n\nOpenBaton is an open source project providing a comprehensive implementation of the ETSI Management and Orchestration (MANO) specification. \n\n\nWhat is NFV\n\n\nETSI NFV represents a concerted telco operator initiative fostering the development of virtual network infrastructures by porting and further adapting network functions to the specific cloud environment. \nETSI NFV has defined a large set of virtualisation use cases, spanning from the cloudification of the main core network functions such as IMS, Evolved Packet Core, and Radio Access Networks, as well as providing on demand and complete virtualised infrastructures as IaaS or PaaS to third parties, such as enterprises and professional radio. \nThat enables providing elastic deployments of cost efficient network infrastructures.\nOne of the main concerns of ETSI NFV is to prove the feasibility of the cloud deployments of the typical network functions through proof of concept trials and prototypes as well as providing indications for further standardization in the areas of underlying infrastructures, software architectures, networking and management, and orchestration to improve performance and grant security of the overall infrastructure.\nETSI NFV limits itself to this level of indications, considering that other standardization bodies and de-facto open source standards such as 3GPP and OpenStack should finalize the specific implementation work. \n\n\nIts main components\n\n\nOpenBaton provides the following components: \n\n\n\n\nA Network Function Virtualisation Orchestrator (NFVO) completely designed and implemented following the ETSI MANO specification\n\n\nA generic Virtual Network Function Manager (VNFM) able to manage the lifecycle of VNFs based on their descriptors\n\n\nA set of libraries which could be used for building your own VNFM\n\n\n\n\nCan I plug in my Network Functions?\n\n\nYes, this is possible using two different approaches:\n\n\n\n\nintegrating your own VNFM. In this case you can use either the REST interface, or the JMS one for interoperating with the NFVO\n\n\nimplementing a set of scripts which can be executed as part of the lifecycle event of your Virtual Network Function Descriptor. We provide a generic VNFM and EMS which can be used for executing them\n\n\n\n\nCan I use OpenBaton to build my own Network Service?\n\n\nYes! OpenBaton provides a NFVO which can interoperate with VNFMs implemented by third parties. In this project we provide also a set of tools (like the vnfm-sdk) which supports developers in building their own VNFM. \n\n\nGet started\n\n\nIn order to get started you can follow the \ninstallation guide\n\n\nGet in contact\n\n\n\n\nVia twitter: \ntwitter\n\n\nSubscribing to our mailing list: \nusers-at-openbaton-dot-org\n\n\nSending us an email to: \ninfo-at-openbaton-dot-org\n\n\n\n\n\n\n\n\n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Get Started"
        }, 
        {
            "location": "/#openbaton", 
            "text": "OpenBaton is an open source project providing a comprehensive implementation of the ETSI Management and Orchestration (MANO) specification.", 
            "title": "OpenBaton"
        }, 
        {
            "location": "/#what-is-nfv", 
            "text": "ETSI NFV represents a concerted telco operator initiative fostering the development of virtual network infrastructures by porting and further adapting network functions to the specific cloud environment. \nETSI NFV has defined a large set of virtualisation use cases, spanning from the cloudification of the main core network functions such as IMS, Evolved Packet Core, and Radio Access Networks, as well as providing on demand and complete virtualised infrastructures as IaaS or PaaS to third parties, such as enterprises and professional radio. \nThat enables providing elastic deployments of cost efficient network infrastructures.\nOne of the main concerns of ETSI NFV is to prove the feasibility of the cloud deployments of the typical network functions through proof of concept trials and prototypes as well as providing indications for further standardization in the areas of underlying infrastructures, software architectures, networking and management, and orchestration to improve performance and grant security of the overall infrastructure.\nETSI NFV limits itself to this level of indications, considering that other standardization bodies and de-facto open source standards such as 3GPP and OpenStack should finalize the specific implementation work.", 
            "title": "What is NFV"
        }, 
        {
            "location": "/#its-main-components", 
            "text": "OpenBaton provides the following components:    A Network Function Virtualisation Orchestrator (NFVO) completely designed and implemented following the ETSI MANO specification  A generic Virtual Network Function Manager (VNFM) able to manage the lifecycle of VNFs based on their descriptors  A set of libraries which could be used for building your own VNFM", 
            "title": "Its main components"
        }, 
        {
            "location": "/#can-i-plug-in-my-network-functions", 
            "text": "Yes, this is possible using two different approaches:   integrating your own VNFM. In this case you can use either the REST interface, or the JMS one for interoperating with the NFVO  implementing a set of scripts which can be executed as part of the lifecycle event of your Virtual Network Function Descriptor. We provide a generic VNFM and EMS which can be used for executing them", 
            "title": "Can I plug in my Network Functions?"
        }, 
        {
            "location": "/#can-i-use-openbaton-to-build-my-own-network-service", 
            "text": "Yes! OpenBaton provides a NFVO which can interoperate with VNFMs implemented by third parties. In this project we provide also a set of tools (like the vnfm-sdk) which supports developers in building their own VNFM.", 
            "title": "Can I use OpenBaton to build my own Network Service?"
        }, 
        {
            "location": "/#get-started", 
            "text": "In order to get started you can follow the  installation guide", 
            "title": "Get started"
        }, 
        {
            "location": "/#get-in-contact", 
            "text": "Via twitter:  twitter  Subscribing to our mailing list:  users-at-openbaton-dot-org  Sending us an email to:  info-at-openbaton-dot-org    \n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Get in contact"
        }, 
        {
            "location": "/install/", 
            "text": "Install OpenBaton\n\n\nThis how-to will walk you through getting started with OpenBaton. In particular it will show you how you can setup and configure its main components. It will also show you how to write your Network Service Descriptor and create your own Virtual Network Function Package and deploy it on your PoPs. \n\n\nOpenBaton comprises different components:\n\n\n\n\nthe Network Function Virtualisation Orchestrator (NFVO), always required for creating a composition of differnet Virtual Network Function Descriptors\n\n\ngeneric-VNFM, needed only when the VNFP approach is used. Using the generic-VNFM implies also the usage of the EMS which is automatically installed on the VDUs where VNF are to be installed. \n\n\n\n\n\n\nBefore you start\n\n\nFirst of all it is important to clarify the different deployment options. Depending on your requirements OpenBaton, using a plugin mechanism, supports different VIM implementations. In particular, in this relesae, two different vim plugins are available: \n\n\n\n\ntest-plugin: it is a mockup of the VIM interface which is quite useful for development. It basically does not create any real virtual resources and it can be used for developing new features on the NFVO without having to always deploy new services;\n\n\nopenstack-plugin: it provides an implementation of the VIM interface to OpenStack for requesting resources. \n\n\n\n\nDepending on which one is your target provider, you will need to configure runtime different Point of Presence (PoP). This is something which will be explained later on in this user guide. \n\n\nLet's move on\n\n\nNext step is to \ninstall the NFVO\n.\n\n\n\n\n\n\n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Overview"
        }, 
        {
            "location": "/install/#install-openbaton", 
            "text": "This how-to will walk you through getting started with OpenBaton. In particular it will show you how you can setup and configure its main components. It will also show you how to write your Network Service Descriptor and create your own Virtual Network Function Package and deploy it on your PoPs.   OpenBaton comprises different components:   the Network Function Virtualisation Orchestrator (NFVO), always required for creating a composition of differnet Virtual Network Function Descriptors  generic-VNFM, needed only when the VNFP approach is used. Using the generic-VNFM implies also the usage of the EMS which is automatically installed on the VDUs where VNF are to be installed.     Before you start  First of all it is important to clarify the different deployment options. Depending on your requirements OpenBaton, using a plugin mechanism, supports different VIM implementations. In particular, in this relesae, two different vim plugins are available:    test-plugin: it is a mockup of the VIM interface which is quite useful for development. It basically does not create any real virtual resources and it can be used for developing new features on the NFVO without having to always deploy new services;  openstack-plugin: it provides an implementation of the VIM interface to OpenStack for requesting resources.    Depending on which one is your target provider, you will need to configure runtime different Point of Presence (PoP). This is something which will be explained later on in this user guide.   Let's move on  Next step is to  install the NFVO .   \n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Install OpenBaton"
        }, 
        {
            "location": "/nfvo-installation/", 
            "text": "Install NFVO\n\n\nThe NFVO is implemented in java using the \nspring.io\n framework. For more details about the NFVO architecture, you can refer to the extend it section.\n\n\nInstall the latest NFVO version from the source code\n\n\nThe NFVO can be installed using different mechanisms. In this how to we will show you how to instantiate it using directly from the git repo. \n\n\nThe NFVO uses the AMQP protocol for communicating with the VNFMs. Therefore an implementation of it is necessary, we chose \nRabbitMQ\n.\nTo facilitate the installation procedures we provide an installation script which can be used for installing the NFVO and the prerequired libraries.\nConsidering that this script needs to install some system libraries, it is required to execute it as super user.\nTo execute the following command you need to have curl installed (see http://curl.haxx.se/). \n\n\nsudo su -\nbash \n(curl -fsSkL http://get.openbaton.org/bootstrap)\n\n\n\n\nAt the end of the installation procedure, if there are no errors, the dashboard is reachable at: \nlocalhost:8080\n and you should have the following structure:\n\n\n/opt/openbaton/\n\u251c\u2500\u2500 generic-vnfm\n\u2514\u2500\u2500 nfvo\n\n\n\n\nWhere:\n\n\n\n\ngeneric-vnfm\ncontains the source code and scripts required for dealing with the generic-vnfm  \n\n\nnfvo\n contains the source code and scripts of the NFVO\n\n\n\n\nAt this point the NFVO is ready to be used. Please refer to the \nIntroduction\n on how to start using it.\n\n\nStarting and stopping NFVO\n\n\nAfter the installation procedure the nfvo is running. If you want to stop it, enter this command:\n\n\ncd /opt/openbaton/nfvo\n./openbaton.sh stop\n\n\n\n\nNote (in case you are also using the generic-vnfm):\n remember to stop also the Generic VNFM with the following command:\n\n\ncd /opt/openbaton/generic-vnfm\n./generic-vnfm.sh stop\n\n\n\n\nTo start the nfvo, enter the command:\n\n\ncd /opt/openbaton/nfvo\n./openbaton.sh start\n\n\n\n\nNote (in case you are also using the generic-vnfm):\n remember to start also the Generic VNFM with the following command:\n\n\ncd /opt/openbaton/generic-vnfm\n./generic-vnfm.sh start\n\n\n\n\nNFVO properties overview\n\n\nThe NFVO is configured with default configuration parameters at the beginning. The configuration file is located at: \n\n\n/etc/openbaton/openbaton.properties\n\n\n\n\nThis file can be modified for specific parameters. For instance, you can decide to change logging levels (TRACE, DEBUG, INFO, WARN, and ERROR) and mechanisms:\n\n\nlogging.level.org.springframework=INFO\nlogging.level.org.hibernate=INFO\nlogging.level.org.apache=INFO\nlogging.level.org.jclouds=WARN\n# logging.level.org.springframework.security=WARN\nlogging.level.org.springframework.web = WARN\n\n# Level for loggers on classes inside the root package \norg.project.openbaton\n (and its\n# sub-packages)\nlogging.level.org.openbaton=INFO\n\n# Direct log to a log file\nlogging.file=/var/log/openbaton.log\n\n\n\n\nOr parameters related with persistency (hibernate):\n\n\n# DB properties\nspring.datasource.username=admin\nspring.datasource.password=changeme\n# hsql jdbc\nspring.datasource.url=jdbc:hsqldb:file:/tmp/openbaton/openbaton.hsdb\nspring.datasource.driver-class-name=org.hsqldb.jdbc.JDBCDriver\nspring.jpa.database-platform=org.hibernate.dialect.HSQLDialect\n# mysql jdbc\n#spring.datasource.url=jdbc:mysql://localhost:3306/openbaton\n#spring.datasource.driver-class-name=com.mysql.jdbc.Driver\n#spring.jpa.database-platform=org.hibernate.dialect.MySQLDialect\n# hibernate properties\nspring.jpa.show-sql=false\nspring.jpa.hibernate.ddl-auto=create-drop\n\n\n\n\n\n\nIMPORTANT NOTE:\n\nBy default RabbitMQ is installed on the host of the NFVO. Be aware of the fact that if you want your VNFM to be executed on a different host, you will need RabbitMQ to be reachable also from the outside.\n\nSo when you want to deploy a VNF (EMS) in a VM which runs on a different host in respect to the NFVO, you will need to configure the rabbitmq endpoint (\nnfvo.rabbit.brokerIp\n) with the real IP of the NFVO host (instead of localhost).\nWhat we suggest is to copy entirely \n/opt/openbaton/NFVO/etc/openbaton.properties\n to \n/etc/openbaton/openbaton.properties\n and then change: \n\n\nnfvo.rabbit.brokerIp = localhost \n\n\n\n\nto\n\n\nnfvo.rabbit.brokerIp = the rabbitmq broker ip (if you run the openbaton.sh update then will be the ip where the NFVO is running) \n\n\n\n\nThese are other parameters about the configuration of Rabbit MQ:\n\n\n#########################################\n############## RabbitMQ #################\n#########################################\n\n# Comma-separated list of addresses to which the client should connect to.\n# spring.rabbitmq.addresses=${nfvo.rabbit.brokerIp}\n# Create an AmqpAdmin bean.\nspring.rabbitmq.dynamic=true\n# RabbitMQ host.\nspring.rabbitmq.host= ${nfvo.rabbit.brokerIp}\n# spring.rabbitmq.host= localhost\n# Acknowledge mode of container.\n# spring.rabbitmq.listener.acknowledge-mode=\n# Start the container automatically on startup.\n# spring.rabbitmq.listener.auto-startup=true\n# Minimum number of consumers.\nspring.rabbitmq.listener.concurrency= 5\n# Maximum number of consumers.\nspring.rabbitmq.listener.max-concurrency= 30\n# Number of messages to be handled in a single request. It should be greater than or equal to the transaction size (if used).\n# spring.rabbitmq.listener.prefetch=\n# Number of messages to be processed in a transaction. For best results it should be less than or equal to the prefetch count.\n# spring.rabbitmq.listener.transaction-size=\n# Login user to authenticate to the broker.\nspring.rabbitmq.username= admin\n# Login to authenticate against the broker.\nspring.rabbitmq.password= openbaton\n# RabbitMQ port.\nspring.rabbitmq.port=5672\n# Requested heartbeat timeout, in seconds; zero for none.\n# spring.rabbitmq.requested-heartbeat=\n# Enable SSL support.\n# spring.rabbitmq.ssl.enabled=false\n# Path to the key store that holds the SSL certificate.\n# spring.rabbitmq.ssl.key-store=\n# Password used to access the key store.\n# spring.rabbitmq.ssl.key-store-password=\n# Trust store that holds SSL certificates.\n# spring.rabbitmq.ssl.trust-store=\n# Password used to access the trust store.\n# spring.rabbitmq.ssl.trust-store-password=\n# Virtual host to use when connecting to the broker.\n# spring.rabbitmq.virtual-host=\n\n\n\n\n\nThese parameters represent the maximum file size of the VNF Package which can be uploaded to the NFVO and the total maximum request size\n\n\n# filesUpload\nmultipart.maxFileSize=2046MB\nmultipart.maxRequestSize=2046MB\n\n\n\n\nThe following properties are related to the plugin mechanism used for loading VIM and Monitoring instances. The \nvim-plugin-installation-dir\n is the directory where all the jar files are, which implement the VIM interface (see the \nvim plugin documentation\n). The NFVO will load them at runtime.  \n\n\n########## plugin install ###############\n# directory for the vim driver plugins\nplugin-installation-dir = ./plugins\n\n\n\n\nThis property allows the user to delete the Network Service Records no matter in which status are they. Pleas note that in any case it is possible to remove a Network Service Record in \nNULL\n state.\n\n\n# nfvo behaviour\nnfvo.delete.all-status = true \n\n\n\n\nMONITORING:\n Openbaton allows the monitoring of the VNFs via Zabbix. If you want to use this feature, install and configure Zabbix server following the guide at this page \nZabbix server configuration\n.\nOnce the Zabbix server is correctly configured and running, you need only to add following property. \nEvery time a new Network Service is instantiated, each VNFC (VM) is automatically registered to Zabbix server.\n\n\nnfvo.monitoring.ip = the Zabbix server ip\n\n\n\n\nThese are other parameters about the configuration of the nfvo behaviour:\n\n\nnfvo.delete.wait = false \n\nnfvo.rabbit.brokerIp = the broker ip here \nnfvo.rabbit.autodelete = true \nnfvo.plugin.active.consumers = 5 \nnfvo.rabbit.minConcurrency = 5 \nnfvo.rabbit.maxConcurrency = 15 \nnfvo.rabbit.management.port = 15672 \n\n\n\n\nThose properties are needed in case you want to tune a bit the performances of the NFVO. When the VNFMs send a message to the NFVO, there is a pool of threads able to process these messages in parallel. These parameters allows you to change the pool configuration, for more details please check the \nspring documentation regarding thread pool executor\n \n\n\n# Thread pool executor configuration\n# for info see http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/scheduling/concurrent/ThreadPoolTaskExecutor.html\nvmanager-executor-core-pool-size = 20\nvmanager-executor-max-pool-size = 25\nvmanager-executor-queue-capacity = 500\nvmanager-keep-alive = 30\n\n\n\n\nWhenever some of those parameters are changed, you will need to restart the orchestrator.\n\n\nLet's move to the next step\n\n\nDependening on the approach used for deploying your VNF, you'll have either to install the generic-VNFM or install and register your own VNFM\n\n\n\n\n\n\n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Install NFVO"
        }, 
        {
            "location": "/nfvo-installation/#install-nfvo", 
            "text": "The NFVO is implemented in java using the  spring.io  framework. For more details about the NFVO architecture, you can refer to the extend it section.  Install the latest NFVO version from the source code  The NFVO can be installed using different mechanisms. In this how to we will show you how to instantiate it using directly from the git repo.   The NFVO uses the AMQP protocol for communicating with the VNFMs. Therefore an implementation of it is necessary, we chose  RabbitMQ .\nTo facilitate the installation procedures we provide an installation script which can be used for installing the NFVO and the prerequired libraries.\nConsidering that this script needs to install some system libraries, it is required to execute it as super user.\nTo execute the following command you need to have curl installed (see http://curl.haxx.se/).   sudo su -\nbash  (curl -fsSkL http://get.openbaton.org/bootstrap)  At the end of the installation procedure, if there are no errors, the dashboard is reachable at:  localhost:8080  and you should have the following structure:  /opt/openbaton/\n\u251c\u2500\u2500 generic-vnfm\n\u2514\u2500\u2500 nfvo  Where:   generic-vnfm contains the source code and scripts required for dealing with the generic-vnfm    nfvo  contains the source code and scripts of the NFVO   At this point the NFVO is ready to be used. Please refer to the  Introduction  on how to start using it.  Starting and stopping NFVO  After the installation procedure the nfvo is running. If you want to stop it, enter this command:  cd /opt/openbaton/nfvo\n./openbaton.sh stop  Note (in case you are also using the generic-vnfm):  remember to stop also the Generic VNFM with the following command:  cd /opt/openbaton/generic-vnfm\n./generic-vnfm.sh stop  To start the nfvo, enter the command:  cd /opt/openbaton/nfvo\n./openbaton.sh start  Note (in case you are also using the generic-vnfm):  remember to start also the Generic VNFM with the following command:  cd /opt/openbaton/generic-vnfm\n./generic-vnfm.sh start  NFVO properties overview  The NFVO is configured with default configuration parameters at the beginning. The configuration file is located at:   /etc/openbaton/openbaton.properties  This file can be modified for specific parameters. For instance, you can decide to change logging levels (TRACE, DEBUG, INFO, WARN, and ERROR) and mechanisms:  logging.level.org.springframework=INFO\nlogging.level.org.hibernate=INFO\nlogging.level.org.apache=INFO\nlogging.level.org.jclouds=WARN\n# logging.level.org.springframework.security=WARN\nlogging.level.org.springframework.web = WARN\n\n# Level for loggers on classes inside the root package  org.project.openbaton  (and its\n# sub-packages)\nlogging.level.org.openbaton=INFO\n\n# Direct log to a log file\nlogging.file=/var/log/openbaton.log  Or parameters related with persistency (hibernate):  # DB properties\nspring.datasource.username=admin\nspring.datasource.password=changeme\n# hsql jdbc\nspring.datasource.url=jdbc:hsqldb:file:/tmp/openbaton/openbaton.hsdb\nspring.datasource.driver-class-name=org.hsqldb.jdbc.JDBCDriver\nspring.jpa.database-platform=org.hibernate.dialect.HSQLDialect\n# mysql jdbc\n#spring.datasource.url=jdbc:mysql://localhost:3306/openbaton\n#spring.datasource.driver-class-name=com.mysql.jdbc.Driver\n#spring.jpa.database-platform=org.hibernate.dialect.MySQLDialect\n# hibernate properties\nspring.jpa.show-sql=false\nspring.jpa.hibernate.ddl-auto=create-drop  IMPORTANT NOTE: \nBy default RabbitMQ is installed on the host of the NFVO. Be aware of the fact that if you want your VNFM to be executed on a different host, you will need RabbitMQ to be reachable also from the outside. \nSo when you want to deploy a VNF (EMS) in a VM which runs on a different host in respect to the NFVO, you will need to configure the rabbitmq endpoint ( nfvo.rabbit.brokerIp ) with the real IP of the NFVO host (instead of localhost).\nWhat we suggest is to copy entirely  /opt/openbaton/NFVO/etc/openbaton.properties  to  /etc/openbaton/openbaton.properties  and then change:   nfvo.rabbit.brokerIp = localhost   to  nfvo.rabbit.brokerIp = the rabbitmq broker ip (if you run the openbaton.sh update then will be the ip where the NFVO is running)   These are other parameters about the configuration of Rabbit MQ:  #########################################\n############## RabbitMQ #################\n#########################################\n\n# Comma-separated list of addresses to which the client should connect to.\n# spring.rabbitmq.addresses=${nfvo.rabbit.brokerIp}\n# Create an AmqpAdmin bean.\nspring.rabbitmq.dynamic=true\n# RabbitMQ host.\nspring.rabbitmq.host= ${nfvo.rabbit.brokerIp}\n# spring.rabbitmq.host= localhost\n# Acknowledge mode of container.\n# spring.rabbitmq.listener.acknowledge-mode=\n# Start the container automatically on startup.\n# spring.rabbitmq.listener.auto-startup=true\n# Minimum number of consumers.\nspring.rabbitmq.listener.concurrency= 5\n# Maximum number of consumers.\nspring.rabbitmq.listener.max-concurrency= 30\n# Number of messages to be handled in a single request. It should be greater than or equal to the transaction size (if used).\n# spring.rabbitmq.listener.prefetch=\n# Number of messages to be processed in a transaction. For best results it should be less than or equal to the prefetch count.\n# spring.rabbitmq.listener.transaction-size=\n# Login user to authenticate to the broker.\nspring.rabbitmq.username= admin\n# Login to authenticate against the broker.\nspring.rabbitmq.password= openbaton\n# RabbitMQ port.\nspring.rabbitmq.port=5672\n# Requested heartbeat timeout, in seconds; zero for none.\n# spring.rabbitmq.requested-heartbeat=\n# Enable SSL support.\n# spring.rabbitmq.ssl.enabled=false\n# Path to the key store that holds the SSL certificate.\n# spring.rabbitmq.ssl.key-store=\n# Password used to access the key store.\n# spring.rabbitmq.ssl.key-store-password=\n# Trust store that holds SSL certificates.\n# spring.rabbitmq.ssl.trust-store=\n# Password used to access the trust store.\n# spring.rabbitmq.ssl.trust-store-password=\n# Virtual host to use when connecting to the broker.\n# spring.rabbitmq.virtual-host=  These parameters represent the maximum file size of the VNF Package which can be uploaded to the NFVO and the total maximum request size  # filesUpload\nmultipart.maxFileSize=2046MB\nmultipart.maxRequestSize=2046MB  The following properties are related to the plugin mechanism used for loading VIM and Monitoring instances. The  vim-plugin-installation-dir  is the directory where all the jar files are, which implement the VIM interface (see the  vim plugin documentation ). The NFVO will load them at runtime.    ########## plugin install ###############\n# directory for the vim driver plugins\nplugin-installation-dir = ./plugins  This property allows the user to delete the Network Service Records no matter in which status are they. Pleas note that in any case it is possible to remove a Network Service Record in  NULL  state.  # nfvo behaviour\nnfvo.delete.all-status = true   MONITORING:  Openbaton allows the monitoring of the VNFs via Zabbix. If you want to use this feature, install and configure Zabbix server following the guide at this page  Zabbix server configuration .\nOnce the Zabbix server is correctly configured and running, you need only to add following property. \nEvery time a new Network Service is instantiated, each VNFC (VM) is automatically registered to Zabbix server.  nfvo.monitoring.ip = the Zabbix server ip  These are other parameters about the configuration of the nfvo behaviour:  nfvo.delete.wait = false \n\nnfvo.rabbit.brokerIp = the broker ip here \nnfvo.rabbit.autodelete = true \nnfvo.plugin.active.consumers = 5 \nnfvo.rabbit.minConcurrency = 5 \nnfvo.rabbit.maxConcurrency = 15 \nnfvo.rabbit.management.port = 15672   Those properties are needed in case you want to tune a bit the performances of the NFVO. When the VNFMs send a message to the NFVO, there is a pool of threads able to process these messages in parallel. These parameters allows you to change the pool configuration, for more details please check the  spring documentation regarding thread pool executor    # Thread pool executor configuration\n# for info see http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/scheduling/concurrent/ThreadPoolTaskExecutor.html\nvmanager-executor-core-pool-size = 20\nvmanager-executor-max-pool-size = 25\nvmanager-executor-queue-capacity = 500\nvmanager-keep-alive = 30  Whenever some of those parameters are changed, you will need to restart the orchestrator.  Let's move to the next step  Dependening on the approach used for deploying your VNF, you'll have either to install the generic-VNFM or install and register your own VNFM   \n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Install NFVO"
        }, 
        {
            "location": "/vim-instance/", 
            "text": "Register a new Point of Presence (PoP)\n\n\nThe \nVirtualised Infrastructure Manager\n (Vim) is the functional block, responsible for controlling and managing the\n NFVI compute, storage and network resources within a Point of Presence (PoP).\n\n\nIn order to interoperate with a PoP it is required to register the VIM instance responsible for it on the NFVO. For doing that you can write a JSon file containing the details of a Vim Instance like the one described below: \n\n\n{\n  \nname\n:\nvim-instance-name\n,\n  \nauthUrl\n:\nhttp://192.168.0.5:5000/v2.0\n,\n  \ntenant\n:\ntenantName\n,\n  \nusername\n:\nuserName\n,\n  \npassword\n:\npassword\n,\n  \nkeyPair\n:\nkeyName\n,\n  \nsecurityGroups\n: [\n    \nsecurityName\n\n  ],\n  \ntype\n:\nopenstack\n,\n  \nlocation\n:{\n        \nname\n:\nBerlin\n,\n        \nlatitude\n:\n52.525876\n,\n        \nlongitude\n:\n13.314400\n\n  }\n}\n\n\n\n\n\n\n\n\n\n\n\nParams\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\nname\n\n\nThe name of the VimInstance\n\n\n\n\n\n\nauthUrl\n\n\nThe endpoint to request the authentication\n\n\n\n\n\n\ntenant\n\n\nThe tenant is a string to refer to a group of users\n\n\n\n\n\n\nusername\n\n\nThe name of the user recognized in OpenStack in the keystone service\n\n\n\n\n\n\npassword\n\n\nThe password of the user recognized in the OpenStack in the keystone service\n\n\n\n\n\n\nkeyPair\n\n\nThe keyPair name stored into OpenStack to get the access to the VMs\n\n\n\n\n\n\nsecurityGroups\n\n\nRecognise a Security group into OpenStack where gives a sets of IP filter rules that are applied to an instance's networking.\n\n\n\n\n\n\ntype\n\n\nThe type of the Vim Instance that will start the corresponding plugin. Possible values are: \nopenstack\n or \ntest\n\n\n\n\n\n\nlocation\n\n\nThe location of the data Center. Name: String of the place where is the Data Center located. Latitude/Longitude geolocation point\n\n\n\n\n\n\n\n\nBy default we use only one tenant on your PoP. We are currently working on supporting the instantiation of different NSDs in different tenants. \n\n\nRegister the PoP using the GUI\n\n\nIn order to make use of your VIM described within your JSON descriptor, you need to request the NFVO to register it. \nYou can use the dashboard available at \nlocalhost:8080\n for this purpose. \nUnder the menu \nManage PoPs\n you can see the \nPoP instances\n. Click on the Register VIM button and upload your VIM descriptor. Following picture shows the dashboard: \n\n\n\n\nOnce the VIM instance is registered, it will appear on the list of available PoPs. At this point the VIM/PoP can be included in your Network Service Descriptors. \n\nPlease note that the name chosen must be unique and will be used to refer the VimInstance\n.\n\n\nFor more information about the dashboard see: \nOpenBaton Dashboard\n\n\nWhat are the supported VIM types?\n\n\nBy default the NFVO supports two different VIM types: \n\n\n\n\nopenstack: for interoperating with an OpenStack instance\n\n\ntest: for testing purposes implementing a VIM mockup\n\n\n\n\nFor each of those types there is a different implementation of the VIM API. The NFVO uses a plugin mechanism for interacting with VIMs. In the folders \nplugins\n under nfvo folder should be a jar file that implements the interface to the your VIM ( i.e. \nOpenstack\n )\n(you can change the folder where OpenBaton searches for the plugins by changing the variable \nplugin-installation-dir\n in the \nopenbaton.properties\n file under /etc/openbaton)\nThis jar is the implementation of the interface that communicates with your VIM.\n\n\nNote\n: You can implement your own interface just follow the documentation \nVim plugin\n.\n\n\n\n\n\n\n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Register a PoP"
        }, 
        {
            "location": "/vim-instance/#register-a-new-point-of-presence-pop", 
            "text": "The  Virtualised Infrastructure Manager  (Vim) is the functional block, responsible for controlling and managing the\n NFVI compute, storage and network resources within a Point of Presence (PoP).  In order to interoperate with a PoP it is required to register the VIM instance responsible for it on the NFVO. For doing that you can write a JSon file containing the details of a Vim Instance like the one described below:   {\n   name : vim-instance-name ,\n   authUrl : http://192.168.0.5:5000/v2.0 ,\n   tenant : tenantName ,\n   username : userName ,\n   password : password ,\n   keyPair : keyName ,\n   securityGroups : [\n     securityName \n  ],\n   type : openstack ,\n   location :{\n         name : Berlin ,\n         latitude : 52.525876 ,\n         longitude : 13.314400 \n  }\n}     Params  Meaning      name  The name of the VimInstance    authUrl  The endpoint to request the authentication    tenant  The tenant is a string to refer to a group of users    username  The name of the user recognized in OpenStack in the keystone service    password  The password of the user recognized in the OpenStack in the keystone service    keyPair  The keyPair name stored into OpenStack to get the access to the VMs    securityGroups  Recognise a Security group into OpenStack where gives a sets of IP filter rules that are applied to an instance's networking.    type  The type of the Vim Instance that will start the corresponding plugin. Possible values are:  openstack  or  test    location  The location of the data Center. Name: String of the place where is the Data Center located. Latitude/Longitude geolocation point     By default we use only one tenant on your PoP. We are currently working on supporting the instantiation of different NSDs in different tenants.", 
            "title": "Register a new Point of Presence (PoP)"
        }, 
        {
            "location": "/vim-instance/#register-the-pop-using-the-gui", 
            "text": "In order to make use of your VIM described within your JSON descriptor, you need to request the NFVO to register it. \nYou can use the dashboard available at  localhost:8080  for this purpose. \nUnder the menu  Manage PoPs  you can see the  PoP instances . Click on the Register VIM button and upload your VIM descriptor. Following picture shows the dashboard:    Once the VIM instance is registered, it will appear on the list of available PoPs. At this point the VIM/PoP can be included in your Network Service Descriptors.  Please note that the name chosen must be unique and will be used to refer the VimInstance .  For more information about the dashboard see:  OpenBaton Dashboard", 
            "title": "Register the PoP using the GUI"
        }, 
        {
            "location": "/vim-instance/#what-are-the-supported-vim-types", 
            "text": "By default the NFVO supports two different VIM types:    openstack: for interoperating with an OpenStack instance  test: for testing purposes implementing a VIM mockup   For each of those types there is a different implementation of the VIM API. The NFVO uses a plugin mechanism for interacting with VIMs. In the folders  plugins  under nfvo folder should be a jar file that implements the interface to the your VIM ( i.e.  Openstack  )\n(you can change the folder where OpenBaton searches for the plugins by changing the variable  plugin-installation-dir  in the  openbaton.properties  file under /etc/openbaton)\nThis jar is the implementation of the interface that communicates with your VIM.  Note : You can implement your own interface just follow the documentation  Vim plugin .   \n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "What are the supported VIM types?"
        }, 
        {
            "location": "/use/", 
            "text": "How to use OpenBaton\n\n\nIn order to use OpenBaton for launching your first Network Service, you will need to follow these steps:\n\n\n\n\nDecide which VNFM to use.\n\n\nCreate the VNF Package(s).\n\n\nPrepare the Network Service Descriptor (NSD).\n\n\n\n\nOnce these steps are completed you will be able to orchestrate your Network Service from the dashboard.\n\n\nVirtual Network Function Manager Approaches\n\n\nIn order to manage the Virtual Network Function(s), the NFV-MANO architectural framework expects a Virtual Network Function Manager (VNFM).\nTo facilitate ease of use and extensibility, the Openbaton project provides three different approaches to using a VNFM:\n\n\n\n\nUse the Generic VNFM\n\n\nBuild a VNFM using the SDK\n\n\nUse your own VNFM\n\n\n\n\nMain purposes of the approaches\n\n\n1. Use the Generic VNFM\n\n\nUsing the generic VNFM you don't need to create a VNFM to use Openbaton.\nIt is called \"Generic\" because it may be assigned the management of a single VNF instance, or the management of VNF multiple instances of the same type or of different types.\nIt is already included in Openbaton as default.\n\n\nPlease refer to the following doc for more details: \nUse the generic VNFM\n\n\n2. Build a VNFM using the SDK\n\n\nOpenbaton provides a Java SDK called vnfm-sdk which helps you to simply create a VNFM for your VNF.\nRegarding the type of the communication between the NFVO and the VNFM (Or-Vnfm), you can use the vnfm-sdk-jms or vnfm-sdk-rest, depending if you prefer to communicate with JMS or REST.\n\n\nPlease refer to the following doc for more details: \nBuild your own VNFM\n\n\n3. Use your own VNFM\n\n\nThis approach allows you to integrate your VNFM and VNF within Openbaton. In this case, the Or-Vnfm communication will be via REST interfaces.\n\n\nThe three pages following describe in details these three different approaches.\n\n\nPlease refer to the following doc for more details: \nBring your own VNFM\n\n\n\n\n\n\n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Introduction"
        }, 
        {
            "location": "/use/#how-to-use-openbaton", 
            "text": "In order to use OpenBaton for launching your first Network Service, you will need to follow these steps:   Decide which VNFM to use.  Create the VNF Package(s).  Prepare the Network Service Descriptor (NSD).   Once these steps are completed you will be able to orchestrate your Network Service from the dashboard.", 
            "title": "How to use OpenBaton"
        }, 
        {
            "location": "/use/#virtual-network-function-manager-approaches", 
            "text": "In order to manage the Virtual Network Function(s), the NFV-MANO architectural framework expects a Virtual Network Function Manager (VNFM).\nTo facilitate ease of use and extensibility, the Openbaton project provides three different approaches to using a VNFM:   Use the Generic VNFM  Build a VNFM using the SDK  Use your own VNFM", 
            "title": "Virtual Network Function Manager Approaches"
        }, 
        {
            "location": "/use/#main-purposes-of-the-approaches", 
            "text": "1. Use the Generic VNFM  Using the generic VNFM you don't need to create a VNFM to use Openbaton.\nIt is called \"Generic\" because it may be assigned the management of a single VNF instance, or the management of VNF multiple instances of the same type or of different types.\nIt is already included in Openbaton as default.  Please refer to the following doc for more details:  Use the generic VNFM  2. Build a VNFM using the SDK  Openbaton provides a Java SDK called vnfm-sdk which helps you to simply create a VNFM for your VNF.\nRegarding the type of the communication between the NFVO and the VNFM (Or-Vnfm), you can use the vnfm-sdk-jms or vnfm-sdk-rest, depending if you prefer to communicate with JMS or REST.  Please refer to the following doc for more details:  Build your own VNFM  3. Use your own VNFM  This approach allows you to integrate your VNFM and VNF within Openbaton. In this case, the Or-Vnfm communication will be via REST interfaces.  The three pages following describe in details these three different approaches.  Please refer to the following doc for more details:  Bring your own VNFM   \n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Main purposes of the approaches"
        }, 
        {
            "location": "/vnfm-generic/", 
            "text": "VNFManager Generic\n\n\nThe Generic VNFManager is an implementation following the \nETSI MANO\n specifications. For that reason it is highly tied to the EMS.\nThis VNFM may be assigned the management of a single VNF instance, or the management of multiple VNF instances of the same type or of different types.\n\n\nThe Generic VNFManager handles communication with the NFVO and with EMS. The communication NFVO \u2194 VNFM \u2194 EMS is done using the AMQP protocol over RabbitMQ.  \n\n\nThe communication between the NFVO and Generic VNFManager:\n\n\n\n\nThe communication between the Generic VNFManager and EMS:\n\n\n\n\nAs you can see, the Generic VNFM sends commands to the EMS, which is running in the VM. Then the EMS executes the commands (scripts) locally in the VNFC. \nPlease note that the EMS executes those scripts as root user\n.\nThe following sequence diagram explains the communication messages.\n\n\n\n\nThe Generic VNFManager is supposed to be used for any type of VNF that follows some conventions regarding:\n\n\n\n\nVMs deployment\n\n\nScript execution costraints\n\n\nVMs termination\n\n\n\n\nVMs deployment\n\n\nAccordingly to the \nETSI MANO B.3\n the VNF instantiation flows can be done in two ways:\n\n\n\n\nWith resource allocation done by NFVO\n\n\nWith resource allocation done by VNF Manager\n\n\n\n\nThe Generic VNFM follows the first approach. In the first approach two messages will be sent to the NFVO:\n\n\n\n\n\n\nGRANT_OPERATION message\n: check if the resources are available on the selected PoP. If the GRANT_OPERATION message is returned, then there are enough resources, otherwise an ERROR message will be sent. After the GRANT_OPERATION message it is possible to send the ALLOCATE_RESOURCE message.  \n\n\n\n\n\n\nALLOCATE_RESOURCE message\n: This message ask the NFVO to create all the resources and then, if no errors occurred, the ALLOCATE_RESOURCE message will be returned to the VNFManager. Only the VNFMs which follow the first approach need to send this message.\n\n\n\n\n\n\nAfter that point the VMs are created and \nthe VNF record is filled with values\n, such as ips, that can be found directly in the VirtualNetworkFunctionRecord\u2192VirtualDeploymentUnit\u2192VNFCInstance object.\n\n\nScript Execution Costraints\n\n\nFor each operation of the VNF Lifecycle Management interface, the VNFManager sends scripts to the EMS which executes them locally in the VMs.\n\n\nNote\n: The scripts come from the VNFPackage which you need to create (see \nVNFPackage documentation\n).\n\n\nThe ordering of this scripts is defined in the NetworkServiceDescriptor from which the NetworkServiceRecord was created, in particular into the NetworkServiceDescriptor\u2192VirtualNetworkFunctionDescriptor\u2192LifecycleEvents.\nHere an example (to make it more readable it is shown only the \nVNF lifecycle event\n part):\n\n\n{// NSD\n  ...\n  {// VNFD\n    ...\n    \nlifecycle_event\n:[\n        {\n            \nevent\n:\nINSTANTIATE\n,\n            \nlifecycle_events\n:[\n                \ninstall.sh\n\n            ]\n        },\n        {\n            \nevent\n:\nCONFIGURE\n,\n            \nlifecycle_events\n:[\n                \nserver_configure.sh\n\n            ]\n        },\n        {\n            \nevent\n:\nSTART\n,\n            \nlifecycle_events\n:[\n                 \nserver_start.sh\n\n            ]\n        },\n        {\n            \nevent\n:\nTERMINATE\n,\n            \nlifecycle_events\n:[\n                 \nserver_terminate.sh\n\n            ]\n        }\n    ],\n    ...\n  }\n  ...\n}\n\n\n\n\nIn the following table is described for each \nVNF lifecycle event\n when the scripts are executed.\n\n\n\n\n\n\n\n\nVNF Lifecycle event\n\n\nWhen scripts are executed\n\n\n\n\n\n\n\n\n\n\nINSTANTIATE\n\n\nDuring the instantiation of the corresponding VNF\n\n\n\n\n\n\nCONFIGURE\n\n\nAfter the instantiation. Useful if the VNF depends on other VNFs, because we can get parameters provided by them (e.g. IP). The parameters are available as environment variables (see later).\n\n\n\n\n\n\nSTART\n\n\nAfter the instantiation or configuration (It depends whether the event CONFIGURE specified).\n\n\n\n\n\n\nTERMINATE\n\n\nDuring the termination of the corresponding VNF\n\n\n\n\n\n\n\n\nThe available parameters are defined in the VirtualNetworkFunctionDescriptor fields:\n\n\n\n\nprovides\n: it contains the VMs parameters which will be available after the instantiation (e.g. IP) for other VNFs.\n\n\nconfigurations\n: it contains specific parameters which you want to use in the scripts.\n\n\n\n\nIn the INSTANTIATE scripts, the parameters defined in these two fields are then available as environment variables into the script exactly as defined (i.e. you can get by $parameter_name).\n\n\nIn the MODIFY scripts, the INSTANTIATE parameters are still available but plus there are environment variables that come from other VNF sources, where they are specified in the provides field. \nThese kind of parameters are defined in the \nrequires\n fields (of the VNF target) and the VNFDependency\u2192parameters fields (of the NSD), and are then available as $\ntype_of_vnf_source\n_\nname_of_parameter\n (in the VNF target).\n\n\nNOTE\n: \nthe scripts in the CONFIGURE lifecycle event need to start with the type of the source VNF followed by _ and the name of the script (i.e. server_configure.sh)\n\n\nVMs termination\n\n\nAs for VMs deployment, VMs termination is done by the NFVO. Specific scripts can be run before termination by putting them under the TERMINATE lifecycle event.\n\n\nLaunch the Generic VNFM\n\n\nTo launch the Generic VNFM, execute the following command:\n\n\n$ cd \ngeneric directory\n\n$ ./generic.sh start\n\n\n\n\nThe Generic VNFM can handle more than one VNF (in parallel) of the same or different type, so that you need to start only one Generic VNFM.\n\n\nEXAMPLE WITH DEPENDENCY AND SCRIPTS\n\n\nLet's see a simple example with two VNFs: vnf-server and vnf-database.\nThe vnf-server needs the ip of the vnf-database to be able to connect properly. The following figure shows the source (vnf-database), the target (vnf-server)\nand the dependency (IP).\n\n\n\n\nINSTANTIATE scripts\n\n\nTo start the VNFs we'll have two scripts \ninstantiate-vnf-server.sh\n and \ninstantiate-vnf-database.sh\n (more scripts are possible). Here an example of the instantiate-vnf-server.sh script:\n\n\n#!/bin/bash\n\necho \nINSTANTIATIATION of the VNF server\n\necho \nThe following parameters are available:\n\necho \nThe answer to everything is.. ${ANSWER_TO_EVERYTHING}\n\n\n# ... Add the code to start the vnf_server ...\n\n\n\n\nMODIFY script\n\n\nAfter the instantiation of the vnf-server we would configure it with the following \ndatabase_connectToDb.sh\n script:\n\n\n#!/bin/bash\n\necho \nThis is the ip of the vnf-database: ${database_private}\n\n# ... Add the code to connect to the vnf-database with the ip: ${database_private1} ...\n\n\n\n\n\nNote1\n: \"database\" is the type of the vnf-database, private is the name of the network.\n\n\nNote2\n: All the scripts need to be in a repository or in the vnf package (see the vnf package structure \nhere\n).\n\n\nIn order to deploy the VNFs we have to create both the VNF descriptor: \nvnf-database-descriptor.json\n and \nvnf-server-descriptor.json\n. Below we'll be showed the most relevant part of them:\n\n\nvnf-database-descriptor.json\n\n\n{\n    \nname\n:\nvnf-database\n,\n    \ntype\n:\ndatabase\n,\n    \nendpoint\n:\ngeneric\n,\n    ...\n    \nlifecycle_event\n:[\n        {\n            \nevent\n:\nINSTANTIATE\n,\n            \nlifecycle_events\n:[\n                \ninstantiate-vnf-database.sh\n\n            ]\n        }\n    ],\n    ...\n}\n\n\n\n\nNote:\n to use the Generic VNFM for managing a VNF just set \"generic\" in the endpoint field.\n\n\nvnf-server-descriptor.json\n\n\n{\n    \nname\n:\nvnf-server\n,\n    \ntype\n:\nserver\n,\n    \nendpoint\n:\ngeneric\n,\n    ...\n    \nconfigurations\n:{\n            \nname\n:\nconfig_name\n,\n            \nconfigurationParameters\n:[\n            {\n                \nconfKey\n:\nANSWER_TO_EVERYTHING\n,\n                \nvalue\n:\n42\n\n            }\n            ]\n    },\n    ...\n    \nlifecycle_event\n:[\n        {\n            \nevent\n:\nINSTANTIATE\n,\n            \nlifecycle_events\n:[\n                \ninstantiate-vnf-server.sh\n\n            ]\n        },\n        {\n            \nevent\n:\nCONFIGURE\n,\n            \nlifecycle_events\n:[\n                \ndatabase_connectToDb.sh\n\n            ]\n        }\n    ],\n    ...\n}\n\n\n\n\nThe result network service descriptor shall include both the vnf descriptors above and the dependency:\n\n\n{\n    \nname\n:\nsimple-nsd\n,\n    \nvnfd\n:[\n        {\n            \nid\n:\n29d918b9-6245-4dc4-abc6-b7dd6e84f2c1\n\n        },\n        {\n            \nid\n:\n87820607-4048-4fad-b02b-dbcab8bb5c1c\n\n        }\n    ],\n    \nvld\n:[\n        {\n            \nname\n:\nprivate\n\n        }\n    ],\n    \nvnf_dependency\n:[\n        {\n            \nsource\n : {\n                \nname\n: \nvnf-database\n\n            },\n            \ntarget\n:{\n                \nname\n: \nvnf-server\n\n            },\n            \nparameters\n:[\n                \nprivate\n\n            ]\n        }\n    ]\n}\n\n\n\n\nSee the complete tutorial \u2192 \nVNFPackage tutorial\n.\n\n\n\n\n\n\n\n\n\n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Generic VNFM"
        }, 
        {
            "location": "/vnfm-generic/#vnfmanager-generic", 
            "text": "The Generic VNFManager is an implementation following the  ETSI MANO  specifications. For that reason it is highly tied to the EMS.\nThis VNFM may be assigned the management of a single VNF instance, or the management of multiple VNF instances of the same type or of different types.  The Generic VNFManager handles communication with the NFVO and with EMS. The communication NFVO \u2194 VNFM \u2194 EMS is done using the AMQP protocol over RabbitMQ.    The communication between the NFVO and Generic VNFManager:   The communication between the Generic VNFManager and EMS:   As you can see, the Generic VNFM sends commands to the EMS, which is running in the VM. Then the EMS executes the commands (scripts) locally in the VNFC.  Please note that the EMS executes those scripts as root user .\nThe following sequence diagram explains the communication messages.   The Generic VNFManager is supposed to be used for any type of VNF that follows some conventions regarding:   VMs deployment  Script execution costraints  VMs termination   VMs deployment  Accordingly to the  ETSI MANO B.3  the VNF instantiation flows can be done in two ways:   With resource allocation done by NFVO  With resource allocation done by VNF Manager   The Generic VNFM follows the first approach. In the first approach two messages will be sent to the NFVO:    GRANT_OPERATION message : check if the resources are available on the selected PoP. If the GRANT_OPERATION message is returned, then there are enough resources, otherwise an ERROR message will be sent. After the GRANT_OPERATION message it is possible to send the ALLOCATE_RESOURCE message.      ALLOCATE_RESOURCE message : This message ask the NFVO to create all the resources and then, if no errors occurred, the ALLOCATE_RESOURCE message will be returned to the VNFManager. Only the VNFMs which follow the first approach need to send this message.    After that point the VMs are created and  the VNF record is filled with values , such as ips, that can be found directly in the VirtualNetworkFunctionRecord\u2192VirtualDeploymentUnit\u2192VNFCInstance object.  Script Execution Costraints  For each operation of the VNF Lifecycle Management interface, the VNFManager sends scripts to the EMS which executes them locally in the VMs.  Note : The scripts come from the VNFPackage which you need to create (see  VNFPackage documentation ).  The ordering of this scripts is defined in the NetworkServiceDescriptor from which the NetworkServiceRecord was created, in particular into the NetworkServiceDescriptor\u2192VirtualNetworkFunctionDescriptor\u2192LifecycleEvents.\nHere an example (to make it more readable it is shown only the  VNF lifecycle event  part):  {// NSD\n  ...\n  {// VNFD\n    ...\n     lifecycle_event :[\n        {\n             event : INSTANTIATE ,\n             lifecycle_events :[\n                 install.sh \n            ]\n        },\n        {\n             event : CONFIGURE ,\n             lifecycle_events :[\n                 server_configure.sh \n            ]\n        },\n        {\n             event : START ,\n             lifecycle_events :[\n                  server_start.sh \n            ]\n        },\n        {\n             event : TERMINATE ,\n             lifecycle_events :[\n                  server_terminate.sh \n            ]\n        }\n    ],\n    ...\n  }\n  ...\n}  In the following table is described for each  VNF lifecycle event  when the scripts are executed.     VNF Lifecycle event  When scripts are executed      INSTANTIATE  During the instantiation of the corresponding VNF    CONFIGURE  After the instantiation. Useful if the VNF depends on other VNFs, because we can get parameters provided by them (e.g. IP). The parameters are available as environment variables (see later).    START  After the instantiation or configuration (It depends whether the event CONFIGURE specified).    TERMINATE  During the termination of the corresponding VNF     The available parameters are defined in the VirtualNetworkFunctionDescriptor fields:   provides : it contains the VMs parameters which will be available after the instantiation (e.g. IP) for other VNFs.  configurations : it contains specific parameters which you want to use in the scripts.   In the INSTANTIATE scripts, the parameters defined in these two fields are then available as environment variables into the script exactly as defined (i.e. you can get by $parameter_name).  In the MODIFY scripts, the INSTANTIATE parameters are still available but plus there are environment variables that come from other VNF sources, where they are specified in the provides field. \nThese kind of parameters are defined in the  requires  fields (of the VNF target) and the VNFDependency\u2192parameters fields (of the NSD), and are then available as $ type_of_vnf_source _ name_of_parameter  (in the VNF target).  NOTE :  the scripts in the CONFIGURE lifecycle event need to start with the type of the source VNF followed by _ and the name of the script (i.e. server_configure.sh)  VMs termination  As for VMs deployment, VMs termination is done by the NFVO. Specific scripts can be run before termination by putting them under the TERMINATE lifecycle event.", 
            "title": "VNFManager Generic"
        }, 
        {
            "location": "/vnfm-generic/#launch-the-generic-vnfm", 
            "text": "To launch the Generic VNFM, execute the following command:  $ cd  generic directory \n$ ./generic.sh start  The Generic VNFM can handle more than one VNF (in parallel) of the same or different type, so that you need to start only one Generic VNFM.", 
            "title": "Launch the Generic VNFM"
        }, 
        {
            "location": "/vnfm-generic/#example-with-dependency-and-scripts", 
            "text": "Let's see a simple example with two VNFs: vnf-server and vnf-database.\nThe vnf-server needs the ip of the vnf-database to be able to connect properly. The following figure shows the source (vnf-database), the target (vnf-server)\nand the dependency (IP).   INSTANTIATE scripts  To start the VNFs we'll have two scripts  instantiate-vnf-server.sh  and  instantiate-vnf-database.sh  (more scripts are possible). Here an example of the instantiate-vnf-server.sh script:  #!/bin/bash\n\necho  INSTANTIATIATION of the VNF server \necho  The following parameters are available: \necho  The answer to everything is.. ${ANSWER_TO_EVERYTHING} \n\n# ... Add the code to start the vnf_server ...  MODIFY script  After the instantiation of the vnf-server we would configure it with the following  database_connectToDb.sh  script:  #!/bin/bash\n\necho  This is the ip of the vnf-database: ${database_private} \n# ... Add the code to connect to the vnf-database with the ip: ${database_private1} ...  Note1 : \"database\" is the type of the vnf-database, private is the name of the network.  Note2 : All the scripts need to be in a repository or in the vnf package (see the vnf package structure  here ).  In order to deploy the VNFs we have to create both the VNF descriptor:  vnf-database-descriptor.json  and  vnf-server-descriptor.json . Below we'll be showed the most relevant part of them:  vnf-database-descriptor.json  {\n     name : vnf-database ,\n     type : database ,\n     endpoint : generic ,\n    ...\n     lifecycle_event :[\n        {\n             event : INSTANTIATE ,\n             lifecycle_events :[\n                 instantiate-vnf-database.sh \n            ]\n        }\n    ],\n    ...\n}  Note:  to use the Generic VNFM for managing a VNF just set \"generic\" in the endpoint field.  vnf-server-descriptor.json  {\n     name : vnf-server ,\n     type : server ,\n     endpoint : generic ,\n    ...\n     configurations :{\n             name : config_name ,\n             configurationParameters :[\n            {\n                 confKey : ANSWER_TO_EVERYTHING ,\n                 value : 42 \n            }\n            ]\n    },\n    ...\n     lifecycle_event :[\n        {\n             event : INSTANTIATE ,\n             lifecycle_events :[\n                 instantiate-vnf-server.sh \n            ]\n        },\n        {\n             event : CONFIGURE ,\n             lifecycle_events :[\n                 database_connectToDb.sh \n            ]\n        }\n    ],\n    ...\n}  The result network service descriptor shall include both the vnf descriptors above and the dependency:  {\n     name : simple-nsd ,\n     vnfd :[\n        {\n             id : 29d918b9-6245-4dc4-abc6-b7dd6e84f2c1 \n        },\n        {\n             id : 87820607-4048-4fad-b02b-dbcab8bb5c1c \n        }\n    ],\n     vld :[\n        {\n             name : private \n        }\n    ],\n     vnf_dependency :[\n        {\n             source  : {\n                 name :  vnf-database \n            },\n             target :{\n                 name :  vnf-server \n            },\n             parameters :[\n                 private \n            ]\n        }\n    ]\n}  See the complete tutorial \u2192  VNFPackage tutorial .    \n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "EXAMPLE WITH DEPENDENCY AND SCRIPTS"
        }, 
        {
            "location": "/vnfm-how-to-write/", 
            "text": "How to write a VNFManager\n\n\nThis section is going to describe how to write your own VNFManager by using any vnfm-sdk.\nMoreover, the vnfm-sdk contains all the things you may need for the development of the VNFManager of your choice as well.\n\n\nThe vnfm-sdk provides the following things:\n\n\n\n\nmultiple \nvnfm-sdks\n where you can choose your preferred type of communication\n\n\nCatalogue, shared with the NFVO containing all entities\n\n\nVNFMHelper\n for providing some methods out of the box\n\n\n\n\nRequirements\n\n\nBefore you can start with developing your own VNFManager you need to prepare your programming environment by installing/configuring the following requirements:\n\n\n\n\nJDK 7 (\ninstallation\n)\n\n\nGradle (\ninstallation\n)\n\n\n\n\nDevelop your own VNFManager\n\n\nThis part is going to describe the steps you need to do to develop your own VNFManager with the help of any vnfm-sdk.\n\n\nThe practical parts of implementing a basic VNFManager will focus on the usage of a specific vnfm-sdk, namely the vnfm-sdk-jms.\n\n\nPreparations\n\n\nThis section describes the initial steps for creating the project structure and configuring essential files for developing your own VNFManager.\nThis can be done in two ways.\nEither you may use your favorite IDE or you may do everything manually via the command line.\n\n\nOnce this is done, you can start implementing your VNFManager by using different communication models, the catalogue and several helpers.\n\n\nUsing your favorite IDE\n\n\nIn the following we will create the project and setup the configuration files by using your favorite IDE.\nSo first of all, start your IDE and go to the next step.\nAll the details base on the usage of \nIntelliJIdea\n.\n\n\nCreate a new project\n\n\nOnce you have started the IDE, click on File -\n New -\n Project...\n\n\nIn this dialog click on Gradle on the left and select java in the main properties window in the middle.\n\n\n\n\nThen click on next to go to the next window.\n\n\nIn the next dialog you need to define the GroupId, ArtifactId and the Version.\nMore information on the specific meaning can be found \nhere\n.\n\n\n\n\nContinue with the next dialog.\n\n\nIn this dialog you need to specify which gradle you want to use.\nIt is recommend to use the default gradle wrapper.\nAdditionally you can enable the auto-import.\n\n\n\n\nContinue with the next dialog by clicking on Next.\n\n\nIn the last dialog, you need to define the project name and the project location.\n\n\n\n\nOnce this is done you can click on Finish and continue with creating the Main Class.\n\n\nCreate the Main Class\n\n\nAfterwards, you need to create the Main Class of the VNFManager which will be started in the end.\nFor doing so, right click on the root folder my-vnfm, then click on New -\n Directory and insert what is show below.\n\n\n\n\nClick on OK to continue.\n\n\nAdditionally you need to create a new package.\nThis is done by a right-click on the previously created directory java.\nClick on New -\n Package.\nHere you can define the package name.\n\n\n\n\nFinally you can create your Main Class by clicking (right click) on the previously created package and click on New -\n Java Class.\n\n\n\n\nOnce you did all these steps, the initial project structure is created.\nWhat we miss right now is the configuration of the gradle files to define and fetch dependencies we need for implementing the VNFManager.\nThis is described in later sections.\n\n\nCreate the properties files\n\n\nThe properties files are used to define several parameters you need at runtime.\nSo just create the following file structure.\n\n\nDo a right-click on the main folder located in the src folder.\nClick on New -\n Directory and create a new folder with the name resources.\n\n\nDo again a right-click on the newly created folder resources and click on New -\n File.\nThis you need to do two times.\nThe first file is called application.properties and the second one is called conf.properties.\n\n\nWhat these files should contain is explained \nhere\n.\n\n\nUsing the command line\n\n\nThis section refers to the developers which don't like to use any IDE.\nBy not using any IDE we need to create all the folders and configuration files manually.\nSo we start with creating the project structure, the Main Class, initializing the gradle wrapper and according configuration files.\n\n\nCreate project folder\n\n\nFirst of all you need to create a new directory for your VNFManager.\nHere we call the new VNFManager my-vnfm.\nSo this can be replaced by whatever you want.\n\n\n$ mkdir my-vnfm\n\n\n\n\nCreate the Main Class\n\n\nThe Main class is the most important class you need to consider.\nHere you implement your main method and also methods you need to have for your VNFManager.\nFurther explanations are done in the according sections.\nThis is only for creating a proper file structure.\nSo execute the following commands to create the Main class in a proper folder and package structure.\n\n\nFirst, you need to create the folders and package by executing the following command in your root folder of the project.\n\n\n$ mkdir -p src/main/java/org/openbaton/vnfm\n\n\n\n\nThis creates the java folder src/main/java with the proposed package name org.openbaton.vnfm.\n\n\nIn the next step you create the Main Class called MyVNFM in this case.\n\n\n$ vim /src/main/java/org/openbaton/vnfm/MyVNFM.java\n\n\n\n\nAt this point you create only the basic Java Class used later as the Main Class for implementing your VNFManager.\nThe newly created Java Class should contain the following lines for now.\n\n\npackage org.openbaton.vnfm;\n\npublic class MyVNFM {\n}\n\n\n\n\nIf you have chosen a different package name you need to replace it as well at this point.\nOnce this is done, you need to initialize the gradle wrapper and configuring according files.\n\n\nThe Build.Gradle file\n\n\nFirst you need to create the build.gradle file by executing the following command from your root project folder.\n\n\n$ vim build.gradle\n\n\n\n\nThis gradle configuration file needs to contain initially the following lines.\n\n\nbuildscript {\n    dependencies {\n        classpath(\norg.springframework.boot:spring-boot-gradle-plugin:1.2.6.RELEASE\n)\n    }\n}\ngroup 'your.group'\nversion '1.0-SNAPSHOT'\n\napply plugin: 'java'\napply plugin: 'spring-boot'\napply plugin: 'maven'\n\n\n\n\nThe second gradle configuration is called settings.gradle.\nThis file contains only the project name.\nSo create a new file called settings.gradle in your root folder.\n\n\n$ vim settings.gradle\n\n\n\n\nAfterwards you need to add the following line containing your project name.\nIn our case my-vnfm.\n\n\nrootProject.name = 'my-vnfm'\n\n\n\n\nAfterwards go back to the root folder and run the following command to create automatically the gradle wrapper which is used for code management and compilation.\nFor more information on how to use the gradle wrapper have a look at the gradle wrapper documentation \nhere\n.\n\n\n$ gradle wrapper --gradle-version 2.4\n\n\n\n\nOnce you did all these steps, the initial project structure is created.\nWhat we miss right now is the configuration of the gradle files to define and fetch dependencies we need for implementing the VNFManager.\nThis is described in later sections.\n\n\nCreate the properties files\n\n\nThe properties files are used to define several parameters you need at runtime.\nSo just create the following file structure by executing the following commands.\n\n\n$ mkdir src/main/resources\n\n\n\n\nNow you need to create two new files by running both commands you can find in the following\n\n\n$ touch src/main/resources/application.properties\n$ touch src/main/resources/conf.properties\n\n\n\n\nWhat these files should contain is explained \nhere\n.\n\n\nConfigure Gradle\n\n\nFinally you need to extend your build.gradle for announcing the Main Class, plugins to apply and repositories to use.\nSo open the build.gradle an add missing line so that the file contains the following line.\n\n\n//...\n\nbootRepackage {\n    mainClass = 'org.openbaton.vnfm.MyVNFM'\n}\n\n//...\n\n\n\n\nTake care about the configuration of the mainClass.\nIf the name or package of your mainClass is different, you need to replace it here as well.\n\n\nProperty files\n\n\nThe previously created properties files are used to define several things.\nThey are located in src/main/resources and are called application.properties and conf.properties.\n\n\nThe \napplication.properties\n contains parameters for setting up all log levels. This file is useful for configuring the springframework (see \nSpring Boot configuration file\n). This file can contain the following lines.\n\n\nlogging.level.org.springframework=INFO\nlogging.level.org.hibernate=INFO\nlogging.level.org.apache=INFO\nlogging.level.org.jclouds=WARN\n# logging.level.org.springframework.security=WARN\nlogging.level.org.springframework.web = WARN\n\n# Level for loggers on classes inside the root package \norg.project.openbaton\n (and its\n# sub-packages)\nlogging.level.org.openbaton=INFO\n\n# Direct log to a log file\nlogging.file=/var/log/openbaton.log\n\n\n\n\nIf you want to change log levels you need to adapt it here. Please note that if the VNFManager is running in the same machine of the rabbitMQ broker, this file is not needed.\n\n\nNOTE\n: \nIf your VNFManager is running on a different machine than the rabbitmq broker, you need to change the \nnfvo.rabbit.brokerIp\n accordingly with the ip:port of the rabbitmq broker.\n\n\nThe \nconf.properties\n is also a very important configuration file.\nHere you need to define the type and endpoint of your VNFManager that is later used for registering on the NFVO.\nFurthermore, you can define your own parameters which can be used at runtime for whatever you want.\nSo this file has to contain at least the type and endpoint.\nAdditionally, it is defined the folder where the vim-plugins are located.\nIn this case the file should contain the following lines.\n\n\ntype=my-vnfm\nendpoint=my-vnfm-endpoint\n\nallocate = true\nconcurrency = 15\ntransacted = false\n\n#### Additionally\nvim-plugin-dir = ./plugins\n\n\n\n\nWhere the parameters mean:\n\n\n\n\n\n\n\n\nParams\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\ntype\n\n\nThe type of VNF you are going to handle\n\n\n\n\n\n\nendpoint\n\n\nThe endpoint used for requesting this VNFManager\n\n\n\n\n\n\nallocate\n\n\ntrue if the NFVO will ALLOCATE_RESOURCES, false if the VNFManager will do\n\n\n\n\n\n\nconcurrency\n\n\nThe number of concurrent Receiver (only for vnfm-sdk-jms)\n\n\n\n\n\n\ntransacted\n\n\nWhenever the JMS receiver method shoud be transacted, this allows the message to be resent in case of exception VNFManager side (only for vnfm-sdk-jms)\n\n\n\n\n\n\n\n\nChoose a vnfm-sdk\n\n\nBefore you can start with the implementation you need to select the type of communication you want to use for the communication between the Orchestrator (NFVO) and the VNFManager.\nEither you can use the vnfm-sdk-jms for using the \nJava Message Service (JMS)\n or the vnfm-sdk-rest for using the \nReST\n interface.\nHowever, your choice doesn't effect the upcoming implementation, because the communication itself is done automatically in the background.\nBut have in mind that both libraries depend on \nSpringBoot\n.\nSo, if you want to avoid this dependency, a third option might be: just use the simple vnfm-sdk artifact.\nBy using the simple vnfm-sdk you need to take care about all the communication between NFVO and VNFManager by yourself.\n\n\nOnce you have imported one of the vnfm-sdks you will have access to all the model classes and the vnfm-sdk classes needed to implement a VNFManager.\n\n\nThe following section shows you how to import the vnfm-sdk-jms, representative for all the other opportunities.\n\n\nImport a vnfm-sdk\n\n\nThis section shows how to import and configure your VNFManager to make use of the vnfm-sdk-jms.\n\n\nFor gathering the vnfm-sdk-jms library you need to import the libraries by adding the missing lines to your build.gradle:\n\n\n//...\n\ndependencies {\n    compile 'org.hibernate:hibernate-core:4.3.10.Final'\n    compile 'org.openbaton:vnfm-sdk-jms:0.15'\n}\n\n//...\n\n\n\n\nNote\n To make use of the vnfm-sdk-rest you need to change 'vnfm-sdk-jms' to 'vnfm-sdk-rest' only.\n\n\nSo the final build.gradle file results like:\n\n\nbuildscript {\n    dependencies {\n        classpath(\norg.springframework.boot:spring-boot-gradle-plugin:1.2.6.RELEASE\n)\n    }\n}\n\napply plugin: 'spring-boot'\napply plugin: 'java'\napply plugin: 'maven'\n\nrepositories {\n    mavenCentral()\n    maven {\n        url \nhttp://193.175.132.176:8081/nexus/content/groups/public\n\n    }\n}\n\ndependencies {\n    compile 'org.openbaton:vnfm-sdk-jms:0.15'\n    compile 'org.hibernate:hibernate-core:4.3.10.Final'\n}\n\ngroup = 'your.group'\nversion = 1.0-SNAPSHOT\n\n\n\n\nOnce you did this, you need to trigger the gradle build process by running the following command via the command line in your project's root folder.\n\n\n$ ./gradlew build\n\n\n\n\nThis will fetch all the dependencies defined in the build.gradle and gives you access to all the Classes you need.\nYou can also do this by using the IDE by running the corresponding gradle task.\n\n\nImplementation of the VNFManager\n\n\nThis section is going to describe the implementation of a basic VNFManager by using the vnfm-sdk-jms.\nIn the end, the VNFManager will be able to allocate and terminate resources by using its own openstack-plugin.\n\n\nSo first of all you need to define the main method used for starting your VNFManager.\nSo add the following to your Main Class that it looks as follows:\n\n\npackage org.openbaton.vnfm;\n\npublic class MyVNFM {\n\n    public static void main(String[] args){\n        SpringApplication.run(MyVNFM.class);\n    }\n}\n\n\n\n\nAfterwards you need to extend your Main Class (in this case MyVNFM) with the \nAbstractVnfmSpringJMS\n.\n\n\nThe \nAbstractVnfmSpringJMS\n takes care of all the configuration you need to register/unregister the VNFManager to the NFVO and handles incoming messages.\nWhereas the \nAbstractVnfm\n, extended by the \nAbstractVnfmSpringJMS\n, is independent of the type of communication.\nThis means more in detail that the \nAbstractVnfm\n processes the incoming messages and executes the right method depending on the defined Action inside the message.\nMoreover, it is responsible for loading predefined configuration files, setting up the VNFManager itself, creating the VNFR (based on the VNFD received in the first step) and doing essential parts like requesting the NFVO for granting operations or deciding who is responsible for allocate resources.\n\n\nOnce you extended your VNFMManger, you need to implement all the methods coming from the extension of \nAbstractVnfmSpringJMS\n as shown below:\n\n\npackage org.openbaton.vnfm;\n\nimport org.openbaton.catalogue.mano.record.VNFRecordDependency;\nimport org.openbaton.catalogue.mano.record.VirtualNetworkFunctionRecord;\nimport org.openbaton.common.vnfm_sdk.VnfmHelper;\nimport org.openbaton.common.vnfm_sdk.jms.AbstractVnfmSpringJMS;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.SpringApplication;\n\npublic class MyVNFM extends AbstractVnfmSpringJMS {\n\n    @Autowired\n    private VnfmHelper vnfmHelper;\n\n    /**\n     * This operation allows creating a VNF instance.\n     * @param virtualNetworkFunctionRecord\n     * @param scripts\n     */\n    @Override\n    public VirtualNetworkFunctionRecord instantiate(VirtualNetworkFunctionRecord virtualNetworkFunctionRecord, Object scripts) throws Exception {\n        return virtualNetworkFunctionRecord;\n    }\n\n    /**\n     * This operation allows retrieving\n     * VNF instance state and attributes.\n     */\n    @Override\n    public void query() {\n\n    }\n\n    /**\n     * This operation allows scaling\n     * (out/in, up/down) a VNF instance.\n     */\n    @Override\n    public void scale() {\n\n    }\n\n    /**\n     * This operation allows verifying if\n     * the VNF instantiation is possible.\n     */\n    @Override\n    public void checkInstantiationFeasibility() {\n\n    }\n\n    /**\n     * This operation allows verifying if\n     * the VNF instantiation is possible.\n     */\n    @Override\n    public void heal() {\n\n    }\n\n    /**\n     * This operation allows applying a minor/limited\n     * software update (e.g. patch) to a VNF instance.\n     */\n    @Override\n    public void updateSoftware() {\n\n    }\n\n    /**\n     * This operation allows making structural changes\n     * (e.g. configuration, topology, behavior,\n     * redundancy model) to a VNF instance.\n     * @param virtualNetworkFunctionRecord\n     * @param dependency\n     */\n    @Override\n    public VirtualNetworkFunctionRecord modify(VirtualNetworkFunctionRecord virtualNetworkFunctionRecord, VNFRecordDependency dependency) throws Exception {\n        return virtualNetworkFunctionRecord;\n    }\n\n    /**\n     * This operation allows deploying a new\n     * software release to a VNF instance.\n     */\n    @Override\n    public void upgradeSoftware() {\n\n    }\n\n    /**\n     * This operation allows terminating gracefully\n     * or forcefully a previously created VNF instance.\n     * @param virtualNetworkFunctionRecord\n     */\n    @Override\n    public VirtualNetworkFunctionRecord terminate(VirtualNetworkFunctionRecord virtualNetworkFunctionRecord) throws Exception{\n        return virtualNetworkFunctionRecord;\n    }\n\n    @Override\n    protected void checkEmsStarted(String hostname) throws RuntimeException {\n\n    }\n\n    @Override\n    public VirtualNetworkFunctionRecord start(VirtualNetworkFunctionRecord virtualNetworkFunctionRecord) throws Exception {\n        return virtualNetworkFunctionRecord;\n    }\n\n    @Override\n    public VirtualNetworkFunctionRecord configure(VirtualNetworkFunctionRecord virtualNetworkFunctionRecord) throws Exception {\n        return virtualNetworkFunctionRecord;\n    }\n\n    /**\n     * This operation allows providing notifications on state changes\n     * of a VNF instance, related to the VNF Lifecycle.\n     */\n    @Override\n    public void NotifyChange() {\n\n    }\n\n    public static void main(String[] args){\n        SpringApplication.run(MyVNFM.class);\n    }\n}\n\n\n\n\nNow you can implement whatever you want. If the VirtualNetworkFunctionRecord is returned, it will go back directly to the NFVO.\n\n\nOne of the methods that can be overwritten is the \nfillSpecificParameters\n. This method is important when you have specified some \"provides\" in your VNFD, in facts you can fill them in this method and make them available afterwards to the scripts (see \nHow to use the parameters\n). \n\n\nAn example of allocating and terminating resource by using a plugin can be found \nhere\n and \nhere\n.\n\n\nNote\n If you use vnfm-sdk-jms or vnfm-sdk-rest \nthe VNFManager main class needs to be stateless\n since it can (will) run each method potentially in parallel.\nFor what concerns vnfm-sdk-jms, even setting concurrency to 1, will not ensure to have always the same instance of the class.\n\n\nUsing the VnfmHelper\n\n\nAdditionally you can autowire the VnfmHelper to make use of several helper methods that are very useful.\nIn this case your VNFManager should look like this:\n\n\npackage org.openbaton.vnfm;\n\nimport org.springframework.beans.factory.annotation.Autowired;\n\npublic class MyVNFM extends AbstractVnfmSpringJMS {\n\n    @Autowired\n    private VnfmHelper vnfmHelper;\n\n    [...]\n}\n\n\n\n\nThe vnfmHelper helps with some methods out of the box:\n\n\npackage org.openbaton.common.vnfm_sdk;\n\nimport org.openbaton.catalogue.nfvo.messages.Interfaces.NFVMessage;\n\npublic abstract class VnfmHelper {\n\n    /**\n     * This operation sends a NFVMessage\n     * to the NFVO and doesn't wait for answer.\n     * @param nfvMessage\n     */\n    public abstract void sendToNfvo(NFVMessage nfvMessage);\n\n    /**\n     * This operation send a NFVMessage\n     * to the NFVO and waits for the answer.\n     * @param nfvMessage\n     */\n    public abstract NFVMessage sendAndReceive(NFVMessage nfvMessage) throws Exception;\n}\n\n\n\n\nAt the moment, the main purpose of the VnfmHelper is to send messages to the NFVO and wait for the answer if needed.\n\n\nNote\n This class needs to be implemented in case you want to use only the vnfm-sdk and must be provided to the AbstractVnfm.\n\n\nUsing plugins\n\n\nThis section describes the initialization and usage of plugins.\nTherefore, you need to do several things:\n\n\n\n\nCreate a Registry\n\n\nStart the plugins\n\n\nConnect an according VIM to the plugin\n\n\n\n\nNote\n If you want to use plugins, you need to fetch also the interfaces and VIM implementations by adding the following lines to your build.gradle dependencies\n\n\ncompile 'org.openbaton:vim-int:0.15'\ncompile 'org.openbaton:vim-impl:0.15'\n\n\n\n\nAfter that you need to rebuild your project for fetching the dependencies automatically.\n\n\nNow you can use the ResourceManagement interface.\nIn the end it should look like the following:\n\n\npackage org.openbaton.vnfm;\n\nimport org.openbaton.nfvo.vim_interfaces.resource_management.ResourceManagement;\nimport org.springframework.context.ConfigurableApplicationContext;\nimport org.springframework.beans.factory.annotation.Autowired;\n\nimport org.openbaton.plugin.utils.PluginStartup;\nimport java.io.IOException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\n\npublic class MyVNFM extends AbstractVnfmSpringJMS {\n\n    @Autowired\n    private ConfigurableApplicationContext context;\n\n    private ResourceManagement resourceManagement;\n\n    [...]\n\n    @Override\n    protected void setup() {\n        super.setup();\n        try {\n            int registryport = 19345;\n            Registry registry = LocateRegistry.createRegistry(registryport);\n            PluginStartup.startPluginRecursive(\n./plugins\n, true, \nlocalhost\n, \n + registryport);\n        } catch (IOException e) {\n            log.error(e.getMessage(), e);\n        }\n        resourceManagement = (ResourceManagement) context.getBean(\nopenstackVIM\n, \nopenstack\n, 19345);\n    }\n}\n\n\n\n\nThis code expects that the plugins are located in ./plugins.\nSo just copy the openstack plugin of your choice to this path.\nNow you are able to use a VIM inside your VNFManager to allocate and release resources whenever you want.\n\n\nAllocate Resources\n\n\nThe following code snippet shows how to instantiate (allocate) resources at VNFManager side with the help of the VIM.\n\n\n@Override\npublic VirtualNetworkFunctionRecord instantiate(VirtualNetworkFunctionRecord virtualNetworkFunctionRecord, Object object) {\n    log.debug(\nProcessing allocation of Resources for vnfr: \n + virtualNetworkFunctionRecord);\n    List\nFuture\nVNFCInstance\n vnfcInstances = new ArrayList\n();\n    try {\n        for (VirtualDeploymentUnit vdu : virtualNetworkFunctionRecord.getVdu()) {\n            log.debug(\nCreating \n + vdu.getVnfc().size() + \n VMs\n);\n            for (VNFComponent vnfComponent : vdu.getVnfc()) {\n                Future\nVNFCInstance\n allocate = resourceManagement.allocate(vdu, virtualNetworkFunctionRecord, vnfComponent, \n#userdata\n, vnfComponent.isExposed());\n                vnfcInstances.add(allocate);\n            }\n        }\n    } catch (VimDriverException e) {\n        log.error(e.getMessage(), e);\n        throw new RuntimeException(e.getMessage(), e);\n    } catch (VimException e) {\n        log.error(e.getMessage(), e);\n        throw new RuntimeException(e.getMessage(), e);\n    }\n    //Print ids of deployed VDUs\n    for (Future\nVNFCInstance\n vnfcInstance : vnfcInstances) {\n        try {\n            log.debug(\nCreated VNFCInstance with id: \n + vnfcInstance.get());\n        } catch (InterruptedException e) {\n            log.error(e.getMessage(), e);\n            throw new RuntimeException(e.getMessage(), e);\n        } catch (ExecutionException e) {\n            log.error(e.getMessage(), e);\n            throw new RuntimeException(e.getMessage(), e);\n        }\n    }\n    log.debug(\nAllocated all Resources for vnfr: \n + virtualNetworkFunctionRecord);\n    return virtualNetworkFunctionRecord;\n}\n\n\n\n\nNote\n Keep in mind that you need to set \nallocate\n to false in conf.properties, if you want to allocate resources on the VNFManager side.\n\n\nRelease Resources\n\n\nThe next code snippet shows an implementation of the terminate method used for releasing resources at VNFManager side.\n\n\n@Override\npublic VirtualNetworkFunctionRecord terminate(VirtualNetworkFunctionRecord virtualNetworkFunctionRecord) {\n    log.info(\nTerminating vnfr with id \n + virtualNetworkFunctionRecord.getId());\n    for (VirtualDeploymentUnit vdu : virtualNetworkFunctionRecord.getVdu()) {\n        Set\nVNFCInstance\n vnfciToRem = new HashSet\n();\n        for (VNFCInstance vnfcInstance : vdu.getVnfc_instance()) {\n            log.debug(\nReleasing resources for vdu with id \n + vdu.getId());\n            try {\n                resourceManagement.release(vnfcInstance, vdu.getVimInstance());\n            } catch (VimException e) {\n                log.error(e.getMessage(), e);\n                throw new RuntimeException(e.getMessage(), e);\n            }\n            vnfciToRem.add(vnfcInstance);\n            log.debug(\nReleased resources for vdu with id \n + vdu.getId());\n        }\n        vdu.getVnfc_instance().removeAll(vnfciToRem);\n    }\n    log.info(\nTerminated vnfr with id \n + virtualNetworkFunctionRecord.getId());\n    return virtualNetworkFunctionRecord;\n}\n\n\n\n\nStart the VNFManager\n\n\nOnce you finalized your VNFManager you can compile and start it with the following commands.\n\n\n$ ./gradlew clean build\n$ java -jar build/libs/my-vnfm.jar\n\n\n\n\nIf everything is fine, your VNFManager will register to NFVO and is able now to receive requests and process them.\n\n\n\n\n\n\n\n\n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  &amp;&amp; (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Write your own VNFM"
        }, 
        {
            "location": "/vnfm-how-to-write/#how-to-write-a-vnfmanager", 
            "text": "This section is going to describe how to write your own VNFManager by using any vnfm-sdk.\nMoreover, the vnfm-sdk contains all the things you may need for the development of the VNFManager of your choice as well.  The vnfm-sdk provides the following things:   multiple  vnfm-sdks  where you can choose your preferred type of communication  Catalogue, shared with the NFVO containing all entities  VNFMHelper  for providing some methods out of the box", 
            "title": "How to write a VNFManager"
        }, 
        {
            "location": "/vnfm-how-to-write/#requirements", 
            "text": "Before you can start with developing your own VNFManager you need to prepare your programming environment by installing/configuring the following requirements:   JDK 7 ( installation )  Gradle ( installation )", 
            "title": "Requirements"
        }, 
        {
            "location": "/vnfm-how-to-write/#develop-your-own-vnfmanager", 
            "text": "This part is going to describe the steps you need to do to develop your own VNFManager with the help of any vnfm-sdk.  The practical parts of implementing a basic VNFManager will focus on the usage of a specific vnfm-sdk, namely the vnfm-sdk-jms.  Preparations  This section describes the initial steps for creating the project structure and configuring essential files for developing your own VNFManager.\nThis can be done in two ways.\nEither you may use your favorite IDE or you may do everything manually via the command line.  Once this is done, you can start implementing your VNFManager by using different communication models, the catalogue and several helpers.  Using your favorite IDE  In the following we will create the project and setup the configuration files by using your favorite IDE.\nSo first of all, start your IDE and go to the next step.\nAll the details base on the usage of  IntelliJIdea .  Create a new project  Once you have started the IDE, click on File -  New -  Project...  In this dialog click on Gradle on the left and select java in the main properties window in the middle.   Then click on next to go to the next window.  In the next dialog you need to define the GroupId, ArtifactId and the Version.\nMore information on the specific meaning can be found  here .   Continue with the next dialog.  In this dialog you need to specify which gradle you want to use.\nIt is recommend to use the default gradle wrapper.\nAdditionally you can enable the auto-import.   Continue with the next dialog by clicking on Next.  In the last dialog, you need to define the project name and the project location.   Once this is done you can click on Finish and continue with creating the Main Class.  Create the Main Class  Afterwards, you need to create the Main Class of the VNFManager which will be started in the end.\nFor doing so, right click on the root folder my-vnfm, then click on New -  Directory and insert what is show below.   Click on OK to continue.  Additionally you need to create a new package.\nThis is done by a right-click on the previously created directory java.\nClick on New -  Package.\nHere you can define the package name.   Finally you can create your Main Class by clicking (right click) on the previously created package and click on New -  Java Class.   Once you did all these steps, the initial project structure is created.\nWhat we miss right now is the configuration of the gradle files to define and fetch dependencies we need for implementing the VNFManager.\nThis is described in later sections.  Create the properties files  The properties files are used to define several parameters you need at runtime.\nSo just create the following file structure.  Do a right-click on the main folder located in the src folder.\nClick on New -  Directory and create a new folder with the name resources.  Do again a right-click on the newly created folder resources and click on New -  File.\nThis you need to do two times.\nThe first file is called application.properties and the second one is called conf.properties.  What these files should contain is explained  here .  Using the command line  This section refers to the developers which don't like to use any IDE.\nBy not using any IDE we need to create all the folders and configuration files manually.\nSo we start with creating the project structure, the Main Class, initializing the gradle wrapper and according configuration files.  Create project folder  First of all you need to create a new directory for your VNFManager.\nHere we call the new VNFManager my-vnfm.\nSo this can be replaced by whatever you want.  $ mkdir my-vnfm  Create the Main Class  The Main class is the most important class you need to consider.\nHere you implement your main method and also methods you need to have for your VNFManager.\nFurther explanations are done in the according sections.\nThis is only for creating a proper file structure.\nSo execute the following commands to create the Main class in a proper folder and package structure.  First, you need to create the folders and package by executing the following command in your root folder of the project.  $ mkdir -p src/main/java/org/openbaton/vnfm  This creates the java folder src/main/java with the proposed package name org.openbaton.vnfm.  In the next step you create the Main Class called MyVNFM in this case.  $ vim /src/main/java/org/openbaton/vnfm/MyVNFM.java  At this point you create only the basic Java Class used later as the Main Class for implementing your VNFManager.\nThe newly created Java Class should contain the following lines for now.  package org.openbaton.vnfm;\n\npublic class MyVNFM {\n}  If you have chosen a different package name you need to replace it as well at this point.\nOnce this is done, you need to initialize the gradle wrapper and configuring according files.  The Build.Gradle file  First you need to create the build.gradle file by executing the following command from your root project folder.  $ vim build.gradle  This gradle configuration file needs to contain initially the following lines.  buildscript {\n    dependencies {\n        classpath( org.springframework.boot:spring-boot-gradle-plugin:1.2.6.RELEASE )\n    }\n}\ngroup 'your.group'\nversion '1.0-SNAPSHOT'\n\napply plugin: 'java'\napply plugin: 'spring-boot'\napply plugin: 'maven'  The second gradle configuration is called settings.gradle.\nThis file contains only the project name.\nSo create a new file called settings.gradle in your root folder.  $ vim settings.gradle  Afterwards you need to add the following line containing your project name.\nIn our case my-vnfm.  rootProject.name = 'my-vnfm'  Afterwards go back to the root folder and run the following command to create automatically the gradle wrapper which is used for code management and compilation.\nFor more information on how to use the gradle wrapper have a look at the gradle wrapper documentation  here .  $ gradle wrapper --gradle-version 2.4  Once you did all these steps, the initial project structure is created.\nWhat we miss right now is the configuration of the gradle files to define and fetch dependencies we need for implementing the VNFManager.\nThis is described in later sections.  Create the properties files  The properties files are used to define several parameters you need at runtime.\nSo just create the following file structure by executing the following commands.  $ mkdir src/main/resources  Now you need to create two new files by running both commands you can find in the following  $ touch src/main/resources/application.properties\n$ touch src/main/resources/conf.properties  What these files should contain is explained  here .  Configure Gradle  Finally you need to extend your build.gradle for announcing the Main Class, plugins to apply and repositories to use.\nSo open the build.gradle an add missing line so that the file contains the following line.  //...\n\nbootRepackage {\n    mainClass = 'org.openbaton.vnfm.MyVNFM'\n}\n\n//...  Take care about the configuration of the mainClass.\nIf the name or package of your mainClass is different, you need to replace it here as well.  Property files  The previously created properties files are used to define several things.\nThey are located in src/main/resources and are called application.properties and conf.properties.  The  application.properties  contains parameters for setting up all log levels. This file is useful for configuring the springframework (see  Spring Boot configuration file ). This file can contain the following lines.  logging.level.org.springframework=INFO\nlogging.level.org.hibernate=INFO\nlogging.level.org.apache=INFO\nlogging.level.org.jclouds=WARN\n# logging.level.org.springframework.security=WARN\nlogging.level.org.springframework.web = WARN\n\n# Level for loggers on classes inside the root package  org.project.openbaton  (and its\n# sub-packages)\nlogging.level.org.openbaton=INFO\n\n# Direct log to a log file\nlogging.file=/var/log/openbaton.log  If you want to change log levels you need to adapt it here. Please note that if the VNFManager is running in the same machine of the rabbitMQ broker, this file is not needed.  NOTE :  If your VNFManager is running on a different machine than the rabbitmq broker, you need to change the  nfvo.rabbit.brokerIp  accordingly with the ip:port of the rabbitmq broker.  The  conf.properties  is also a very important configuration file.\nHere you need to define the type and endpoint of your VNFManager that is later used for registering on the NFVO.\nFurthermore, you can define your own parameters which can be used at runtime for whatever you want.\nSo this file has to contain at least the type and endpoint.\nAdditionally, it is defined the folder where the vim-plugins are located.\nIn this case the file should contain the following lines.  type=my-vnfm\nendpoint=my-vnfm-endpoint\n\nallocate = true\nconcurrency = 15\ntransacted = false\n\n#### Additionally\nvim-plugin-dir = ./plugins  Where the parameters mean:     Params  Meaning      type  The type of VNF you are going to handle    endpoint  The endpoint used for requesting this VNFManager    allocate  true if the NFVO will ALLOCATE_RESOURCES, false if the VNFManager will do    concurrency  The number of concurrent Receiver (only for vnfm-sdk-jms)    transacted  Whenever the JMS receiver method shoud be transacted, this allows the message to be resent in case of exception VNFManager side (only for vnfm-sdk-jms)", 
            "title": "Develop your own VNFManager"
        }, 
        {
            "location": "/vnfm-how-to-write/#choose-a-vnfm-sdk", 
            "text": "Before you can start with the implementation you need to select the type of communication you want to use for the communication between the Orchestrator (NFVO) and the VNFManager.\nEither you can use the vnfm-sdk-jms for using the  Java Message Service (JMS)  or the vnfm-sdk-rest for using the  ReST  interface.\nHowever, your choice doesn't effect the upcoming implementation, because the communication itself is done automatically in the background.\nBut have in mind that both libraries depend on  SpringBoot .\nSo, if you want to avoid this dependency, a third option might be: just use the simple vnfm-sdk artifact.\nBy using the simple vnfm-sdk you need to take care about all the communication between NFVO and VNFManager by yourself.  Once you have imported one of the vnfm-sdks you will have access to all the model classes and the vnfm-sdk classes needed to implement a VNFManager.  The following section shows you how to import the vnfm-sdk-jms, representative for all the other opportunities.  Import a vnfm-sdk  This section shows how to import and configure your VNFManager to make use of the vnfm-sdk-jms.  For gathering the vnfm-sdk-jms library you need to import the libraries by adding the missing lines to your build.gradle:  //...\n\ndependencies {\n    compile 'org.hibernate:hibernate-core:4.3.10.Final'\n    compile 'org.openbaton:vnfm-sdk-jms:0.15'\n}\n\n//...  Note  To make use of the vnfm-sdk-rest you need to change 'vnfm-sdk-jms' to 'vnfm-sdk-rest' only.  So the final build.gradle file results like:  buildscript {\n    dependencies {\n        classpath( org.springframework.boot:spring-boot-gradle-plugin:1.2.6.RELEASE )\n    }\n}\n\napply plugin: 'spring-boot'\napply plugin: 'java'\napply plugin: 'maven'\n\nrepositories {\n    mavenCentral()\n    maven {\n        url  http://193.175.132.176:8081/nexus/content/groups/public \n    }\n}\n\ndependencies {\n    compile 'org.openbaton:vnfm-sdk-jms:0.15'\n    compile 'org.hibernate:hibernate-core:4.3.10.Final'\n}\n\ngroup = 'your.group'\nversion = 1.0-SNAPSHOT  Once you did this, you need to trigger the gradle build process by running the following command via the command line in your project's root folder.  $ ./gradlew build  This will fetch all the dependencies defined in the build.gradle and gives you access to all the Classes you need.\nYou can also do this by using the IDE by running the corresponding gradle task.", 
            "title": "Choose a vnfm-sdk"
        }, 
        {
            "location": "/vnfm-how-to-write/#implementation-of-the-vnfmanager", 
            "text": "This section is going to describe the implementation of a basic VNFManager by using the vnfm-sdk-jms.\nIn the end, the VNFManager will be able to allocate and terminate resources by using its own openstack-plugin.  So first of all you need to define the main method used for starting your VNFManager.\nSo add the following to your Main Class that it looks as follows:  package org.openbaton.vnfm;\n\npublic class MyVNFM {\n\n    public static void main(String[] args){\n        SpringApplication.run(MyVNFM.class);\n    }\n}  Afterwards you need to extend your Main Class (in this case MyVNFM) with the  AbstractVnfmSpringJMS .  The  AbstractVnfmSpringJMS  takes care of all the configuration you need to register/unregister the VNFManager to the NFVO and handles incoming messages.\nWhereas the  AbstractVnfm , extended by the  AbstractVnfmSpringJMS , is independent of the type of communication.\nThis means more in detail that the  AbstractVnfm  processes the incoming messages and executes the right method depending on the defined Action inside the message.\nMoreover, it is responsible for loading predefined configuration files, setting up the VNFManager itself, creating the VNFR (based on the VNFD received in the first step) and doing essential parts like requesting the NFVO for granting operations or deciding who is responsible for allocate resources.  Once you extended your VNFMManger, you need to implement all the methods coming from the extension of  AbstractVnfmSpringJMS  as shown below:  package org.openbaton.vnfm;\n\nimport org.openbaton.catalogue.mano.record.VNFRecordDependency;\nimport org.openbaton.catalogue.mano.record.VirtualNetworkFunctionRecord;\nimport org.openbaton.common.vnfm_sdk.VnfmHelper;\nimport org.openbaton.common.vnfm_sdk.jms.AbstractVnfmSpringJMS;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.SpringApplication;\n\npublic class MyVNFM extends AbstractVnfmSpringJMS {\n\n    @Autowired\n    private VnfmHelper vnfmHelper;\n\n    /**\n     * This operation allows creating a VNF instance.\n     * @param virtualNetworkFunctionRecord\n     * @param scripts\n     */\n    @Override\n    public VirtualNetworkFunctionRecord instantiate(VirtualNetworkFunctionRecord virtualNetworkFunctionRecord, Object scripts) throws Exception {\n        return virtualNetworkFunctionRecord;\n    }\n\n    /**\n     * This operation allows retrieving\n     * VNF instance state and attributes.\n     */\n    @Override\n    public void query() {\n\n    }\n\n    /**\n     * This operation allows scaling\n     * (out/in, up/down) a VNF instance.\n     */\n    @Override\n    public void scale() {\n\n    }\n\n    /**\n     * This operation allows verifying if\n     * the VNF instantiation is possible.\n     */\n    @Override\n    public void checkInstantiationFeasibility() {\n\n    }\n\n    /**\n     * This operation allows verifying if\n     * the VNF instantiation is possible.\n     */\n    @Override\n    public void heal() {\n\n    }\n\n    /**\n     * This operation allows applying a minor/limited\n     * software update (e.g. patch) to a VNF instance.\n     */\n    @Override\n    public void updateSoftware() {\n\n    }\n\n    /**\n     * This operation allows making structural changes\n     * (e.g. configuration, topology, behavior,\n     * redundancy model) to a VNF instance.\n     * @param virtualNetworkFunctionRecord\n     * @param dependency\n     */\n    @Override\n    public VirtualNetworkFunctionRecord modify(VirtualNetworkFunctionRecord virtualNetworkFunctionRecord, VNFRecordDependency dependency) throws Exception {\n        return virtualNetworkFunctionRecord;\n    }\n\n    /**\n     * This operation allows deploying a new\n     * software release to a VNF instance.\n     */\n    @Override\n    public void upgradeSoftware() {\n\n    }\n\n    /**\n     * This operation allows terminating gracefully\n     * or forcefully a previously created VNF instance.\n     * @param virtualNetworkFunctionRecord\n     */\n    @Override\n    public VirtualNetworkFunctionRecord terminate(VirtualNetworkFunctionRecord virtualNetworkFunctionRecord) throws Exception{\n        return virtualNetworkFunctionRecord;\n    }\n\n    @Override\n    protected void checkEmsStarted(String hostname) throws RuntimeException {\n\n    }\n\n    @Override\n    public VirtualNetworkFunctionRecord start(VirtualNetworkFunctionRecord virtualNetworkFunctionRecord) throws Exception {\n        return virtualNetworkFunctionRecord;\n    }\n\n    @Override\n    public VirtualNetworkFunctionRecord configure(VirtualNetworkFunctionRecord virtualNetworkFunctionRecord) throws Exception {\n        return virtualNetworkFunctionRecord;\n    }\n\n    /**\n     * This operation allows providing notifications on state changes\n     * of a VNF instance, related to the VNF Lifecycle.\n     */\n    @Override\n    public void NotifyChange() {\n\n    }\n\n    public static void main(String[] args){\n        SpringApplication.run(MyVNFM.class);\n    }\n}  Now you can implement whatever you want. If the VirtualNetworkFunctionRecord is returned, it will go back directly to the NFVO.  One of the methods that can be overwritten is the  fillSpecificParameters . This method is important when you have specified some \"provides\" in your VNFD, in facts you can fill them in this method and make them available afterwards to the scripts (see  How to use the parameters ).   An example of allocating and terminating resource by using a plugin can be found  here  and  here .  Note  If you use vnfm-sdk-jms or vnfm-sdk-rest  the VNFManager main class needs to be stateless  since it can (will) run each method potentially in parallel.\nFor what concerns vnfm-sdk-jms, even setting concurrency to 1, will not ensure to have always the same instance of the class.  Using the VnfmHelper  Additionally you can autowire the VnfmHelper to make use of several helper methods that are very useful.\nIn this case your VNFManager should look like this:  package org.openbaton.vnfm;\n\nimport org.springframework.beans.factory.annotation.Autowired;\n\npublic class MyVNFM extends AbstractVnfmSpringJMS {\n\n    @Autowired\n    private VnfmHelper vnfmHelper;\n\n    [...]\n}  The vnfmHelper helps with some methods out of the box:  package org.openbaton.common.vnfm_sdk;\n\nimport org.openbaton.catalogue.nfvo.messages.Interfaces.NFVMessage;\n\npublic abstract class VnfmHelper {\n\n    /**\n     * This operation sends a NFVMessage\n     * to the NFVO and doesn't wait for answer.\n     * @param nfvMessage\n     */\n    public abstract void sendToNfvo(NFVMessage nfvMessage);\n\n    /**\n     * This operation send a NFVMessage\n     * to the NFVO and waits for the answer.\n     * @param nfvMessage\n     */\n    public abstract NFVMessage sendAndReceive(NFVMessage nfvMessage) throws Exception;\n}  At the moment, the main purpose of the VnfmHelper is to send messages to the NFVO and wait for the answer if needed.  Note  This class needs to be implemented in case you want to use only the vnfm-sdk and must be provided to the AbstractVnfm.  Using plugins  This section describes the initialization and usage of plugins.\nTherefore, you need to do several things:   Create a Registry  Start the plugins  Connect an according VIM to the plugin   Note  If you want to use plugins, you need to fetch also the interfaces and VIM implementations by adding the following lines to your build.gradle dependencies  compile 'org.openbaton:vim-int:0.15'\ncompile 'org.openbaton:vim-impl:0.15'  After that you need to rebuild your project for fetching the dependencies automatically.  Now you can use the ResourceManagement interface.\nIn the end it should look like the following:  package org.openbaton.vnfm;\n\nimport org.openbaton.nfvo.vim_interfaces.resource_management.ResourceManagement;\nimport org.springframework.context.ConfigurableApplicationContext;\nimport org.springframework.beans.factory.annotation.Autowired;\n\nimport org.openbaton.plugin.utils.PluginStartup;\nimport java.io.IOException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\n\npublic class MyVNFM extends AbstractVnfmSpringJMS {\n\n    @Autowired\n    private ConfigurableApplicationContext context;\n\n    private ResourceManagement resourceManagement;\n\n    [...]\n\n    @Override\n    protected void setup() {\n        super.setup();\n        try {\n            int registryport = 19345;\n            Registry registry = LocateRegistry.createRegistry(registryport);\n            PluginStartup.startPluginRecursive( ./plugins , true,  localhost ,   + registryport);\n        } catch (IOException e) {\n            log.error(e.getMessage(), e);\n        }\n        resourceManagement = (ResourceManagement) context.getBean( openstackVIM ,  openstack , 19345);\n    }\n}  This code expects that the plugins are located in ./plugins.\nSo just copy the openstack plugin of your choice to this path.\nNow you are able to use a VIM inside your VNFManager to allocate and release resources whenever you want.  Allocate Resources  The following code snippet shows how to instantiate (allocate) resources at VNFManager side with the help of the VIM.  @Override\npublic VirtualNetworkFunctionRecord instantiate(VirtualNetworkFunctionRecord virtualNetworkFunctionRecord, Object object) {\n    log.debug( Processing allocation of Resources for vnfr:   + virtualNetworkFunctionRecord);\n    List Future VNFCInstance  vnfcInstances = new ArrayList ();\n    try {\n        for (VirtualDeploymentUnit vdu : virtualNetworkFunctionRecord.getVdu()) {\n            log.debug( Creating   + vdu.getVnfc().size() +   VMs );\n            for (VNFComponent vnfComponent : vdu.getVnfc()) {\n                Future VNFCInstance  allocate = resourceManagement.allocate(vdu, virtualNetworkFunctionRecord, vnfComponent,  #userdata , vnfComponent.isExposed());\n                vnfcInstances.add(allocate);\n            }\n        }\n    } catch (VimDriverException e) {\n        log.error(e.getMessage(), e);\n        throw new RuntimeException(e.getMessage(), e);\n    } catch (VimException e) {\n        log.error(e.getMessage(), e);\n        throw new RuntimeException(e.getMessage(), e);\n    }\n    //Print ids of deployed VDUs\n    for (Future VNFCInstance  vnfcInstance : vnfcInstances) {\n        try {\n            log.debug( Created VNFCInstance with id:   + vnfcInstance.get());\n        } catch (InterruptedException e) {\n            log.error(e.getMessage(), e);\n            throw new RuntimeException(e.getMessage(), e);\n        } catch (ExecutionException e) {\n            log.error(e.getMessage(), e);\n            throw new RuntimeException(e.getMessage(), e);\n        }\n    }\n    log.debug( Allocated all Resources for vnfr:   + virtualNetworkFunctionRecord);\n    return virtualNetworkFunctionRecord;\n}  Note  Keep in mind that you need to set  allocate  to false in conf.properties, if you want to allocate resources on the VNFManager side.  Release Resources  The next code snippet shows an implementation of the terminate method used for releasing resources at VNFManager side.  @Override\npublic VirtualNetworkFunctionRecord terminate(VirtualNetworkFunctionRecord virtualNetworkFunctionRecord) {\n    log.info( Terminating vnfr with id   + virtualNetworkFunctionRecord.getId());\n    for (VirtualDeploymentUnit vdu : virtualNetworkFunctionRecord.getVdu()) {\n        Set VNFCInstance  vnfciToRem = new HashSet ();\n        for (VNFCInstance vnfcInstance : vdu.getVnfc_instance()) {\n            log.debug( Releasing resources for vdu with id   + vdu.getId());\n            try {\n                resourceManagement.release(vnfcInstance, vdu.getVimInstance());\n            } catch (VimException e) {\n                log.error(e.getMessage(), e);\n                throw new RuntimeException(e.getMessage(), e);\n            }\n            vnfciToRem.add(vnfcInstance);\n            log.debug( Released resources for vdu with id   + vdu.getId());\n        }\n        vdu.getVnfc_instance().removeAll(vnfciToRem);\n    }\n    log.info( Terminated vnfr with id   + virtualNetworkFunctionRecord.getId());\n    return virtualNetworkFunctionRecord;\n}  Start the VNFManager  Once you finalized your VNFManager you can compile and start it with the following commands.  $ ./gradlew clean build\n$ java -jar build/libs/my-vnfm.jar  If everything is fine, your VNFManager will register to NFVO and is able now to receive requests and process them.    \n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  &amp;&amp; (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Implementation of the VNFManager"
        }, 
        {
            "location": "/vnfm-vendor-specific/", 
            "text": "Use my VNFM\n\n\nIn this section are described the REST interfaces which allow you to integrate your VNFM with Openbaton's NFVO.\n\n\nNFVO - VNFM ReST interface\n\n\nNfvo exposes a ReST interface for the communication with the VnfManagers. The sequence diagram regarding the instantiation of a NetworkServiceRecord is shown in the following picture.\n\n\n\n\nAs shown in the picture, NFVO calls some ReST methods on the vnfm in a particular order. Then it expects some kind of back call. The list of these call exchange is described in the following sections. The ALLOCATE_RESOURCES call is not needed if the vnfm will take care of creating VMs. The communication with the EMS is particular to each VnfManagers. In order to be able to be found, the Vnfm needs to register to the NFVO. This can be done through a particular call.\n\n\nIn the following 'Vnfm-Or' means that the Vnfm sends to the Nfvo and 'Or-Vnfm' means that the Nfvo sends to the Vnfm.\n\n\n\n\n\n\n\n\nParams\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\nOrEndpoint\n\n\nthe endpoint of the NFVO (i.e. http://127.0.0.1:8080)\n\n\n\n\n\n\nVnfmEnpoint\n\n\nthe endpoint of the Vnfm. this is given to the nfvo while registering\n\n\n\n\n\n\n\n\nRegistering a Vnfm to the Nfvo (Vnfm-Or)\n\n\nThis call registers a vnfm to a nfvo. \n\n\nrequest path\n\n\nPOST request on\n\n\nOrEndpoint\n/admin/v1/vnfm-register\n\n\nrequest body\n\n\n{\n    \ntype\n:\ndummy\n,\n    \nendpointType\n:\nREST\n,\n    \nendpoint\n:\nVnfmEndpoint\n\n}\n\n\n\n\nrequest structure\n\n\n\n\n\n\n\n\nField\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\ntype\n\n\nthe vnfm type you are going to handle (specified in VirtualNetowrkFunctionDescriptor \u2192 endpoint)\n\n\n\n\n\n\nendpointType\n\n\nthe vnfm type you are going to implement (REST or JMS)\n\n\n\n\n\n\nendpoint\n\n\nthe vnfm endpoint you have chosen (basically http://\nIP>:\nPORT>)\n\n\n\n\n\n\n\n\nINSTANTIATE (Or-Vnfm)\n\n\nThis call sends the Vnfm the Virtual Network Function Descriptor, which shall be used to create the Virtual Network Funtion Record and also sends to the Vnfm all the scripts which are executed in actions like INSTANTIATE, MODIFY or START. This call triggers the creation of a virtual machine for the sent vnfd and the execution of the scripts which are associated with the INSTANTIATE lifecycle event in the vnfd. \n\n\nrequest path\n\n\nPOST request on\n\n\nVnfmEnpoint\n\n\nrequest body\n\n\n{\n    \nscriptsLink\n:\nlinktogit\n, \n    \nscripts\n:\nscriptsfiles\n, \n    \nvnfd\n:{  ...  }, \n    \nvnfdf\n:{  ...  }, \n    \nvlrs\n:[  ...  ], \n    \nextention\n:{  \nnsr-id\n:\n...\n  }, \n    \naction\n:\nINSTANTIATE\n \n}\n\n\n\n\nIn this action either the \nscriptsLink\n or the \nscripts\n fields are set. The vnfm-sdk will take care of them.\n\n\nrequest structure\n\n\n\n\n\n\n\n\nField\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\nscriptsLink\n\n\na link to the repository where the links are located\n\n\n\n\n\n\nscripts\n\n\nthe script files coming from the vnfPackage, in case no scriptsLink is provided\n\n\n\n\n\n\nvnfd\n\n\nthe VirtualNetworkFunctionDescriptor from which a VirtualNetworkFunctionRecord is created\n\n\n\n\n\n\nvnfdf\n\n\nthe deployment flavours to be used\n\n\n\n\n\n\nvlrs\n\n\nthe list of VirtualLinkRecords of the NetworkServiceRecord\n\n\n\n\n\n\nextention\n\n\nsome info like the NetworkServiceRecord id\n\n\n\n\n\n\naction\n\n\nthe action to be executed\n\n\n\n\n\n\n\n\nInstantiate (Vnfm-Or)\n\n\nThis call sends back the created Virtual Network Function Record to the Nfvo. \n\n\nrequest path\n\n\nPOST request on\n\n\nOrEndpoint\n/admin/v1/vnfm-core-actions\n\n\nrequest body\n\n\n{\n    \nvirtualNetworkFunctionRecord\n:{  ...  }, \n    \naction\n:\nINSTANTIATE\n\n}\n\n\n\n\nrequest structure\n\n\n\n\n\n\n\n\nField\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\nvirtualNetworkFunctionRecord\n\n\nthe created VirtualNetworkFunctionRecord\n\n\n\n\n\n\naction\n\n\nthe action that was executed\n\n\n\n\n\n\n\n\nModify (aka AddRelations) (Or-Vnfm)\n\n\nThe Nfvo uses this request to provide dependencies of Virtual Network Functions to the Vnfm. The scripts associated with the CONFIGURATION lifecycle event in the vnfr will be executed.\n\n\nrequest path\n\n\nPOST request on\n\n\nVnfmEnpoint\n\n\nrequest body\n\n\n{\n    \nvnfr\n:{ ... }, \n    \nvnfrd\n:{ ... }, \n    \naction\n:\nMODIFY\n\n}\n\n\n\n\nrequest structure\n\n\n\n\n\n\n\n\nField\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\nvnfr\n\n\nthe VirtualNetowrkFunctionRecord target of the depedendecy\n\n\n\n\n\n\nvnfrd\n\n\nthe VNFDependency containing all the source parameters needed by the scripts\n\n\n\n\n\n\naction\n\n\nthe action to be executed\n\n\n\n\n\n\n\n\nModify (aka AddRelations) (Vnfm-Or)\n\n\nThis call sends back the modified Virtual Network Function Record to the Nfvo. \n\n\nrequest path\n\n\nPOST request on\n\n\nOrEndpoint\n/admin/v1/vnfm-core-actions\n\n\nrequest body\n\n\n{\n    \nvirtualNetworkFunctionRecord\n:{ ... },\n    \naction\n:\nMODIFY\n\n}\n\n\n\n\nrequest structure\n\n\n\n\n\n\n\n\nField\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\nvirtualNetworkFunctionRecord\n\n\nthe VirtualNetworkFunctionRecord\n\n\n\n\n\n\naction\n\n\nthe action that was executed\n\n\n\n\n\n\n\n\nStart (Or-Vnfm)\n\n\nThis call will trigger the execution of the scripts associated with the START lifecycle event in the vnfr. \n\n\nrequest path\n\n\nPOST request on\n\n\nVnfmEnpoint\n\n\nrequest body\n\n\n{\n    \nvnfr\n:{  ...  },\n    \naction\n:\nSTART\n\n}\n\n\n\n\nrequest structure\n\n\n\n\n\n\n\n\nField\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\nvnfr\n\n\n\n\n\n\n\n\naction\n\n\nthe action to be executed\n\n\n\n\n\n\n\n\nStart (Vnfm-Or)\n\n\nrequest path\n\n\nPOST request on\n\n\nOrEndpoint\n/admin/v1/vnfm-core-actions\n\n\nrequest body\n\n\n{\n    \nvirtualNetworkFunctionRecord\n:{  ...  },\n    \naction\n:\nSTART\n\n}\n\n\n\n\nrequest structure\n\n\n\n\n\n\n\n\nField\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\nvirtualNetworkFunctionRecord\n\n\nthe Virtual Network Function Record\n\n\n\n\n\n\naction\n\n\nthe action that was executed\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Integrate your own VNFM"
        }, 
        {
            "location": "/vnfm-vendor-specific/#use-my-vnfm", 
            "text": "In this section are described the REST interfaces which allow you to integrate your VNFM with Openbaton's NFVO.", 
            "title": "Use my VNFM"
        }, 
        {
            "location": "/vnfm-vendor-specific/#nfvo-vnfm-rest-interface", 
            "text": "Nfvo exposes a ReST interface for the communication with the VnfManagers. The sequence diagram regarding the instantiation of a NetworkServiceRecord is shown in the following picture.   As shown in the picture, NFVO calls some ReST methods on the vnfm in a particular order. Then it expects some kind of back call. The list of these call exchange is described in the following sections. The ALLOCATE_RESOURCES call is not needed if the vnfm will take care of creating VMs. The communication with the EMS is particular to each VnfManagers. In order to be able to be found, the Vnfm needs to register to the NFVO. This can be done through a particular call.  In the following 'Vnfm-Or' means that the Vnfm sends to the Nfvo and 'Or-Vnfm' means that the Nfvo sends to the Vnfm.     Params  Meaning      OrEndpoint  the endpoint of the NFVO (i.e. http://127.0.0.1:8080)    VnfmEnpoint  the endpoint of the Vnfm. this is given to the nfvo while registering     Registering a Vnfm to the Nfvo (Vnfm-Or)  This call registers a vnfm to a nfvo.   request path  POST request on  OrEndpoint /admin/v1/vnfm-register  request body  {\n     type : dummy ,\n     endpointType : REST ,\n     endpoint : VnfmEndpoint \n}  request structure     Field  Meaning      type  the vnfm type you are going to handle (specified in VirtualNetowrkFunctionDescriptor \u2192 endpoint)    endpointType  the vnfm type you are going to implement (REST or JMS)    endpoint  the vnfm endpoint you have chosen (basically http:// IP>: PORT>)     INSTANTIATE (Or-Vnfm)  This call sends the Vnfm the Virtual Network Function Descriptor, which shall be used to create the Virtual Network Funtion Record and also sends to the Vnfm all the scripts which are executed in actions like INSTANTIATE, MODIFY or START. This call triggers the creation of a virtual machine for the sent vnfd and the execution of the scripts which are associated with the INSTANTIATE lifecycle event in the vnfd.   request path  POST request on  VnfmEnpoint  request body  {\n     scriptsLink : linktogit , \n     scripts : scriptsfiles , \n     vnfd :{  ...  }, \n     vnfdf :{  ...  }, \n     vlrs :[  ...  ], \n     extention :{   nsr-id : ...   }, \n     action : INSTANTIATE  \n}  In this action either the  scriptsLink  or the  scripts  fields are set. The vnfm-sdk will take care of them.  request structure     Field  Meaning      scriptsLink  a link to the repository where the links are located    scripts  the script files coming from the vnfPackage, in case no scriptsLink is provided    vnfd  the VirtualNetworkFunctionDescriptor from which a VirtualNetworkFunctionRecord is created    vnfdf  the deployment flavours to be used    vlrs  the list of VirtualLinkRecords of the NetworkServiceRecord    extention  some info like the NetworkServiceRecord id    action  the action to be executed     Instantiate (Vnfm-Or)  This call sends back the created Virtual Network Function Record to the Nfvo.   request path  POST request on  OrEndpoint /admin/v1/vnfm-core-actions  request body  {\n     virtualNetworkFunctionRecord :{  ...  }, \n     action : INSTANTIATE \n}  request structure     Field  Meaning      virtualNetworkFunctionRecord  the created VirtualNetworkFunctionRecord    action  the action that was executed     Modify (aka AddRelations) (Or-Vnfm)  The Nfvo uses this request to provide dependencies of Virtual Network Functions to the Vnfm. The scripts associated with the CONFIGURATION lifecycle event in the vnfr will be executed.  request path  POST request on  VnfmEnpoint  request body  {\n     vnfr :{ ... }, \n     vnfrd :{ ... }, \n     action : MODIFY \n}  request structure     Field  Meaning      vnfr  the VirtualNetowrkFunctionRecord target of the depedendecy    vnfrd  the VNFDependency containing all the source parameters needed by the scripts    action  the action to be executed     Modify (aka AddRelations) (Vnfm-Or)  This call sends back the modified Virtual Network Function Record to the Nfvo.   request path  POST request on  OrEndpoint /admin/v1/vnfm-core-actions  request body  {\n     virtualNetworkFunctionRecord :{ ... },\n     action : MODIFY \n}  request structure     Field  Meaning      virtualNetworkFunctionRecord  the VirtualNetworkFunctionRecord    action  the action that was executed     Start (Or-Vnfm)  This call will trigger the execution of the scripts associated with the START lifecycle event in the vnfr.   request path  POST request on  VnfmEnpoint  request body  {\n     vnfr :{  ...  },\n     action : START \n}  request structure     Field  Meaning      vnfr     action  the action to be executed     Start (Vnfm-Or)  request path  POST request on  OrEndpoint /admin/v1/vnfm-core-actions  request body  {\n     virtualNetworkFunctionRecord :{  ...  },\n     action : START \n}  request structure     Field  Meaning      virtualNetworkFunctionRecord  the Virtual Network Function Record    action  the action that was executed       \n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "NFVO - VNFM ReST interface"
        }, 
        {
            "location": "/vnfpackage/", 
            "text": "VNFPackage\n\n\nNote\n: This is the initial version of the VNFPackage and might change most probably in the next releases to improve and simplify the creation, usability and power.\n\n\nThis doc describes essential components of a VNFPackage, how to create them and how to use them after onboarding.\nTherefore, you can find a practical tutorial at the end with all the steps starting from the creation over onboarding and finally referencing it by a NSD.\n\n\nA VNFPackage is a tar-archive that contains all the information required for creating a VNF for the openbaton NFVO.\nAfter onboarding the VNFPackage on the NFVO you can use the VNF directly in the NSD by referencing the VNFD by its id.\nA VNFPackage includes the VNFD, the image, scripts and a Metadata file structured as shown in the next part.\n\n\nPackage structure\n\n\nThe VNFPackage has the following structure:\n\n\n- Metadata.yaml\n- vnfd.json\n- scripts/\n    - 1_script.sh\n    - 2_script.sh\n- image.img\n\n\n\n\nMetadata.yaml\n\n\nThe Metadata.yaml defines essential properties for the VNF. This file bases on the YAML syntax where information are stored in simple \nkey> : \nvalue> associations.\n\n\nThe example of a Metadata.yaml file below shows a basic definition of a VNFPackage.\n\n\nname: vnfPackage_name\nscripts-link: scripts_link\nimage:\n    upload: option\n    ids: list_of_ids\n    names: list_of_names\n    link: image_link\nimage-config:\n    name: image_name\n    diskFormat: disk_format\n    containerFormat: container_format\n    minCPU: min_cpu\n    minDisk: min_disk\n    minRam: min_ram\n    isPublic: is_public\n\n\n\n\nIn the following each property is explained in more detail. Please consider also the notes since some properties are optional (or even not implemented) and if they are defined, they may have more priority than other and override them therefore.\n\n\n\n\nname\n: The name defines the name of the VNFPackage itself used to store it on the database.\n\n\nscripts-link\n: This link points to a public git repository where scripts are stored that are needed to be executed for managing the lifecycle of the exposed VNF.\n\n\nNote\n Either you can define the scripts-link or put the scripts into the folder scripts/.\n    The scripts-link has a higher priority than the scripts located in the folder scripts/.\n    So if you set the scripts-link, the scripts in folder scripts/ are ignored completely.\n\n\nNote\n The scripts-link is processed by the Element Management System (EMS) in the meaning of fetching the files from that link.\n    So you need to take care about ensuring that the URL defined is available.\n\n\nNote\n Scripts are executed during different lifecycle-events.\n\n\n\n\n\n\nimage\n:\n\n\nupload\n: Here you can choose between different options (true, false, check).\n\n\ntrue: choosing this option means to upload the defined image on all the VimInstances. It does not matter if an image with the defined name exists or not.\n\n\nfalse: choosing this option means that you assume that the image (defined in the ids or names) is already present.\nIf the image does not exist, the VNFPackage onboarding will throw an exception.\nIn this case the image (if defined) will be ignored.\n\n\ncheck: this option means that the VNFPackageManagement checks first if the image is available (defined in ids or names).\nIf the image does not exist, a new one with the image defined in the VNFPackage will be created.\n\n\nNote\n Please use quotation marks for this option since the values are handled as strings internally.\nOtherwise true and false will be handled as a boolean that would lead to a faulty behavior when onboarding a new VNFPackage.\n\n\n\n\n\n\nids\n: The list of image ids is used to fetch the image from the corresponding VimInstance.\n    To do it, the manager iterates over all ids and checks if an image with that id exists on the VimInstance.\n    The defined ids have a higher priority than the list of names.\n    We distinguish between the following cases:\n\n\nIf it finds no image with these ids, it continues with the list of image names.\n\n\nIf it finds one image with these ids, this image will be used.\n\n\nIf it finds multiple images with the same id (should never happen) or multiple ids matching to multiple images, an exception will be thrown because it is not clear which image to use.\n\n\n\n\n\n\nnames\n: The list of image names is used to fetch the image from the corresponding VimInstance.\n    To do it, manager iterates over all names and checks if an image with that name exists on the VimInstance.\n    The list of names have a lower priority than the list of ids.\n    We distinguish between the following cases:\n\n\nIf it finds no image with that name, an exception will be thrown except you defined the upload option check.\nThen it will create a new image defined in the VNFPackage.\n\n\nIf it finds one image, this image will be used.\n\n\nIf it finds multiple images with the same name or multiple names matching to multiple images, an exception will be thrown because it is not clear which image to use.\n\n\n\n\n\n\nlink\n: This link points to an image available at this URL used to upload the image to the cloud environment.\n\n\nNote\n Either you have to define the image-link or put the image directly into the VNFPackage.\n    Otherwise a NotFoundException will be thrown and the VNFPackage will not onboard.\n    The image-link has a higher priority than the image stored in the VNFPackage directly.\n\n\n\n\n\n\n\n\n\n\nimage-config\n: All the properties explained below are required to upload the image to the cloud environment properly.\n    In case of creating a new image this configuration will be used.\n\n\nname\n: This defines the name for the image to upload either located directly in the VNFPackage or available via the URL defined in image-link.\n\n\ndiskFormat\n: The diskFormat defines the format in which disk type the image is stored.\n\n\ncontainerFormat\n: The containerFormat defines the format in which container type the image is stored .\n\n\nminCPU\n: The minCPU defines the minimum amount of CPU cores for using this image properly.\n\n\nminDisk\n: The minDisk defines the minimum amount of disk space for using this image properly.\n\n\nminRam\n: The minRam defines the minimum amount of RAM for using this image properly.\n\n\nisPublic\n: The isPublic defines whether the image is available public or not.\n\n\n\n\n\n\n\n\nVNFD>.json\n\n\nThe \nvnfd>.json contains the VirtualNetworkFunctionDescriptor (VNFD) onboarded on the Orchestrator.\nThis VNFD can later be referenced in a NSD by its id to make use of it.\nA more detailed explanation of the VNFD can be found \nhere\n.\n\n\nNote\n The name of the file is not important but the file extension .json is, since the VNFPackageManagement is looking for this kind of file format.\n\n\nscripts\n\n\nThe scripts folder contains all the scripts required for starting, configuring or whatever you want to do on the running instance.\nThe execution order is defined by the lifecycle_events inside the VNFD.\nThis lifecycle_events are triggered by the NFVO in the meaning of: if the event \"INSTANTIATE\" contains a script in the lifecycle_events, this script is executed when the NFVO calls the instantiate method for the specific VNFR.\n\n\nNote\n The scripts in the folder \nscripts\n are fetched only if the \nscripts-link\n is not defined in the \nMetadata.yaml\n.\n    This means that the scripts in that folder have less priority than the scripts located under \nscripts-link\n.\n\n\nNote\n Scripts are executed when a specific Event is fired and this Event references to specific scripts.\n\n\nimage>.img\n\n\nThis image is used to upload it to all the cloud environments which are addressed inside the VNFD with that image.\nIt doesn't matter whether an image already exists on the considered cloud environment or not.\n\n\nNote\n This image has lower priority than the \nimage-links\n defined in \nMetadata.yaml\n.\n    This means that the image will be ignored if the \nimage-links\n is defined.\n\n\nNote\n The name of the image doesn't matter but the suffix .img since the VNFPackageManagement is looking for a file with this suffix.\n    However, the name and all the properties for storing it on the cloud environment are defined in \nMetadata.yaml\n under the key \nimage\n.\n\n\nTutorial\n\n\nThis section explains how to create, upload and make use of VNFPackages.\nThe chosen scenario is a NetworkService for testing the network connectivity by using \niPerf\n.\niPerf is a tool for active measurements of the maximum achievable bandwidth on IP networks.\nTherefore, we need a server and a client installing the iPerf server/client and configuring them for communication between.\n\n\nCreation of VNFPackages\n\n\nFor doing so, we need to create two VNFPackages and reference them in the NSD.\nSo we need one VNFPackage for the iperf server (called iperf-server) and one for the iperf client (called iperf-client).\nFirst we will start with the creation of the iperf-server VNFPackage and then we will create the iperf-client VNFPackage.\n\n\nFirst of all we should create a directory for each VNFPackage where we put all the files related to the VNFPackage because in the end we need to pack them into a tar archive for onboarding it on the NFVO.\n\n\nVNFPackage [iperf-server]\n\n\nThis iperf-server VNFPackage has to install the iperf server and needs to provide its ip to the iperf client.\n\n\nMetadata [iperf-server]\n\n\nIn the Metadata.yaml we define the name of the VNFPackage, the scripts location and also the properties for the image to upload.\nSince the image-link is not implemented in the current release we will put the image directly into the VNFPackage.\nFinally, it looks as shown below.\n\n\nname: iperf-server\nscripts-link: https://script-link-to-git.git\nimage:\n    upload: \ncheck\n\n    names:\n        - iperf_server_image\nimage-config:\n    name: iperf_server_image\n    diskFormat: QCOW2\n    containerFormat: BARE\n    minCPU: 2\n    minDisk: 5\n    minRam: 2048\n    isPublic: false\n\n\n\n\nVNFD [iperf-server]\n\n\nThis is how the \nVNFD\n looks like for the iperf-server VNFPackage.\nImportant to notice here is the vm_image that points to the image we have defined in the Metadata.yaml\n\n\n{\n    \nvendor\n:\nfokus\n,\n    \nversion\n:\n0.2\n,\n    \nname\n:\niperf-server\n,\n    \ntype\n:\nserver\n,\n    \nendpoint\n:\ngeneric\n,\n    \nvdu\n:[\n        {\n            \nvm_image\n:[\n                \niperf_server_image\n\n            ],\n            \nvimInstanceName\n:\nvim-instance\n,\n            \nscale_in_out\n:2,\n            \nvnfc\n:[\n                {\n                    \nconnection_point\n:[\n                        {\n                            \nfloatingIp\n:\nrandom\n,\n                            \nvirtual_link_reference\n:\nprivate\n\n                        }\n                    ]\n                }\n            ]\n        }\n    ],\n    \nvirtual_link\n:[\n        {\n            \nname\n:\nprivate\n\n        }\n    ],\n    \nlifecycle_event\n:[\n        {\n            \nevent\n:\nINSTANTIATE\n,\n            \nlifecycle_events\n:[\n                \ninstall.sh\n,\n                \ninstall-srv.sh\n\n            ]\n        }\n    ],\n    \ndeployment_flavour\n:[\n        {\n            \ndf_constraint\n:[\n                \nconstraint1\n,\n                \nconstraint2\n\n            ],\n            \ncostituent_vdu\n:[\n            ],\n            \nflavour_key\n:\nm1.small\n\n        }\n    ]\n}\n\n\n\n\nImage\n\n\nThe image we have to choose must be a debian 64bit image (e.g. ubuntu amd64) for satisfying the EMS and scripts which are designed for that kind of image.\nWe have chosen this one \nubuntu-14.04.3-server-amd64.iso\n.\n\n\nVNFPackage [iperf-client]\n\n\nThis iperf-server VNFPackage has to install the iperf client and needs to configure it to set the iperf servers' IP.\n\n\nMetadata [iperf-client]\n\n\nIn the Metadata.yaml we define the name of the VNFPackage, the scripts location and also the properties for the image to upload.\nSince the image-link is not implemented in the current release we will put the image directly into the VNFPackage.\nFinally, it looks as shown below.\n\n\nname: iperf-client\nscripts-link: https://gitlab.fokus.fraunhofer.de/openbaton/scripts-test-public.git\nimage:\n    upload: \ncheck\n\n    names:\n        - iperf_client_image\nimage-config:\n    name: iperf_client_image\n    diskFormat: QCOW2\n    containerFormat: BARE\n    minCPU: 2\n    minDisk: 5\n    minRam: 2048\n    isPublic: false\n\n\n\n\nVNFD [iperf-client]\n\n\nThis is how the \nVNFD\n looks like for the iperf-client VNFPackage.\nImportant to notice here is the vm_image that points to the image we have defined in the Metadata.yaml\n\n\n{\n    \nvendor\n:\nfokus\n,\n    \nversion\n:\n0.1\n,\n    \nname\n:\niperf-client\n,\n    \ntype\n:\nclient\n,\n    \nendpoint\n:\ngeneric\n,\n    \nvdu\n:[\n        {\n            \nvm_image\n:[\n                \niperf_client_image\n\n            ],\n            \nvirtual_memory_resource_element\n:\n1024\n,\n            \nvirtual_network_bandwidth_resource\n:\n1000000\n,\n            \nvimInstanceName\n:\nvim-instance\n,\n            \nvdu_constraint\n:\n,\n            \nhigh_availability\n:\nACTIVE_PASSIVE\n,\n            \nscale_in_out\n:2,\n            \nvnfc\n:[\n                {\n                    \nconnection_point\n:[\n                        {\n                            \nvirtual_link_reference\n:\nprivate\n\n                        }\n                    ]\n                }\n            ]\n        }\n    ],\n    \nvirtual_link\n:[\n        {\n            \nname\n:\nprivate\n\n        }\n    ],\n    \nlifecycle_event\n:[\n        {\n            \nevent\n:\nINSTANTIATE\n,\n            \nlifecycle_events\n:[\n                \ninstall.sh\n\n            ]\n        },\n        {\n            \nevent\n:\nCONFIGURE\n,\n            \nlifecycle_events\n:[\n                \nserver_configure.sh\n\n            ]\n        }\n    ],\n    \ndeployment_flavour\n:[\n        {\n            \ndf_constraint\n:[\n                \nconstraint1\n,\n                \nconstraint2\n\n            ],\n            \ncostituent_vdu\n:[\n            ],\n            \nflavour_key\n:\nm1.small\n\n        }\n    ]\n}\n\n\n\n\nImage\n\n\nThe image we have to choose must be a debian 64bit image (e.g. ubuntu amd64) for satisfying the EMS and scripts which are designed for that kind of architecture.\nWe have chosen this one \nubuntu-14.04.3-server-amd64.iso\n.\n\n\nOnboarding VNFPackages\n\n\nOnce we have finalized the creation of VNFPackages and packed them into a tar we can onboard them on the NFVO. Make sure that you also uploaded a VimInstance before onboarding the package. Onboarding can be done as shown in the following:\n\n\n$ curl -X POST -v -F file=@vnf-package.tar \nhttp://localhost:8080/api/v1/vnf-packages\n\n\n\n\n\nThis must be done for both VNFPackages expecting that the NFVO is running locally and the tar archive is called vnf-package.tar.\nOtherwise you need to adapt the path to the package and also the URL where the NFVO is located.\nNow where we onboarded the VNFPackages they are available on the NFVO and we can make use of it by referencing them in the NSD by their ids'.\n\n\nNote\n You could use the \nDashboard\n as well for onboarding the VNFPackages.\n\n\nTo get the ids of the newly created VNFDs you need to fetch the VNFDs by invoking the following command:\n\n\n$ curl -X \nGET http://localhost:8080/api/v1/vnf-descriptors\n\n\n\n\n\nThis request will return a list of already existing VNFDs.\nJust looking for the VNFDs we created before and use the id to reference them in the NSD.\nThe following list of VNFDs is an example of this request.\nTo make it more readable only the interesting parts are shown.\n\n\n[\n  [...]\n  {\n    [...]\n    \nid\n: \n29d918b9-6245-4dc4-abc6-b7dd6e84f2c1\n,\n    \nname\n: \niperf-server\n,\n    [...]\n  },\n  {\n    [...]\n    \nid\n: \n87820607-4048-4fad-b02b-dbcab8bb5c1c\n,\n    \nname\n: \niperf-client\n,\n    [...]\n  }\n  [...]\n]\n\n\n\n\nNSD [iperf]\n\n\nIn this section we will create a \nNSD\n and reference the previously created VNFPackages by their ids'.\nFor doing that we just need to define the \nid\n for each VNFPackges' VNFD in the list of VNFDs.\nTo provide also the iperf-servers' IP to the iperf-client we need to define dependencies you can find under the key \nvnf_dependency\n setting the source to \niperf-server\n and the target to \niperf-client\n by providing the parameter \nprivate1\n.\n\n\nNote\n When creating the NSD the VNFD is fetched by the id defined. Other properties we would set in the VNFD in this NSD will be ignored.\n\n\n{\n    \nname\n:\niperf\n,\n    \nvendor\n:\nfokus\n,\n    \nversion\n:\n0.1-ALPHA\n,\n    \nvnfd\n:[\n        {\n            \nid\n:\n29d918b9-6245-4dc4-abc6-b7dd6e84f2c1\n\n        },\n        {\n            \nid\n:\n87820607-4048-4fad-b02b-dbcab8bb5c1c\n\n        }\n    ],\n    \nvld\n:[\n        {\n            \nname\n:\nprivate\n\n        }\n    ],\n    \nvnf_dependency\n:[\n        {\n            \nsource\n : {\n                \nname\n: \niperf-server\n\n            },\n            \ntarget\n:{\n                \nname\n: \niperf-client\n\n            },\n            \nparameters\n:[\n                \nprivate1\n\n            ]\n        }\n    ]\n}\n\n\n\n\nFinally you can onboard this NSD and create a NSR that bases on both VNFPackages created before.\n\n\nOnboard NSD\n\n\nThe following command will onboard the NSD on the NFVO:\n\n\n$ curl -X POST -v -F file=@nsd.json \nhttp://localhost:8080/api/v1/ns-descriptors\n\n\n\n\n\nThis will return the NSD with the id we need to create NSR.\nAfterwards, we can deploy the NSD.\n\n\nNote\n You could use the \nDashboard\n as well for onboarding the NSD.\n\n\nCreate NSR (Deployment)\n\n\nTo deploy the NSD we create a NSR with the following command:\n\n\n$ curl -X POST -v -F file=@vnf-package.tar \nhttp://localhost:8080/api/v1/ns-records/\nNSD_ID\n\n\n\n\n\nInstallation and configuration is done automatically and provides you with a configured iperf server/client infrastructure.\n\n\nNote\n You could use the \nDashboard\n as well for creating the NSR of this NSD.\n\n\n\n\n\n\n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Create your own VNF Package"
        }, 
        {
            "location": "/vnfpackage/#vnfpackage", 
            "text": "Note : This is the initial version of the VNFPackage and might change most probably in the next releases to improve and simplify the creation, usability and power.  This doc describes essential components of a VNFPackage, how to create them and how to use them after onboarding.\nTherefore, you can find a practical tutorial at the end with all the steps starting from the creation over onboarding and finally referencing it by a NSD.  A VNFPackage is a tar-archive that contains all the information required for creating a VNF for the openbaton NFVO.\nAfter onboarding the VNFPackage on the NFVO you can use the VNF directly in the NSD by referencing the VNFD by its id.\nA VNFPackage includes the VNFD, the image, scripts and a Metadata file structured as shown in the next part.", 
            "title": "VNFPackage"
        }, 
        {
            "location": "/vnfpackage/#package-structure", 
            "text": "The VNFPackage has the following structure:  - Metadata.yaml\n- vnfd.json\n- scripts/\n    - 1_script.sh\n    - 2_script.sh\n- image.img", 
            "title": "Package structure"
        }, 
        {
            "location": "/vnfpackage/#metadatayaml", 
            "text": "The Metadata.yaml defines essential properties for the VNF. This file bases on the YAML syntax where information are stored in simple  key> :  value> associations.  The example of a Metadata.yaml file below shows a basic definition of a VNFPackage.  name: vnfPackage_name\nscripts-link: scripts_link\nimage:\n    upload: option\n    ids: list_of_ids\n    names: list_of_names\n    link: image_link\nimage-config:\n    name: image_name\n    diskFormat: disk_format\n    containerFormat: container_format\n    minCPU: min_cpu\n    minDisk: min_disk\n    minRam: min_ram\n    isPublic: is_public  In the following each property is explained in more detail. Please consider also the notes since some properties are optional (or even not implemented) and if they are defined, they may have more priority than other and override them therefore.   name : The name defines the name of the VNFPackage itself used to store it on the database.  scripts-link : This link points to a public git repository where scripts are stored that are needed to be executed for managing the lifecycle of the exposed VNF.  Note  Either you can define the scripts-link or put the scripts into the folder scripts/.\n    The scripts-link has a higher priority than the scripts located in the folder scripts/.\n    So if you set the scripts-link, the scripts in folder scripts/ are ignored completely.  Note  The scripts-link is processed by the Element Management System (EMS) in the meaning of fetching the files from that link.\n    So you need to take care about ensuring that the URL defined is available.  Note  Scripts are executed during different lifecycle-events.    image :  upload : Here you can choose between different options (true, false, check).  true: choosing this option means to upload the defined image on all the VimInstances. It does not matter if an image with the defined name exists or not.  false: choosing this option means that you assume that the image (defined in the ids or names) is already present.\nIf the image does not exist, the VNFPackage onboarding will throw an exception.\nIn this case the image (if defined) will be ignored.  check: this option means that the VNFPackageManagement checks first if the image is available (defined in ids or names).\nIf the image does not exist, a new one with the image defined in the VNFPackage will be created.  Note  Please use quotation marks for this option since the values are handled as strings internally.\nOtherwise true and false will be handled as a boolean that would lead to a faulty behavior when onboarding a new VNFPackage.    ids : The list of image ids is used to fetch the image from the corresponding VimInstance.\n    To do it, the manager iterates over all ids and checks if an image with that id exists on the VimInstance.\n    The defined ids have a higher priority than the list of names.\n    We distinguish between the following cases:  If it finds no image with these ids, it continues with the list of image names.  If it finds one image with these ids, this image will be used.  If it finds multiple images with the same id (should never happen) or multiple ids matching to multiple images, an exception will be thrown because it is not clear which image to use.    names : The list of image names is used to fetch the image from the corresponding VimInstance.\n    To do it, manager iterates over all names and checks if an image with that name exists on the VimInstance.\n    The list of names have a lower priority than the list of ids.\n    We distinguish between the following cases:  If it finds no image with that name, an exception will be thrown except you defined the upload option check.\nThen it will create a new image defined in the VNFPackage.  If it finds one image, this image will be used.  If it finds multiple images with the same name or multiple names matching to multiple images, an exception will be thrown because it is not clear which image to use.    link : This link points to an image available at this URL used to upload the image to the cloud environment.  Note  Either you have to define the image-link or put the image directly into the VNFPackage.\n    Otherwise a NotFoundException will be thrown and the VNFPackage will not onboard.\n    The image-link has a higher priority than the image stored in the VNFPackage directly.      image-config : All the properties explained below are required to upload the image to the cloud environment properly.\n    In case of creating a new image this configuration will be used.  name : This defines the name for the image to upload either located directly in the VNFPackage or available via the URL defined in image-link.  diskFormat : The diskFormat defines the format in which disk type the image is stored.  containerFormat : The containerFormat defines the format in which container type the image is stored .  minCPU : The minCPU defines the minimum amount of CPU cores for using this image properly.  minDisk : The minDisk defines the minimum amount of disk space for using this image properly.  minRam : The minRam defines the minimum amount of RAM for using this image properly.  isPublic : The isPublic defines whether the image is available public or not.", 
            "title": "Metadata.yaml"
        }, 
        {
            "location": "/vnfpackage/#vnfd62json", 
            "text": "The  vnfd>.json contains the VirtualNetworkFunctionDescriptor (VNFD) onboarded on the Orchestrator.\nThis VNFD can later be referenced in a NSD by its id to make use of it.\nA more detailed explanation of the VNFD can be found  here .  Note  The name of the file is not important but the file extension .json is, since the VNFPackageManagement is looking for this kind of file format.", 
            "title": "&lt;VNFD>.json"
        }, 
        {
            "location": "/vnfpackage/#scripts", 
            "text": "The scripts folder contains all the scripts required for starting, configuring or whatever you want to do on the running instance.\nThe execution order is defined by the lifecycle_events inside the VNFD.\nThis lifecycle_events are triggered by the NFVO in the meaning of: if the event \"INSTANTIATE\" contains a script in the lifecycle_events, this script is executed when the NFVO calls the instantiate method for the specific VNFR.  Note  The scripts in the folder  scripts  are fetched only if the  scripts-link  is not defined in the  Metadata.yaml .\n    This means that the scripts in that folder have less priority than the scripts located under  scripts-link .  Note  Scripts are executed when a specific Event is fired and this Event references to specific scripts.", 
            "title": "scripts"
        }, 
        {
            "location": "/vnfpackage/#image62img", 
            "text": "This image is used to upload it to all the cloud environments which are addressed inside the VNFD with that image.\nIt doesn't matter whether an image already exists on the considered cloud environment or not.  Note  This image has lower priority than the  image-links  defined in  Metadata.yaml .\n    This means that the image will be ignored if the  image-links  is defined.  Note  The name of the image doesn't matter but the suffix .img since the VNFPackageManagement is looking for a file with this suffix.\n    However, the name and all the properties for storing it on the cloud environment are defined in  Metadata.yaml  under the key  image .", 
            "title": "&lt;image>.img"
        }, 
        {
            "location": "/vnfpackage/#tutorial", 
            "text": "This section explains how to create, upload and make use of VNFPackages.\nThe chosen scenario is a NetworkService for testing the network connectivity by using  iPerf .\niPerf is a tool for active measurements of the maximum achievable bandwidth on IP networks.\nTherefore, we need a server and a client installing the iPerf server/client and configuring them for communication between.", 
            "title": "Tutorial"
        }, 
        {
            "location": "/vnfpackage/#creation-of-vnfpackages", 
            "text": "For doing so, we need to create two VNFPackages and reference them in the NSD.\nSo we need one VNFPackage for the iperf server (called iperf-server) and one for the iperf client (called iperf-client).\nFirst we will start with the creation of the iperf-server VNFPackage and then we will create the iperf-client VNFPackage.  First of all we should create a directory for each VNFPackage where we put all the files related to the VNFPackage because in the end we need to pack them into a tar archive for onboarding it on the NFVO.  VNFPackage [iperf-server]  This iperf-server VNFPackage has to install the iperf server and needs to provide its ip to the iperf client.  Metadata [iperf-server]  In the Metadata.yaml we define the name of the VNFPackage, the scripts location and also the properties for the image to upload.\nSince the image-link is not implemented in the current release we will put the image directly into the VNFPackage.\nFinally, it looks as shown below.  name: iperf-server\nscripts-link: https://script-link-to-git.git\nimage:\n    upload:  check \n    names:\n        - iperf_server_image\nimage-config:\n    name: iperf_server_image\n    diskFormat: QCOW2\n    containerFormat: BARE\n    minCPU: 2\n    minDisk: 5\n    minRam: 2048\n    isPublic: false  VNFD [iperf-server]  This is how the  VNFD  looks like for the iperf-server VNFPackage.\nImportant to notice here is the vm_image that points to the image we have defined in the Metadata.yaml  {\n     vendor : fokus ,\n     version : 0.2 ,\n     name : iperf-server ,\n     type : server ,\n     endpoint : generic ,\n     vdu :[\n        {\n             vm_image :[\n                 iperf_server_image \n            ],\n             vimInstanceName : vim-instance ,\n             scale_in_out :2,\n             vnfc :[\n                {\n                     connection_point :[\n                        {\n                             floatingIp : random ,\n                             virtual_link_reference : private \n                        }\n                    ]\n                }\n            ]\n        }\n    ],\n     virtual_link :[\n        {\n             name : private \n        }\n    ],\n     lifecycle_event :[\n        {\n             event : INSTANTIATE ,\n             lifecycle_events :[\n                 install.sh ,\n                 install-srv.sh \n            ]\n        }\n    ],\n     deployment_flavour :[\n        {\n             df_constraint :[\n                 constraint1 ,\n                 constraint2 \n            ],\n             costituent_vdu :[\n            ],\n             flavour_key : m1.small \n        }\n    ]\n}  Image  The image we have to choose must be a debian 64bit image (e.g. ubuntu amd64) for satisfying the EMS and scripts which are designed for that kind of image.\nWe have chosen this one  ubuntu-14.04.3-server-amd64.iso .  VNFPackage [iperf-client]  This iperf-server VNFPackage has to install the iperf client and needs to configure it to set the iperf servers' IP.  Metadata [iperf-client]  In the Metadata.yaml we define the name of the VNFPackage, the scripts location and also the properties for the image to upload.\nSince the image-link is not implemented in the current release we will put the image directly into the VNFPackage.\nFinally, it looks as shown below.  name: iperf-client\nscripts-link: https://gitlab.fokus.fraunhofer.de/openbaton/scripts-test-public.git\nimage:\n    upload:  check \n    names:\n        - iperf_client_image\nimage-config:\n    name: iperf_client_image\n    diskFormat: QCOW2\n    containerFormat: BARE\n    minCPU: 2\n    minDisk: 5\n    minRam: 2048\n    isPublic: false  VNFD [iperf-client]  This is how the  VNFD  looks like for the iperf-client VNFPackage.\nImportant to notice here is the vm_image that points to the image we have defined in the Metadata.yaml  {\n     vendor : fokus ,\n     version : 0.1 ,\n     name : iperf-client ,\n     type : client ,\n     endpoint : generic ,\n     vdu :[\n        {\n             vm_image :[\n                 iperf_client_image \n            ],\n             virtual_memory_resource_element : 1024 ,\n             virtual_network_bandwidth_resource : 1000000 ,\n             vimInstanceName : vim-instance ,\n             vdu_constraint : ,\n             high_availability : ACTIVE_PASSIVE ,\n             scale_in_out :2,\n             vnfc :[\n                {\n                     connection_point :[\n                        {\n                             virtual_link_reference : private \n                        }\n                    ]\n                }\n            ]\n        }\n    ],\n     virtual_link :[\n        {\n             name : private \n        }\n    ],\n     lifecycle_event :[\n        {\n             event : INSTANTIATE ,\n             lifecycle_events :[\n                 install.sh \n            ]\n        },\n        {\n             event : CONFIGURE ,\n             lifecycle_events :[\n                 server_configure.sh \n            ]\n        }\n    ],\n     deployment_flavour :[\n        {\n             df_constraint :[\n                 constraint1 ,\n                 constraint2 \n            ],\n             costituent_vdu :[\n            ],\n             flavour_key : m1.small \n        }\n    ]\n}  Image  The image we have to choose must be a debian 64bit image (e.g. ubuntu amd64) for satisfying the EMS and scripts which are designed for that kind of architecture.\nWe have chosen this one  ubuntu-14.04.3-server-amd64.iso .", 
            "title": "Creation of VNFPackages"
        }, 
        {
            "location": "/vnfpackage/#onboarding-vnfpackages", 
            "text": "Once we have finalized the creation of VNFPackages and packed them into a tar we can onboard them on the NFVO. Make sure that you also uploaded a VimInstance before onboarding the package. Onboarding can be done as shown in the following:  $ curl -X POST -v -F file=@vnf-package.tar  http://localhost:8080/api/v1/vnf-packages   This must be done for both VNFPackages expecting that the NFVO is running locally and the tar archive is called vnf-package.tar.\nOtherwise you need to adapt the path to the package and also the URL where the NFVO is located.\nNow where we onboarded the VNFPackages they are available on the NFVO and we can make use of it by referencing them in the NSD by their ids'.  Note  You could use the  Dashboard  as well for onboarding the VNFPackages.  To get the ids of the newly created VNFDs you need to fetch the VNFDs by invoking the following command:  $ curl -X  GET http://localhost:8080/api/v1/vnf-descriptors   This request will return a list of already existing VNFDs.\nJust looking for the VNFDs we created before and use the id to reference them in the NSD.\nThe following list of VNFDs is an example of this request.\nTo make it more readable only the interesting parts are shown.  [\n  [...]\n  {\n    [...]\n     id :  29d918b9-6245-4dc4-abc6-b7dd6e84f2c1 ,\n     name :  iperf-server ,\n    [...]\n  },\n  {\n    [...]\n     id :  87820607-4048-4fad-b02b-dbcab8bb5c1c ,\n     name :  iperf-client ,\n    [...]\n  }\n  [...]\n]", 
            "title": "Onboarding VNFPackages"
        }, 
        {
            "location": "/vnfpackage/#nsd-iperf", 
            "text": "In this section we will create a  NSD  and reference the previously created VNFPackages by their ids'.\nFor doing that we just need to define the  id  for each VNFPackges' VNFD in the list of VNFDs.\nTo provide also the iperf-servers' IP to the iperf-client we need to define dependencies you can find under the key  vnf_dependency  setting the source to  iperf-server  and the target to  iperf-client  by providing the parameter  private1 .  Note  When creating the NSD the VNFD is fetched by the id defined. Other properties we would set in the VNFD in this NSD will be ignored.  {\n     name : iperf ,\n     vendor : fokus ,\n     version : 0.1-ALPHA ,\n     vnfd :[\n        {\n             id : 29d918b9-6245-4dc4-abc6-b7dd6e84f2c1 \n        },\n        {\n             id : 87820607-4048-4fad-b02b-dbcab8bb5c1c \n        }\n    ],\n     vld :[\n        {\n             name : private \n        }\n    ],\n     vnf_dependency :[\n        {\n             source  : {\n                 name :  iperf-server \n            },\n             target :{\n                 name :  iperf-client \n            },\n             parameters :[\n                 private1 \n            ]\n        }\n    ]\n}  Finally you can onboard this NSD and create a NSR that bases on both VNFPackages created before.  Onboard NSD  The following command will onboard the NSD on the NFVO:  $ curl -X POST -v -F file=@nsd.json  http://localhost:8080/api/v1/ns-descriptors   This will return the NSD with the id we need to create NSR.\nAfterwards, we can deploy the NSD.  Note  You could use the  Dashboard  as well for onboarding the NSD.  Create NSR (Deployment)  To deploy the NSD we create a NSR with the following command:  $ curl -X POST -v -F file=@vnf-package.tar  http://localhost:8080/api/v1/ns-records/ NSD_ID   Installation and configuration is done automatically and provides you with a configured iperf server/client infrastructure.  Note  You could use the  Dashboard  as well for creating the NSR of this NSD.   \n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "NSD [iperf]"
        }, 
        {
            "location": "/ns-descriptor/", 
            "text": "Network Service Descriptor\n\n\nThe Network Service Descriptor contains the values that are defined in \nETSI MANO specification\n. The NFVO is able to handle JSON file describing a Network Service Descriptor. An example of the most important fields follows:\n\n\n{  \n    \nname\n:\niperf-NSD\n,\n    \nvendor\n:\nfokus\n,\n    \nversion\n:\n0.1-ALPHA\n,\n    \nvnfd\n:[  ...  ],\n    \nvld\n:[  \n        {  \n            \nname\n:\nprivate\n\n        }\n    ],\n    \nvnf_dependency\n:[\n        {\n            \nsource\n : {\n                \nname\n: \niperf-server\n\n            },\n            \ntarget\n:{\n                \nname\n: \niperf-client\n\n            },\n            \nparameters\n:[\n                \nip1\n\n            ]\n        }\n    ]\n}\n\n\n\n\nYou can see a complete NSD json \nhere\n.\n\n\n\n\n\n\n\n\nParams\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\nname\n\n\nThe name to give to the NetworkServiceDescriptor\n\n\n\n\n\n\nvendor\n\n\nThe vendor creating this NetworkServiceDescriptor\n\n\n\n\n\n\nversion\n\n\nThe version of the NetworkServiceDescriptor (can be any string)\n\n\n\n\n\n\nvnfd\n\n\nA list of VirtualNetworkFunctionDescriptors (see \nVirtualNetworkFunctionDescriptor\n)\n\n\n\n\n\n\nvld\n\n\nA list of VirtualLinkDescriptors\n\n\n\n\n\n\nvnf_dependency\n\n\nA list of VNF_Dependencies\n\n\n\n\n\n\n\n\nVirtualLinkDescriptor\n\n\nThe Virtual Link Descriptor (VLD) describes the basic topology of the connectivity between one or more VNFs connected to this VL.\nThe VLD must contain a parameter \nname\n with the value of a network that will be used by the VirtualNetworkFunctionDescriptors.\nIf the network exists, then this network will be used, if not a new one will be created.\n\n\nVNF Dependencies\n\n\nA VNF Dependency is composed by \n\n\n\n\n\n\n\n\nParams\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\nsource\n\n\nThe name of the VirtualNetworkFunctionDescriptor that provides one or more parameters (see \nVNFManager Generic\n and \nVNF Parameters\n)\n\n\n\n\n\n\ntarget\n\n\nThe name of the VirtualNetworkFunctionDescriptor that requires one or more parameters (see \nVNFManager Generic\n and \nVNF Parameters\n)\n\n\n\n\n\n\nparameters\n\n\nThe name of the parameters that the \ntarget\n requires\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Create the NSD"
        }, 
        {
            "location": "/ns-descriptor/#network-service-descriptor", 
            "text": "The Network Service Descriptor contains the values that are defined in  ETSI MANO specification . The NFVO is able to handle JSON file describing a Network Service Descriptor. An example of the most important fields follows:  {  \n     name : iperf-NSD ,\n     vendor : fokus ,\n     version : 0.1-ALPHA ,\n     vnfd :[  ...  ],\n     vld :[  \n        {  \n             name : private \n        }\n    ],\n     vnf_dependency :[\n        {\n             source  : {\n                 name :  iperf-server \n            },\n             target :{\n                 name :  iperf-client \n            },\n             parameters :[\n                 ip1 \n            ]\n        }\n    ]\n}  You can see a complete NSD json  here .     Params  Meaning      name  The name to give to the NetworkServiceDescriptor    vendor  The vendor creating this NetworkServiceDescriptor    version  The version of the NetworkServiceDescriptor (can be any string)    vnfd  A list of VirtualNetworkFunctionDescriptors (see  VirtualNetworkFunctionDescriptor )    vld  A list of VirtualLinkDescriptors    vnf_dependency  A list of VNF_Dependencies     VirtualLinkDescriptor  The Virtual Link Descriptor (VLD) describes the basic topology of the connectivity between one or more VNFs connected to this VL.\nThe VLD must contain a parameter  name  with the value of a network that will be used by the VirtualNetworkFunctionDescriptors.\nIf the network exists, then this network will be used, if not a new one will be created.  VNF Dependencies  A VNF Dependency is composed by      Params  Meaning      source  The name of the VirtualNetworkFunctionDescriptor that provides one or more parameters (see  VNFManager Generic  and  VNF Parameters )    target  The name of the VirtualNetworkFunctionDescriptor that requires one or more parameters (see  VNFManager Generic  and  VNF Parameters )    parameters  The name of the parameters that the  target  requires       \n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Network Service Descriptor"
        }, 
        {
            "location": "/nfvo-how-to-use-gui/", 
            "text": "OpenBaton Dashboard\n\n\nThe Dashboard of OpenBaton helps you managing the lifecycle of different objects like \nVimInstaces, Network Service Descriptors/Records and Virtual Network Function Descriptors/Records in the OpenBaton environment.\n\n\nOverview\n\n\nThe index page shows an overview of the state of the NFVO \n\n\n\n\nNumber of Network Service Records\n\n\nNumber of Virtual Network Functions\n\n\nNumber of Virtual Deployment Units\n\n\nNumber of Network Service Descriptors\n\n\n\n\n\n\nManage PoPs\n\n\nOn this page you can see the list of Vim Instances registered\n\n\n\n\nFor registering a new Vim Instance you should click on the button in the top-right corner \nRegister Vim\n of this page and select your json to register a Vim Instance\n\n\n\n\nIf you want to delete a Vim Instance you can click on the button \nAction\n and then \nDelete\n in the menu\n\n\nCatalogue\n\n\nIn the menu on the left side under the template \nCatalogue\n you can manage \n\n\n\n\nNS Descriptors\n\n\nVNF Packages\n\n\n\n\nNetwork Service Descriptors\n\n\nIn the menu on the left side under the template Catalogue you can find the \nNS Decriptors\n button.\nOn this page you can see the list of NS Descriptors stored in OpenBaton\n\n\n\n\nYou have two options for storing a NS Descriptor:\n\n\n\n\nCreate a NSD by filling in a form\n\n\nCreate a NSD by using a json file\n\n\n\n\nCreate a NSD by using a json file\n\n\n\n\nCreate a NSD by filling in a form\n\n\n\n\nNetwork Service Descriptor Information\n\n\nIf you click on the id of a NSD shown in the list of NSDs you can see the information\nstored in this Network Service Descriptor.\n\n\n\n\nYou can observe the NSD in json format by clicking on the \nShow JSON\n button\n\n\n\n\nOn the page \nNetwork Service Descriptor Information\n you can also look at the \nGraphical view\n of the Network Service Descriptor \nby clicking on \nShow Graph\n\n\n\n\nIf you click on the \nAction\n button in the list of VNFDs you can delete the VNFD from the NSD\nand the information about the \nDependencies\n stored in the Network Service Descriptor\n\n\n\n\nIf you click on the \nAction\n button in the list of VNFDependencies you can delete the VNFDependency from the NSD\n\n\nVirtual Network Function Descriptor Information\n\n\nIn the list of Virtual Network Function Descriptors in NSD template you can click on the id of a Virtual Network Function Descriptor to get to this page\n\n\n\n\nAt the bottom of the page you can see the Virtual Deployment Unit (VDU) tab and if you click on the \nid\n of the \nVDU you can see the details of it\n\n\n\n\nVNF Packages\n\n\nOn this page you can upload the \nVNF Package\n. For more information about the VNF Package please read the \nVNF Package documentation\n \nFor uploading a \n.tar\n you can click on the button \nUpload VNFPackage\n and this window will be shown where you can drag \n drop the file or just click on the white area and choose your file using your file manager\n\n\n\n\nAfter you click on the button \nStart\n the package will be sent to the \nNFVO\n and once the process is finished you will see the package appearing in the list\n\n\n\n\n\n\nNetwork Service Records\n\n\nIn the menu on the left side if you click on the \nOrchestrator NS\n and then \nNS Records\n you will see the list of \nNetwork Service Records\n\nLike in this screenshot \n\n\n\n\nOn this page you can see the details of a Network Service Record by clicking on the id\n\n\n\n\nOn this page you can look at the JSON file of the NSR by clicking on the link \nShow JSON\n and also the \nGraphical view\n. \nof Network Service Record by clicking on the link \nShow Graph\n. \nIn the table of VNF Records you can delete a VNFR by clicking on \nAction\n and then \nDelete\n. \nTo look at the details of a VNFR just click on the \nid\n of it.\n\n\n\n\n\n\n\n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  &amp;&amp; (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Use via the Dashboard"
        }, 
        {
            "location": "/nfvo-how-to-use-gui/#openbaton-dashboard", 
            "text": "The Dashboard of OpenBaton helps you managing the lifecycle of different objects like \nVimInstaces, Network Service Descriptors/Records and Virtual Network Function Descriptors/Records in the OpenBaton environment.", 
            "title": "OpenBaton Dashboard"
        }, 
        {
            "location": "/nfvo-how-to-use-gui/#overview", 
            "text": "The index page shows an overview of the state of the NFVO    Number of Network Service Records  Number of Virtual Network Functions  Number of Virtual Deployment Units  Number of Network Service Descriptors", 
            "title": "Overview"
        }, 
        {
            "location": "/nfvo-how-to-use-gui/#manage-pops", 
            "text": "On this page you can see the list of Vim Instances registered   For registering a new Vim Instance you should click on the button in the top-right corner  Register Vim  of this page and select your json to register a Vim Instance   If you want to delete a Vim Instance you can click on the button  Action  and then  Delete  in the menu", 
            "title": "Manage PoPs"
        }, 
        {
            "location": "/nfvo-how-to-use-gui/#catalogue", 
            "text": "In the menu on the left side under the template  Catalogue  you can manage    NS Descriptors  VNF Packages   Network Service Descriptors  In the menu on the left side under the template Catalogue you can find the  NS Decriptors  button.\nOn this page you can see the list of NS Descriptors stored in OpenBaton   You have two options for storing a NS Descriptor:   Create a NSD by filling in a form  Create a NSD by using a json file   Create a NSD by using a json file   Create a NSD by filling in a form   Network Service Descriptor Information  If you click on the id of a NSD shown in the list of NSDs you can see the information\nstored in this Network Service Descriptor.   You can observe the NSD in json format by clicking on the  Show JSON  button   On the page  Network Service Descriptor Information  you can also look at the  Graphical view  of the Network Service Descriptor \nby clicking on  Show Graph   If you click on the  Action  button in the list of VNFDs you can delete the VNFD from the NSD\nand the information about the  Dependencies  stored in the Network Service Descriptor   If you click on the  Action  button in the list of VNFDependencies you can delete the VNFDependency from the NSD  Virtual Network Function Descriptor Information  In the list of Virtual Network Function Descriptors in NSD template you can click on the id of a Virtual Network Function Descriptor to get to this page   At the bottom of the page you can see the Virtual Deployment Unit (VDU) tab and if you click on the  id  of the \nVDU you can see the details of it   VNF Packages  On this page you can upload the  VNF Package . For more information about the VNF Package please read the  VNF Package documentation  \nFor uploading a  .tar  you can click on the button  Upload VNFPackage  and this window will be shown where you can drag   drop the file or just click on the white area and choose your file using your file manager   After you click on the button  Start  the package will be sent to the  NFVO  and once the process is finished you will see the package appearing in the list", 
            "title": "Catalogue"
        }, 
        {
            "location": "/nfvo-how-to-use-gui/#network-service-records", 
            "text": "In the menu on the left side if you click on the  Orchestrator NS  and then  NS Records  you will see the list of  Network Service Records \nLike in this screenshot    On this page you can see the details of a Network Service Record by clicking on the id   On this page you can look at the JSON file of the NSR by clicking on the link  Show JSON  and also the  Graphical view . \nof Network Service Record by clicking on the link  Show Graph . \nIn the table of VNF Records you can delete a VNFR by clicking on  Action  and then  Delete . \nTo look at the details of a VNFR just click on the  id  of it.    \n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  &amp;&amp; (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Network Service Records"
        }, 
        {
            "location": "/nfvo-sdk/", 
            "text": "NFVO SDK\n\n\nA SDK is available if you want to use the NFVO from a java application.\n\n\nImport it\n\n\nThe build.gradle file must contain:\n\n\nrepositories {\n    mavenCentral()\n    maven {\n        url \nhttp://get.openbaton.org:8081/nexus/content/groups/public\n\n    }\n}\n\ndependencies {\n    compile 'org.openbaton:sdk:0.15'\n}\n\n\n\n\nIn this way you will have access to the NFVO SDK.\n\n\nAnd then?\n\n\nThe UML diagram of the classes follows:\n\n\n\n\nThe NFVORequestor is the main and only class you need to use. From this class it is possible to retrieve all the Agents that are in charge of making calls to the NFVO. The NFVORequestor takes as constructor parameters:\n\n\n\n\n\n\n\n\nParams\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\nusername\n\n\nthe username if the security is enabled in the NFVO\n\n\n\n\n\n\npassword\n\n\nthe password if the security is enabled in the NFVO\n\n\n\n\n\n\nnfvo_ip\n\n\nthe ip of the NFVO\n\n\n\n\n\n\nnfvo_port\n\n\nthe port of the orchestrator\n\n\n\n\n\n\nversion\n\n\nthe API version. Now only \"1\" is available\n\n\n\n\n\n\n\n\nOnce you have the NFVORequestor object, you can get the Agents. Available agents are:\n\n\n\n\nConfigurationRestRequest\n\n\nEventAgent\n\n\nImageRestAgent\n\n\nNetworkServiceDescriptorRestAgent\n\n\nNetworkServiceRecordRestAgent\n\n\nVimInstanceRestAgent\n\n\nVirtualLinkRestAgent\n\n\nVNFFGRestAgent\n\n\n\n\neach of them exposes these methods:\n\n\n\n\ncreate\n\n\nfindById\n\n\nfindAll\n\n\ndelete\n\n\nupdate\n\n\n\n\nplus some specific methods and they refer to the \ncatalogue\n class contained in the name of the Agent. For instance, the NetworkServiceDescriptorRestAgent refers to NetworkServiceDescriptor class and, besides the above methods, exposes:\n\n\n\n\ngetVirtualNetworkFunctionDescriptors\n\n\ngetVirtualNetworkFunctionDescriptor\n\n\ndeleteVirtualNetworkFunctionDescriptors\n\n\ncreateVNFD\n\n\nupdateVNFD\n\n\ngetVNFDependencies\n\n\ngetVNFDependency\n\n\ndeleteVNFDependency\n\n\ncreateVNFDependency\n\n\nupdateVNFD\n\n\ngetPhysicalNetworkFunctionDescriptors\n\n\ngetPhysicalNetworkFunctionDescriptor\n\n\ndeletePhysicalNetworkFunctionDescriptor\n\n\ncreatePhysicalNetworkFunctionDescriptor\n\n\nupdatePNFD\n\n\ngetSecurities\n\n\ndeleteSecurity\n\n\ncreateSecurity\n\n\nupdateSecurity\n\n\n\n\nThe method names are explicit, they do what the name explains.\n\n\nUse it\n\n\nCreate VimInstance\n\n\npublic class Main {\n\n    public static void main(String[] args) {\n        NFVORequestor nfvoRequestor = new NFVORequestor(\nusername\n,\npassword\n,\nnfvo_ip\n,\nnfvo_port\n,\n1\n);\n        VimInstanceRestAgent vimInstanceAgent = nfvoRequestor.getVimInstanceAgent();\n\n        VimInstance vimInstance = new VimInstance();\n\n        // fill the vimInstance object accordingly to your VIM chosen\n\n        try {\n            vimInstance = vimInstanceAgent.create(vimInstance);\n        } catch (SDKException e) {\n            e.printStackTrace();\n        }\n\n        System.out.println(\nCreated VimInstance with id: \n + vimInstance.getId());\n    }\n}", 
            "title": "Use via the SDK"
        }, 
        {
            "location": "/nfvo-sdk/#nfvo-sdk", 
            "text": "A SDK is available if you want to use the NFVO from a java application.  Import it  The build.gradle file must contain:  repositories {\n    mavenCentral()\n    maven {\n        url  http://get.openbaton.org:8081/nexus/content/groups/public \n    }\n}\n\ndependencies {\n    compile 'org.openbaton:sdk:0.15'\n}  In this way you will have access to the NFVO SDK.  And then?  The UML diagram of the classes follows:   The NFVORequestor is the main and only class you need to use. From this class it is possible to retrieve all the Agents that are in charge of making calls to the NFVO. The NFVORequestor takes as constructor parameters:     Params  Meaning      username  the username if the security is enabled in the NFVO    password  the password if the security is enabled in the NFVO    nfvo_ip  the ip of the NFVO    nfvo_port  the port of the orchestrator    version  the API version. Now only \"1\" is available     Once you have the NFVORequestor object, you can get the Agents. Available agents are:   ConfigurationRestRequest  EventAgent  ImageRestAgent  NetworkServiceDescriptorRestAgent  NetworkServiceRecordRestAgent  VimInstanceRestAgent  VirtualLinkRestAgent  VNFFGRestAgent   each of them exposes these methods:   create  findById  findAll  delete  update   plus some specific methods and they refer to the  catalogue  class contained in the name of the Agent. For instance, the NetworkServiceDescriptorRestAgent refers to NetworkServiceDescriptor class and, besides the above methods, exposes:   getVirtualNetworkFunctionDescriptors  getVirtualNetworkFunctionDescriptor  deleteVirtualNetworkFunctionDescriptors  createVNFD  updateVNFD  getVNFDependencies  getVNFDependency  deleteVNFDependency  createVNFDependency  updateVNFD  getPhysicalNetworkFunctionDescriptors  getPhysicalNetworkFunctionDescriptor  deletePhysicalNetworkFunctionDescriptor  createPhysicalNetworkFunctionDescriptor  updatePNFD  getSecurities  deleteSecurity  createSecurity  updateSecurity   The method names are explicit, they do what the name explains.  Use it  Create VimInstance  public class Main {\n\n    public static void main(String[] args) {\n        NFVORequestor nfvoRequestor = new NFVORequestor( username , password , nfvo_ip , nfvo_port , 1 );\n        VimInstanceRestAgent vimInstanceAgent = nfvoRequestor.getVimInstanceAgent();\n\n        VimInstance vimInstance = new VimInstance();\n\n        // fill the vimInstance object accordingly to your VIM chosen\n\n        try {\n            vimInstance = vimInstanceAgent.create(vimInstance);\n        } catch (SDKException e) {\n            e.printStackTrace();\n        }\n\n        System.out.println( Created VimInstance with id:   + vimInstance.getId());\n    }\n}", 
            "title": "NFVO SDK"
        }, 
        {
            "location": "/zabbix-plugin/", 
            "text": "Zabbix plugin\n\n\nZabbix plugin is an open source project providing a reference implementation of two interfaces of the VIM, based on the ETSI \nNFV MANO\n specification.\n\n\nThe two interfaces are:\n-   VirtualisedResourceFaultManagement\n-   VirtualisedResourcePerformanceManagement\n\n\nA detailed description of the interfaces is in the last ETSI Draft \nIFA005_Or-Vi_ref_point_Spec\n.\n\nIn particular with the Zabbix plugin you can create/delete items, trigger and action on-demand. \n\n\n\n\nSome of the benefits introduced by the usage of such plugin: \n1) Make the consumers (NFVO, VNFM) indipendent to the monitoring system.\n\n2) The communication between the consumers and zabbix-plugin is JSON based, so the consumers can be written in any languages.\n\n3) The values of the items are cached and updated periodically in order to avoid to contact the zabbix server each time a specific metric is required.\n4) If your consumer is written in java, we provide a simple class MonitoringPluginCaller which handle the communication via RabbitMQ.\n\n\nGetting Started\n\n\nPrerequisites\n\n\nThe prerequisites are:  \n\n\n\n\nZabbix server installed and running. See \nhow to configure Zabbix server\n.\n\n\nRabbitMQ server installed and running  \n\n\nGit installed\n\n\nGradle installed\n\n\n\n\nAdditional Zabbix Server configuration required for receiving notifications\n\n\nHow is the zabbix-plugin receiving notification from the Zabbix Server? \n\n\nWhen using the method createThreshold provided by the plugin,it automatically creates an \naction\n executed when the specific condition is met. \nIf the threshold is crossed (the status of the trigger goes from OK to PROBLEM or viceversa) the action is performed. The action gets the informations of the threshold and sends them to a custom alertScript.\nThe custom alertscripts is executed on the zabbix server and its task is to send the informations received from the action to the zabbix-plugin. \n\n\nThe zabbix-pluging waits for notifications at the url: http://zabbix-plugin-ip:defaultPort/defaultContext.\n\n\nDefatult context and ports are specified in the configuration file as: \n\n \nnotification-receiver-server-context\n.\n\n \nnotification-receiver-server-port\n.\n\n\nThe custom alert script we use is the following:  \n\n\n#!/bin/bash\nto=$1\nbody=$3\ncurl -X POST -H \nAccept: application/json\n -H \nContent-Type: application/json\n -d \n$body\n http://$to\n\n\n\n\nCopy this script in the directory defined in the Zabbix server configuration file as AlertScriptsPath variable.\nThe variable 'to' is the endpoint where zabbix-plugin receives the notification (specified in \nnotification-receiver-server-context\n property). \nAfter you copied the script in the right directoy, the Zabbix server needs to be configured correctly in order to use \ncustom alertscripts\n. \nThis configuration will be automatized in later releases. \n\n\nInstallation\n\n\nOnce the prerequisites are met, you can clone the following project from git, compile it using gradle and launch it:  \n\n\ngit clone link_of_zabbix-plugin\ncd zabbix-plugin\ngit checkout develop\n./gradlew build -x test\njava -jar build/lib/zabbix-agent-\nversion\n.jar\n\n\n\n\nConfiguration\n\n\nCreate a configuration file called zabbix-plugin.conf in the path /etc/openbaton/plugins/ and fill it with the configuration parameter explained in the following section.\n\n\n\n\n\n\n\n\nParameter\n\n\nDescription\n\n\nDefault\n\n\n\n\n\n\n\n\n\n\nzabbix-ip\n\n\nIP of the Zabbix Server\n\n\n\n\n\n\n\n\nzabbix-port\n\n\nPort of the Zabbix Server\n\n\n\n\n\n\n\n\ntype\n\n\nThe type of the plugin\n\n\nzabbix-plugin\n\n\n\n\n\n\nuser-zbx\n\n\nUser of the Zabbix Server\n\n\n\n\n\n\n\n\npassword-zbx\n\n\nPassword of Zabbix Server\n\n\n\n\n\n\n\n\nclient-request-frequency\n\n\nUpdate cache period (Basically each time t, the zabbix plugin ask to every items value for all hosts and fill the local cache)\n\n\n15 (seconds)\n\n\n\n\n\n\nhistory-length\n\n\nHow long is the history. If the client-request-frequency is 10 seconds and history-length 100, we have available the value of the items of the previous 1000 seconds.\n\n\n250\n\n\n\n\n\n\nnotification-receiver-server-context\n\n\nContext where the zabbix-plugin receive the notifications by the zabbix server. (see the section 'How to configure Zabbix to get notifications')\n\n\n/zabbixplugin/notifications\n\n\n\n\n\n\nnotification-receiver-server-port\n\n\nPort where the zabbix-plugin receive the notifications by the zabbix server.\n\n\n8010\n\n\n\n\n\n\nexternal-properties-file\n\n\nFull path of the configuration file.\n\n\n/etc/openbaton/plugins/zabbix-plugin.conf\n\n\n\n\n\n\n\n\nThe configuration file should look like the one below:\n\n\nzabbix-ip = xxx.xxx.xxx.xxx\nzabbix-ip = xxxxx\ntype = zabbix-plugin\nuser-zbx = zabbixUSer\npassword-zbx = zabbixPassword\nclient-request-frequency = 10\nhistory-length = 250\n\nnotification-receiver-server-context = /zabbixplugin/notifications\nnotification-receiver-server-port = 8010\n\nexternal-properties-file=/etc/openbaton/plugins/zabbix-plugin.conf\n\n\n\n\nUsing it via MonitoringPluginCaller\n\n\nIn order to use the MonitorPluginCaller you need to import the relative plugin-sdk, coming from \nOpenbaton\n project.\nTo import the plugin-sdk, please add in your gradle file the following dependencies:\n\n\nrepositories {\n       maven { url \nhttp://get.openbaton.org:8081/nexus/content/groups/public/\n }\n}\n\ndependencies {\n    compile 'org.openbaton:plugin-sdk:0.15-SNAPSHOT'\n}\n\n\n\n\nThen in your main, obtain the MonitoringPluginCaller as follow:\n\n\nMonitoringPluginCaller monitoringPluginCaller=null;\ntry {\n    monitoringPluginCaller = new MonitoringPluginCaller(\nzabbix\n,\n15672\n);\n} catch (TimeoutException e) {\n    e.printStackTrace();\n} catch (NotFoundException e) {\n    e.printStackTrace();\n} catch (IOException e) {\n    e.printStackTrace();\n}\n\n\n\n\nFunctionalities provided by the Zabbix Plugin Interface\n\n\nVirtualisedResourcePerformanceManagement interface\n\n\n\n\n\n\n\n\nMethods\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nCREATE PM JOB\n\n\nCreate one or more items to be monitored in one or more hosts.\n\n\n\n\n\n\nDELETE PM JOB\n\n\nDelete a PM job.\n\n\n\n\n\n\nQUERY PM JOB\n\n\nGet item values from one or more host. Fast method since the item values are cached.\n\n\n\n\n\n\nSUBSCRIBE\n\n\nSubscribe to a pm job or a threshold in order to be notified.\n\n\n\n\n\n\nNOTIFY\n\n\nNotification method invoked by zabbix plugin, the customer must not invoke directly this method.\n\n\n\n\n\n\nCREATE THRESHOLD\n\n\nCreate trigger on a specific item for one or more hosts\n\n\n\n\n\n\nDELETE THRESHOLD\n\n\nDelete a threshold.\n\n\n\n\n\n\nQUERY THRESHOLD\n\n\nGet information about the status of the thresholds\n\n\n\n\n\n\n\n\nVirtualisedResourceFaultManagement interface\n\n\n\n\n\n\n\n\nMethods\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nSUBSCRIBE\n\n\nSubscribe for alarm coming from an host\n\n\n\n\n\n\nNOTIFY\n\n\nNotification method invoked by zabbix plugin, the customer must not invoke directly this method.\n\n\n\n\n\n\nGET ALARM LIST\n\n\nGet alarms and relative status\n\n\n\n\n\n\n\n\nVirtualisedResourcePerformanceManagement interface\n\n\nCreate PM Job\n\n\nString createPMJob(ObjectSelection selector, List\nString\n performanceMetrics, List\nString\n performanceMetricGroup, Integer collectionPeriod,Integer reportingPeriod) throws MonitoringException;\n\n\n\n\nThis method create one or more items to be monitored in one or more hosts.\n\n\nselector\n: object to select the hosts in which we want to add the items.\n\n\nperformanceMetrics\n: List of items. We can create items which are available in the \nZabbix documentation 2.2\n.\n\n\nperformanceMetricGroup\n: pre-defined list of metrics. (NOT YET IMPLEMENTED, please pass an empty list of string).\n\n\ncollectionPeriod\n: Update interval of the item/s in seconds.\n\n\nreportingPeriod\n: Specifies the periodicity at which the VIM will report to the customers about performance information\u0000\u0000. (NOT YET IMPLEMENTED, please pass an integer \n= 0 ).\n\n\nIn the following example we create two items ('net.tcp.listen[8080]' and 'agent.ping') for two hosts ('host-1' and 'host-2'). As a return value we get the ID of the PMJob.\n\n\nObjectSelection objectSelection = getObjectSelector(\nhost-1\n,\nhost-2\n);\nList\nString\n performanceMetrics = getPerformanceMetrics(\nnet.tcp.listen[8080]\n,\nagent.ping\n);\nString pmJobId = monitoringPluginCaller.createPMJob(objectSelection, performanceMetrics, new ArrayList\nString\n(),60, 0);\nSystem.out.println(\nPmJobId is: \n+pmJobId);\n\n\n\n\nHere the methods getObjectSelector and getPerformanceMetrics:\n\n\nprivate List\nString\n getPerformanceMetrics(String ... performanceMetrics) {\n    List\nString\n result = new ArrayList\nString\n();\n    for(String performanceMetric : performanceMetrics){\n        result.add(performanceMetric);\n    }\n    return result;\n}\n\nprivate ObjectSelection getObjectSelector(String ... hosts) {\n    ObjectSelection objectSelection = new ObjectSelection();\n    for(String host : hosts){\n        objectSelection.addObjectInstanceId(host);\n    }\n    return objectSelection;\n}\n\n\n\n\nDelete Pm Job\n\n\nList\nString\n deletePMJob(List\nString\n pmJobIdsToDelete) throws MonitoringException;\n\n\n\n\nThis method delete an existing PmJob. We can get the id of the PmJob after the creation with createPMJob. As a return value we get the ID of the PMJobs effectively deleted.\n\n\nQuery Pm Job\n\n\nList\nItem\n queryPMJob(List\nString\n hostnames, List\nString\n performanceMetrics, String period) throws MonitoringException;\n\n\n\n\nThis method get item values from one or more host. As a return value we get the list of items.\n\n\nhostnames\n: list of hostnames which we want to know items values.\n\n\nperformanceMetrics\n: List of items. We can get items which are available in: the \nZabbix documentation 2.2\n and in the \nhostnames\n.\n\n\nperiod\n: period in seconds. If period is 0 than you get the last available value of the item. If \n 0 you get the average of the values inside that period.\n    Remember than the zabbix-plugin read all value of the all hosts every \nclient-request-frequency\n (see the configuration section) and keep them in the history.\n    So if \nclient-request-frequency\n is 15 seconds and the period 30 seconds you get the average of the previous 2 values of the item.\n\n\nIn the following example we ask for the last value of two items ('net.tcp.listen[8080]' and 'agent.ping') for the hosts 'host-1'.\n\n\nArrayList\nString\n hostnames = getHostnames(\nhost-1\n);\nArrayList\nString\n performanceMetrics = getPerformanceMetrics(\nnet.tcp.listen[8080]\n,\nagent.ping\n);\nList\nItem\n items = monitoringPluginCaller.queryPMJob(hostnames,performanceMetrics,\n0\n);\n\n\n\n\nitems\n: list of items. An item is a simple object of openbaton-libs which contains properties like: metric, hostname, lastValue, value.\n\n\nSubscribe \n notifyInfo\n\n\nNOT YET IMPLEMENTED\n\n\nCreate Threshold\n\n\nString createThreshold(ObjectSelection selector, String performanceMetric, ThresholdType thresholdType, ThresholdDetails thresholdDetails) throws MonitoringException;\n\n\n\n\nThis method create a trigger on a specific item for one or more hosts. As a return value we get the id of the threshold.\n\n\nselector\n: object to select the hosts which will be part of the trigger.\n\n\nperformanceMetric\n: item to include in the trigger. The item need to be already present in the hosts specified in the \nselector\n.\n\n\nthresholdType\n: defines the type of threshold\u0000. (NOT YET IMPLEMENTED, please pass ThresholdType.SINGLE for the moment).\n\n\nthresholdDetails\n: details of the threshold. It contains:\n\n\n\n\nfunction: refer to \nZabbix trigger function 2.2\n \u0000\n\n\ntriggerOperator: operator\n\n\nperceiverSeverity: severity of the trigger.\n\n\nvalue: threshold value to compare with the actual value of the \nperformanceMetric\n.\n\n\nhostOperator: can be \"|\" or \"\n\", meaning that the threshold will trigger when at least one host or all the hosts cross the threshold value.\n\n\n\n\nIn the following example we create a treshold for two hosts ('host-1' and 'host-2').\n\n\nObjectSelection objectSelector = getObjectSelector(\nhost-1\n,\nhost-2\n);\nThresholdDetails thresholdDetails= new ThresholdDetails(\nlast(0)\n,\n=\n,PerceivedSeverity.CRITICAL,\n0\n,\n|\n);\nString thresholdId = zabbixMonitoringAgent.createThreshold(objectSelector,\nnet.tcp.listen[5001]\n,ThresholdType.SINGLE_VALUE,thresholdDetails);\n\n\n\n\nThe trigger that will be created has this expression: {host-1:net.tcp.listen[5001].last(0)}=0|{host-2:net.tcp.listen[5001].last(0)}=0.\nIt means that if host-1 OR host-2 have no more process listening on the port 5001 then create an alarm with severity critical.\nRefer to \nZabbix expression 2.2\n to understand better the expression.\n\n\nDelete Threshold\n\n\nList\nString\n deleteThreshold(List\nString\n thresholdIds) throws MonitoringException;\n\n\n\n\nThis method delete an existing threshold/s. We can get the id of the threshold after the creation with createThreshold. As a return value we get the list of the ID of the threshold effectively deleted.\n\n\nQuery Threshold\n\n\nNOT YET IMPLEMENTED\n\n\nVirtualisedResourceFaultManagement interface\n\n\nSubscribe\n\n\nString subscribeForFault(AlarmEndpoint filter) throws MonitoringException;\n\n\n\n\nSubscribe for alarm generated by thresholds. As a return value we get the id of the subscription.\n\nfilter\n: AlarmEndpoint object which contains:\n-  name: name of the alarmEndpoint.\n-  resourceId: hostname which we want to subscribe.\n-  type: REST or JMS.\n-  endpoint: endpoint where we want to be notified. It is and url for REST or a queue name for JMS. (actually only rest is supported).\n-  perceivedSeverity: define the severity of the alarm we want to get.\n    If we specify PerceivedSeverity.WARNING we will able to get notification from alarm with severity equals or higher than WARNING.\n\n\nIn the following example we subscribe for all alarms with severity higher than WARNING coming from the host 'host-1'.\n\n\nAlarmEndpoint alarmEndpoint = new AlarmEndpoint(\nfault-manager-of-host-1\n,\nhost-1\n,EndpointType.REST,\nhttp://localhost:5555/alarm\n,PerceivedSeverity.WARNING);\nString subscriptionId = monitoringPluginCaller.subscribeForFault(alarmEndpoint);\n\n\n\n\nUnsubscribe\n\n\nString unsubscribeForFault(String subscriptionId) throws MonitoringException;\n\n\n\n\nThis method detele the subscription with the ID passed as a argument. As a return value we get the id of the subscription effectively deleted.\nWe can get the id of the subscription after the creation with subscribeForFault.\n\n\nGet alarm list\n\n\nNOT YET IMPLEMENTED\n\n\nNotify\n\n\nThis method cannot be invoked by the customers as specified in the ETSI draft \nIFA005_Or-Vi_ref_point_Spec\n.\n\n\nZabbix severity mapping with ETSI severity\n\n\nIn Zabbix we can specify a severity of a trigger: not classified, information, warning, average, high, disaster.\n\n\nIn the ETSI draft there are different level of severity, called perceived severity: Indeterminate, warning, minor, major, critical.\n\n\nSo the mapping in the zabbix plugin is showed in the following table:\n\n\n\n\n\n\n\n\nZabbix severity\n\n\nETSI perceived severity\n\n\n\n\n\n\n\n\n\n\nNot classified\n\n\nIndeterminate\n\n\n\n\n\n\nInformation\n\n\nWarning\n\n\n\n\n\n\nWarning\n\n\nWarning\n\n\n\n\n\n\nAverage\n\n\nMinor\n\n\n\n\n\n\nHigh\n\n\nMajor\n\n\n\n\n\n\nDisaster\n\n\nCritical\n\n\n\n\n\n\n\n\nNotifications types\n\n\nWhen we create a new threshold, we would like to get a notification as soon as the threshold is crossed. Both interfaces send notifications with the method notify.\nAccording to ETSI specification there are 4 types of notifications. \n\n\nThe interface VirtualisedResourcePerformanceManagement sends two types of notifications:  \n\n\n\n\nPerformanceInformationAvailableNotification (NOT YET IMPLEMENTED) \u0000: this notification informs the receiver that performance information is available.  \u0000   \n\n\nhresholdCrossedNotification\u0000 (NOT YET IMPLEMENTED) : his notification informs the receiver that a threshold value has been crossed.\u0000  \n\n\n\n\nThe interface VirtualisedResourceFaultManagement sends the following notifications:\n\n\n\n\nAlarmNotification\u0000: This notification informs the receiver of alarms resulting from the faults related to the virtualised resources managed by the VIM\u0000. It contains the Alarm with all the information about the fault.\n\n\nAlarmStateChangedNotification\u0000: This notification informs the receiver of state change of alarm related to the virtualised resources managed by the VIM, e.g. the alarm shall be set to \u201ccleared\u201d if the corresponding fault has been solved.\n    It contains the id of the Alarm and the actual status which could be (CLEARED,FIRED,UPDATED).\u0000\n\n\n\n\nActually the zabbix-plugin when receives the notification by zabbix server, \nif the trigger has severity higher than Information\n, \nit creates an alarm (mapping zabbix notification into standard Alarm) and notify the subscribers with a AlarmNotification. If the notification is not new, then it sends an AlarmStateChangedNotification.", 
            "title": "Use Zabbix plugin"
        }, 
        {
            "location": "/zabbix-plugin/#zabbix-plugin", 
            "text": "Zabbix plugin is an open source project providing a reference implementation of two interfaces of the VIM, based on the ETSI  NFV MANO  specification.  The two interfaces are:\n-   VirtualisedResourceFaultManagement\n-   VirtualisedResourcePerformanceManagement  A detailed description of the interfaces is in the last ETSI Draft  IFA005_Or-Vi_ref_point_Spec . \nIn particular with the Zabbix plugin you can create/delete items, trigger and action on-demand.    Some of the benefits introduced by the usage of such plugin: \n1) Make the consumers (NFVO, VNFM) indipendent to the monitoring system. \n2) The communication between the consumers and zabbix-plugin is JSON based, so the consumers can be written in any languages. \n3) The values of the items are cached and updated periodically in order to avoid to contact the zabbix server each time a specific metric is required.\n4) If your consumer is written in java, we provide a simple class MonitoringPluginCaller which handle the communication via RabbitMQ.", 
            "title": "Zabbix plugin"
        }, 
        {
            "location": "/zabbix-plugin/#getting-started", 
            "text": "Prerequisites  The prerequisites are:     Zabbix server installed and running. See  how to configure Zabbix server .  RabbitMQ server installed and running    Git installed  Gradle installed", 
            "title": "Getting Started"
        }, 
        {
            "location": "/zabbix-plugin/#additional-zabbix-server-configuration-required-for-receiving-notifications", 
            "text": "How is the zabbix-plugin receiving notification from the Zabbix Server?   When using the method createThreshold provided by the plugin,it automatically creates an  action  executed when the specific condition is met. \nIf the threshold is crossed (the status of the trigger goes from OK to PROBLEM or viceversa) the action is performed. The action gets the informations of the threshold and sends them to a custom alertScript.\nThe custom alertscripts is executed on the zabbix server and its task is to send the informations received from the action to the zabbix-plugin.   The zabbix-pluging waits for notifications at the url: http://zabbix-plugin-ip:defaultPort/defaultContext.  Defatult context and ports are specified in the configuration file as:    notification-receiver-server-context .   notification-receiver-server-port .  The custom alert script we use is the following:    #!/bin/bash\nto=$1\nbody=$3\ncurl -X POST -H  Accept: application/json  -H  Content-Type: application/json  -d  $body  http://$to  Copy this script in the directory defined in the Zabbix server configuration file as AlertScriptsPath variable.\nThe variable 'to' is the endpoint where zabbix-plugin receives the notification (specified in  notification-receiver-server-context  property). \nAfter you copied the script in the right directoy, the Zabbix server needs to be configured correctly in order to use  custom alertscripts . \nThis configuration will be automatized in later releases.   Installation  Once the prerequisites are met, you can clone the following project from git, compile it using gradle and launch it:    git clone link_of_zabbix-plugin\ncd zabbix-plugin\ngit checkout develop\n./gradlew build -x test\njava -jar build/lib/zabbix-agent- version .jar  Configuration  Create a configuration file called zabbix-plugin.conf in the path /etc/openbaton/plugins/ and fill it with the configuration parameter explained in the following section.     Parameter  Description  Default      zabbix-ip  IP of the Zabbix Server     zabbix-port  Port of the Zabbix Server     type  The type of the plugin  zabbix-plugin    user-zbx  User of the Zabbix Server     password-zbx  Password of Zabbix Server     client-request-frequency  Update cache period (Basically each time t, the zabbix plugin ask to every items value for all hosts and fill the local cache)  15 (seconds)    history-length  How long is the history. If the client-request-frequency is 10 seconds and history-length 100, we have available the value of the items of the previous 1000 seconds.  250    notification-receiver-server-context  Context where the zabbix-plugin receive the notifications by the zabbix server. (see the section 'How to configure Zabbix to get notifications')  /zabbixplugin/notifications    notification-receiver-server-port  Port where the zabbix-plugin receive the notifications by the zabbix server.  8010    external-properties-file  Full path of the configuration file.  /etc/openbaton/plugins/zabbix-plugin.conf     The configuration file should look like the one below:  zabbix-ip = xxx.xxx.xxx.xxx\nzabbix-ip = xxxxx\ntype = zabbix-plugin\nuser-zbx = zabbixUSer\npassword-zbx = zabbixPassword\nclient-request-frequency = 10\nhistory-length = 250\n\nnotification-receiver-server-context = /zabbixplugin/notifications\nnotification-receiver-server-port = 8010\n\nexternal-properties-file=/etc/openbaton/plugins/zabbix-plugin.conf", 
            "title": "Additional Zabbix Server configuration required for receiving notifications"
        }, 
        {
            "location": "/zabbix-plugin/#using-it-via-monitoringplugincaller", 
            "text": "In order to use the MonitorPluginCaller you need to import the relative plugin-sdk, coming from  Openbaton  project.\nTo import the plugin-sdk, please add in your gradle file the following dependencies:  repositories {\n       maven { url  http://get.openbaton.org:8081/nexus/content/groups/public/  }\n}\n\ndependencies {\n    compile 'org.openbaton:plugin-sdk:0.15-SNAPSHOT'\n}  Then in your main, obtain the MonitoringPluginCaller as follow:  MonitoringPluginCaller monitoringPluginCaller=null;\ntry {\n    monitoringPluginCaller = new MonitoringPluginCaller( zabbix , 15672 );\n} catch (TimeoutException e) {\n    e.printStackTrace();\n} catch (NotFoundException e) {\n    e.printStackTrace();\n} catch (IOException e) {\n    e.printStackTrace();\n}", 
            "title": "Using it via MonitoringPluginCaller"
        }, 
        {
            "location": "/zabbix-plugin/#functionalities-provided-by-the-zabbix-plugin-interface", 
            "text": "VirtualisedResourcePerformanceManagement interface     Methods  Description      CREATE PM JOB  Create one or more items to be monitored in one or more hosts.    DELETE PM JOB  Delete a PM job.    QUERY PM JOB  Get item values from one or more host. Fast method since the item values are cached.    SUBSCRIBE  Subscribe to a pm job or a threshold in order to be notified.    NOTIFY  Notification method invoked by zabbix plugin, the customer must not invoke directly this method.    CREATE THRESHOLD  Create trigger on a specific item for one or more hosts    DELETE THRESHOLD  Delete a threshold.    QUERY THRESHOLD  Get information about the status of the thresholds     VirtualisedResourceFaultManagement interface     Methods  Description      SUBSCRIBE  Subscribe for alarm coming from an host    NOTIFY  Notification method invoked by zabbix plugin, the customer must not invoke directly this method.    GET ALARM LIST  Get alarms and relative status     VirtualisedResourcePerformanceManagement interface  Create PM Job  String createPMJob(ObjectSelection selector, List String  performanceMetrics, List String  performanceMetricGroup, Integer collectionPeriod,Integer reportingPeriod) throws MonitoringException;  This method create one or more items to be monitored in one or more hosts.  selector : object to select the hosts in which we want to add the items.  performanceMetrics : List of items. We can create items which are available in the  Zabbix documentation 2.2 .  performanceMetricGroup : pre-defined list of metrics. (NOT YET IMPLEMENTED, please pass an empty list of string).  collectionPeriod : Update interval of the item/s in seconds.  reportingPeriod : Specifies the periodicity at which the VIM will report to the customers about performance information\u0000\u0000. (NOT YET IMPLEMENTED, please pass an integer  = 0 ).  In the following example we create two items ('net.tcp.listen[8080]' and 'agent.ping') for two hosts ('host-1' and 'host-2'). As a return value we get the ID of the PMJob.  ObjectSelection objectSelection = getObjectSelector( host-1 , host-2 );\nList String  performanceMetrics = getPerformanceMetrics( net.tcp.listen[8080] , agent.ping );\nString pmJobId = monitoringPluginCaller.createPMJob(objectSelection, performanceMetrics, new ArrayList String (),60, 0);\nSystem.out.println( PmJobId is:  +pmJobId);  Here the methods getObjectSelector and getPerformanceMetrics:  private List String  getPerformanceMetrics(String ... performanceMetrics) {\n    List String  result = new ArrayList String ();\n    for(String performanceMetric : performanceMetrics){\n        result.add(performanceMetric);\n    }\n    return result;\n}\n\nprivate ObjectSelection getObjectSelector(String ... hosts) {\n    ObjectSelection objectSelection = new ObjectSelection();\n    for(String host : hosts){\n        objectSelection.addObjectInstanceId(host);\n    }\n    return objectSelection;\n}  Delete Pm Job  List String  deletePMJob(List String  pmJobIdsToDelete) throws MonitoringException;  This method delete an existing PmJob. We can get the id of the PmJob after the creation with createPMJob. As a return value we get the ID of the PMJobs effectively deleted.  Query Pm Job  List Item  queryPMJob(List String  hostnames, List String  performanceMetrics, String period) throws MonitoringException;  This method get item values from one or more host. As a return value we get the list of items.  hostnames : list of hostnames which we want to know items values.  performanceMetrics : List of items. We can get items which are available in: the  Zabbix documentation 2.2  and in the  hostnames .  period : period in seconds. If period is 0 than you get the last available value of the item. If   0 you get the average of the values inside that period.\n    Remember than the zabbix-plugin read all value of the all hosts every  client-request-frequency  (see the configuration section) and keep them in the history.\n    So if  client-request-frequency  is 15 seconds and the period 30 seconds you get the average of the previous 2 values of the item.  In the following example we ask for the last value of two items ('net.tcp.listen[8080]' and 'agent.ping') for the hosts 'host-1'.  ArrayList String  hostnames = getHostnames( host-1 );\nArrayList String  performanceMetrics = getPerformanceMetrics( net.tcp.listen[8080] , agent.ping );\nList Item  items = monitoringPluginCaller.queryPMJob(hostnames,performanceMetrics, 0 );  items : list of items. An item is a simple object of openbaton-libs which contains properties like: metric, hostname, lastValue, value.  Subscribe   notifyInfo  NOT YET IMPLEMENTED  Create Threshold  String createThreshold(ObjectSelection selector, String performanceMetric, ThresholdType thresholdType, ThresholdDetails thresholdDetails) throws MonitoringException;  This method create a trigger on a specific item for one or more hosts. As a return value we get the id of the threshold.  selector : object to select the hosts which will be part of the trigger.  performanceMetric : item to include in the trigger. The item need to be already present in the hosts specified in the  selector .  thresholdType : defines the type of threshold\u0000. (NOT YET IMPLEMENTED, please pass ThresholdType.SINGLE for the moment).  thresholdDetails : details of the threshold. It contains:   function: refer to  Zabbix trigger function 2.2  \u0000  triggerOperator: operator  perceiverSeverity: severity of the trigger.  value: threshold value to compare with the actual value of the  performanceMetric .  hostOperator: can be \"|\" or \" \", meaning that the threshold will trigger when at least one host or all the hosts cross the threshold value.   In the following example we create a treshold for two hosts ('host-1' and 'host-2').  ObjectSelection objectSelector = getObjectSelector( host-1 , host-2 );\nThresholdDetails thresholdDetails= new ThresholdDetails( last(0) , = ,PerceivedSeverity.CRITICAL, 0 , | );\nString thresholdId = zabbixMonitoringAgent.createThreshold(objectSelector, net.tcp.listen[5001] ,ThresholdType.SINGLE_VALUE,thresholdDetails);  The trigger that will be created has this expression: {host-1:net.tcp.listen[5001].last(0)}=0|{host-2:net.tcp.listen[5001].last(0)}=0.\nIt means that if host-1 OR host-2 have no more process listening on the port 5001 then create an alarm with severity critical.\nRefer to  Zabbix expression 2.2  to understand better the expression.  Delete Threshold  List String  deleteThreshold(List String  thresholdIds) throws MonitoringException;  This method delete an existing threshold/s. We can get the id of the threshold after the creation with createThreshold. As a return value we get the list of the ID of the threshold effectively deleted.  Query Threshold  NOT YET IMPLEMENTED  VirtualisedResourceFaultManagement interface  Subscribe  String subscribeForFault(AlarmEndpoint filter) throws MonitoringException;  Subscribe for alarm generated by thresholds. As a return value we get the id of the subscription. filter : AlarmEndpoint object which contains:\n-  name: name of the alarmEndpoint.\n-  resourceId: hostname which we want to subscribe.\n-  type: REST or JMS.\n-  endpoint: endpoint where we want to be notified. It is and url for REST or a queue name for JMS. (actually only rest is supported).\n-  perceivedSeverity: define the severity of the alarm we want to get.\n    If we specify PerceivedSeverity.WARNING we will able to get notification from alarm with severity equals or higher than WARNING.  In the following example we subscribe for all alarms with severity higher than WARNING coming from the host 'host-1'.  AlarmEndpoint alarmEndpoint = new AlarmEndpoint( fault-manager-of-host-1 , host-1 ,EndpointType.REST, http://localhost:5555/alarm ,PerceivedSeverity.WARNING);\nString subscriptionId = monitoringPluginCaller.subscribeForFault(alarmEndpoint);  Unsubscribe  String unsubscribeForFault(String subscriptionId) throws MonitoringException;  This method detele the subscription with the ID passed as a argument. As a return value we get the id of the subscription effectively deleted.\nWe can get the id of the subscription after the creation with subscribeForFault.  Get alarm list  NOT YET IMPLEMENTED  Notify  This method cannot be invoked by the customers as specified in the ETSI draft  IFA005_Or-Vi_ref_point_Spec .", 
            "title": "Functionalities provided by the Zabbix Plugin Interface"
        }, 
        {
            "location": "/zabbix-plugin/#zabbix-severity-mapping-with-etsi-severity", 
            "text": "In Zabbix we can specify a severity of a trigger: not classified, information, warning, average, high, disaster.  In the ETSI draft there are different level of severity, called perceived severity: Indeterminate, warning, minor, major, critical.  So the mapping in the zabbix plugin is showed in the following table:     Zabbix severity  ETSI perceived severity      Not classified  Indeterminate    Information  Warning    Warning  Warning    Average  Minor    High  Major    Disaster  Critical", 
            "title": "Zabbix severity mapping with ETSI severity"
        }, 
        {
            "location": "/zabbix-plugin/#notifications-types", 
            "text": "When we create a new threshold, we would like to get a notification as soon as the threshold is crossed. Both interfaces send notifications with the method notify.\nAccording to ETSI specification there are 4 types of notifications.   The interface VirtualisedResourcePerformanceManagement sends two types of notifications:     PerformanceInformationAvailableNotification (NOT YET IMPLEMENTED) \u0000: this notification informs the receiver that performance information is available.  \u0000     hresholdCrossedNotification\u0000 (NOT YET IMPLEMENTED) : his notification informs the receiver that a threshold value has been crossed.\u0000     The interface VirtualisedResourceFaultManagement sends the following notifications:   AlarmNotification\u0000: This notification informs the receiver of alarms resulting from the faults related to the virtualised resources managed by the VIM\u0000. It contains the Alarm with all the information about the fault.  AlarmStateChangedNotification\u0000: This notification informs the receiver of state change of alarm related to the virtualised resources managed by the VIM, e.g. the alarm shall be set to \u201ccleared\u201d if the corresponding fault has been solved.\n    It contains the id of the Alarm and the actual status which could be (CLEARED,FIRED,UPDATED).\u0000   Actually the zabbix-plugin when receives the notification by zabbix server,  if the trigger has severity higher than Information , \nit creates an alarm (mapping zabbix notification into standard Alarm) and notify the subscribers with a AlarmNotification. If the notification is not new, then it sends an AlarmStateChangedNotification.", 
            "title": "Notifications types"
        }, 
        {
            "location": "/integration-test-use/", 
            "text": "How to use the Integration Tests\n\n\nOverview\n\n\nThis project provides integration tests. \nThree tests are run.\n\n\n\n\nscenario-dummy-iperf\n\n\nscenario-many-dependencies\n\n\nscenario-real-iperf\n\n\n\n\nscenario-dummy-iperf uses the Dummy VNFM to simulate a VNFM and therefore tests the communication between NFVO and VNFM. \nIt does not actually deploy a network service. The fake network service is a simple iperf scenario with one server and one client. \n\n\nscenario-many-dependencies also uses the Dummy VNFM but its fake network service is a little bit more complex in the sense that it has many \nVNFD\n with many dependencies between them. \n\n\nThe last test scenario-real-iperf is the only one which actually deploys a network service on openstack. \nIt consists of two \nVNFD\n and deploys one iperf server and two iperf clients. The clients contact the server. \n\n\nIn every test a vim instance and a network service descriptor is stored on the orchestrator and the network service launched. \nIf that is successful, the network service is stoped and the network service record, network service descriptor and the vim instance are removed. \nIn the case of the scenario-real-iperf test also the service itself is tested, i.e. if iperf is running and the clients can connect to the server. \n\n\nRequirements\n\n\n\n\nA running \nNFVO\n\n\nA running \nGeneric VNFM\n\n\nA running \nDummy VNFM\n\n\n\n\nInstallation and configuration\n\n\nClone the project to your machine. \nIn \nintegration-tests/src/main/resources\n is a file named integration-test.properties. \nOpen it and set the property values according to your needs. \n\n\n\n\n\n\n\n\nField\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nnfvo-ip\n\n\nThe ip of the machine on which the NFVO you want to use is running\n\n\n\n\n\n\nnfvo-port\n\n\nThe port on which the NFVO is running\n\n\n\n\n\n\nnfvo-usr\n\n\nThe username if a login is required for the NFVO\n\n\n\n\n\n\nnfvo-pwd\n\n\nThe password if a login is required for the NFVO\n\n\n\n\n\n\nlocal-ip\n\n\nThe ip of the machine on which the integration test is running\n\n\n\n\n\n\n\n\nAfter that you will also need a keypair for openstack. Create one and download the private key as a .pem file. \nRename it to integration-test.pem and provide it with the needed permissions by executing \nchmod 400 integration-test.pem\n.\nCreate the directory \n/etc/openbaton/integration-test\n on your machine and move the pem file into it. \nThe next step is to create a vim file. \nHere is an example where you just have to change some fields. \n\n\n{\n  \nname\n:\nvim-instance\n,\n  \nauthUrl\n:\nhttp://your-openstack-url\n,\n  \ntenant\n:\nthe tenant you use\n,\n  \nusername\n:\nopenstack username\n,\n  \npassword\n:\nopenstack password\n,\n  \nkeyPair\n:\nin here the one you created\n,\n  \nsecurityGroups\n: [\n    \ndefault\n\n  ],\n  \ntype\n:\nopenstack\n,\n  \nlocation\n:{\n    \nname\n:\nyour location\n,\n    \nlatitude\n:\nthe latitude\n,\n    \nlongitude\n:\nthe longitude\n\n  }\n}\n\n\n\n\nName the vim file \nreal-vim.json\n and add it to the folder \nintegration-tests/src/main/resources/etc/json_file/vim_instances/\n in the project.\nIn the folder \nintegration-tests/src/main/resources/etc/json_file/network_service_descriptors\n of the project you will find a file named NetworkServiceDescriptor-iperf-real.json. \nOpen it and replace the floating ip values at lines 42, 107 and 114 with floating ips which are provided to you by openstack. \nIf you want to you can also change the virtual link which is at the moment \"private\" to one you want to use. \nMake sure that you have the image ubuntu-14.04-server-cloudimg-amd64-disk1 available on openstack. \nThen use a shell to navigate into the project's root directory. \nExecute the command \n./gradlew clean build\n.\nAfter that you will find the folder \nbuild/libs/\n in the project. Inside of this folder is the project's executable jar file. \n\n\nStart the integration test\n\n\nBefore starting the integration test be sure that the NFVO, Generic VNFM and Dummy VNFM you want to use are already running. \nThen start the test by navigating into the folder \nintegration-tests/build/libs\n and execute the command \njava -jar integration-tests-0.15-SNAPSHOT.jar\n.\n\n\nTest results\n\n\nWhile the tests are running they will produce output to the console. This output will be logged in the file integration-test.log which is in the project's root directory. \nIf a test finished it will either tell you that it passed successfully or not. \nIf it did not pass correctly you will find the reason in the log file. \n\n\nWrite your own integration tests\n\n\nPlease refer to \nthis page\n.\n\n\n\n\n\n\n\n\n\n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Integration Tests"
        }, 
        {
            "location": "/integration-test-use/#how-to-use-the-integration-tests", 
            "text": "", 
            "title": "How to use the Integration Tests"
        }, 
        {
            "location": "/integration-test-use/#overview", 
            "text": "This project provides integration tests. \nThree tests are run.   scenario-dummy-iperf  scenario-many-dependencies  scenario-real-iperf   scenario-dummy-iperf uses the Dummy VNFM to simulate a VNFM and therefore tests the communication between NFVO and VNFM. \nIt does not actually deploy a network service. The fake network service is a simple iperf scenario with one server and one client.   scenario-many-dependencies also uses the Dummy VNFM but its fake network service is a little bit more complex in the sense that it has many  VNFD  with many dependencies between them.   The last test scenario-real-iperf is the only one which actually deploys a network service on openstack. \nIt consists of two  VNFD  and deploys one iperf server and two iperf clients. The clients contact the server.   In every test a vim instance and a network service descriptor is stored on the orchestrator and the network service launched. \nIf that is successful, the network service is stoped and the network service record, network service descriptor and the vim instance are removed. \nIn the case of the scenario-real-iperf test also the service itself is tested, i.e. if iperf is running and the clients can connect to the server.", 
            "title": "Overview"
        }, 
        {
            "location": "/integration-test-use/#requirements", 
            "text": "A running  NFVO  A running  Generic VNFM  A running  Dummy VNFM", 
            "title": "Requirements"
        }, 
        {
            "location": "/integration-test-use/#installation-and-configuration", 
            "text": "Clone the project to your machine. \nIn  integration-tests/src/main/resources  is a file named integration-test.properties. \nOpen it and set the property values according to your needs.      Field  Value      nfvo-ip  The ip of the machine on which the NFVO you want to use is running    nfvo-port  The port on which the NFVO is running    nfvo-usr  The username if a login is required for the NFVO    nfvo-pwd  The password if a login is required for the NFVO    local-ip  The ip of the machine on which the integration test is running     After that you will also need a keypair for openstack. Create one and download the private key as a .pem file. \nRename it to integration-test.pem and provide it with the needed permissions by executing  chmod 400 integration-test.pem .\nCreate the directory  /etc/openbaton/integration-test  on your machine and move the pem file into it. \nThe next step is to create a vim file. \nHere is an example where you just have to change some fields.   {\n   name : vim-instance ,\n   authUrl : http://your-openstack-url ,\n   tenant : the tenant you use ,\n   username : openstack username ,\n   password : openstack password ,\n   keyPair : in here the one you created ,\n   securityGroups : [\n     default \n  ],\n   type : openstack ,\n   location :{\n     name : your location ,\n     latitude : the latitude ,\n     longitude : the longitude \n  }\n}  Name the vim file  real-vim.json  and add it to the folder  integration-tests/src/main/resources/etc/json_file/vim_instances/  in the project.\nIn the folder  integration-tests/src/main/resources/etc/json_file/network_service_descriptors  of the project you will find a file named NetworkServiceDescriptor-iperf-real.json. \nOpen it and replace the floating ip values at lines 42, 107 and 114 with floating ips which are provided to you by openstack. \nIf you want to you can also change the virtual link which is at the moment \"private\" to one you want to use. \nMake sure that you have the image ubuntu-14.04-server-cloudimg-amd64-disk1 available on openstack. \nThen use a shell to navigate into the project's root directory. \nExecute the command  ./gradlew clean build .\nAfter that you will find the folder  build/libs/  in the project. Inside of this folder is the project's executable jar file.", 
            "title": "Installation and configuration"
        }, 
        {
            "location": "/integration-test-use/#start-the-integration-test", 
            "text": "Before starting the integration test be sure that the NFVO, Generic VNFM and Dummy VNFM you want to use are already running. \nThen start the test by navigating into the folder  integration-tests/build/libs  and execute the command  java -jar integration-tests-0.15-SNAPSHOT.jar .", 
            "title": "Start the integration test"
        }, 
        {
            "location": "/integration-test-use/#test-results", 
            "text": "While the tests are running they will produce output to the console. This output will be logged in the file integration-test.log which is in the project's root directory. \nIf a test finished it will either tell you that it passed successfully or not. \nIf it did not pass correctly you will find the reason in the log file.", 
            "title": "Test results"
        }, 
        {
            "location": "/integration-test-use/#write-your-own-integration-tests", 
            "text": "Please refer to  this page .    \n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Write your own integration tests"
        }, 
        {
            "location": "/use-case-example/", 
            "text": "Use case example: Iperf client - server\n\n\n\n\nIn this page there is a full use case example explaining how the deployment process works, step-by-step. We assume that the NFVO and the Generic VNFM are ready to receive invocations.\n\n\nThe following pictures shows what is going to be deployed, an \nIperf\n client and an Iperf server.\n\n\n\n\nAs shown in the picture, the iperf server is the source of the dependency and the client is the target. In this case the client needs the IP of the server. The semantics of the vnf dependency is: the source provides some parameters to the target.\n\n\nBefore starting we need to send the VimInstance to the NFVO and the Network Service Descriptor. For doing this please have a look into the \nVim instance documentation\n, \nVNF Package documentation\n and \nNetwork Service Descriptor documentation\n. In fact, for creating a Network Service Record, we need to have a Network Service Descriptor loaded into the catalogue with two Virtual Network Functions (iperf client and server) created from a VNF Package. A Virtual Network Function Descriptor Json-File for Iperf client looks like this:\n\n\n{\n    \nvendor\n:\nfokus\n,\n    \nversion\n:\n0.1\n,\n    \nname\n:\niperf-client\n,\n    \ntype\n:\nclient\n,\n    \nendpoint\n:\ngeneric\n,\n    \nvdu\n:[\n        {\n            \nvm_image\n:[\n                \nubuntu-14.04-server-cloudimg-amd64-disk1\n\n            ],\n            \ncomputation_requirement\n:\n,\n            \nvirtual_memory_resource_element\n:\n1024\n,\n            \nvirtual_network_bandwidth_resource\n:\n1000000\n,\n            \nlifecycle_event\n:[\n\n            ],\n            \nvimInstanceName\n:\nvim-instance\n,\n            \nvdu_constraint\n:\n,\n            \nhigh_availability\n:\nACTIVE_PASSIVE\n,\n            \nscale_in_out\n:2,\n            \nvnfc\n:[\n                {\n                    \nconnection_point\n:[\n                        {\n                            \nvirtual_link_reference\n:\nprivate\n\n                        }\n                    ]\n                }\n            ],\n            \nmonitoring_parameter\n:[\n                \ncpu_utilization\n\n            ]\n        }\n    ],\n    \nvirtual_link\n:[\n        {\n            \nname\n:\nprivate\n\n        }\n    ],\n    \nconnection_point\n:[\n\n    ],\n    \nlifecycle_event\n:[\n        {\n            \nevent\n:\nINSTANTIATE\n,\n            \nlifecycle_events\n:[\n                \ninstall.sh\n\n            ]\n        },\n        {\n            \nevent\n:\nCONFIGURE\n,\n            \nlifecycle_events\n:[\n                \nserver_configure.sh\n\n            ]\n        }\n    ],\n    \nvdu_dependency\n:[\n\n    ],\n    \nmonitoring_parameter\n:[\n        \ncpu_utilization\n\n    ],\n    \ndeployment_flavour\n:[\n        {\n            \ndf_constraint\n:[\n                \nconstraint1\n,\n                \nconstraint2\n\n            ],\n            \ncostituent_vdu\n:[\n\n            ],\n            \nflavour_key\n:\nm1.small\n\n        }\n    ],\n    \nmanifest_file\n:\n\n}\n\n\n\n\nThis is a perfect example of a dependency. The VNFManager Generic, after creation of the client VNF described, will run the \ninstall.sh\n script during the instantiate method. The install.sh script is:\n\n\n#!/bin/bash\n\nsudo apt-get update \n sudo apt-get install -y iperf screen\n\n\n\n\nAs said before in the documentation \nVNFManager Generic\n, \nthe scripts in the CONFIGURE lifecycle event need to start with the type of the source VNF followed by _ and the name of the script\n, so the `server_configure.sh is:\n\n\n#!/bin/bash\n\nscreen -d -m -S client iperf -c $server_private1 -t 300\n\n\n\n\nThese scripts shown above, are contained in the VNF Package or in a git repository accessible from the VM. Be aware that all the scripts will be executed with root permissions. Once all these steps are done we are ready to create a Network Service Record from the id of the Network Service Descriptor. \n\n\nLet's again have a look at the sequence diagram of a create Network Service Record operation.\n\n\n\n\nWhen the Network Service Record create is called with the Iperf Network Service Descriptor's id, the steps defined in the sequence diagram above happen.\n\n\nINSTANTIATE Method\n\n\nThe first message sent to the Generic VNFM is the INSTANTIATE message \n(1)\n. This message contains the VNF Descriptor and some other parameters needed to create the VNF Record, for instance the list of Virtual Link Records. The Generic VNFM  is called and then the create Virtual Network Function Record and the Virtual Network Function Record is created \n(2)\n and sent back to the NFVO into a GrantOperation message \n(3)\n. This message will trigger the NFVO to check if there are enough resources to create that VNF Record. If so, then a GrantOperation message with the updated VNF Record is sent back to the Generic VNFManager. Then the Generic VNFManager creates an AllocateResources message with the received VNF Record and sends it to the NFVO \n(4)\n. The NFVO after creating the Resources (VMs) sends back the AllocateResources message to the VNFManager. Here the instantiate method is called \n(5)\n. Inside this method, the scripts (or the link to the git repository containing the scripts) contained in the VNF Package is sent to the EMS, the scripts are saved locally to the VM and then the Generic VNFManager will call the execution of each script defined in the VNF Descriptor \n(6)\n. Once all of the scripts are executed and there wasn't any error, the VNFManager sends the Instantiate message back to the NFVO \n(7)\n. \n\n\nMODIFY Method\n\n\nIf the VNF is target for some dependencies, like the iperf client, the MODIFY message is sent to the VNFManager by the NFVO \n(8)\n. Then the VNFManager executes the scripts contained in the CONFIGURE lifecycle event defined in the VNF Descriptor \n(9)\n, and sends back the modify message to the NFVO \n(10)\n, if no errors occurred. In this case, the scripts environment will contain the variables defined in the related VNF dependency.\n\n\nSTART Method\n\n\nHere exactly as before, the NFVO sends the START message to the Generic VNFManager \n(11)\n, and the VNFManager calls the EMS for execution of the scripts defined in the START lifecycle (none for this example) \n(12)\n. And the start message is then sent back to the NFVO meaning that no errors occurred \n(13)\n.\n\n\nConclusions\n\n\nWhen all the VNF Records are done with all of the scripts defined in the lifecycle events, the NFVO will put the state of the VNF Record to ACTIVE and when all the VNF Records are in state ACTIVE, also the Network Service Record will be in state ACTIVE. This means that the service was correctly run. For knowing more about the states of a VNF Record please refer to \nVNF Record state documentation\n\n\n\n\n\n\n\n\n\n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "A full example"
        }, 
        {
            "location": "/use-case-example/#use-case-example-iperf-client-server", 
            "text": "In this page there is a full use case example explaining how the deployment process works, step-by-step. We assume that the NFVO and the Generic VNFM are ready to receive invocations.  The following pictures shows what is going to be deployed, an  Iperf  client and an Iperf server.   As shown in the picture, the iperf server is the source of the dependency and the client is the target. In this case the client needs the IP of the server. The semantics of the vnf dependency is: the source provides some parameters to the target.  Before starting we need to send the VimInstance to the NFVO and the Network Service Descriptor. For doing this please have a look into the  Vim instance documentation ,  VNF Package documentation  and  Network Service Descriptor documentation . In fact, for creating a Network Service Record, we need to have a Network Service Descriptor loaded into the catalogue with two Virtual Network Functions (iperf client and server) created from a VNF Package. A Virtual Network Function Descriptor Json-File for Iperf client looks like this:  {\n     vendor : fokus ,\n     version : 0.1 ,\n     name : iperf-client ,\n     type : client ,\n     endpoint : generic ,\n     vdu :[\n        {\n             vm_image :[\n                 ubuntu-14.04-server-cloudimg-amd64-disk1 \n            ],\n             computation_requirement : ,\n             virtual_memory_resource_element : 1024 ,\n             virtual_network_bandwidth_resource : 1000000 ,\n             lifecycle_event :[\n\n            ],\n             vimInstanceName : vim-instance ,\n             vdu_constraint : ,\n             high_availability : ACTIVE_PASSIVE ,\n             scale_in_out :2,\n             vnfc :[\n                {\n                     connection_point :[\n                        {\n                             virtual_link_reference : private \n                        }\n                    ]\n                }\n            ],\n             monitoring_parameter :[\n                 cpu_utilization \n            ]\n        }\n    ],\n     virtual_link :[\n        {\n             name : private \n        }\n    ],\n     connection_point :[\n\n    ],\n     lifecycle_event :[\n        {\n             event : INSTANTIATE ,\n             lifecycle_events :[\n                 install.sh \n            ]\n        },\n        {\n             event : CONFIGURE ,\n             lifecycle_events :[\n                 server_configure.sh \n            ]\n        }\n    ],\n     vdu_dependency :[\n\n    ],\n     monitoring_parameter :[\n         cpu_utilization \n    ],\n     deployment_flavour :[\n        {\n             df_constraint :[\n                 constraint1 ,\n                 constraint2 \n            ],\n             costituent_vdu :[\n\n            ],\n             flavour_key : m1.small \n        }\n    ],\n     manifest_file : \n}  This is a perfect example of a dependency. The VNFManager Generic, after creation of the client VNF described, will run the  install.sh  script during the instantiate method. The install.sh script is:  #!/bin/bash\n\nsudo apt-get update   sudo apt-get install -y iperf screen  As said before in the documentation  VNFManager Generic ,  the scripts in the CONFIGURE lifecycle event need to start with the type of the source VNF followed by _ and the name of the script , so the `server_configure.sh is:  #!/bin/bash\n\nscreen -d -m -S client iperf -c $server_private1 -t 300  These scripts shown above, are contained in the VNF Package or in a git repository accessible from the VM. Be aware that all the scripts will be executed with root permissions. Once all these steps are done we are ready to create a Network Service Record from the id of the Network Service Descriptor.   Let's again have a look at the sequence diagram of a create Network Service Record operation.   When the Network Service Record create is called with the Iperf Network Service Descriptor's id, the steps defined in the sequence diagram above happen.  INSTANTIATE Method  The first message sent to the Generic VNFM is the INSTANTIATE message  (1) . This message contains the VNF Descriptor and some other parameters needed to create the VNF Record, for instance the list of Virtual Link Records. The Generic VNFM  is called and then the create Virtual Network Function Record and the Virtual Network Function Record is created  (2)  and sent back to the NFVO into a GrantOperation message  (3) . This message will trigger the NFVO to check if there are enough resources to create that VNF Record. If so, then a GrantOperation message with the updated VNF Record is sent back to the Generic VNFManager. Then the Generic VNFManager creates an AllocateResources message with the received VNF Record and sends it to the NFVO  (4) . The NFVO after creating the Resources (VMs) sends back the AllocateResources message to the VNFManager. Here the instantiate method is called  (5) . Inside this method, the scripts (or the link to the git repository containing the scripts) contained in the VNF Package is sent to the EMS, the scripts are saved locally to the VM and then the Generic VNFManager will call the execution of each script defined in the VNF Descriptor  (6) . Once all of the scripts are executed and there wasn't any error, the VNFManager sends the Instantiate message back to the NFVO  (7) .   MODIFY Method  If the VNF is target for some dependencies, like the iperf client, the MODIFY message is sent to the VNFManager by the NFVO  (8) . Then the VNFManager executes the scripts contained in the CONFIGURE lifecycle event defined in the VNF Descriptor  (9) , and sends back the modify message to the NFVO  (10) , if no errors occurred. In this case, the scripts environment will contain the variables defined in the related VNF dependency.  START Method  Here exactly as before, the NFVO sends the START message to the Generic VNFManager  (11) , and the VNFManager calls the EMS for execution of the scripts defined in the START lifecycle (none for this example)  (12) . And the start message is then sent back to the NFVO meaning that no errors occurred  (13) .", 
            "title": "Use case example: Iperf client - server"
        }, 
        {
            "location": "/use-case-example/#conclusions", 
            "text": "When all the VNF Records are done with all of the scripts defined in the lifecycle events, the NFVO will put the state of the VNF Record to ACTIVE and when all the VNF Records are in state ACTIVE, also the Network Service Record will be in state ACTIVE. This means that the service was correctly run. For knowing more about the states of a VNF Record please refer to  VNF Record state documentation    \n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Conclusions"
        }, 
        {
            "location": "/extend/", 
            "text": "Extend OpenBaton\n\n\nBeing an open source implementation, OpenBaton can be easily extended for supporting additional features or capabilities.\n\n\nExtend the NFVO\n\n\nThe NFVO has been implemented as a java modular application using the Spring.io framework. It is pretty easy to add a new module for extending the supported features. Please refer to the \nNFVO documentation\n for learning a bit more about the NFVO architecture.\n\n\nIt is possible to extend the NFVO by implementing new plugins. The options available is to implement a new Monitoring plugin or a new VIM plugin. The procedure is the same so we will explain how to write a VIM plugin, please see the \nplugin sdk documentation page\n\n\nBefore doing that you can have a look inside the architecture of the NFVO in the \nfollowing page\n\n\n\n\n\n\n\n\n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Extend it"
        }, 
        {
            "location": "/extend/#extend-openbaton", 
            "text": "Being an open source implementation, OpenBaton can be easily extended for supporting additional features or capabilities.  Extend the NFVO  The NFVO has been implemented as a java modular application using the Spring.io framework. It is pretty easy to add a new module for extending the supported features. Please refer to the  NFVO documentation  for learning a bit more about the NFVO architecture.  It is possible to extend the NFVO by implementing new plugins. The options available is to implement a new Monitoring plugin or a new VIM plugin. The procedure is the same so we will explain how to write a VIM plugin, please see the  plugin sdk documentation page  Before doing that you can have a look inside the architecture of the NFVO in the  following page    \n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Extend OpenBaton"
        }, 
        {
            "location": "/nfvo-architecture/", 
            "text": "NFVO Architecture\n\n\nNFVO\n is a modular software composed by the modules illustrated in the following picture:\n\n\n\n\nAPI\n\n\nThis module contains the necessary classes exposing APIs as ReST server. The most importat ones are the classes managing VimInstances, NetworkServiceDescriptors and NetworkServiceRecords. For more details please see \nthe api documentation\n\n\nMAIN\n\n\nThis module contains the classes in charge of the startup of the whole system and gathering configuratons for instance.\n\n\nCOMMON\n\n\nThis module contains the classes that are common to the NFVO\n\n\nCLI\n\n\nThis module contains the NFVO console.\n\n\nDASHBOARD\n\n\nThis module contains the web dashboard available at localhost:8080\n\n\nCORE-INT\n\n\nThis module contains the interfaces of the core functionalities regarding only the internal NFVO interfaces. Most of them are definend in \nETSI MANO specification\n in NFV-MANO interfaces section.\n\n\nCORE-IMPL\n\n\nThis module contains the beans implementing the core-int interfaces.\n\n\nVNFM-INT\n\n\nThis module contains the interfaces of the core functionalities regarding only the NFVO interfaces to the VnfManagers. Most of them are definend in \nETSI MANO specification\n in NFV-MANO interfaces section.\n\n\nVNFM-IMPL\n\n\nThis module contains the beans implementing the vnfm-int interfaces.\n\n\nREPOSITORY\n\n\nThis module contains specific repositories interfacing the database in a generic way.\n\n\nCATALOGUE\n\n\nThis module contains the complete model of NFVO that is sharde in the openbaton libraries.\n\n\nVIM-INT\n\n\nThis module contains the interfaces of the core functionalities regarding only the NFVO interfaces to the VIM. Most of them are definend in \nETSI MANO specification\n in NFV-MANO interfaces section.\n\n\nVIM-IMPL\n\n\nThis module contains the beans implementing the vim-int interfaces.\n\n\nPLUGIN\n\n\nThis module contains the utility classes used to interface to the openbaton plugins.\n\n\nVIM-DRIVERS\n\n\nThis module contains the interface for the VIM openbaton plugins.\n\n\nEXCEPTION\n\n\nThis module contains all the exception classes common to every project containing openbaton libraries.\n\n\nMONITORING\n\n\nThis module contains the interface for the monitoring of the openbaton plugins.\n\n\n\n\n\n\n\n\n\n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "NFVO Architecture"
        }, 
        {
            "location": "/nfvo-architecture/#nfvo-architecture", 
            "text": "NFVO  is a modular software composed by the modules illustrated in the following picture:   API  This module contains the necessary classes exposing APIs as ReST server. The most importat ones are the classes managing VimInstances, NetworkServiceDescriptors and NetworkServiceRecords. For more details please see  the api documentation  MAIN  This module contains the classes in charge of the startup of the whole system and gathering configuratons for instance.  COMMON  This module contains the classes that are common to the NFVO  CLI  This module contains the NFVO console.  DASHBOARD  This module contains the web dashboard available at localhost:8080  CORE-INT  This module contains the interfaces of the core functionalities regarding only the internal NFVO interfaces. Most of them are definend in  ETSI MANO specification  in NFV-MANO interfaces section.  CORE-IMPL  This module contains the beans implementing the core-int interfaces.  VNFM-INT  This module contains the interfaces of the core functionalities regarding only the NFVO interfaces to the VnfManagers. Most of them are definend in  ETSI MANO specification  in NFV-MANO interfaces section.  VNFM-IMPL  This module contains the beans implementing the vnfm-int interfaces.  REPOSITORY  This module contains specific repositories interfacing the database in a generic way.  CATALOGUE  This module contains the complete model of NFVO that is sharde in the openbaton libraries.  VIM-INT  This module contains the interfaces of the core functionalities regarding only the NFVO interfaces to the VIM. Most of them are definend in  ETSI MANO specification  in NFV-MANO interfaces section.  VIM-IMPL  This module contains the beans implementing the vim-int interfaces.  PLUGIN  This module contains the utility classes used to interface to the openbaton plugins.  VIM-DRIVERS  This module contains the interface for the VIM openbaton plugins.  EXCEPTION  This module contains all the exception classes common to every project containing openbaton libraries.  MONITORING  This module contains the interface for the monitoring of the openbaton plugins.    \n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "NFVO Architecture"
        }, 
        {
            "location": "/vim-plugin/", 
            "text": "Create Vim Plugin\n\n\nOpenBaton is an open source project providing a reference implementation of the NFVO and VNFM based on the ETSI specification, it is implemented in java using the spring.io framework. It consists of two main components: a NFVO and a generic VNFM. This project plugin-sdk contains modules that are needed to implement a plugin for OpenBaton system.\n\n\nHow does this works?\n\n\nAn OpenBaton Plugin is a \nRMI\n Server that connects to the NFVO or any other rmiregistry with access to the OpenBaton catalogue as codebase. It offers an implementation of an interface that is used by the NFVO. By default the NFVO starts a rmiregistry at localhost:1099.\n\n\nRequirements\n\n\nBefore you can start with developing your own Vim Plugin you need to prepare your programming environment by installing/configuring the following requirements:\n\n\n\n\nJDK 7 (\ninstallation\n)\n\n\nGradle (\ninstallation\n)\n\n\n\n\nCreate a new project\n\n\nOnce you have started the IDE, click on File -\n New -\n Project...\n\n\nIn this dialog click on Gradle on the left and select java in the main properties window in the middle.\n\n\n\n\nThen click on next to go to the next window.\n\n\nIn the next dialog you need to define the GroupId, ArtifactId and the Version.\nMore information on the specific meaning can be found \nhere\n.\n\n\n\n\nContinue with the next dialog.\n\n\nIn this dialog you need to specify which gradle you want to use.\nIt is recommend to use the default gradle wrapper.\nAdditionally you can enable the auto-import.\n\n\n\n\nContinue with the next dialog by clicking on Next.\n\n\nIn the last dialog, you need to define the project name and the project location.\n\n\n\n\nOnce this is done you can click on Finish and continue with creating the Main Class.\n\n\nCreate the Main Class\n\n\nAfterwards, you need to create the Main Class of the VIM plugin which will be started in the end.\nFor doing so, right click on the root folder my-vim, then click on New -\n Directory and insert what is show below.\n\n\n\n\nClick on OK to continue.\n\n\nAdditionally you need to create a new package.\nThis is done by a right-click on the previously created directory java.\nClick on New -\n Package.\nHere you can define the package name.\n\n\n\n\nFinally you can create your MyVim Class by clicking (right click) on the previously created package and click on New -\n Java Class.\n\n\n\n\nOnce you did all these steps, the initial project structure is created.\nWhat we miss right now is the configuration of the gradle files to define and fetch dependencies we need for implementing the Vim plugin.\nThis is described in later sections.\n\n\nIn order to create a VIM plugin for OpenBaton system you need to add to your \nbuild.gradle\n file:\n\n\n\ngroup 'org.myplugin.example'\nversion '1.0-SNAPSHOT'\n\nbuildscript {\n    repositories {\n        mavenLocal()\n        mavenCentral()\n    }\n    dependencies {\n        classpath(\norg.springframework.boot:spring-boot-gradle-plugin:1.2.6.RELEASE\n)\n    }\n}\n\nrepositories {\n    maven { url \nhttp://get.openbaton.org:8081/nexus/content/groups/public/\n }\n}\n\napply plugin: 'java'\napply plugin: 'maven'\napply plugin: 'spring-boot'\n\n\nmainClassName = 'org.myplugin.example.Starter'\n\n\ndependencies {\n    compile 'org.openbaton:plugin-sdk:0.15'\n    compile'org.springframework:spring-context:4.2.1.RELEASE'\n}\n\n\n\n\n\nWrite your Vim plugin\n\n\nThe Vim plugin is splitted into two classes \n\n\n\n\nImplementation of \nVimDriver\n\n\nThe \nStarter Class\n that contain the main function for bootstrapping the Vim plugin\n\n\n\n\nType of Vim Instance\n\n\nOpenBaton expects only these three \ntype\n of Vim Instance:\n\n\n\n\nTest\n\n\nOpenStack\n\n\nAmazon\n\n\n\n\nNOTE:\n Your Vim plugin implementation \ntype\n should be one of these to be launched and used by OpenBaton\n\n\n1. Implement VimDriver\n\n\nThe \nVimDriver\n is an bastract class that contains tha basic functionality that a Vim Instance should be provide, and extends the \nRemote Class\n. \n\n\nNOTE\n: If you want to implement a Monitoring plugin, then you need to implement the Interface \nResourcePerformanceManagement\n\n\nYour \nMyVim\n class will implement the methods inherited from \nVimDriver\n that manages your Vim Instance:\n\n\n\n\n\n\n\n\nFunction\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nList\\\nNFVImage> listImages\n\n\nReturns the list of Images\n\n\n\n\n\n\nList\\\nServer> listServer\n\n\nReturns the list of Servers\n\n\n\n\n\n\nList\\\nNetwork> listNetworks\n\n\nReturns the list of Network\n\n\n\n\n\n\nList\\\nDeploymentFlavour> listFlavors\n\n\nReturns the list of DeploymentFlavour\n\n\n\n\n\n\nServer launchInstanceAndWait\n\n\nCreates a new Server\n\n\n\n\n\n\nvoid deleteServerByIdAndWait\n\n\nRemoves the Server with id\n\n\n\n\n\n\nNetwork createNetwork\n\n\nCreates a new Network\n\n\n\n\n\n\nNetwork getNetworkById\n\n\nReturns the Network with id\n\n\n\n\n\n\nNetwork updateNetwork\n\n\nUpdates a new Network\n\n\n\n\n\n\nboolean deleteNetwork\n\n\nDeletes the Network\n\n\n\n\n\n\nSubnet createSubnet\n\n\nCreates a new Subnet\n\n\n\n\n\n\nSubnet updateSubnet\n\n\nUpdates the Subnet\n\n\n\n\n\n\nboolean deleteSubnet\n\n\nDeletes the Subnet\n\n\n\n\n\n\nList\\\nString> getSubnetsExtIds\n\n\nReturns the list of SubnetsExtId\n\n\n\n\n\n\nDeploymentFlavour addFlavor\n\n\nAdds a new DeploymentFlavour\n\n\n\n\n\n\nDeploymentFlavour updateFlavor\n\n\nUpdates the DeploymentFlavour\n\n\n\n\n\n\nboolean deleteFlavor\n\n\nDeletes the DeploymentFlavour\n\n\n\n\n\n\nNFVImage addImage\n\n\nAdds a new NFVImage\n\n\n\n\n\n\nNFVImage updateImage\n\n\nUpdates the NFVImage\n\n\n\n\n\n\nNFVImage copyImage\n\n\nCopies the NFVImage\n\n\n\n\n\n\nboolean deleteImage\n\n\nDeletes the NFVImage\n\n\n\n\n\n\nQuota getQuota\n\n\nReturns the Quota\n\n\n\n\n\n\nString getType\n\n\nReturns the type\n\n\n\n\n\n\n\n\nAn example of the class:\n\n\npackage org.myplugin.example;\n\nimport org.openbaton.catalogue.mano.common.DeploymentFlavour;\nimport org.openbaton.catalogue.nfvo.*;\nimport org.openbaton.vim.drivers.exceptions.VimDriverException;\nimport org.openbaton.vim.drivers.interfaces.VimDriver;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.context.annotation.Scope;\nimport org.springframework.stereotype.Service;\n\nimport java.rmi.RemoteException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Set;\n\n@Service\n@Scope(\nprototype\n)\npublic class MyVim implements VimDriver{\n\n\n    private Logger log = LoggerFactory.getLogger(this.getClass());\n\n    @Override\n    public Server launchInstance(VimInstance vimInstance, String name, String image, String flavor, String keypair, Set\nString\n network, Set\nString\n secGroup, String userData) throws RemoteException {\n        // ...\n    }\n\n    @Override\n    public String getType(VimInstance vimInstance) {\n        // ...\n    }\n\n    @Override\n    public List\nNFVImage\n listImages(VimInstance vimInstance) {\n        // ...\n    }\n\n\n    // ...\n}\n\n\n\n\n2. Starter Class\n\n\nCreate another class and set the path to it in a variable \nmainClassName\n in \nbuild.gradle\n.\nThe starter class should be like the following:\n\n\npackage org.myplugin.example;\n\nimport org.openbaton.plugin.PluginStarter;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class Starter {\n\n    private static Logger log = LoggerFactory.getLogger(Starter.class);\n\n    public static void main(String[] args) {\n        log.info(\nparams are: pluginName registryIp registryPort\\ndefault is test localhost 1099\n);\n\n        if (args.length \n 1)\n            PluginStarter.run(MyVim.class, args[0], args[1], Integer.parseInt(args[2]));\n        else\n            PluginStarter.run(MyVim.class, \ntest\n, \nlocalhost\n, 1099);\n    }\n}\n\n\n\n\nRun your Vim plugin in OpenBaton environment\n\n\nUnder the folder of your project \nsrc/main/resources\n you should create a file \nplugin.conf.properties\n and write the variable \ntype = \nthe-vim-type\n.\nThe structure of your project should be like:\n\n\n\n\nNow you can run \n./gradlew build\n and Gradle will create the jar that you can find in the folder \nbuild/libs/myPlugin-1.0-SNAPSHOT.jar\n.\n\n\nOnce all these steps are done, you can copy and paste the \nmyPlugin-1.0-SNAPSHOT.jar\n under the folder specified in the \nopenbaton.properties\n (under \n/etc/openbaton\n folder) \nplugin-installation-dir\n property, as default NFVO/plugins.\n\n\nCongratulations you have your version of the interface for your Vim Instance that will be used by NFVO\n\n\nUse my plugin\n\n\nOnce you copied the jar file into the right folder, you need to (re)start the NFVO. The plugin will automatically register and you can see that there will be a log file in the NFVO folder called \nplugin-myPlugin.log\n containing the logs of the plugin. The myPlugin now acts as a normal plugin so for using it check out the \nVim instance documentation\n in order to point out to the new plugin.\n\n\nNOTE\n: Since you are using an implementation of \nRMI\n you can also launch your plugin from your command line just typing\n\n\n$ java -jar myPlugin-1.0-SNAPSHOT.jar [the-vim-type] [ip_NFVO] 1099\n\n\n\n\n\n\n\n\n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Write your own Plugin"
        }, 
        {
            "location": "/vim-plugin/#create-vim-plugin", 
            "text": "OpenBaton is an open source project providing a reference implementation of the NFVO and VNFM based on the ETSI specification, it is implemented in java using the spring.io framework. It consists of two main components: a NFVO and a generic VNFM. This project plugin-sdk contains modules that are needed to implement a plugin for OpenBaton system.", 
            "title": "Create Vim Plugin"
        }, 
        {
            "location": "/vim-plugin/#how-does-this-works", 
            "text": "An OpenBaton Plugin is a  RMI  Server that connects to the NFVO or any other rmiregistry with access to the OpenBaton catalogue as codebase. It offers an implementation of an interface that is used by the NFVO. By default the NFVO starts a rmiregistry at localhost:1099.", 
            "title": "How does this works?"
        }, 
        {
            "location": "/vim-plugin/#requirements", 
            "text": "Before you can start with developing your own Vim Plugin you need to prepare your programming environment by installing/configuring the following requirements:   JDK 7 ( installation )  Gradle ( installation )   Create a new project  Once you have started the IDE, click on File -  New -  Project...  In this dialog click on Gradle on the left and select java in the main properties window in the middle.   Then click on next to go to the next window.  In the next dialog you need to define the GroupId, ArtifactId and the Version.\nMore information on the specific meaning can be found  here .   Continue with the next dialog.  In this dialog you need to specify which gradle you want to use.\nIt is recommend to use the default gradle wrapper.\nAdditionally you can enable the auto-import.   Continue with the next dialog by clicking on Next.  In the last dialog, you need to define the project name and the project location.   Once this is done you can click on Finish and continue with creating the Main Class.  Create the Main Class  Afterwards, you need to create the Main Class of the VIM plugin which will be started in the end.\nFor doing so, right click on the root folder my-vim, then click on New -  Directory and insert what is show below.   Click on OK to continue.  Additionally you need to create a new package.\nThis is done by a right-click on the previously created directory java.\nClick on New -  Package.\nHere you can define the package name.   Finally you can create your MyVim Class by clicking (right click) on the previously created package and click on New -  Java Class.   Once you did all these steps, the initial project structure is created.\nWhat we miss right now is the configuration of the gradle files to define and fetch dependencies we need for implementing the Vim plugin.\nThis is described in later sections.  In order to create a VIM plugin for OpenBaton system you need to add to your  build.gradle  file:  \ngroup 'org.myplugin.example'\nversion '1.0-SNAPSHOT'\n\nbuildscript {\n    repositories {\n        mavenLocal()\n        mavenCentral()\n    }\n    dependencies {\n        classpath( org.springframework.boot:spring-boot-gradle-plugin:1.2.6.RELEASE )\n    }\n}\n\nrepositories {\n    maven { url  http://get.openbaton.org:8081/nexus/content/groups/public/  }\n}\n\napply plugin: 'java'\napply plugin: 'maven'\napply plugin: 'spring-boot'\n\n\nmainClassName = 'org.myplugin.example.Starter'\n\n\ndependencies {\n    compile 'org.openbaton:plugin-sdk:0.15'\n    compile'org.springframework:spring-context:4.2.1.RELEASE'\n}", 
            "title": "Requirements"
        }, 
        {
            "location": "/vim-plugin/#write-your-vim-plugin", 
            "text": "The Vim plugin is splitted into two classes    Implementation of  VimDriver  The  Starter Class  that contain the main function for bootstrapping the Vim plugin   Type of Vim Instance  OpenBaton expects only these three  type  of Vim Instance:   Test  OpenStack  Amazon   NOTE:  Your Vim plugin implementation  type  should be one of these to be launched and used by OpenBaton  1. Implement VimDriver  The  VimDriver  is an bastract class that contains tha basic functionality that a Vim Instance should be provide, and extends the  Remote Class .   NOTE : If you want to implement a Monitoring plugin, then you need to implement the Interface  ResourcePerformanceManagement  Your  MyVim  class will implement the methods inherited from  VimDriver  that manages your Vim Instance:     Function  Description      List\\ NFVImage> listImages  Returns the list of Images    List\\ Server> listServer  Returns the list of Servers    List\\ Network> listNetworks  Returns the list of Network    List\\ DeploymentFlavour> listFlavors  Returns the list of DeploymentFlavour    Server launchInstanceAndWait  Creates a new Server    void deleteServerByIdAndWait  Removes the Server with id    Network createNetwork  Creates a new Network    Network getNetworkById  Returns the Network with id    Network updateNetwork  Updates a new Network    boolean deleteNetwork  Deletes the Network    Subnet createSubnet  Creates a new Subnet    Subnet updateSubnet  Updates the Subnet    boolean deleteSubnet  Deletes the Subnet    List\\ String> getSubnetsExtIds  Returns the list of SubnetsExtId    DeploymentFlavour addFlavor  Adds a new DeploymentFlavour    DeploymentFlavour updateFlavor  Updates the DeploymentFlavour    boolean deleteFlavor  Deletes the DeploymentFlavour    NFVImage addImage  Adds a new NFVImage    NFVImage updateImage  Updates the NFVImage    NFVImage copyImage  Copies the NFVImage    boolean deleteImage  Deletes the NFVImage    Quota getQuota  Returns the Quota    String getType  Returns the type     An example of the class:  package org.myplugin.example;\n\nimport org.openbaton.catalogue.mano.common.DeploymentFlavour;\nimport org.openbaton.catalogue.nfvo.*;\nimport org.openbaton.vim.drivers.exceptions.VimDriverException;\nimport org.openbaton.vim.drivers.interfaces.VimDriver;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.context.annotation.Scope;\nimport org.springframework.stereotype.Service;\n\nimport java.rmi.RemoteException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Set;\n\n@Service\n@Scope( prototype )\npublic class MyVim implements VimDriver{\n\n\n    private Logger log = LoggerFactory.getLogger(this.getClass());\n\n    @Override\n    public Server launchInstance(VimInstance vimInstance, String name, String image, String flavor, String keypair, Set String  network, Set String  secGroup, String userData) throws RemoteException {\n        // ...\n    }\n\n    @Override\n    public String getType(VimInstance vimInstance) {\n        // ...\n    }\n\n    @Override\n    public List NFVImage  listImages(VimInstance vimInstance) {\n        // ...\n    }\n\n\n    // ...\n}  2. Starter Class  Create another class and set the path to it in a variable  mainClassName  in  build.gradle .\nThe starter class should be like the following:  package org.myplugin.example;\n\nimport org.openbaton.plugin.PluginStarter;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class Starter {\n\n    private static Logger log = LoggerFactory.getLogger(Starter.class);\n\n    public static void main(String[] args) {\n        log.info( params are: pluginName registryIp registryPort\\ndefault is test localhost 1099 );\n\n        if (args.length   1)\n            PluginStarter.run(MyVim.class, args[0], args[1], Integer.parseInt(args[2]));\n        else\n            PluginStarter.run(MyVim.class,  test ,  localhost , 1099);\n    }\n}", 
            "title": "Write your Vim plugin"
        }, 
        {
            "location": "/vim-plugin/#run-your-vim-plugin-in-openbaton-environment", 
            "text": "Under the folder of your project  src/main/resources  you should create a file  plugin.conf.properties  and write the variable  type =  the-vim-type .\nThe structure of your project should be like:   Now you can run  ./gradlew build  and Gradle will create the jar that you can find in the folder  build/libs/myPlugin-1.0-SNAPSHOT.jar .  Once all these steps are done, you can copy and paste the  myPlugin-1.0-SNAPSHOT.jar  under the folder specified in the  openbaton.properties  (under  /etc/openbaton  folder)  plugin-installation-dir  property, as default NFVO/plugins.  Congratulations you have your version of the interface for your Vim Instance that will be used by NFVO", 
            "title": "Run your Vim plugin in OpenBaton environment"
        }, 
        {
            "location": "/vim-plugin/#use-my-plugin", 
            "text": "Once you copied the jar file into the right folder, you need to (re)start the NFVO. The plugin will automatically register and you can see that there will be a log file in the NFVO folder called  plugin-myPlugin.log  containing the logs of the plugin. The myPlugin now acts as a normal plugin so for using it check out the  Vim instance documentation  in order to point out to the new plugin.  NOTE : Since you are using an implementation of  RMI  you can also launch your plugin from your command line just typing  $ java -jar myPlugin-1.0-SNAPSHOT.jar [the-vim-type] [ip_NFVO] 1099   \n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Use my plugin"
        }, 
        {
            "location": "/FAQ/", 
            "text": "Frequently Asked Questions (FAQ)\n\n\nQ1 What type of database is the NFVO using?\n\n\nThe NFVO uses Hibernate for managing transactions with a relational database. By default the NFVO is configured with an in memory database (HSQL). \nOther types of databases are supported, for instance MySQL. This can be changed directly from the configuration file, outcommenting the : \n\n\n# mysql jdbc\nspring.datasource.url=jdbc:mysql://localhost:3306/openbaton\nspring.datasource.driver-class-name=com.mysql.jdbc.Driver\nspring.jpa.database-platform=org.hibernate.dialect.MySQLDialect\n\n\n\n\n\n\n\n\n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "FAQ"
        }, 
        {
            "location": "/FAQ/#frequently-asked-questions-faq", 
            "text": "Q1 What type of database is the NFVO using?  The NFVO uses Hibernate for managing transactions with a relational database. By default the NFVO is configured with an in memory database (HSQL). \nOther types of databases are supported, for instance MySQL. This can be changed directly from the configuration file, outcommenting the :   # mysql jdbc\nspring.datasource.url=jdbc:mysql://localhost:3306/openbaton\nspring.datasource.driver-class-name=com.mysql.jdbc.Driver\nspring.jpa.database-platform=org.hibernate.dialect.MySQLDialect   \n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Frequently Asked Questions (FAQ)"
        }, 
        {
            "location": "/vnf-descriptor/", 
            "text": "Virtual Network Function Descriptor\n\n\nThe VirtualNetworkFunctionDescriptor is contained inside the Network Service Descriptor (NSD). It is a json file and is defined as follows:\n\n\n{  \n    \nvendor\n:\nfokus\n,\n    \nversion\n:\n0.2\n,\n    \nname\n:\niperf-server\n,\n    \ntype\n:\nserver\n,\n    \nendpoint\n:\ngeneric\n,\n    \nconfigurations\n:{\n        \nname\n:\nconfig_name\n,\n        \nconfigurationParameters\n:[\n        {\n            \nconfKey\n:\nkey\n,\n            \nvalue\n:\nvalue\n\n        }\n        ]\n    },\n    \nvdu\n:[  \n        {  \n            \nvm_image\n:[  \n                \nubuntu-14.04-server-cloudimg-amd64-disk1\n\n            ],\n            \nvimInstanceName\n:\nvim-instance\n,\n            \nscale_in_out\n:2,\n            \nvnfc\n:[  \n                {  \n                    \nconnection_point\n:[  \n                        {  \n                            \nfloatingIp\n:\nrandom\n,\n                            \nvirtual_link_reference\n:\nprivate\n\n                        }\n                    ]\n                }\n            ]\n        }\n    ],\n    \nvirtual_link\n:[  \n        {  \n            \nname\n:\nprivate\n\n        }\n    ],\n    \nlifecycle_event\n:[  \n        {  \n            \nevent\n:\nINSTANTIATE\n,\n            \nlifecycle_events\n:[  \n                \ninstall.sh\n,\n                \ninstall-srv.sh\n\n            ]\n        }\n    ],\n    \ndeployment_flavour\n:[  \n        {  \n            \nflavour_key\n:\nm1.small\n\n        }\n    ],\n    \nprovides\n:[\n        \nip\n,\n        \nsource\n,\n        \nparam1\n,\n        \nparam2\n\n      ]\n}\n\n\n\n\n\n\n\n\n\n\nParams\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\nname\n\n\nThe name to give to the VirtualNetworkFunctionDescriptor\n\n\n\n\n\n\nvendor\n\n\nThe vendor creating this VirtualNetworkFunctionDescriptor\n\n\n\n\n\n\nversion\n\n\nThe version of the VirtualNetworkFunctionDescriptor (can be any string)\n\n\n\n\n\n\ntype\n\n\nThe type of the VirtualNetworkFunctionDescriptor (can be any string) and it is used in the dependency parameters in the scripts\n\n\n\n\n\n\nendpoint\n\n\nThe endpoint of the VirtualNetworkFunctionDescriptor (can be any string) needs to point to a registered VnfManager\n\n\n\n\n\n\n\n\nThe other most important parameters are described in the following sections.\n\n\nVirtual Deployment Unit (VDU)\n\n\n\n\n\n\n\n\nParams\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\nvm_image\n\n\nThe list of image names or ids existing in the VimInstance or in the VNF Package\n\n\n\n\n\n\nvimInstanceName\n\n\nThe VimInstance name chosen\n\n\n\n\n\n\nscale_in_out\n\n\nThe maximum number of instances (VMs) which can be created to support scale out/in.\n\n\n\n\n\n\nvnfc\n\n\nThis field contains a list of VNFComponents which will be deployed for this VNFD.\n\n\n\n\n\n\n\n\nVNFC\n\n\nAfter launching a network service, every VNFComponent will run on a separate virtual machine. If scaling is enabled by the scale_in_out field in the VDU, the number of instantiated VNFCs can increase.\nVNFCs contain the following fields:\n\n\n\n\n\n\n\n\nParams\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\nconnection_point\n\n\neach connection point is a reference to an Internal Virtual Link (see Connection Point at \nETSI NFV\n). Moreover you can specify a floatingIp to be assigned to this connection point. The possible values are the actual floatingip ip or \"random\" if no preference is specified. If omitted no floatingip will be assigned.\n\n\n\n\n\n\n\n\nConfigurations\n\n\nThe configuration object contains a list of parameters defined by key, value that can be used in the scripts (see \nVNF Parameters\n).\n\n\nVirtual Link (aka Internal Virtual Link)\n\n\nThe Internal Virtual Link points to a Virtual Link Descriptor defined in the Network Service Descriptor.\n\n\nNote:\n at the moment there are no difference between internal and external VL. All the available networks should be specified in the NSD-\nVLD, then in the VNFD-\nVL you specify which networks you want to use.\nFinally in the VNFD-\nVDU-\nVNFC-\nconnection_point you can specify which network to attach among those available in VNFD-\nVL. The virtual_link_reference parameter also must be filled with the exact same links.\n\n\nLifecycle Events\n\n\nA lifecycle event is composed by an Event and a list of strings that correspond to the script names needed to be run in that particular Event.\n\n\nDeployment Flavour\n\n\nA delpoyment flavour corresponds to a flavour name existing in the VimInstance.\nFor example if you are using Openstack as Vim, the flavour_key parameter shall correspond to a \nflavour name of Openstack\n (e.q. m1.small).\n\n\nProvides, Requires\n\n\nThis list of parameter names defines the parameters that the VnfManager will fill at runtime. For that reason they have a meaning only if you \nwrite your own VnfManager\n. This parameters are then available in any scripts. For the usage of the parameters, please, refer to \nHow to use the parameters\n page.\n\n\n\n\n\n\n\n\n\n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "**HIDDEN**"
        }, 
        {
            "location": "/vnf-descriptor/#virtual-network-function-descriptor", 
            "text": "The VirtualNetworkFunctionDescriptor is contained inside the Network Service Descriptor (NSD). It is a json file and is defined as follows:  {  \n     vendor : fokus ,\n     version : 0.2 ,\n     name : iperf-server ,\n     type : server ,\n     endpoint : generic ,\n     configurations :{\n         name : config_name ,\n         configurationParameters :[\n        {\n             confKey : key ,\n             value : value \n        }\n        ]\n    },\n     vdu :[  \n        {  \n             vm_image :[  \n                 ubuntu-14.04-server-cloudimg-amd64-disk1 \n            ],\n             vimInstanceName : vim-instance ,\n             scale_in_out :2,\n             vnfc :[  \n                {  \n                     connection_point :[  \n                        {  \n                             floatingIp : random ,\n                             virtual_link_reference : private \n                        }\n                    ]\n                }\n            ]\n        }\n    ],\n     virtual_link :[  \n        {  \n             name : private \n        }\n    ],\n     lifecycle_event :[  \n        {  \n             event : INSTANTIATE ,\n             lifecycle_events :[  \n                 install.sh ,\n                 install-srv.sh \n            ]\n        }\n    ],\n     deployment_flavour :[  \n        {  \n             flavour_key : m1.small \n        }\n    ],\n     provides :[\n         ip ,\n         source ,\n         param1 ,\n         param2 \n      ]\n}     Params  Meaning      name  The name to give to the VirtualNetworkFunctionDescriptor    vendor  The vendor creating this VirtualNetworkFunctionDescriptor    version  The version of the VirtualNetworkFunctionDescriptor (can be any string)    type  The type of the VirtualNetworkFunctionDescriptor (can be any string) and it is used in the dependency parameters in the scripts    endpoint  The endpoint of the VirtualNetworkFunctionDescriptor (can be any string) needs to point to a registered VnfManager     The other most important parameters are described in the following sections.  Virtual Deployment Unit (VDU)     Params  Meaning      vm_image  The list of image names or ids existing in the VimInstance or in the VNF Package    vimInstanceName  The VimInstance name chosen    scale_in_out  The maximum number of instances (VMs) which can be created to support scale out/in.    vnfc  This field contains a list of VNFComponents which will be deployed for this VNFD.     VNFC  After launching a network service, every VNFComponent will run on a separate virtual machine. If scaling is enabled by the scale_in_out field in the VDU, the number of instantiated VNFCs can increase.\nVNFCs contain the following fields:     Params  Meaning      connection_point  each connection point is a reference to an Internal Virtual Link (see Connection Point at  ETSI NFV ). Moreover you can specify a floatingIp to be assigned to this connection point. The possible values are the actual floatingip ip or \"random\" if no preference is specified. If omitted no floatingip will be assigned.     Configurations  The configuration object contains a list of parameters defined by key, value that can be used in the scripts (see  VNF Parameters ).  Virtual Link (aka Internal Virtual Link)  The Internal Virtual Link points to a Virtual Link Descriptor defined in the Network Service Descriptor.  Note:  at the moment there are no difference between internal and external VL. All the available networks should be specified in the NSD- VLD, then in the VNFD- VL you specify which networks you want to use.\nFinally in the VNFD- VDU- VNFC- connection_point you can specify which network to attach among those available in VNFD- VL. The virtual_link_reference parameter also must be filled with the exact same links.  Lifecycle Events  A lifecycle event is composed by an Event and a list of strings that correspond to the script names needed to be run in that particular Event.  Deployment Flavour  A delpoyment flavour corresponds to a flavour name existing in the VimInstance.\nFor example if you are using Openstack as Vim, the flavour_key parameter shall correspond to a  flavour name of Openstack  (e.q. m1.small).  Provides, Requires  This list of parameter names defines the parameters that the VnfManager will fill at runtime. For that reason they have a meaning only if you  write your own VnfManager . This parameters are then available in any scripts. For the usage of the parameters, please, refer to  How to use the parameters  page.    \n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "Virtual Network Function Descriptor"
        }, 
        {
            "location": "/zabbix-server-configuration/", 
            "text": "Zabbix server installation and configuration\n\n\nOn Ubuntu 14.04\n\n\nWhile performing the installation on the same host where the NFVO was installed, remember that both systems are heavily consuming CPU and Memory resources, therefore you'll need a powerful machine in order to satisfy both requirements\n\n\nDuring the installation the installer will request to put a password for the user root of the mysql server. You can choose the password you like, however make sure you use the same password while configuring zabbix components\n\n\nsudo su\nwget http://repo.zabbix.com/zabbix/2.2/ubuntu/pool/main/z/zabbix-release/zabbix-release_2.2-1+trusty_all.deb\ndpkg -i zabbix-release_2.2-1+trusty_all.deb\napt-get update \n apt-get -y install mysql-server zabbix-server-mysql zabbix-frontend-php\n\n\n\n\nOnce done, you should configure the file /etc/php5/apache2/php.ini file with the following parameters: \n\n\n[PHP]\n.....\nmax_execution_time = 300\nmemory_limit = 128M\npost_max_size = 16M\nupload_max_filesize = 2M\nmax_input_time =  300\n......\n[Date]\ndate.timezone = Europe/Berlin\n\n\n\n\nRestart the apache service and you are almost done:\n\n\n/etc/init.d/apache2 restart\n\n\n\n\nAt this point the Zabbix frontend should be available at http://your-ip/zabbix in the browser. Default username/password is Admin/zabbix. It will pop up a wizard window which will guide you through the final configuration of the server. \n\n\nAdditionally, you need to configure the auto registration action so that VNFs hosts are added automatically into zabbix db when they are started. For doing it you can either do it via the zabbix dashboard reachable at  http://your-ip/zabbix/actionconf.php or using the provided sql file. Both options are explained below\n\n\nConfigure the auto registration using the dashboard\n\n\nFirst of all you need to open the actions tab\n\n\n\n\nThen you need to create an action:\n\n\n\n\nFinally you need to add two operations:\n\n\n\n\nadd host\n\n\nlink to template: you can select the template you prefer\n\n\n\n\n\n\nRemember to save all the changes in all tabs.\n\n\nConfigure the auto registration importing the sql file\n\n\nIn order to facilitate the configuration of the Zabbix Server, we also provide a zabbix.sql file with all the configuration already done. The file can be found in the folder zabbix-configuration of the zabbix-plugin project.\nYou should run the following command into the host: \n\n\n# Please note that this will overwrite whatever configuration or data is stored into the existing zabbix db.\nmysql -u root -p zabbix \n zabbix.sql\n\n\n\n\nAfter that, the zabbix server is ready to monitor your VNFs!", 
            "title": "**HIDDEN**"
        }, 
        {
            "location": "/zabbix-server-configuration/#zabbix-server-installation-and-configuration", 
            "text": "", 
            "title": "Zabbix server installation and configuration"
        }, 
        {
            "location": "/zabbix-server-configuration/#on-ubuntu-1404", 
            "text": "While performing the installation on the same host where the NFVO was installed, remember that both systems are heavily consuming CPU and Memory resources, therefore you'll need a powerful machine in order to satisfy both requirements  During the installation the installer will request to put a password for the user root of the mysql server. You can choose the password you like, however make sure you use the same password while configuring zabbix components  sudo su\nwget http://repo.zabbix.com/zabbix/2.2/ubuntu/pool/main/z/zabbix-release/zabbix-release_2.2-1+trusty_all.deb\ndpkg -i zabbix-release_2.2-1+trusty_all.deb\napt-get update   apt-get -y install mysql-server zabbix-server-mysql zabbix-frontend-php  Once done, you should configure the file /etc/php5/apache2/php.ini file with the following parameters:   [PHP]\n.....\nmax_execution_time = 300\nmemory_limit = 128M\npost_max_size = 16M\nupload_max_filesize = 2M\nmax_input_time =  300\n......\n[Date]\ndate.timezone = Europe/Berlin  Restart the apache service and you are almost done:  /etc/init.d/apache2 restart  At this point the Zabbix frontend should be available at http://your-ip/zabbix in the browser. Default username/password is Admin/zabbix. It will pop up a wizard window which will guide you through the final configuration of the server.   Additionally, you need to configure the auto registration action so that VNFs hosts are added automatically into zabbix db when they are started. For doing it you can either do it via the zabbix dashboard reachable at  http://your-ip/zabbix/actionconf.php or using the provided sql file. Both options are explained below", 
            "title": "On Ubuntu 14.04"
        }, 
        {
            "location": "/zabbix-server-configuration/#configure-the-auto-registration-using-the-dashboard", 
            "text": "First of all you need to open the actions tab   Then you need to create an action:   Finally you need to add two operations:   add host  link to template: you can select the template you prefer    Remember to save all the changes in all tabs.", 
            "title": "Configure the auto registration using the dashboard"
        }, 
        {
            "location": "/zabbix-server-configuration/#configure-the-auto-registration-importing-the-sql-file", 
            "text": "In order to facilitate the configuration of the Zabbix Server, we also provide a zabbix.sql file with all the configuration already done. The file can be found in the folder zabbix-configuration of the zabbix-plugin project.\nYou should run the following command into the host:   # Please note that this will overwrite whatever configuration or data is stored into the existing zabbix db.\nmysql -u root -p zabbix   zabbix.sql  After that, the zabbix server is ready to monitor your VNFs!", 
            "title": "Configure the auto registration importing the sql file"
        }, 
        {
            "location": "/vnfr-states/", 
            "text": "VNF Record States\n\n\n\n\nThe states of a VNF Record are reflecting the \nETSI NFV states\n and they are shown in the following picture.\n\n\n\n\nWhen the create NSR is called the VNF and the NSR are in state NULL. After the instantiate method is finished in the VNFManager, the corresponding VNFR state is set to INSTANTIATED. When all the VNFR are in state INSTANTIATED then also the NSR goes in state INSTANTIATED. Then in case the VNFR is target of a dependency, the MODIFY message is sent to the VNFManager and when it comes back to the NFVO, the VNFR status is set to INACTIVE. When all the VNFR are in state INACTIVE then also the NSR goes in state INACTIVE. In any case the START message is sent to the VNFManager and when it comes back, the NFVO set the VNFR state to ACTIVE. When all the VNFR are in state ACTIVE then also the NSR goes in state ACTIVE. Then when the terminate NSR is called, the NFVO sends to all the VNFManagers the TERMINATE message. When this message returns to the NFVO, the related VNFR state is set to TERMINATED. When all the VNFR are in state TERMINATED then the NSR is completely deleted from the database.\n\n\n\n\n\n\n\n\n\n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "**HIDDEN**"
        }, 
        {
            "location": "/vnfr-states/#vnf-record-states", 
            "text": "The states of a VNF Record are reflecting the  ETSI NFV states  and they are shown in the following picture.   When the create NSR is called the VNF and the NSR are in state NULL. After the instantiate method is finished in the VNFManager, the corresponding VNFR state is set to INSTANTIATED. When all the VNFR are in state INSTANTIATED then also the NSR goes in state INSTANTIATED. Then in case the VNFR is target of a dependency, the MODIFY message is sent to the VNFManager and when it comes back to the NFVO, the VNFR status is set to INACTIVE. When all the VNFR are in state INACTIVE then also the NSR goes in state INACTIVE. In any case the START message is sent to the VNFManager and when it comes back, the NFVO set the VNFR state to ACTIVE. When all the VNFR are in state ACTIVE then also the NSR goes in state ACTIVE. Then when the terminate NSR is called, the NFVO sends to all the VNFManagers the TERMINATE message. When this message returns to the NFVO, the related VNFR state is set to TERMINATED. When all the VNFR are in state TERMINATED then the NSR is completely deleted from the database.    \n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "VNF Record States"
        }, 
        {
            "location": "/vnf-parameters/", 
            "text": "VNF Parameters\n\n\n\n\nThe useful parameters that you can use in your scripts are defined in two different fields of a VNFD.\n\n\n...\n\nconfigurations\n:{\n                \nname\n:\nconfig_name\n,\n                \nconfigurationParameters\n:[\n                {\n                    \nconfKey\n:\nkey1\n,\n                    \nvalue\n:\nthe_value\n\n                }\n                ]\n            },\n\n...\n\n\nprovides\n:[\n        \nparam1\n,\n        \nparam2\n\n      ]\n...\n\n\n\n\nConfigurations\n\n\nThis field describes an Entity that has a list of ConfigurationParameters inside. This is a list of Entities containing key:value. These parameters are always available in your scripts. See the section below, \nhow to use the parameters\n, in order to see how to use them.\n\n\nProvides\n\n\nThis field is a list of parameter keys that will be available in all your scripts. The difference is that these parameters are parameters whose actual value will be known only at runtime. For that reason these parameters can only be filled by a specific VNFM. So you need to implement a VNFM able to handle these specific parameters in the fillSpecificParameters method (see \nHow to write a VNFM\n).\n\n\nNOTE\n: \n  there are some out-of-the-box parameters that will be added automatically to the VNFRecord. These parameters are:\n\n the networkName=IP,  key = \n network_name \n, value = \n actual-IP \n\n\n the hostname, key = \n hostname \n, value = the actual hostname\n* the floatingIp, key = \n network_name \n_floatingIp , value = the actual floatingIp\n\n\nHow to use the parameters\n\n\nAll the above parameters are available in all the scripts of the VNF that defines them. You just need to use them as environment variables, a script of the INSTANTIATE lifecycle event for instance would be:\n\n\n#!/bin/bash\n\necho \nthe value of the configuration parameter key1 is $key1\n\n\n\n\n\nAs described in the \nGeneric VNFM\n page, you can set up dependencies in order to use parameters from another VNF in the MODIFY lifecycle event. For doing that you need to specify in the Network Service Descriptor the VNF Dependency, for instance if a VNF vnf-1 is connected to network net1 and vnf-2 needs the ip of vnf-1 on that network the VNF Dependency will be:\n\n\n\n\nvnf_dependency\n:[\n        {\n            \nsource\n : {\n                \nname\n: \nvnf-1\n\n            },\n            \ntarget\n:{\n                \nname\n: \nvnf-2\n\n            },\n            \nparameters\n:[\n                \nnet1\n\n            ]\n        }\n    ]\n\n\n\n\n\nDone that, in the MODIFY scripts it is possible to use that ip in this way:\n\n\n#!/bin/bash\n\necho \nthe value of the ip on net1 of vnf-1 is $vnf1type_net1\n\n\n\n\n\nConclusion\n\n\nYou are always able to use the parameters of a VNF simply using the key as variable name, but when you want to use a parameter of a different VNF (like a relation) you need to specify the type followed by an underscore and then the name of the foreign parameter key (for instance \n$typeExt_key\n). In this last case, you can use them only in the MODIFY lifecycle event scripts.\n\n\n\n\n\n\n\n\n\n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "**HIDDEN**"
        }, 
        {
            "location": "/vnf-parameters/#vnf-parameters", 
            "text": "The useful parameters that you can use in your scripts are defined in two different fields of a VNFD.  ... configurations :{\n                 name : config_name ,\n                 configurationParameters :[\n                {\n                     confKey : key1 ,\n                     value : the_value \n                }\n                ]\n            },\n\n... provides :[\n         param1 ,\n         param2 \n      ]\n...  Configurations  This field describes an Entity that has a list of ConfigurationParameters inside. This is a list of Entities containing key:value. These parameters are always available in your scripts. See the section below,  how to use the parameters , in order to see how to use them.  Provides  This field is a list of parameter keys that will be available in all your scripts. The difference is that these parameters are parameters whose actual value will be known only at runtime. For that reason these parameters can only be filled by a specific VNFM. So you need to implement a VNFM able to handle these specific parameters in the fillSpecificParameters method (see  How to write a VNFM ).  NOTE : \n  there are some out-of-the-box parameters that will be added automatically to the VNFRecord. These parameters are:  the networkName=IP,  key =   network_name  , value =   actual-IP    the hostname, key =   hostname  , value = the actual hostname\n* the floatingIp, key =   network_name  _floatingIp , value = the actual floatingIp  How to use the parameters  All the above parameters are available in all the scripts of the VNF that defines them. You just need to use them as environment variables, a script of the INSTANTIATE lifecycle event for instance would be:  #!/bin/bash\n\necho  the value of the configuration parameter key1 is $key1   As described in the  Generic VNFM  page, you can set up dependencies in order to use parameters from another VNF in the MODIFY lifecycle event. For doing that you need to specify in the Network Service Descriptor the VNF Dependency, for instance if a VNF vnf-1 is connected to network net1 and vnf-2 needs the ip of vnf-1 on that network the VNF Dependency will be:   vnf_dependency :[\n        {\n             source  : {\n                 name :  vnf-1 \n            },\n             target :{\n                 name :  vnf-2 \n            },\n             parameters :[\n                 net1 \n            ]\n        }\n    ]  Done that, in the MODIFY scripts it is possible to use that ip in this way:  #!/bin/bash\n\necho  the value of the ip on net1 of vnf-1 is $vnf1type_net1   Conclusion  You are always able to use the parameters of a VNF simply using the key as variable name, but when you want to use a parameter of a different VNF (like a relation) you need to specify the type followed by an underscore and then the name of the foreign parameter key (for instance  $typeExt_key ). In this last case, you can use them only in the MODIFY lifecycle event scripts.    \n      // Creating custom :external selector\n      $.expr[':'].external = function(obj){\n          return !obj.href.match(/^mailto\\:/)\n                  && (obj.hostname != location.hostname);\n      };\n      $(function(){\n        $('a:external').addClass('external');\n        $(\".external\").attr('target','_blank');\n      })", 
            "title": "VNF Parameters"
        }, 
        {
            "location": "/nsd-json-example/", 
            "text": "This network service is composed by two VNF (iperf-server and iperf-client), which the iperf-client is composed by two VNFC.\n\n\nNote:\n no vnf package is used in this example. Only a link to reach the scripts. Basically could be a link to a git repository in which there are all the scripts.\n\n\n{\n   \nname\n:\niperf-NS\n,\n   \nvendor\n:\nFokus\n,\n   \nversion\n:\n0.1\n,\n   \nvnfd\n:[\n      {\n         \nvendor\n:\ntbr\n,\n         \nversion\n:\n0.1\n,\n         \nname\n:\niperf-server\n,\n         \ntype\n:\nserver\n,\n         \nendpoint\n:\ngeneric\n,\n         \nconfigurations\n:{\n            \nname\n:\nconfig_name\n,\n            \nconfigurationParameters\n:[]\n         },\n         \nvdu\n:[\n            {\n               \nvm_image\n:[\n                  \nubuntu-14.04-server-cloudimg-amd64-disk1\n\n               ],\n               \nvimInstanceName\n:\nvim-instance\n,\n               \nscale_in_out\n:1,\n               \nvnfc\n:[\n                  {\n                     \nconnection_point\n:[\n                        {\n                           \nvirtual_link_reference\n:\nprivate\n\n                        }\n                     ]\n                  }\n               ]\n            }\n         ],\n         \nvirtual_link\n:[\n            {\n               \nname\n:\nprivate\n\n            }\n         ],\n         \nlifecycle_event\n:[\n            {\n               \nevent\n:\nINSTANTIATE\n,\n               \nlifecycle_events\n:[\n                  \ninstall.sh\n,\n          \nstart-srv.sh\n\n               ]\n            }\n         ],\n         \ndeployment_flavour\n:[\n            {\n               \nflavour_key\n:\nm1.small\n\n            }\n         ],\n         \nvnfPackage\n:{\n            \nscriptsLink\n:\nhttps://ENTER A VALID LINK TO REACH THE SCRIPTS\n\n         }\n      },\n      {\n         \nvendor\n:\ntbr\n,\n         \nversion\n:\n0.1\n,\n         \nname\n:\niperf-client\n,\n         \ntype\n:\nclient\n,\n         \nendpoint\n:\ngeneric\n,\n         \nconfigurations\n:{\n            \nname\n:\nconfig_name\n,\n            \nconfigurationParameters\n:[\n\n            ]\n         },\n         \nvdu\n:[\n            {\n               \nvm_image\n:[\n                  \nubuntu-14.04-server-cloudimg-amd64-disk1\n\n               ],\n               \nvimInstanceName\n:\nvim-instance\n,\n               \nscale_in_out\n:2,\n               \nvnfc\n:[\n                  {\n                     \nconnection_point\n:[\n                        {\n                           \nfloatingIp\n:\nrandom\n,\n                           \nvirtual_link_reference\n:\nprivate\n\n                        }\n                     ]\n                  },\n                  {\n                     \nconnection_point\n:[\n                        {\n                           \nfloatingIp\n:\nrandom\n,\n                           \nvirtual_link_reference\n:\nprivate\n\n                        }\n                     ]\n                  }\n               ]\n            }\n         ],\n         \nvirtual_link\n:[\n            {\n               \nname\n:\nprivate\n\n            }\n         ],\n         \nlifecycle_event\n:[\n            {\n               \nevent\n:\nINSTANTIATE\n,\n               \nlifecycle_events\n:[\n                  \ninstall.sh\n\n               ]\n            },\n            {\n               \nevent\n:\nCONFIGURE\n,\n               \nlifecycle_events\n:[\n                  \nserver_start-clt.sh\n\n               ]\n            }\n         ],\n         \ndeployment_flavour\n:[\n            {\n               \nflavour_key\n:\nm1.small\n\n            }\n         ],\n         \nvnfPackage\n:{\n            \nscriptsLink\n:\nhttps://ENTER A VALID LINK TO REACH THE SCRIPTS\n\n         }\n      }\n   ],\n   \nvnffgd\n:[\n\n   ],\n   \nvld\n:[\n      {\n         \nname\n:\nprivate\n\n      }\n   ],\n   \nvnf_dependency\n:[\n      {\n         \nsource\n:{\n            \nname\n:\niperf-server\n\n         },\n         \ntarget\n:{\n            \nname\n:\niperf-client\n\n         },\n         \nparameters\n:[\n            \nprivate\n\n         ]\n      }\n   ]\n}", 
            "title": "**HIDDEN**"
        }, 
        {
            "location": "/integration-test-write/", 
            "text": "Write your own integration tests\n\n\nDescription\n\n\nThe integration tests are defined in .ini files which are in the directory \nintegration-tests/src/main/resources/integration-test-scenarios\n. If you want to add a integration test, just add its ini file to this folder. \n\n\nIni file structure\n\n\nIn the ini file you can describe a graph or tree like execution plan of different tasks. \nWe will implement here as an example the test which is found in the \nscenario-real-iperf.ini\n file step by step. \nFirst we need a base node and define the maximum time of the integration test and the maximum number of concurrent successors. \n\n\n[it]\n;set the maximum time (in seconds) of the Integration test. e.g. 10 min = 600 seconds\nmax-integration-test-time = 800\n;set the maximum number of concurrent successors (max number of active child threads)\nmax-concurrent-successors = 10\n\n\n\n\nAfter that the first step is to store a vim instance on the orchestrator. \n\n\n[it]\n;set the maximum time (in seconds) of the Integration test. e.g. 10 min = 600 seconds\nmax-integration-test-time = 800\n;set the maximum number of concurrent successors (max number of active child threads)\nmax-concurrent-successors = 10\n\n;vimInstance-create\n[it/vim-c-1]\nclass-name = VimInstanceCreate\nname-file = real-vim.json\n\n\n\n\nThe node we just added will create a vim instance. That is defined by the class-name field. \nThe class VimInstanceCreate stores a vim instance from the \nreal-vim.json\n file on the orchestrator. \nA complete list of classes you can use is provided later in this document. \nThe file \nreal-vim.json\n has to be stored either in \n/etc/openbaton/integration-test/vim-instances/real-vim.json\n or in \n.../integration-tests/src/main/resources/etc/json_file/vim_instances/real-vim.json\n. \nThe file in the first folder has a higher priority than the one in the second one.\n\n\nWe already know that we want to delete this vim from the orchestrator at the end of the test. \nSo we can add the following:\n\n\n[it]\n;set the maximum time (in seconds) of the Integration test. e.g. 10 min = 600 seconds\nmax-integration-test-time = 800\n;set the maximum number of concurrent successors (max number of active child threads)\nmax-concurrent-successors = 10\n\n;vimInstance-create\n[it/vim-c-1]\nclass-name = VimInstanceCreate\nname-file = real-vim.json\nsuccessor-remover = vim-d-1\n\n[it/vim-c-1/vim-d-1]\nclass-name = VimInstanceDelete\n\n\n\n\nThe successor-remover field specifies, that the node \nvim-d-1\n will be executed after every child node/task of \nvim-c-1\n has finished. \nEvery node can only have one successor-remover. \nA successor remover node cannot have child nodes. \nThe new node gets the information which vim instance it should delete passed from the first node. \n\n\nThe next step will be to create and delete a network service descriptor (NSD). \n\n\n[it]\n;set the maximum time (in seconds) of the Integration test. e.g. 10 min = 600 seconds\nmax-integration-test-time = 800\n;set the maximum number of concurrent successors (max number of active child threads)\nmax-concurrent-successors = 10\n\n\n;vimInstance-create\n[it/vim-c-1]\nclass-name = VimInstanceCreate\nname-file = real-vim.json\nsuccessor-remover = vim-d-1\n\n[it/vim-c-1/vim-d-1]\nclass-name = VimInstanceDelete\n\n;nsd-create\n[it/vim-c-1/nsd-c-1]\nclass-name = NetworkServiceDescriptorCreate\nnum_instances = 1\nsuccessor-remover = nsd-d-1\nname-file = NetworkServiceDescriptor-iperf-real.json\n\n;nsd-delete\n[it/vim-c-1/nsd-c-1/nsd-d-1]\nclass-name = NetworkServiceDescriptorDelete\n\n\n\n\nHere the new nodes are \nnsd-c-1\n and \nnsd-d-1\n. \n\nnsd-d-1\n is the successor remover of \nnsd-c-1\n and will be executed if every child node/task from \nnsd-c-1\n finished. \n\nnsd-c-1\n has some fields that need explanation. \nnum_instances\n specifies how many of those tasks should be created. \nAt the moment there is just one so only one NSD will be stored on the orchestrator. \nBut if we would provide for example a 2, then this task would be executed twice concurrently. \nEvery task would be independent and every child node which is defined for \nnsd-c-1\n would be executed for every instance separately. \nThe name-file specifies the .json file that shall be used to create the NSD. \nIt may be stored either in \n/etc/openbaton/integration-test/network-service-descriptors/NetworkServiceDescriptor-iperf-real.json\n or in \n.../integration-tests/src/main/resources/etc/json_file/network_service_descriptors/NetworkServiceDescriptor-iperf-real.json\n. \nAgain the former folder has a higher priority than the latter one. \n\n\nIn the next step we will deploy the network service record (NSR) from the created NSDs and wait for its instantiation. \n\n\n[it]\n;set the maximum time (in seconds) of the Integration test. e.g. 10 min = 600 seconds\nmax-integration-test-time = 800\n;set the maximum number of concurrent successors (max number of active child threads)\nmax-concurrent-successors = 10\n\n;vimInstance-create\n[it/vim-c-1]\nclass-name = VimInstanceCreate\nname-file = real-vim.json\nsuccessor-remover = vim-d-1\n\n[it/vim-c-1/vim-d-1]\nclass-name = VimInstanceDelete\n\n;nsd-create\n[it/vim-c-1/nsd-c-1]\nclass-name = NetworkServiceDescriptorCreate\nnum_instances = 1\nsuccessor-remover = nsd-d-1\nname-file = NetworkServiceDescriptor-iperf-real.json\n\n;nsd-delete\n[it/vim-c-1/nsd-c-1/nsd-d-1]\nclass-name = NetworkServiceDescriptorDelete\n\n;nsr-create\n[it/vim-c-1/nsd-c-1/nsr-c-1]\nclass-name = NetworkServiceRecordCreate\nnum_instances = 1\n\n;nsr-wait for creation\n[it/vim-c-1/nsd-c-1/nsr-c-1/nsr-w-1]\nclass-name = NetworkServiceRecordWait\n;the default timeout is 5 seconds\ntimeout = 600\naction = INSTANTIATE_FINISH\n\n\n\n\nnsr-c-1\n works similar to the creation of a NSD. It gets its information on which NSD it should use from the preceiding task, so it has to be the NSD creation node. \nThe interesting part in this step is the \nnsr-w-1\n node. \nThis waits for the orchestrator to send the action INSTANTIATE_FINISH. If it receives it, the task was successful and the integration test proceeds. \n\n\nNow we will show how to test, if the network service is actually running.\nTherefore you can tell the integration test to ssh the instantiated virtual machines and execute commands.\nThose commands have to be written in scripts which can be placed in two locations.\nEither in \n/etc/openbaton/integration-test/scripts/\n or in \n/integration-tests/src/main/resources/etc/scripts/\n in the\nproject itself. The former directory is checked first for a script name. If it does not exist there the latter location is used. \nBash sources the scripts on the remote machines. \nBut where do I specify the Virtual Machines on which the scripts shall be executed?? Well, also in the .ini file.\nUse the \nGenericServiceTester\n.\n\n\n[it]\n;set the maximum time (in seconds) of the Integration test. e.g. 10 min = 600 seconds\nmax-integration-test-time = 800\n;set the maximum number of concurrent successors (max number of active child threads)\nmax-concurrent-successors = 10\n\n;vimInstance-create\n[it/vim-c-1]\nclass-name = VimInstanceCreate\nname-file = real-vim.json\nsuccessor-remover = vim-d-1\n\n[it/vim-c-1/vim-d-1]\nclass-name = VimInstanceDelete\n\n;nsd-create\n[it/vim-c-1/nsd-c-1]\nclass-name = NetworkServiceDescriptorCreate\nnum_instances = 1\nsuccessor-remover = nsd-d-1\nname-file = NetworkServiceDescriptor-iperf-real.json\n\n;nsd-delete\n[it/vim-c-1/nsd-c-1/nsd-d-1]\nclass-name = NetworkServiceDescriptorDelete\n\n;nsr-create\n[it/vim-c-1/nsd-c-1/nsr-c-1]\nclass-name = NetworkServiceRecordCreate\nnum_instances = 1\n\n;nsr-wait for creation\n[it/vim-c-1/nsd-c-1/nsr-c-1/nsr-w-1]\nclass-name = NetworkServiceRecordWait\n;the default timeout is 5 seconds\ntimeout = 600\naction = INSTANTIATE_FINISH\n\n[it/vim-c-1/nsd-c-1/nsr-c-1/nsr-w-1/gst-1]\nclass-name = GenericServiceTester\nvnf-type = client\nuser-name = ubuntu\nscript-1 = iperf-running.sh\nscript-2 = iperf-clt-connection.sh\n\n\n\n\nThe class name specifies, that we want to use the GenericServiceTester to test our service.\nThe vnf-type is used to say on which virtual network functions the scripts should be executed and is equal to the one you wrote into the network service descriptor.\nIn our example the integration test would execute them on a virtual machine, which runs the iperfserver VNF which has the type 'server'. \nIn user-name you have to specify the user name of the virtual machine, so that the integration test can ssh into the machine. \nAnd finally you have to specify the script name. script-1 will be the first script executed in that task.\nIf you want to execute more than that, just add script-2, script-3 and so on.\n\n\nHere is the script \niperf-running.sh\n used to see if iperf is running:\n\n\n#!/bin/bash\n\niperf_count=`exec ps -aux | grep -v grep | grep iperf | wc -l`\nif [ $iperf_count -lt 1 ]\nthen\n  exit 1\nelse\n  exit 0\nfi\n\n\n\n\n\nAs you can see the script exits with status 0 on success and otherwise on 1 like usual. \nEvery script you write for the integration test should exit on a value not 0 if they fail. \nThe integration test will just pass if all the scripts exit on 0.\n\n\nSo, now we know that iperf is running on the client virtual machine. But are the client and server really communicating at the moment?\nTo test that we added another script \niperf-clt-connection.sh\n to the client task, that checks if there is an outgoing or incoming connection related to iperf and exits successfully if one exists. Here's the script:\n\n\n#!/bin/bash\n\n# this will return the ip of the remote partner of the communication, here the iperf-server\noutgoing=`sudo netstat -npt | grep iperf | awk '{print $5}' | sed 's/:.*//'` \n\n# check if the communication partner is really the iperf-server\nif [ $outgoing == ${server_ip} ]\nthen\n  exit 0\nelse\n  exit 1\nfi\n\n\n\n\n(You may wonder where '${server_ip}' comes from. It is a variable provided by the integration test as explained later. \nWe use sudo for the netstat command, because the iperf command was started by the root user.)\n\n\nWe now also add a node in the ini file for the server. \n\n\n[it]\n;set the maximum time (in seconds) of the Integration test. e.g. 10 min = 600 seconds\nmax-integration-test-time = 800\n;set the maximum number of concurrent successors (max number of active child threads)\nmax-concurrent-successors = 10\n\n;vimInstance-create\n[it/vim-c-1]\nclass-name = VimInstanceCreate\nname-file = real-vim.json\nsuccessor-remover = vim-d-1\n\n[it/vim-c-1/vim-d-1]\nclass-name = VimInstanceDelete\n\n;nsd-create\n[it/vim-c-1/nsd-c-1]\nclass-name = NetworkServiceDescriptorCreate\nnum_instances = 1\nsuccessor-remover = nsd-d-1\nname-file = NetworkServiceDescriptor-iperf-real.json\n\n;nsd-delete\n[it/vim-c-1/nsd-c-1/nsd-d-1]\nclass-name = NetworkServiceDescriptorDelete\n\n;nsr-create\n[it/vim-c-1/nsd-c-1/nsr-c-1]\nclass-name = NetworkServiceRecordCreate\nnum_instances = 1\n\n;nsr-wait for creation\n[it/vim-c-1/nsd-c-1/nsr-c-1/nsr-w-1]\nclass-name = NetworkServiceRecordWait\n;the default timeout is 5 seconds\ntimeout = 600\naction = INSTANTIATE_FINISH\n\n[it/vim-c-1/nsd-c-1/nsr-c-1/nsr-w-1/gst-1]\nclass-name = GenericServiceTester\nvnf-type = client\nuser-name = ubuntu\nscript-1 = iperf-running.sh\nscript-2 = iperf-clt-connection.sh\n\n\n[it/vim-c-1/nsd-c-1/nsr-c-1/nsr-w-1/gst-1/gst-2]\nclass-name = GenericServiceTester\nvnf-type = server\nnet-name = private\nuser-name = ubuntu\nscript-1 = iperf-running.sh\nscript-2 = iperf-srv-connection.sh\n\n\n\n\nThe second script for the server task looks like this:\n\n\n#!/bin/bash\n\n\nincoming=`sudo netstat -npt | grep iperf | wc -l`\n\nif [ $incoming -eq 0 ] \nthen\n  exit 1\nelse\n  exit 0\nfi\n\n\n\n\nHere we just count if there are incoming connections to the server. \n\n\nAfter the iperf-running.sh script, the iperf-srv-connection.sh script will be executed on the server virtual machines \nand on the client one's also iperf-running.sh and then the script iperf-clt-conection.sh.\n\n\nNow imagine, that you did not specify one virtual network function component in the client's NSD, but five. And you want to test them all.\nDo you have to create five tasks for that?? No, if you define the task for the client as shown above, the integration test will execute\nthe scripts on every virtual machine, that was deployed by the vnfd with the type \nclient\n.\n\n\nAnd if you have some virtual network function components connected to two different networks but just want to test the ones connected\nto one of them, you can add a \nnet-name\n field to the task and just the ones connected to it will be involved like in the server task.\n\n\nAfterwards we want to delete the NSDs and simutaniously wait for a message from the orchestrator, that it has been done. \n\n\n[it]\n;set the maximum time (in seconds) of the Integration test. e.g. 10 min = 600 seconds\nmax-integration-test-time = 800\n;set the maximum number of concurrent successors (max number of active child threads)\nmax-concurrent-successors = 10\n\n;vimInstance-create\n[it/vim-c-1]\nclass-name = VimInstanceCreate\nname-file = real-vim.json\nsuccessor-remover = vim-d-1\n\n[it/vim-c-1/vim-d-1]\nclass-name = VimInstanceDelete\n\n;nsd-create\n[it/vim-c-1/nsd-c-1]\nclass-name = NetworkServiceDescriptorCreate\nnum_instances = 1\nsuccessor-remover = nsd-d-1\nname-file = NetworkServiceDescriptor-iperf-real.json\n\n;nsd-delete\n[it/vim-c-1/nsd-c-1/nsd-d-1]\nclass-name = NetworkServiceDescriptorDelete\n\n;nsr-create\n[it/vim-c-1/nsd-c-1/nsr-c-1]\nclass-name = NetworkServiceRecordCreate\nnum_instances = 1\n\n;nsr-wait for creation\n[it/vim-c-1/nsd-c-1/nsr-c-1/nsr-w-1]\nclass-name = NetworkServiceRecordWait\n;the default timeout is 5 seconds\ntimeout = 600\naction = INSTANTIATE_FINISH\n\n[it/vim-c-1/nsd-c-1/nsr-c-1/nsr-w-1/gst-1]\nclass-name = GenericServiceTester\nvnf-type = client\nuser-name = ubuntu\nscript-1 = iperf-running.sh\nscript-2 = iperf-clt-connection.sh\n\n\n[it/vim-c-1/nsd-c-1/nsr-c-1/nsr-w-1/gst-1/gst-2]\nclass-name = GenericServiceTester\nvnf-type = server\nnet-name = private\nuser-name = ubuntu\nscript-1 = iperf-running.sh\nscript-2 = iperf-srv-connection.sh\n\n;nsr-wait for deletion\n[it/vim-c-1/nsd-c-1/nsr-c-1/nsr-w-1/gst-1/gst-2/nsr-w-2]\nclass-name = NetworkServiceRecordWait\n;the default timeout is 5 seconds\ntimeout = 360\naction = RELEASE_RESOURCES_FINISH\n\n;nsr-delete\n[it/vim-c-1/nsd-c-1/nsr-c-1/nsr-w-1/gst-1/gst-2/nsr-d-1]\nclass-name = NetworkServiceRecordDelete\n\n\n\n\nAs you can see the nodes \nnsr-w-2\n and \nnsr-d-1\n are both child nodes of \ngst-2\n. \nThis means that they are executed concurrently. \nThe \nnsr-w-2\n node waits for the action RELEASE_RESOURCES_FINISH sent by the NFVO and finishes successfully if it receives it. \n\n\nNow are all the child nodes of \nnsd-c-1\n finished and its successor remover nsd-d-1 will be executed which deletes the stored NSDs. \nAfter that all the child nodes of \nvim-c-1\n finished and its successor remover \nvim-d-1\n starts to delete the stored vim instance. \n\n\nA little more on scripts\n\n\nNow we come back to the '${server_ip}' variable in the iperf-clt-connection script. As mentioned earlier this variable is provided \nby the integration test. It stores the ip of the server. If you wanted to access the IPs of the clients, you could use ${client_ip}. \nThe problem is, that we could for example also have two or more instances of clients. Which ip is chosen? \nActually the script, which contains this variable will be executed twice or more on the virtual machine until every possible substitution was handled. \nYou have access to the IPs, floating IPs and configurations. \nYou can access ips by writing ${vnfrtype_ip} or ${vnfrtype_network_ip} (don't forget the braces). The 'vnfrtype' in our example would be 'server' or 'client'. \nThe 'network' is the virtual_link you specified in the VNFD for the VNF Component and will only retrieve the VNFC ips which are connected to this network. \nIf you have more than one VNFC Instance which is deployed, so for example you have two iperf-servers \ndeployed from one VNFD, then there would be two possibilities to substitute ${server_ip}. If you want to execute a script on the virtual machine of the \niperf-client which contains this variable the integration test will do the following. Execute the script containing the \nvariable with first the ip of one server. And then executing the same script, but now replacing the variable with the other ip. \nThat way you just have to write one script and all the VNF Components of the VNF will be tested. \nYou can access the floating ips of VNFCs by writing ${vnfrtype_fip} or ${vnfrtype_network_fip}. \nOf course, this will only work if there is a floating ip for that virtual machine. \nThe configurations are accessible by typing ${vnfrtype_configurationkey}. \nFor all the variables it is essential, that you enclose them with braces otherwise they won't work. \n\n\nOther important information\n\n\nFor the integration test to be able to ssh to the virtual machines on openstack, you have to provide a .pem file of a key-pair you are using on openstack.\nDownload this file, name it \nintegration-test.pem\n and put it into the directory \n/etc/openbaton/integration-test/\n.\nFurthermore it has to have the correct permissions so you probably have to execute \nchmod 400 integration-test.pem\n.\nAnd don't forget to make the scripts executable.\nDo NOT use '-' in types of VNFDs or configuration names as you cannot use them in bash scripts it will not work for the integration test scripts. \n\n\nThe class-name types available\n\n\nAs mentioned earlier here is a summary of all the class-names available at the moment to use in a ini file node.\n\n\n\n\n\n\n\n\nclass-name\n\n\npurpose\n\n\n\n\n\n\n\n\n\n\nGenericServiceTester\n\n\nTest the network service itself\n\n\n\n\n\n\nNetworkServiceDescriptorCreate\n\n\nStore a NSD on the NFVO\n\n\n\n\n\n\nNetworkServiceDescriptorCreateFromPackage\n\n\nCreate a NSD by using a VNFPackage that was uploaded beforehand\n\n\n\n\n\n\nNetworkServiceDescriptorDelete\n\n\nDelete a NSD from the NFVO\n\n\n\n\n\n\nNetworkServiceDescriptorWait\n\n\nUsed for waiting for the deletion of a NSD from the NFVO\n\n\n\n\n\n\nNetworkServiceRecordCreate\n\n\nDeploy a network service from a NSD and create the NSR\n\n\n\n\n\n\nNetworkServiceRecordDelete\n\n\nDelete the NSR\n\n\n\n\n\n\nNetworkServiceRecordWait\n\n\nWait for an specific action of the NFVO to happen that is related to NSRs\n\n\n\n\n\n\nPackageDelete\n\n\nDelete a VNFPackage\n\n\n\n\n\n\nPackageUpload\n\n\nUpload a VNFPackage\n\n\n\n\n\n\nVimInstanceCreate\n\n\nStore a vim instance on the NFVO from a json file\n\n\n\n\n\n\nVimInstanceDelete\n\n\nDelete a vim instance\n\n\n\n\n\n\nVirtualNetworkFunctionRecordWait\n\n\nWait for an action sent by the NFVO which is related to a VNFR\n\n\n\n\n\n\n\n\nUsing VNFPackages\n\n\nHere is an example on how to use VNFPackages in your tests. \n\n\n[it]\n;set the maximum time (in seconds) of the Integration test. e.g. 10 min = 600 seconds\nmax-integration-test-time = 800\n;set the maximum number of concurrent successors (max number of active child threads)\nmax-concurrent-successors = 10\n\n;vimInstance-create\n[it/vim-c-1]\nclass-name = VimInstanceCreate\nname-file = vim.json\nsuccessor-remover = vim-d-1\n\n[it/vim-c-1/vim-d-1]\nclass-name = VimInstanceDelete\n\n;package-create\n[it/vim-c-1/vnfp-c-1]\nclass-name = PackageUpload\npackage-name = iperf-server-package.tar\n\n;nsd-create\n[it/vim-c-1/vnfp-c-1/nsd-c-1]\nclass-name = NetworkServiceDescriptorCreateFromPackage\nname-file = NetworkServiceDescriptor.json\n\n;nsd-delete\n[it/vim-c-1/vnfp-c-1/nsd-c-1/nsd-d-1]\nclass-name = NetworkServiceDescriptorDelete\n\n;package-delete\n[it/vim-c-1/vnfp-c-1/nsd-c-1/nsd-d-1/vnfp-d-1]\nclass-name = PackageDelete\npackage-name = iperf-server-package\n\n\n\n\nThis example begins by storing a vim instance. Then the package iperf-server-package.tar is stored. \nThe packages have to be in the directory /etc/openbaton/integration-test/vnf-packages/. \nAfterwards a NSD is created from the VNFDs in the package and right after that deleted. Be aware that you \nhave to use the class NetworkServiceDescriptorCreateFromPackage to store a NSD from a package. \nThen also the package will be deleted. You have to provide the name of the package you want to delete. \nAt the end the vim instance is deleted. \n\n\nIf you create a NSD from a VNFPackage, the VNFD field of the NSD file would look something like this: \n\n\nvnfd\n:[\n{\n      \nid\n:\n\n},\n{\n      \nid\n:\n\n}\n\n   ],\n\n\n\n\nThe integration test will automatically insert some IDs of VNFDs that were previously stored by a VNFPackage. \n\n\nParser\n\n\nThe class Parser looks for a configuration file with this syntax:\n\n\nold_value = new_value\n\n\nIn the json file, passed to the method Parser.randomize(), all the old_value will be replace with new_value.\nIMPORTANT: in the json file, the old_value must have the following sintax:\n\n\n\"some_parameter\" = \"\n::old_value::\n\"\n\n\nIf we want to put random values:\n\n\nold_value = new_value***\n\n\nIn the json file, passed to the method Parser.randomize(), all the old_value will be replace\nwith new_value plus 3 random characters (e.g. new_valuezxd).\n\n\nSimple parser example\n\n\nParser config file (parser.config):\n\n\nadmin=admin***\n\n\n\n\nJson file:\n\n\n{\n\nusername\n:\n::admin::\n\n}\n\n\n\n\nUse of Parser class:\n\n\nString newJson = Parser.randomize(oldJson, \nparser.config\n);\n\n\n\n\nThe string newJson will be:\n\n\n{\n\nusername\n:\nadminxkz\n\n}", 
            "title": "**HIDDEN**"
        }, 
        {
            "location": "/integration-test-write/#write-your-own-integration-tests", 
            "text": "", 
            "title": "Write your own integration tests"
        }, 
        {
            "location": "/integration-test-write/#description", 
            "text": "The integration tests are defined in .ini files which are in the directory  integration-tests/src/main/resources/integration-test-scenarios . If you want to add a integration test, just add its ini file to this folder.   Ini file structure  In the ini file you can describe a graph or tree like execution plan of different tasks. \nWe will implement here as an example the test which is found in the  scenario-real-iperf.ini  file step by step. \nFirst we need a base node and define the maximum time of the integration test and the maximum number of concurrent successors.   [it]\n;set the maximum time (in seconds) of the Integration test. e.g. 10 min = 600 seconds\nmax-integration-test-time = 800\n;set the maximum number of concurrent successors (max number of active child threads)\nmax-concurrent-successors = 10  After that the first step is to store a vim instance on the orchestrator.   [it]\n;set the maximum time (in seconds) of the Integration test. e.g. 10 min = 600 seconds\nmax-integration-test-time = 800\n;set the maximum number of concurrent successors (max number of active child threads)\nmax-concurrent-successors = 10\n\n;vimInstance-create\n[it/vim-c-1]\nclass-name = VimInstanceCreate\nname-file = real-vim.json  The node we just added will create a vim instance. That is defined by the class-name field. \nThe class VimInstanceCreate stores a vim instance from the  real-vim.json  file on the orchestrator. \nA complete list of classes you can use is provided later in this document. \nThe file  real-vim.json  has to be stored either in  /etc/openbaton/integration-test/vim-instances/real-vim.json  or in  .../integration-tests/src/main/resources/etc/json_file/vim_instances/real-vim.json . \nThe file in the first folder has a higher priority than the one in the second one.  We already know that we want to delete this vim from the orchestrator at the end of the test. \nSo we can add the following:  [it]\n;set the maximum time (in seconds) of the Integration test. e.g. 10 min = 600 seconds\nmax-integration-test-time = 800\n;set the maximum number of concurrent successors (max number of active child threads)\nmax-concurrent-successors = 10\n\n;vimInstance-create\n[it/vim-c-1]\nclass-name = VimInstanceCreate\nname-file = real-vim.json\nsuccessor-remover = vim-d-1\n\n[it/vim-c-1/vim-d-1]\nclass-name = VimInstanceDelete  The successor-remover field specifies, that the node  vim-d-1  will be executed after every child node/task of  vim-c-1  has finished. \nEvery node can only have one successor-remover. \nA successor remover node cannot have child nodes. \nThe new node gets the information which vim instance it should delete passed from the first node.   The next step will be to create and delete a network service descriptor (NSD).   [it]\n;set the maximum time (in seconds) of the Integration test. e.g. 10 min = 600 seconds\nmax-integration-test-time = 800\n;set the maximum number of concurrent successors (max number of active child threads)\nmax-concurrent-successors = 10  ;vimInstance-create\n[it/vim-c-1]\nclass-name = VimInstanceCreate\nname-file = real-vim.json\nsuccessor-remover = vim-d-1\n\n[it/vim-c-1/vim-d-1]\nclass-name = VimInstanceDelete\n\n;nsd-create\n[it/vim-c-1/nsd-c-1]\nclass-name = NetworkServiceDescriptorCreate\nnum_instances = 1\nsuccessor-remover = nsd-d-1\nname-file = NetworkServiceDescriptor-iperf-real.json\n\n;nsd-delete\n[it/vim-c-1/nsd-c-1/nsd-d-1]\nclass-name = NetworkServiceDescriptorDelete  Here the new nodes are  nsd-c-1  and  nsd-d-1 .  nsd-d-1  is the successor remover of  nsd-c-1  and will be executed if every child node/task from  nsd-c-1  finished.  nsd-c-1  has some fields that need explanation.  num_instances  specifies how many of those tasks should be created. \nAt the moment there is just one so only one NSD will be stored on the orchestrator. \nBut if we would provide for example a 2, then this task would be executed twice concurrently. \nEvery task would be independent and every child node which is defined for  nsd-c-1  would be executed for every instance separately. \nThe name-file specifies the .json file that shall be used to create the NSD. \nIt may be stored either in  /etc/openbaton/integration-test/network-service-descriptors/NetworkServiceDescriptor-iperf-real.json  or in  .../integration-tests/src/main/resources/etc/json_file/network_service_descriptors/NetworkServiceDescriptor-iperf-real.json . \nAgain the former folder has a higher priority than the latter one.   In the next step we will deploy the network service record (NSR) from the created NSDs and wait for its instantiation.   [it]\n;set the maximum time (in seconds) of the Integration test. e.g. 10 min = 600 seconds\nmax-integration-test-time = 800\n;set the maximum number of concurrent successors (max number of active child threads)\nmax-concurrent-successors = 10\n\n;vimInstance-create\n[it/vim-c-1]\nclass-name = VimInstanceCreate\nname-file = real-vim.json\nsuccessor-remover = vim-d-1\n\n[it/vim-c-1/vim-d-1]\nclass-name = VimInstanceDelete\n\n;nsd-create\n[it/vim-c-1/nsd-c-1]\nclass-name = NetworkServiceDescriptorCreate\nnum_instances = 1\nsuccessor-remover = nsd-d-1\nname-file = NetworkServiceDescriptor-iperf-real.json\n\n;nsd-delete\n[it/vim-c-1/nsd-c-1/nsd-d-1]\nclass-name = NetworkServiceDescriptorDelete\n\n;nsr-create\n[it/vim-c-1/nsd-c-1/nsr-c-1]\nclass-name = NetworkServiceRecordCreate\nnum_instances = 1\n\n;nsr-wait for creation\n[it/vim-c-1/nsd-c-1/nsr-c-1/nsr-w-1]\nclass-name = NetworkServiceRecordWait\n;the default timeout is 5 seconds\ntimeout = 600\naction = INSTANTIATE_FINISH  nsr-c-1  works similar to the creation of a NSD. It gets its information on which NSD it should use from the preceiding task, so it has to be the NSD creation node. \nThe interesting part in this step is the  nsr-w-1  node. \nThis waits for the orchestrator to send the action INSTANTIATE_FINISH. If it receives it, the task was successful and the integration test proceeds.   Now we will show how to test, if the network service is actually running.\nTherefore you can tell the integration test to ssh the instantiated virtual machines and execute commands.\nThose commands have to be written in scripts which can be placed in two locations.\nEither in  /etc/openbaton/integration-test/scripts/  or in  /integration-tests/src/main/resources/etc/scripts/  in the\nproject itself. The former directory is checked first for a script name. If it does not exist there the latter location is used. \nBash sources the scripts on the remote machines. \nBut where do I specify the Virtual Machines on which the scripts shall be executed?? Well, also in the .ini file.\nUse the  GenericServiceTester .  [it]\n;set the maximum time (in seconds) of the Integration test. e.g. 10 min = 600 seconds\nmax-integration-test-time = 800\n;set the maximum number of concurrent successors (max number of active child threads)\nmax-concurrent-successors = 10\n\n;vimInstance-create\n[it/vim-c-1]\nclass-name = VimInstanceCreate\nname-file = real-vim.json\nsuccessor-remover = vim-d-1\n\n[it/vim-c-1/vim-d-1]\nclass-name = VimInstanceDelete\n\n;nsd-create\n[it/vim-c-1/nsd-c-1]\nclass-name = NetworkServiceDescriptorCreate\nnum_instances = 1\nsuccessor-remover = nsd-d-1\nname-file = NetworkServiceDescriptor-iperf-real.json\n\n;nsd-delete\n[it/vim-c-1/nsd-c-1/nsd-d-1]\nclass-name = NetworkServiceDescriptorDelete\n\n;nsr-create\n[it/vim-c-1/nsd-c-1/nsr-c-1]\nclass-name = NetworkServiceRecordCreate\nnum_instances = 1\n\n;nsr-wait for creation\n[it/vim-c-1/nsd-c-1/nsr-c-1/nsr-w-1]\nclass-name = NetworkServiceRecordWait\n;the default timeout is 5 seconds\ntimeout = 600\naction = INSTANTIATE_FINISH\n\n[it/vim-c-1/nsd-c-1/nsr-c-1/nsr-w-1/gst-1]\nclass-name = GenericServiceTester\nvnf-type = client\nuser-name = ubuntu\nscript-1 = iperf-running.sh\nscript-2 = iperf-clt-connection.sh  The class name specifies, that we want to use the GenericServiceTester to test our service.\nThe vnf-type is used to say on which virtual network functions the scripts should be executed and is equal to the one you wrote into the network service descriptor.\nIn our example the integration test would execute them on a virtual machine, which runs the iperfserver VNF which has the type 'server'. \nIn user-name you have to specify the user name of the virtual machine, so that the integration test can ssh into the machine. \nAnd finally you have to specify the script name. script-1 will be the first script executed in that task.\nIf you want to execute more than that, just add script-2, script-3 and so on.  Here is the script  iperf-running.sh  used to see if iperf is running:  #!/bin/bash\n\niperf_count=`exec ps -aux | grep -v grep | grep iperf | wc -l`\nif [ $iperf_count -lt 1 ]\nthen\n  exit 1\nelse\n  exit 0\nfi  As you can see the script exits with status 0 on success and otherwise on 1 like usual. \nEvery script you write for the integration test should exit on a value not 0 if they fail. \nThe integration test will just pass if all the scripts exit on 0.  So, now we know that iperf is running on the client virtual machine. But are the client and server really communicating at the moment?\nTo test that we added another script  iperf-clt-connection.sh  to the client task, that checks if there is an outgoing or incoming connection related to iperf and exits successfully if one exists. Here's the script:  #!/bin/bash\n\n# this will return the ip of the remote partner of the communication, here the iperf-server\noutgoing=`sudo netstat -npt | grep iperf | awk '{print $5}' | sed 's/:.*//'` \n\n# check if the communication partner is really the iperf-server\nif [ $outgoing == ${server_ip} ]\nthen\n  exit 0\nelse\n  exit 1\nfi  (You may wonder where '${server_ip}' comes from. It is a variable provided by the integration test as explained later. \nWe use sudo for the netstat command, because the iperf command was started by the root user.)  We now also add a node in the ini file for the server.   [it]\n;set the maximum time (in seconds) of the Integration test. e.g. 10 min = 600 seconds\nmax-integration-test-time = 800\n;set the maximum number of concurrent successors (max number of active child threads)\nmax-concurrent-successors = 10\n\n;vimInstance-create\n[it/vim-c-1]\nclass-name = VimInstanceCreate\nname-file = real-vim.json\nsuccessor-remover = vim-d-1\n\n[it/vim-c-1/vim-d-1]\nclass-name = VimInstanceDelete\n\n;nsd-create\n[it/vim-c-1/nsd-c-1]\nclass-name = NetworkServiceDescriptorCreate\nnum_instances = 1\nsuccessor-remover = nsd-d-1\nname-file = NetworkServiceDescriptor-iperf-real.json\n\n;nsd-delete\n[it/vim-c-1/nsd-c-1/nsd-d-1]\nclass-name = NetworkServiceDescriptorDelete\n\n;nsr-create\n[it/vim-c-1/nsd-c-1/nsr-c-1]\nclass-name = NetworkServiceRecordCreate\nnum_instances = 1\n\n;nsr-wait for creation\n[it/vim-c-1/nsd-c-1/nsr-c-1/nsr-w-1]\nclass-name = NetworkServiceRecordWait\n;the default timeout is 5 seconds\ntimeout = 600\naction = INSTANTIATE_FINISH\n\n[it/vim-c-1/nsd-c-1/nsr-c-1/nsr-w-1/gst-1]\nclass-name = GenericServiceTester\nvnf-type = client\nuser-name = ubuntu\nscript-1 = iperf-running.sh\nscript-2 = iperf-clt-connection.sh\n\n\n[it/vim-c-1/nsd-c-1/nsr-c-1/nsr-w-1/gst-1/gst-2]\nclass-name = GenericServiceTester\nvnf-type = server\nnet-name = private\nuser-name = ubuntu\nscript-1 = iperf-running.sh\nscript-2 = iperf-srv-connection.sh  The second script for the server task looks like this:  #!/bin/bash\n\n\nincoming=`sudo netstat -npt | grep iperf | wc -l`\n\nif [ $incoming -eq 0 ] \nthen\n  exit 1\nelse\n  exit 0\nfi  Here we just count if there are incoming connections to the server.   After the iperf-running.sh script, the iperf-srv-connection.sh script will be executed on the server virtual machines \nand on the client one's also iperf-running.sh and then the script iperf-clt-conection.sh.  Now imagine, that you did not specify one virtual network function component in the client's NSD, but five. And you want to test them all.\nDo you have to create five tasks for that?? No, if you define the task for the client as shown above, the integration test will execute\nthe scripts on every virtual machine, that was deployed by the vnfd with the type  client .  And if you have some virtual network function components connected to two different networks but just want to test the ones connected\nto one of them, you can add a  net-name  field to the task and just the ones connected to it will be involved like in the server task.  Afterwards we want to delete the NSDs and simutaniously wait for a message from the orchestrator, that it has been done.   [it]\n;set the maximum time (in seconds) of the Integration test. e.g. 10 min = 600 seconds\nmax-integration-test-time = 800\n;set the maximum number of concurrent successors (max number of active child threads)\nmax-concurrent-successors = 10\n\n;vimInstance-create\n[it/vim-c-1]\nclass-name = VimInstanceCreate\nname-file = real-vim.json\nsuccessor-remover = vim-d-1\n\n[it/vim-c-1/vim-d-1]\nclass-name = VimInstanceDelete\n\n;nsd-create\n[it/vim-c-1/nsd-c-1]\nclass-name = NetworkServiceDescriptorCreate\nnum_instances = 1\nsuccessor-remover = nsd-d-1\nname-file = NetworkServiceDescriptor-iperf-real.json\n\n;nsd-delete\n[it/vim-c-1/nsd-c-1/nsd-d-1]\nclass-name = NetworkServiceDescriptorDelete\n\n;nsr-create\n[it/vim-c-1/nsd-c-1/nsr-c-1]\nclass-name = NetworkServiceRecordCreate\nnum_instances = 1\n\n;nsr-wait for creation\n[it/vim-c-1/nsd-c-1/nsr-c-1/nsr-w-1]\nclass-name = NetworkServiceRecordWait\n;the default timeout is 5 seconds\ntimeout = 600\naction = INSTANTIATE_FINISH\n\n[it/vim-c-1/nsd-c-1/nsr-c-1/nsr-w-1/gst-1]\nclass-name = GenericServiceTester\nvnf-type = client\nuser-name = ubuntu\nscript-1 = iperf-running.sh\nscript-2 = iperf-clt-connection.sh\n\n\n[it/vim-c-1/nsd-c-1/nsr-c-1/nsr-w-1/gst-1/gst-2]\nclass-name = GenericServiceTester\nvnf-type = server\nnet-name = private\nuser-name = ubuntu\nscript-1 = iperf-running.sh\nscript-2 = iperf-srv-connection.sh\n\n;nsr-wait for deletion\n[it/vim-c-1/nsd-c-1/nsr-c-1/nsr-w-1/gst-1/gst-2/nsr-w-2]\nclass-name = NetworkServiceRecordWait\n;the default timeout is 5 seconds\ntimeout = 360\naction = RELEASE_RESOURCES_FINISH\n\n;nsr-delete\n[it/vim-c-1/nsd-c-1/nsr-c-1/nsr-w-1/gst-1/gst-2/nsr-d-1]\nclass-name = NetworkServiceRecordDelete  As you can see the nodes  nsr-w-2  and  nsr-d-1  are both child nodes of  gst-2 . \nThis means that they are executed concurrently. \nThe  nsr-w-2  node waits for the action RELEASE_RESOURCES_FINISH sent by the NFVO and finishes successfully if it receives it.   Now are all the child nodes of  nsd-c-1  finished and its successor remover nsd-d-1 will be executed which deletes the stored NSDs. \nAfter that all the child nodes of  vim-c-1  finished and its successor remover  vim-d-1  starts to delete the stored vim instance.   A little more on scripts  Now we come back to the '${server_ip}' variable in the iperf-clt-connection script. As mentioned earlier this variable is provided \nby the integration test. It stores the ip of the server. If you wanted to access the IPs of the clients, you could use ${client_ip}. \nThe problem is, that we could for example also have two or more instances of clients. Which ip is chosen? \nActually the script, which contains this variable will be executed twice or more on the virtual machine until every possible substitution was handled. \nYou have access to the IPs, floating IPs and configurations. \nYou can access ips by writing ${vnfrtype_ip} or ${vnfrtype_network_ip} (don't forget the braces). The 'vnfrtype' in our example would be 'server' or 'client'. \nThe 'network' is the virtual_link you specified in the VNFD for the VNF Component and will only retrieve the VNFC ips which are connected to this network. \nIf you have more than one VNFC Instance which is deployed, so for example you have two iperf-servers \ndeployed from one VNFD, then there would be two possibilities to substitute ${server_ip}. If you want to execute a script on the virtual machine of the \niperf-client which contains this variable the integration test will do the following. Execute the script containing the \nvariable with first the ip of one server. And then executing the same script, but now replacing the variable with the other ip. \nThat way you just have to write one script and all the VNF Components of the VNF will be tested. \nYou can access the floating ips of VNFCs by writing ${vnfrtype_fip} or ${vnfrtype_network_fip}. \nOf course, this will only work if there is a floating ip for that virtual machine. \nThe configurations are accessible by typing ${vnfrtype_configurationkey}. \nFor all the variables it is essential, that you enclose them with braces otherwise they won't work.", 
            "title": "Description"
        }, 
        {
            "location": "/integration-test-write/#other-important-information", 
            "text": "For the integration test to be able to ssh to the virtual machines on openstack, you have to provide a .pem file of a key-pair you are using on openstack.\nDownload this file, name it  integration-test.pem  and put it into the directory  /etc/openbaton/integration-test/ .\nFurthermore it has to have the correct permissions so you probably have to execute  chmod 400 integration-test.pem .\nAnd don't forget to make the scripts executable.\nDo NOT use '-' in types of VNFDs or configuration names as you cannot use them in bash scripts it will not work for the integration test scripts.", 
            "title": "Other important information"
        }, 
        {
            "location": "/integration-test-write/#the-class-name-types-available", 
            "text": "As mentioned earlier here is a summary of all the class-names available at the moment to use in a ini file node.     class-name  purpose      GenericServiceTester  Test the network service itself    NetworkServiceDescriptorCreate  Store a NSD on the NFVO    NetworkServiceDescriptorCreateFromPackage  Create a NSD by using a VNFPackage that was uploaded beforehand    NetworkServiceDescriptorDelete  Delete a NSD from the NFVO    NetworkServiceDescriptorWait  Used for waiting for the deletion of a NSD from the NFVO    NetworkServiceRecordCreate  Deploy a network service from a NSD and create the NSR    NetworkServiceRecordDelete  Delete the NSR    NetworkServiceRecordWait  Wait for an specific action of the NFVO to happen that is related to NSRs    PackageDelete  Delete a VNFPackage    PackageUpload  Upload a VNFPackage    VimInstanceCreate  Store a vim instance on the NFVO from a json file    VimInstanceDelete  Delete a vim instance    VirtualNetworkFunctionRecordWait  Wait for an action sent by the NFVO which is related to a VNFR", 
            "title": "The class-name types available"
        }, 
        {
            "location": "/integration-test-write/#using-vnfpackages", 
            "text": "Here is an example on how to use VNFPackages in your tests.   [it]\n;set the maximum time (in seconds) of the Integration test. e.g. 10 min = 600 seconds\nmax-integration-test-time = 800\n;set the maximum number of concurrent successors (max number of active child threads)\nmax-concurrent-successors = 10\n\n;vimInstance-create\n[it/vim-c-1]\nclass-name = VimInstanceCreate\nname-file = vim.json\nsuccessor-remover = vim-d-1\n\n[it/vim-c-1/vim-d-1]\nclass-name = VimInstanceDelete\n\n;package-create\n[it/vim-c-1/vnfp-c-1]\nclass-name = PackageUpload\npackage-name = iperf-server-package.tar\n\n;nsd-create\n[it/vim-c-1/vnfp-c-1/nsd-c-1]\nclass-name = NetworkServiceDescriptorCreateFromPackage\nname-file = NetworkServiceDescriptor.json\n\n;nsd-delete\n[it/vim-c-1/vnfp-c-1/nsd-c-1/nsd-d-1]\nclass-name = NetworkServiceDescriptorDelete\n\n;package-delete\n[it/vim-c-1/vnfp-c-1/nsd-c-1/nsd-d-1/vnfp-d-1]\nclass-name = PackageDelete\npackage-name = iperf-server-package  This example begins by storing a vim instance. Then the package iperf-server-package.tar is stored. \nThe packages have to be in the directory /etc/openbaton/integration-test/vnf-packages/. \nAfterwards a NSD is created from the VNFDs in the package and right after that deleted. Be aware that you \nhave to use the class NetworkServiceDescriptorCreateFromPackage to store a NSD from a package. \nThen also the package will be deleted. You have to provide the name of the package you want to delete. \nAt the end the vim instance is deleted.   If you create a NSD from a VNFPackage, the VNFD field of the NSD file would look something like this:   vnfd :[\n{\n       id : \n},\n{\n       id : \n}\n\n   ],  The integration test will automatically insert some IDs of VNFDs that were previously stored by a VNFPackage.", 
            "title": "Using VNFPackages"
        }, 
        {
            "location": "/integration-test-write/#parser", 
            "text": "The class Parser looks for a configuration file with this syntax:  old_value = new_value  In the json file, passed to the method Parser.randomize(), all the old_value will be replace with new_value.\nIMPORTANT: in the json file, the old_value must have the following sintax:  \"some_parameter\" = \" ::old_value:: \"  If we want to put random values:  old_value = new_value***  In the json file, passed to the method Parser.randomize(), all the old_value will be replace\nwith new_value plus 3 random characters (e.g. new_valuezxd).  Simple parser example  Parser config file (parser.config):  admin=admin***  Json file:  { username : ::admin:: \n}  Use of Parser class:  String newJson = Parser.randomize(oldJson,  parser.config );  The string newJson will be:  { username : adminxkz \n}", 
            "title": "Parser"
        }
    ]
}